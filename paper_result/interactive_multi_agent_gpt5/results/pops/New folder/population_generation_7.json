[
     {
          "operator": "time_expert",
          "algorithm_description": "TIDAL-BiRRT: Time-Optimized Directional Adaptive Lazy BiRRT. It accelerates planning via slab-based exact collision tests with obstacle spatial hashing (cell-indexed AABBs) to cut collision checks, a tight hashed-grid nearest search, goal/line-of-sight biased sampling with direct long steps when visible, and a fast greedy multi-step connect that minimizes iterations. Lightweight visibility prune plus micro-shortcutting returns a short, smooth path with minimal overhead.",
          "planning_mechanism": "Alternate expanding start/goal trees. Each iteration samples (goal/line/uniform), finds a hashed-grid nearest, and, if the straight segment is free, takes a long step (up to the sample), else a capped step. After insertion, the other tree greedily extends toward the new node for a few steps using exact slab checks against only nearby obstacles via a spatial hash; if visible within a step, trees meet and the path is extracted and lightly smoothed.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=7000,\n                 step_size=6.0,\n                 goal_bias=0.30,\n                 line_bias=0.20,\n                 search_r_max=2,\n                 connect_steps=10,\n                 smoothing_iters=8):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.search_r_max = search_r_max\n        self.connect_steps = connect_steps\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n\n        # RNG\n        self._lcg_state = 2463534242\n\n        # Obstacle spatial hash\n        self._obs_grid = {}\n        self._obs_cell = 10.0\n        self._obstacles = []\n        self._is_3d = False\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self._is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        self._obstacles = list(map.obstacles)\n\n        # RNG reset\n        self._lcg_state = 2463534242\n\n        # Build obstacle spatial hash\n        self._obs_cell = max(6.0, self.step_size * 2.0)\n        self._build_obstacle_grid()\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obstacles(start) or self._point_in_obstacles(goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight line\n        if not self._edge_blocked(start, goal):\n            n0 = Node(start)\n            n1 = Node(goal, parent=n0, cost=self._dist(start, goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [start, goal], [n0, n1], [(n0, n1)])\n\n        # Trees and node grids\n        node_cell = max(1.0, self.step_size)\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes_all = [start_root, goal_root]\n        edges_all = []\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root, node_cell)\n        self._grid_add(grid_goal, goal_root, node_cell)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = goal if active_start else start\n\n            # Sampling: goal bias, line-of-sight line bias, else uniform\n            r = self._rand()\n            if r < self.goal_bias:\n                x_rand = root_other\n            elif r < self.goal_bias + self.line_bias:\n                x_rand = self._sample_on_line(start, goal)\n            else:\n                x_rand = self._sample_free()\n\n            nearest = self._nearest_hashed(grid_a, tree_a, x_rand, node_cell)\n            if nearest is None:\n                continue\n\n            # Try long step directly to sample if visible; else capped step\n            d_ns = self._dist(nearest.position, x_rand)\n            direct_allowed = (d_ns <= self.step_size * 1.8) and (not self._edge_blocked(nearest.position, x_rand))\n            new_pos = x_rand if direct_allowed else self._steer(nearest.position, x_rand, self.step_size)\n\n            if not self._in_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if self._edge_blocked(nearest.position, new_pos):\n                continue\n            # light dedup near check\n            if self._near_dup(grid_a, new_pos, node_cell, 0.2 * self.step_size):\n                continue\n\n            # Insert node\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes_all.append(new_node)\n            edges_all.append((nearest, new_node))\n            self._grid_add(grid_a, new_node, node_cell)\n\n            # Greedy bounded connect from other tree toward new_node\n            meet = self._greedy_connect(tree_b, grid_b, new_node.position, node_cell)\n            if meet is not None:\n                # Confirm final visibility (already enforced inside), extract and smooth\n                path = self._extract_path(new_node, meet, active_start)\n                path = self._visibility_prune(path)\n                path = self._shortcut_smooth(path, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges_all)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges_all)\n\n    # ---------------- RNG ----------------\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------- Geometry --------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / max(d, 1e-9)\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # --------- Obstacle grid -------------\n    def _obs_key(self, p):\n        if self._is_3d:\n            return (int(p[0] // self._obs_cell), int(p[1] // self._obs_cell), int(p[2] // self._obs_cell))\n        else:\n            return (int(p[0] // self._obs_cell), int(p[1] // self._obs_cell))\n\n    def _build_obstacle_grid(self):\n        self._obs_grid = {}\n        cell = self._obs_cell\n        if self._is_3d:\n            for idx, o in enumerate(self._obstacles):\n                x, y, z, w, h, d = o\n                x0 = int(x // cell); x1 = int((x + w) // cell)\n                y0 = int(y // cell); y1 = int((y + h) // cell)\n                z0 = int(z // cell); z1 = int((z + d) // cell)\n                for i in range(x0, x1 + 1):\n                    for j in range(y0, y1 + 1):\n                        for k in range(z0, z1 + 1):\n                            self._obs_grid.setdefault((i, j, k), []).append(idx)\n        else:\n            for idx, o in enumerate(self._obstacles):\n                x, y, w, h = o\n                x0 = int(x // cell); x1 = int((x + w) // cell)\n                y0 = int(y // cell); y1 = int((y + h) // cell)\n                for i in range(x0, x1 + 1):\n                    for j in range(y0, y1 + 1):\n                        self._obs_grid.setdefault((i, j), []).append(idx)\n\n    def _point_in_obstacles(self, p):\n        # Query only obstacles in the point's cell\n        key = self._obs_key(p)\n        idxs = self._obs_grid.get(key, [])\n        if self._is_3d:\n            px, py, pz = p\n            for idx in idxs:\n                x, y, z, w, h, d = self._obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = p\n            for idx in idxs:\n                x, y, w, h = self._obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_candidates(self, a, b):\n        # Collect obstacles from all grid cells overlapping the segment AABB\n        cell = self._obs_cell\n        if self._is_3d:\n            minx = min(a[0], b[0]); maxx = max(a[0], b[0])\n            miny = min(a[1], b[1]); maxy = max(a[1], b[1])\n            minz = min(a[2], b[2]); maxz = max(a[2], b[2])\n            x0 = int(minx // cell); x1 = int(maxx // cell)\n            y0 = int(miny // cell); y1 = int(maxy // cell)\n            z0 = int(minz // cell); z1 = int(maxz // cell)\n            seen = set()\n            res = []\n            for i in range(x0, x1 + 1):\n                for j in range(y0, y1 + 1):\n                    for k in range(z0, z1 + 1):\n                        lst = self._obs_grid.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                if idx not in seen:\n                                    seen.add(idx)\n                                    res.append(idx)\n            return res\n        else:\n            minx = min(a[0], b[0]); maxx = max(a[0], b[0])\n            miny = min(a[1], b[1]); maxy = max(a[1], b[1])\n            x0 = int(minx // cell); x1 = int(maxx // cell)\n            y0 = int(miny // cell); y1 = int(maxy // cell)\n            seen = set()\n            res = []\n            for i in range(x0, x1 + 1):\n                for j in range(y0, y1 + 1):\n                    lst = self._obs_grid.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            if idx not in seen:\n                                seen.add(idx)\n                                res.append(idx)\n            return res\n\n    def _edge_blocked(self, a, b):\n        cand = self._segment_candidates(a, b)\n        if not cand:\n            return False\n        if self._is_3d:\n            for idx in cand:\n                x, y, z, w, h, d = self._obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n        else:\n            for idx in cand:\n                x, y, w, h = self._obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x, y), (x + w, y + h)):\n                    return True\n        return False\n\n    def _seg_aabb_intersect(self, p0, p1, bmin, bmax):\n        # Slab method for 2D/3D\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(self.dim):\n            a = p0[i]\n            b = p1[i]\n            d = b - a\n            if abs(d) < 1e-12:\n                if a < bmin[i] or a > bmax[i]:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (bmin[i] - a) * inv\n                t2 = (bmax[i] - a) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return (tmin <= tmax) and (tmax >= 0.0) and (tmin <= 1.0)\n\n    # ------------- Sampling --------------\n    def _sample_free(self):\n        # Try bounded attempts; fallback to unconditional loop\n        for _ in range(64):\n            if self._is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._point_in_obstacles(p):\n                return p\n        while True:\n            if self._is_3d:\n                p = (self.bounds[0] * self._rand(),\n                     self.bounds[1] * self._rand(),\n                     self.bounds[2] * self._rand())\n            else:\n                p = (self.bounds[0] * self._rand(),\n                     self.bounds[1] * self._rand())\n            if not self._point_in_obstacles(p):\n                return p\n\n    def _sample_on_line(self, s, g):\n        t = self._rand()\n        p = tuple(s[i] + (g[i] - s[i]) * t for i in range(self.dim))\n        p = self._clamp(p)\n        if not self._point_in_obstacles(p):\n            return p\n        return self._sample_free()\n\n    # ------------- Node grid -------------\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        res = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        res.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            res.extend(b)\n        return res\n\n    def _nearest_hashed(self, grid, tree, pos, cell):\n        key = self._grid_key(pos, cell)\n        best = None\n        bestd = float('inf')\n        found = False\n        for r in range(0, self.search_r_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n                    found = True\n            if found:\n                return best\n        # fallback random probing\n        if tree:\n            trials = min(32, len(tree))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(tree)))\n                n = tree[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _near_dup(self, grid, pos, cell, radius):\n        key = self._grid_key(pos, cell)\n        cand = self._grid_ring_collect(grid, key, 1)\n        rr = max(radius, 1e-6)\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # ------------- Connect & Path -------------\n    def _greedy_connect(self, tree_b, grid_b, target, cell):\n        cur = self._nearest_hashed(grid_b, tree_b, target, cell)\n        if cur is None:\n            return None\n        # If within one step and visible\n        if self._dist(cur.position, target) <= self.step_size and (not self._edge_blocked(cur.position, target)):\n            return cur\n        steps = 0\n        while steps < self.connect_steps:\n            steps += 1\n            if self._dist(cur.position, target) <= self.step_size:\n                if not self._edge_blocked(cur.position, target):\n                    return cur\n                else:\n                    break\n            nxt_pos = self._steer(cur.position, target, self.step_size)\n            if not self._in_bounds(nxt_pos):\n                break\n            if self._point_in_obstacles(nxt_pos):\n                break\n            if self._edge_blocked(cur.position, nxt_pos):\n                break\n            nxt = Node(nxt_pos, parent=cur, cost=cur.cost + self._dist(cur.position, nxt_pos))\n            cur.add_child(nxt)\n            tree_b.append(nxt)\n            self._grid_add(grid_b, nxt, cell)\n            cur = nxt\n        return None\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    # ------------- Smoothing -------------\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j]):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, iters):\n        if len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 2, n))  # ensure at least one point skipped and allow last index\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j - 1]):\n                pts = pts[:i + 1] + pts[j - 1:]\n        return pts",
          "objective": -40.43025,
          "time_improvement": 70.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1875.0,
          "node_improvement": 81.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008312249183654785,
                    "num_nodes_avg": 62.0,
                    "path_length_avg": 156.69148465051805,
                    "smoothness_avg": 0.038492658323530965,
                    "success_improvement": 0.0,
                    "time_improvement": 69.86334643481058,
                    "node_improvement": 84.38680433140266,
                    "length_improvement": 14.114914327586433,
                    "smoothness_improvement": 502.49369090868373,
                    "objective_score": 31.940420981538455
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03631515502929687,
                    "num_nodes_avg": 250.0,
                    "path_length_avg": 241.12950159214583,
                    "smoothness_avg": 0.12182159461241919,
                    "success_improvement": 0.0,
                    "time_improvement": 78.05451619363491,
                    "node_improvement": 83.20231136195659,
                    "length_improvement": 19.504031840666407,
                    "smoothness_improvement": 3034.5573739254837,
                    "objective_score": 50.29156083211774
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02010810375213623,
                    "num_nodes_avg": 186.0,
                    "path_length_avg": 124.86780284803544,
                    "smoothness_avg": 0.1720857560769434,
                    "success_improvement": 0.0,
                    "time_improvement": 61.24308687730198,
                    "node_improvement": 76.35092180546727,
                    "length_improvement": 17.068750914146232,
                    "smoothness_improvement": 2088.918115249488,
                    "objective_score": 39.058767187925774
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Simple Balanced BiRRT-Connect-S (SB-Connect-S): a lean, robust bidirectional RRT-Connect variant with lightweight hash-grid nearest search, duplicate suppression, capped greedy connect, and deterministic shortcut-plus-relax smoothing. It avoids rewiring/compression to reduce overhead and improve generalization, while enforcing strict node/edge collision checks and bounds at every insertion.",
          "planning_mechanism": "Alternate expanding start and goal trees. Each iteration: sample (with small goal bias), steer one step from the nearest node if both node and edge are free, then greedily connect the opposite tree toward the new node with a capped number of steps. On first line-of-sight bridge, concatenate the two trees and post-process using chord shortcuts followed by bounded Laplacian relaxation; return the smoothed path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=7.0,\n        goal_bias=0.2,\n        collision_step=1.0,\n        grid_cell=4.0,\n        dupe_radius_ratio=0.5,\n        connect_limit=24,\n        shortcut_passes=2,\n        relax_iters=16,\n        relax_alpha=0.3\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.connect_limit = connect_limit\n        self.shortcut_passes = shortcut_passes\n        self.relax_iters = relax_iters\n        self.relax_alpha = relax_alpha\n\n        self.bounds = None\n        self.dim = 2\n        self.edge_res = 1.0\n\n        self._rng_s = 2463534242  # xorshift seed\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.edge_res = max(0.5, min(self.collision_step, self.step_size * 0.5))\n        self.grid_cell = max(1.0, self.grid_cell)\n\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early LOS\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_res):\n            n0 = Node(start)\n            n1 = Node(goal, parent=n0, cost=self._dist(start, goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [start, goal], [n0, n1], [(n0, n1)])\n\n        # Initialize trees and neighbor grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        dupe_radius = max(1e-6, self.dupe_radius_ratio * self.step_size)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            grow_tree = tree_a if active_start else tree_b\n            other_tree = tree_b if active_start else tree_a\n            grow_grid = grid_a if active_start else grid_b\n            other_grid = grid_b if active_start else grid_a\n            attractor = goal if active_start else start\n\n            # Sample\n            x_rand = attractor if (self._rand() < self.goal_bias) else self._sample_free(obstacles, is_3d)\n\n            # Extend one step from nearest with both checks\n            nearest = self._nearest_grid(grow_grid, grow_tree, x_rand)\n            if nearest is None:\n                continue\n            x_new = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(x_new):\n                continue\n            if self._is_in_obstacle(x_new, obstacles, is_3d):\n                continue\n            if self._exists_close(grow_grid, x_new, dupe_radius):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, x_new, obstacles, is_3d, self.edge_res):\n                continue\n\n            new_node = Node(x_new, parent=nearest, cost=nearest.cost + self._dist(nearest.position, x_new))\n            nearest.add_child(new_node)\n            grow_tree.append(new_node)\n            nodes.append(new_node)\n            self._grid_add(grow_grid, new_node)\n            edges.append((nearest, new_node))\n\n            # Greedy capped connect from the opposite tree\n            bridger = self._connect_toward(other_tree, other_grid, new_node.position, obstacles, is_3d, edges, nodes)\n            if bridger is not None:\n                # Verify LOS between last node of opposite tree and new_node\n                if not self._is_edge_in_obstacle(bridger.position, new_node.position, obstacles, is_3d, self.edge_res):\n                    if active_start:\n                        path_a = self._collect_root_to(new_node)\n                        path_b = self._collect_to_root(bridger)\n                    else:\n                        path_a = self._collect_root_to(bridger)\n                        path_b = self._collect_to_root(new_node)\n                    raw_path = path_a + path_b\n                    smooth = self._smooth_path(raw_path, obstacles, is_3d)\n                    return PlannerResult(True, smooth, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG utilities\n    def _rand(self):\n        # xorshift32\n        x = self._rng_s & 0xFFFFFFFF\n        x ^= (x << 13) & 0xFFFFFFFF\n        x ^= (x >> 17) & 0xFFFFFFFF\n        x ^= (x << 5) & 0xFFFFFFFF\n        self._rng_s = x & 0xFFFFFFFF\n        return (self._rng_s % 1000003) / 1000003.0\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry and bounds\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / (d if d > 1e-12 else 1.0)\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision checks\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for ox, oy, oz, w, h, d in obstacles:\n                if ox <= px <= ox + w and oy <= py <= oy + h and oz <= pz <= oz + d:\n                    return True\n        else:\n            px, py = pos\n            for ox, oy, w, h in obstacles:\n                if ox <= px <= ox + w and oy <= py <= oy + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = max(1, int(d / max(1e-9, resolution)))\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # Hash grid for neighbors\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, 3):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # Connect routine\n    def _connect_toward(self, tree, grid, target, obstacles, is_3d, edges, nodes):\n        last = None\n        steps = 0\n        while steps < self.connect_limit:\n            nearest = self._nearest_grid(grid, tree, target)\n            if nearest is None:\n                break\n            step = self._steer(nearest.position, target, self.step_size)\n            if not self._in_bounds(step):\n                break\n            if self._is_in_obstacle(step, obstacles, is_3d):\n                break\n            if self._is_edge_in_obstacle(nearest.position, step, obstacles, is_3d, self.edge_res):\n                break\n\n            node = Node(step, parent=nearest, cost=nearest.cost + self._dist(nearest.position, step))\n            nearest.add_child(node)\n            tree.append(node)\n            nodes.append(node)\n            self._grid_add(grid, node)\n            edges.append((nearest, node))\n            last = node\n            steps += 1\n\n            # If we can directly see the target from here, stop\n            if not self._is_edge_in_obstacle(node.position, target, obstacles, is_3d, self.edge_res):\n                return node\n        return last\n\n    # Paths\n    def _collect_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts\n\n    def _collect_root_to(self, node):\n        pts = self._collect_to_root(node)\n        pts.reverse()\n        return pts\n\n    # Smoothing\n    def _smooth_path(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return list(path)\n\n        pts = list(path)\n\n        # Deterministic chord shortcutting (multiple passes)\n        for _ in range(self.shortcut_passes):\n            i = 0\n            while i + 2 < len(pts):\n                j = len(pts) - 1\n                merged = False\n                while j >= i + 2:\n                    if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d, self.edge_res):\n                        pts = pts[:i + 1] + pts[j:]\n                        merged = True\n                        break\n                    j -= 1\n                if not merged:\n                    i += 1\n\n        # Bounded Laplacian relaxation (keep endpoints)\n        for _ in range(self.relax_iters):\n            changed = False\n            for k in range(1, len(pts) - 1):\n                prevp = pts[k - 1]\n                nextp = pts[k + 1]\n                mid = tuple((prevp[d] + nextp[d]) * 0.5 for d in range(self.dim))\n                cand = tuple(pts[k][d] * (1.0 - self.relax_alpha) + mid[d] * self.relax_alpha for d in range(self.dim))\n                cand = self._clamp(cand)\n                if self._is_in_obstacle(cand, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(prevp, cand, obstacles, is_3d, self.edge_res):\n                    continue\n                if self._is_edge_in_obstacle(cand, nextp, obstacles, is_3d, self.edge_res):\n                    continue\n                if cand != pts[k]:\n                    pts[k] = cand\n                    changed = True\n            if not changed:\n                break\n\n        return pts",
          "objective": -37.58195,
          "time_improvement": 61.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1824.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01876068115234375,
                    "num_nodes_avg": 52.9,
                    "path_length_avg": 157.00483474933822,
                    "smoothness_avg": 0.041133669291120264,
                    "success_improvement": 0.0,
                    "time_improvement": 31.98180949063289,
                    "node_improvement": 86.67841853437423,
                    "length_improvement": 13.943162173073038,
                    "smoothness_improvement": 543.831247598565,
                    "objective_score": 20.679596389026514
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02154686450958252,
                    "num_nodes_avg": 118.9,
                    "path_length_avg": 237.81157593905044,
                    "smoothness_avg": 0.12476449035220605,
                    "success_improvement": 0.0,
                    "time_improvement": 86.97908997520419,
                    "node_improvement": 92.01101928374655,
                    "length_improvement": 20.611650924864367,
                    "smoothness_improvement": 3110.2802009923225,
                    "objective_score": 54.012118552441486
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01912965774536133,
                    "num_nodes_avg": 120.4,
                    "path_length_avg": 125.41225389807512,
                    "smoothness_avg": 0.1508052150070723,
                    "success_improvement": 0.0,
                    "time_improvement": 63.12897066561279,
                    "node_improvement": 84.69167196439923,
                    "length_improvement": 16.70715245068287,
                    "smoothness_improvement": 1818.231203606877,
                    "objective_score": 38.05413868812794
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "FLASH-IBRRT*: Fast, Low-Overhead, Adaptive, Informed BiRRT* with capped rewiring and greedy bridging. It uses obstacle-bin accelerated collision checks, compact spatial hashing for nearest/neighbor queries, LOS-adaptive stepping, small-radius k-best parenting, and a short greedy connect. Successful bridges are finalized with shortcutting, visibility pruning, and elastic smoothing for short, smooth paths with low planning time.",
          "planning_mechanism": "Alternate bidirectional growth with biased sampling (goal/line/uniform; switch to informed-ellipse once a path length is known). For each side: pick nearest via hashed rings, steer with LOS-accelerated step, enforce node and edge collision checks, suppress near-duplicates, choose a lower-cost parent from nearby nodes, add the node, and lightly rewire neighbors if cheaper (cycle-safe). Attempt a direct or few-step greedy bridge to the opposite tree\u2019s nearest. On success, stitch start-to-goal, then shortcut, prune by visibility, and elastically smooth before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        pts.reverse()\n        return pts\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3500,\n        step=5.0,\n        connect_factor=2.2,\n        goal_bias=0.22,\n        line_bias=0.25,\n        informed_bias=0.55,\n        grid_cell_factor=1.4,\n        dupe_ratio=0.35,\n        neighbor_cap=80,\n        rewire_cap=10,\n        connect_trials=10,\n        shortcut_attempts=100,\n        smooth_passes=8\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step)\n        self.connect_step = float(step * connect_factor)\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dupe_ratio = float(dupe_ratio)\n        self.neighbor_cap = int(max(1, neighbor_cap))\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_trials = int(max(1, connect_trials))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.smooth_passes = int(max(0, smooth_passes))\n        self._rng = 88172645463393265\n        self._eindex = {}\n        self._ecache = {}\n        self._ecache_cap = 50000\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n        self._eindex = {}\n        self._ecache = {}\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n\n        # Prepare grids\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dupe_radius = max(0.4, self.step * self.dupe_ratio)\n\n        # Build obstacle bins for fast collision\n        self._build_obs_bins()\n\n        # Validate start/goal\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight-line solution\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            self._edges_add(edges, n0, n1)\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Trees and spatial hashes\n        Ta, Tb = [], []\n        Ga, Gb = {}, {}\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        Ta.append(root_a)\n        Tb.append(root_b)\n        nodes.extend([root_a, root_b])\n        self._grid_add(Ga, root_a)\n        self._grid_add(Gb, root_b)\n\n        best_len = float('inf')\n\n        for _ in range(self.max_iter):\n            target = self._sample_target(best_len)\n            # Expand start side\n            res = self._expand_and_connect(Ta, Ga, Tb, Gb, target, nodes, edges, a_is_start=True)\n            if res is not None:\n                path, L = res\n                best_len = L\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n            # Expand goal side\n            res = self._expand_and_connect(Tb, Gb, Ta, Ga, target, nodes, edges, a_is_start=False)\n            if res is not None:\n                path, L = res\n                best_len = L\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # Core expansion + bridge\n    def _expand_and_connect(self, Ta, Ga, Tb, Gb, target, nodes, edges, a_is_start):\n        na = self._nearest(Ga, target)\n        if na is None:\n            return None\n        q_new = self._steer_los(na.position, target)\n        if (not self._in_bounds(q_new)) or self._point_blocked(q_new):\n            return None\n        if self._too_close(Ga, q_new, 0.8 * self.dupe_radius):\n            return None\n\n        parent = self._choose_parent(Ga, q_new, na, len(Ta))\n        if parent is None:\n            return None\n\n        # Both checks before adding node/edge\n        if self._point_blocked(q_new) or (not self._edge_free(parent.position, q_new)):\n            return None\n\n        cost = parent.cost + self._dist(parent.position, q_new)\n        nn = Node(q_new, parent, cost)\n        parent.add_child(nn)\n        Ta.append(nn)\n        nodes.append(nn)\n        self._grid_add(Ga, nn)\n        self._edges_add(edges, parent, nn)\n\n        # Light rewiring\n        if self.rewire_cap > 0:\n            self._rewire_local(Ga, nn, edges, self.rewire_cap)\n\n        # Try to connect to opposite tree\n        meet = self._bridge(Tb, Gb, nn.position, nodes, edges)\n        if meet is not None:\n            pa = nn.path_to_root()\n            pb = meet.path_to_root()\n            if a_is_start:\n                # start-side expansion\n                path = pa + pb[-2::-1]\n            else:\n                path = pb + pa[-2::-1]\n            L = self._path_len(path)\n            return (self._dedup(path), L)\n        return None\n\n    # RNG\n    def _seed_rng(self):\n        s = 1469598103934665603\n        for v in self.start + self.goal:\n            s ^= int(v * 1315423911 + 0.5) & 0xffffffffffffffff\n            s = (s * 1099511628211) & 0xffffffffffffffff\n        s ^= (len(self.obstacles) * 11400714819323198485) & 0xffffffffffffffff\n        if s == 0:\n            s = 88172645463393265\n        self._rng = s & 0xffffffffffffffff\n\n    def _rand(self):\n        # xorshift64*\n        x = self._rng\n        x ^= (x >> 12) & 0xffffffffffffffff\n        x ^= (x << 25) & 0xffffffffffffffff\n        x ^= (x >> 27) & 0xffffffffffffffff\n        self._rng = x & 0xffffffffffffffff\n        return ((x * 2685821657736338717) & 0xffffffffffffffff) / float(1 << 64)\n\n    def _rr(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Sampling\n    def _sample_target(self, best_len):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._sample_informed(self.start, self.goal, best_len * 1.01)\n            if p is not None:\n                return p\n        r2 = self._rand()\n        if r2 < self.goal_bias:\n            return self.goal\n        if r2 < self.goal_bias + self.line_bias:\n            t = self._rand()\n            if self.is3:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t,\n                     self.start[2] + (self.goal[2] - self.start[2]) * t)\n            else:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t)\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        # Uniform\n        if self.is3:\n            return (self._rr(0.0, self.bounds[0]),\n                    self._rr(0.0, self.bounds[1]),\n                    self._rr(0.0, self.bounds[2]))\n        else:\n            return (self._rr(0.0, self.bounds[0]),\n                    self._rr(0.0, self.bounds[1]))\n\n    def _sample_informed(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rr(-ext[0], ext[0]),\n                     c[1] + self._rr(-ext[1], ext[1]),\n                     c[2] + self._rr(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rr(-ext[0], ext[0]),\n                     c[1] + self._rr(-ext[1], ext[1]))\n            if self._in_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and (not self._point_blocked(p)):\n                return p\n        return None\n\n    # Geometry and helpers\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(self._lerp(a, b, r))\n\n    def _steer_los(self, a, b):\n        # If LOS, take a longer stride; else normal step\n        if self._edge_free(a, b):\n            d = self._dist(a, b)\n            s = self.connect_step if d > self.connect_step else d\n            return self._steer(a, b, s)\n        return self._steer(a, b, self.step)\n\n    # Node grid and NN\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 3):\n            cand = self._grid_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n            if best is not None:\n                return best\n        # fallback: randomized subset to avoid O(N)\n        all_nodes = []\n        for lst in grid.values():\n            for n in lst:\n                all_nodes.append(n)\n        if not all_nodes:\n            return None\n        tries = min(64, len(all_nodes))\n        for _ in range(tries):\n            idx = int(self._rr(0, len(all_nodes)))\n            n = all_nodes[idx]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                best = n\n                bestd = d\n        return best\n\n    def _neighbors_within(self, grid, pos, radius, cap):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        seen = {}\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            i2 = id(n)\n                            if i2 in seen:\n                                continue\n                            seen[i2] = True\n                            d2 = 0.0\n                            p = n.position\n                            for i in range(self.dim):\n                                di = p[i] - pos[i]\n                                d2 += di * di\n                            if d2 <= r2:\n                                out.append(n)\n                                if len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        i2 = id(n)\n                        if i2 in seen:\n                            continue\n                        seen[i2] = True\n                        d2 = 0.0\n                        p = n.position\n                        for i in range(self.dim):\n                            di = p[i] - pos[i]\n                            d2 += di * di\n                        if d2 <= r2:\n                            out.append(n)\n                            if len(out) >= cap:\n                                return out\n        return out\n\n    def _adaptive_radius(self, n_nodes):\n        t = float(max(1, n_nodes))\n        base = 1.25 * self.step\n        extra = 2.5 * self.step / ((1.0 + t) ** (1.0 / 3.0))\n        r = base + extra\n        if r < 1.05 * self.step:\n            r = 1.05 * self.step\n        return r\n\n    def _too_close(self, grid, pos, radius):\n        nb = self._neighbors_within(grid, pos, radius, 1)\n        return len(nb) > 0\n\n    def _choose_parent(self, grid, newp, fallback, n_tree_nodes):\n        r = self._adaptive_radius(n_tree_nodes)\n        neigh = self._neighbors_within(grid, newp, r, self.neighbor_cap)\n        best = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        for n in neigh:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                best = n\n                best_cost = c\n        return best\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _rewire_local(self, grid, node, edges, cap):\n        r = self._adaptive_radius(1) + self._adaptive_radius(1) + self.step\n        neigh = self._neighbors_within(grid, node.position, r, self.neighbor_cap)\n        cnt = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            if self._point_blocked(nb.position):\n                continue\n            if not self._edge_free(node.position, nb.position):\n                continue\n            newc = node.cost + self._dist(node.position, nb.position)\n            if newc + 1e-12 < nb.cost:\n                self._reparent(nb, node, edges)\n                cnt += 1\n                if cnt >= cap:\n                    break\n\n    def _reparent(self, child, new_parent, edges):\n        if child is new_parent or child.parent is new_parent:\n            return\n        if self._point_blocked(child.position) or self._point_blocked(new_parent.position):\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._edges_remove(edges, old, child)\n        new_parent.add_child(child)\n        self._edges_add(edges, new_parent, child)\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        stack = list(child.children)\n        while stack:\n            n = stack.pop()\n            n.cost = n.parent.cost + self._dist(n.parent.position, n.position)\n            for c in n.children:\n                stack.append(c)\n\n    # Bridge attempts\n    def _bridge(self, T, G, target_pos, nodes, edges):\n        near = self._nearest(G, target_pos)\n        if near is None:\n            return None\n        # Direct visibility first\n        if self._edge_free(near.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                if not self._too_close(G, target_pos, 0.6 * self.dupe_radius):\n                    newc = near.cost + self._dist(near.position, target_pos)\n                    nn = Node(target_pos, near, newc)\n                    if (not self._point_blocked(nn.position)) and self._edge_free(near.position, nn.position):\n                        near.add_child(nn)\n                        T.append(nn)\n                        nodes.append(nn)\n                        self._grid_add(G, nn)\n                        self._edges_add(edges, near, nn)\n                        return nn\n                return near\n            return near\n        # Greedy stepping towards target_pos\n        cur = near\n        steps = 0\n        while steps < self.connect_trials:\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                break\n            if not self._edge_free(cur.position, nxt):\n                break\n            if self._too_close(G, nxt, 0.6 * self.dupe_radius):\n                break\n            newc = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, newc)\n            if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                break\n            cur.add_child(nn)\n            T.append(nn)\n            nodes.append(nn)\n            self._grid_add(G, nn)\n            self._edges_add(edges, cur, nn)\n            cur = nn\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                    if not self._too_close(G, target_pos, 0.6 * self.dupe_radius):\n                        newc2 = cur.cost + self._dist(cur.position, target_pos)\n                        nn2 = Node(target_pos, cur, newc2)\n                        if (not self._point_blocked(nn2.position)) and self._edge_free(cur.position, nn2.position):\n                            cur.add_child(nn2)\n                            T.append(nn2)\n                            nodes.append(nn2)\n                            self._grid_add(G, nn2)\n                            self._edges_add(edges, cur, nn2)\n                            return nn2\n                return cur\n            steps += 1\n        # Final check\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                if not self._too_close(G, target_pos, 0.6 * self.dupe_radius):\n                    newc = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, newc)\n                    if (not self._point_blocked(nn.position)) and self._edge_free(cur.position, nn.position):\n                        cur.add_child(nn)\n                        T.append(nn)\n                        nodes.append(nn)\n                        self._grid_add(G, nn)\n                        self._edges_add(edges, cur, nn)\n                        return nn\n            return cur\n        return None\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(3.0, self.step * 1.5)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy1, iy0 - 1, -1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        if key in self._ecache:\n            return self._ecache[key]\n        hit = self._segment_hits_any(a, b)\n        res = not hit\n        if len(self._ecache) > self._ecache_cap:\n            self._ecache.clear()\n        self._ecache[key] = res\n        return res\n\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Edge bookkeeping\n    def _edges_add(self, edges, parent, child):\n        key = (id(parent), id(child))\n        if key in self._eindex:\n            return\n        edges.append((parent, child))\n        self._eindex[key] = len(edges) - 1\n\n    def _edges_remove(self, edges, parent, child):\n        key = (id(parent), id(child))\n        idx = self._eindex.get(key)\n        if idx is None:\n            return\n        last = len(edges) - 1\n        if idx != last:\n            edges[idx] = edges[last]\n            pk, ck = id(edges[idx][0]), id(edges[idx][1])\n            self._eindex[(pk, ck)] = idx\n        edges.pop()\n        self._eindex.pop(key, None)\n\n    # Path utilities and smoothing\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rr(0, max(1, len(cur) - 2)))\n            j = int(self._rr(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _elastic(self, pts, passes):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = list(pts)\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                b = cur[i]\n                c = cur[i + 1]\n                target = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                t = 1.0\n                best = b\n                while t > 1e-3:\n                    cand = tuple(b[k] + (target[k] - b[k]) * t for k in range(self.dim))\n                    cand = self._clamp(cand)\n                    if (not self._point_blocked(cand)) and self._edge_free(a, cand) and self._edge_free(cand, c):\n                        best = cand\n                        break\n                    t *= 0.5\n                if best != b:\n                    cur[i] = best\n                    moved = True\n            if not moved:\n                break\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._shortcut(path, self.shortcut_attempts)\n        p2 = self._visibility_prune(p1)\n        p3 = self._elastic(p2, self.smooth_passes)\n        return self._dedup(p3)",
          "objective": -36.2946,
          "time_improvement": 70.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1565.0,
          "node_improvement": 91.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010896635055541993,
                    "num_nodes_avg": 37.0,
                    "path_length_avg": 158.8373930707889,
                    "smoothness_avg": 0.04065007760526215,
                    "success_improvement": 0.0,
                    "time_improvement": 60.49347072740427,
                    "node_improvement": 90.68244774615965,
                    "length_improvement": 12.938707918341045,
                    "smoothness_improvement": 536.2619875787317,
                    "objective_score": 28.592575907119567
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04400351047515869,
                    "num_nodes_avg": 121.0,
                    "path_length_avg": 258.28080909958425,
                    "smoothness_avg": 0.12915590334471116,
                    "success_improvement": 0.0,
                    "time_improvement": 73.40839311365298,
                    "node_improvement": 91.869918699187,
                    "length_improvement": 13.778431721669307,
                    "smoothness_improvement": 3223.2744202964086,
                    "objective_score": 46.40594906857952
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.012626433372497558,
                    "num_nodes_avg": 67.0,
                    "path_length_avg": 134.24774687852602,
                    "smoothness_avg": 0.08149139702456171,
                    "success_improvement": 0.0,
                    "time_improvement": 75.66346447683141,
                    "node_improvement": 91.48124602670057,
                    "length_improvement": 10.83903871403107,
                    "smoothness_improvement": 936.5645550831911,
                    "objective_score": 33.88528534688402
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "HASTE-BiRRT: Hashed, Anytime, Saturation\u2011Throttled, Efficient BiRRT-Connect. It accelerates bidirectional RRT with cached collision tests, hashed nearest search with leader fallbacks, per-cell growth throttling, and duplicate-suppressed commit-only connections. A light visibility prune plus brief shortcutting refines the path while keeping postprocessing costs low.",
          "planning_mechanism": "Alternate expanding start/goal trees with goal-biased sampling; find nearest via grid rings, else leader-guided buckets; steer one step and validate with cached edge checks; suppress inserts in saturated/duplicate cells; attempt a single, commit-only direct bridge to the opposite tree, skipping known-blocked cell pairs; upon success, extract start-to-goal path, visibility-prune, then run a few shortcuts; terminate on success or iteration cap.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=7.0,\n                 goal_bias=0.25,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=40,\n                 max_per_cell=6,\n                 search_r_max=2,\n                 leader_stride=25):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n        self.max_per_cell = max_per_cell\n        self.search_r_max = search_r_max\n        self.leader_stride = leader_stride\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        # Caches\n        self._edge_blocked_cache = set()   # quantized blocked segments (safe to reuse only for blocked)\n        self._edge_exact_cache = {}        # exact endpoint pairs -> bool\n        self._connect_blocked_cells = set()  # (cellA, cellB) pairs known to fail direct connect\n\n    # ------------- Public API -------------\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Parameters derived\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size * 2.5)\n        self.edge_res = max(0.5, self.collision_step)\n\n        # Reset caches\n        self._edge_blocked_cache = set()\n        self._edge_exact_cache = {}\n        self._connect_blocked_cells = set()\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            path = [start, goal]\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Initialize trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Grids and counts\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n        self._grid_add(grid_start, counts_start, start_root)\n        self._grid_add(grid_goal, counts_goal, goal_root)\n\n        # Leaders\n        leaders_start = [start_root]\n        leaders_goal = [goal_root]\n        inserted_since_leader_start = 0\n        inserted_since_leader_goal = 0\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            grid_a = grid_start if active_start else grid_goal\n            counts_a = counts_start if active_start else counts_goal\n            leaders_a = leaders_start if active_start else leaders_goal\n\n            tree_b = goal_tree if active_start else start_tree\n            grid_b = grid_goal if active_start else grid_start\n            counts_b = counts_goal if active_start else counts_start\n            leaders_b = leaders_goal if active_start else leaders_start\n\n            root_other = goal if active_start else start\n\n            # Sample with goal/opposite-root bias\n            if self._rand() < self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest lookup\n            nearest = self._nearest_hashed(grid_a, leaders_a, tree_a, x_rand)\n            if nearest is None:\n                continue\n\n            # Steer\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Per-cell throttling and duplicate suppression\n            key_new = self._grid_key(new_pos)\n            if self._cell_count(counts_a, key_new) >= self.max_per_cell:\n                continue\n            if self._near_duplicate(grid_a, new_pos, dup_radius=0.7 * self.step_size):\n                continue\n\n            # Insert node and edge\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, counts_a, new_node)\n\n            # Leader sampling\n            if active_start:\n                inserted_since_leader_start += 1\n                if inserted_since_leader_start >= self.leader_stride:\n                    leaders_start.append(new_node)\n                    inserted_since_leader_start = 0\n            else:\n                inserted_since_leader_goal += 1\n                if inserted_since_leader_goal >= self.leader_stride:\n                    leaders_goal.append(new_node)\n                    inserted_since_leader_goal = 0\n\n            # Try commit-only direct connection to the other tree (with cell-pair de-dup)\n            other_near = self._nearest_hashed(grid_b, leaders_b, tree_b, new_node.position)\n            if other_near is not None:\n                pair_key = (self._grid_key(new_node.position), self._grid_key(other_near.position))\n                if pair_key not in self._connect_blocked_cells:\n                    if not self._edge_blocked(new_node.position, other_near.position, obstacles, is_3d):\n                        path = self._extract_path(new_node, other_near, a_is_start_tree=active_start)\n                        path = self._visibility_prune(path, obstacles, is_3d)\n                        path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                        return PlannerResult(True, path, start_tree + goal_tree, edges)\n                    else:\n                        # cache blocked cell pair to avoid repeating futile checks\n                        self._connect_blocked_cells.add(pair_key)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ------------- Random -------------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------- Geometry -------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ------------- Collision & caches -------------\n    def _quant(self, p, q=1.5):\n        # Quantize for blocked-segment cache; coarse to avoid false frees; safe for blocked reuse only\n        if self.dim == 3:\n            return (int(p[0] // q), int(p[1] // q), int(p[2] // q))\n        else:\n            return (int(p[0] // q), int(p[1] // q))\n\n    def _seg_key_exact(self, a, b):\n        # Canonicalize order for undirected segment\n        if a <= b:\n            return (a, b)\n        else:\n            return (b, a)\n\n    def _seg_key_quant_blocked(self, a, b):\n        qa = self._quant(a)\n        qb = self._quant(b)\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        # Exact cache check\n        k_exact = self._seg_key_exact(a, b)\n        cached = self._edge_exact_cache.get(k_exact)\n        if cached is not None:\n            return cached\n        # Blocked quantized cache\n        kq = self._seg_key_quant_blocked(a, b)\n        if kq in self._edge_blocked_cache:\n            self._edge_exact_cache[k_exact] = True\n            return True\n        # Compute\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res)\n        # Update caches\n        self._edge_exact_cache[k_exact] = blocked\n        if blocked:\n            self._edge_blocked_cache.add(kq)\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ------------- Sampling -------------\n    def _sample_free(self, obstacles, is_3d):\n        # Rejection sampling within bounds until a free point is found\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ------------- Grid / NN -------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n\n    def _cell_count(self, counts, key):\n        return counts.get(key, 0)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, leaders, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Local rings\n        for r in range(0, self.search_r_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Leader fallback\n        if leaders:\n            lead_best = None\n            lead_bestd = float('inf')\n            for n in leaders:\n                d = self._dist(n.position, pos)\n                if d < lead_bestd:\n                    lead_bestd = d\n                    lead_best = n\n            if lead_best is not None:\n                # Search around leader cell for neighbors\n                lk = self._grid_key(lead_best.position)\n                for r in range(0, min(2, self.search_r_max) + 1):\n                    cand = self._grid_ring_collect(grid, lk, r)\n                    for n in cand:\n                        d = self._dist(n.position, pos)\n                        if d < bestd:\n                            bestd = d\n                            best = n\n                if best is not None:\n                    return best\n        # Sparse random subset fallback (avoid full scan)\n        if tree:\n            trials = min(64, len(tree))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(tree)))\n                n = tree[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            if best is not None:\n                return best\n        return None\n\n    def _near_duplicate(self, grid, pos, dup_radius):\n        key = self._grid_key(pos)\n        r = 1\n        cand = self._grid_ring_collect(grid, key, r)\n        rr = dup_radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # ------------- Path -------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            # start-tree path to meet, then meet->goal via reversed goal-tree path\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -35.78786,
          "time_improvement": 66.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1772.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016536712646484375,
                    "num_nodes_avg": 67.3,
                    "path_length_avg": 176.25078259592178,
                    "smoothness_avg": 0.05067539409595988,
                    "success_improvement": 0.0,
                    "time_improvement": 35.1470831615236,
                    "node_improvement": 83.05212792747419,
                    "length_improvement": 3.3941531868009323,
                    "smoothness_improvement": 693.1799609813568,
                    "objective_score": 16.046516665444422
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023010659217834472,
                    "num_nodes_avg": 105.2,
                    "path_length_avg": 247.25890321415372,
                    "smoothness_avg": 0.1191098532602342,
                    "success_improvement": 0.0,
                    "time_improvement": 85.63605318102866,
                    "node_improvement": 92.93153262111133,
                    "length_improvement": 17.45786115419664,
                    "smoothness_improvement": 2964.7823157454163,
                    "objective_score": 50.989444225553655
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.011754655838012695,
                    "num_nodes_avg": 94.4,
                    "path_length_avg": 127.41557160345823,
                    "smoothness_avg": 0.13822063405561777,
                    "success_improvement": 0.0,
                    "time_improvement": 76.0361625858193,
                    "node_improvement": 87.99745708836618,
                    "length_improvement": 15.376644218505373,
                    "smoothness_improvement": 1658.156262801516,
                    "objective_score": 40.327616620856595
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Bounded BiRRT-Connect with Grid-Accelerated Nearest and Lightweight Shortcutting: a time-capped, bidirectional RRT-Connect that uses a coarse spatial grid for fast nearest-neighbor queries, commits only validated steps, attempts a single greedy bridge per iteration, and applies a brief shortcut smoother to the first found path for quality without heavy rewiring or anytime overhead.",
          "planning_mechanism": "Mechanism: Alternate growing start/goal trees with one extend loop toward a biased sample; each successful extension triggers a greedy extend from the opposite tree toward the new node. Both node and edge collisions are strictly checked before every insertion and the final bridge. Nearest queries use a bucket grid with limited ring expansion and linear fallback. On success, a bounded-time shortcut pass improves path length/smoothness; the planner enforces a hard time limit and returns the best (first) feasible path promptly.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=6.0,\n        goal_sample_rate=0.15,\n        bridge_bias_rate=0.30,\n        cell_size_factor=2.0,\n        time_limit_sec=12.0,\n        edge_resolution=1.0,\n        smooth_attempts=80,\n        smooth_time_frac=0.2\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.bridge_bias_rate = bridge_bias_rate\n        self.cell_size_factor = cell_size_factor\n        self.time_limit_sec = time_limit_sec\n        self.edge_resolution = edge_resolution\n        self.smooth_attempts = smooth_attempts\n        self.smooth_time_frac = smooth_time_frac\n\n    def plan(self, map):\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Validate start/goal feasibility\n        if self._is_in_obstacle(start_position, obstacles, is_3d) or self._is_in_obstacle(goal_position, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Initialize trees and spatial grids\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root = Node(goal_position, parent=None, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        grid_start = {}\n        grid_goal = {}\n        self._grid_insert(grid_start, start_root.position, start_root, cell_size, dim)\n        self._grid_insert(grid_goal, goal_root.position, goal_root, cell_size, dim)\n\n        start_time = time.time()\n\n        # Early straight-line check\n        if not self._is_edge_in_obstacle(start_position, goal_position, obstacles, is_3d, self.edge_resolution):\n            edges.append((start_root, goal_root))\n            direct_path = [start_position, goal_position]\n            return PlannerResult(True, direct_path, start_tree + goal_tree, edges)\n\n        # Main loop\n        for it in range(self.max_iter):\n            if time.time() - start_time >= self.time_limit_sec:\n                return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n            # Alternate tree growth\n            if it % 2 == 0:\n                grow_tree, grow_grid = start_tree, grid_start\n                other_tree, other_grid = goal_tree, grid_goal\n                a_is_start_side = True\n                other_root_pos = goal_root.position\n            else:\n                grow_tree, grow_grid = goal_tree, grid_goal\n                other_tree, other_grid = start_tree, grid_start\n                a_is_start_side = False\n                other_root_pos = start_root.position\n\n            sample = self._sample(bounds, obstacles, is_3d, other_root_pos)\n\n            # Extend grow_tree toward sample\n            a_near = self._nearest_from_grid(grow_tree, grow_grid, sample, cell_size, dim)\n            a_last = self._extend(grow_tree, grow_grid, a_near, sample, nodes, edges, obstacles, is_3d, bounds, cell_size, dim)\n            if a_last is None:\n                continue\n\n            # Greedy connect: extend other_tree toward the new node\n            b_near = self._nearest_from_grid(other_tree, other_grid, a_last.position, cell_size, dim)\n            b_last = self._extend(other_tree, other_grid, b_near, a_last.position, nodes, edges, obstacles, is_3d, bounds, cell_size, dim)\n            if b_last is None:\n                continue\n\n            # Attempt final short bridge\n            if self._distance(b_last.position, a_last.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(b_last.position, a_last.position, obstacles, is_3d, self.edge_resolution):\n                    edges.append((b_last, a_last))\n                    # Extract and smooth path\n                    final_path = self._assemble_path(a_last, b_last, a_is_start_side)\n                    remaining = max(0.0, self.time_limit_sec - (time.time() - start_time))\n                    budget = min(remaining, self.time_limit_sec * self.smooth_time_frac)\n                    final_path = self._shortcut_path(final_path, obstacles, is_3d, bounds, budget, self.smooth_attempts)\n                    return PlannerResult(True, final_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---- Utilities ----\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _within_bounds(self, p, bounds):\n        for i in range(len(bounds)):\n            if p[i] < 0.0 or p[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step_size):\n        d = self._distance(from_pos, to_pos)\n        if d <= step_size:\n            return to_pos\n        r = step_size / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    def _sample(self, bounds, obstacles, is_3d, other_root_pos):\n        # Bias toward the opposite root\n        if random.random() < self.bridge_bias_rate:\n            return other_root_pos\n        # Mild goal bias to encourage meeting/goal attraction\n        if random.random() < self.goal_sample_rate:\n            return other_root_pos\n        # Uniform rejection sampling in free space\n        dim = len(bounds)\n        for _ in range(30):\n            pt = tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n        # Fallback: last sample even if occupied (extend will reject)\n        return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n\n    def _extend(self, tree, grid, nearest_node, target_pos, nodes, edges, obstacles, is_3d, bounds, cell_size, dim):\n        current = nearest_node\n        last_new = None\n        while True:\n            step_pos = self._steer(current.position, target_pos, self.step_size)\n            if not self._within_bounds(step_pos, bounds):\n                break\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                break\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d, self.edge_resolution):\n                break\n            # Both node and edge are valid \u2192 commit\n            new_node = Node(step_pos)\n            new_node.cost = current.cost + self._distance(current.position, step_pos)\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node.position, new_node, cell_size, dim)\n            last_new = new_node\n            current = new_node\n            # Stop if reached target (within one step)\n            if self._distance(current.position, target_pos) <= self.step_size:\n                break\n        return last_new\n\n    def _assemble_path(self, a_node, b_node, a_is_start_side):\n        if a_is_start_side:\n            pa = a_node.path_from_root()   # start -> ... -> a\n            pb = b_node.path_from_root()   # goal  -> ... -> b\n            return pa + pb[::-1]           # start ... a, b ... goal\n        else:\n            pa = a_node.path_from_root()   # goal  -> ... -> a\n            pb = b_node.path_from_root()   # start -> ... -> b\n            return pb + pa[::-1]           # start ... b, a ... goal\n\n    # ---- Spatial grid for approximate nearest ----\n    def _cell_index(self, pos, cell_size, dim):\n        if dim == 2:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size))\n        else:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size), int(pos[2] // cell_size))\n\n    def _grid_insert(self, grid, pos, node, cell_size, dim):\n        idx = self._cell_index(pos, cell_size, dim)\n        if idx in grid:\n            grid[idx].append(node)\n        else:\n            grid[idx] = [node]\n\n    def _nearest_from_grid(self, tree, grid, point, cell_size, dim, max_rings=3):\n        # For small trees, just do linear scan\n        if len(tree) < 32:\n            return min(tree, key=lambda n: self._distance(n.position, point))\n\n        center = self._cell_index(point, cell_size, dim)\n        best = None\n        # Expand rings until some candidates found, then pick nearest among them\n        for r in range(0, max_rings + 1):\n            candidates = []\n            if dim == 2:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        idx = (center[0] + dx, center[1] + dy)\n                        if idx in grid:\n                            candidates.extend(grid[idx])\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            idx = (center[0] + dx, center[1] + dy, center[2] + dz)\n                            if idx in grid:\n                                candidates.extend(grid[idx])\n            if candidates:\n                best = min(candidates, key=lambda n: self._distance(n.position, point))\n                break\n\n        if best is None:\n            # Fallback to linear scan if grid empty nearby\n            best = min(tree, key=lambda n: self._distance(n.position, point))\n        return best\n\n    # ---- Collision utilities ----\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist / max(1e-6, resolution)))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    # ---- Path shortcutting ----\n    def _shortcut_path(self, path, obstacles, is_3d, bounds, time_budget, attempts):\n        if len(path) < 3:\n            return path\n        start_t = time.time()\n        pts = list(path)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and (time.time() - start_t) <= time_budget:\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            # Keep within bounds and collision-free\n            if not self._segment_within_bounds(a, b, bounds):\n                tries += 1\n                continue\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_resolution):\n                # Apply shortcut\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n            tries += 1\n        return pts\n\n    def _segment_within_bounds(self, a, b, bounds):\n        # The interpolated segment is within bounds if endpoints are; checks along the way via edge collision\n        for d in range(len(bounds)):\n            if a[d] < 0.0 or a[d] > bounds[d]:\n                return False\n            if b[d] < 0.0 or b[d] > bounds[d]:\n                return False\n        return True",
          "objective": -35.38986,
          "time_improvement": 79.0,
          "length_improvement": 6.0,
          "smoothness_improvement": 1571.0,
          "node_improvement": 81.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009288859367370606,
                    "num_nodes_avg": 87.5,
                    "path_length_avg": 179.7819366813108,
                    "smoothness_avg": 0.041891929272141075,
                    "success_improvement": 0.0,
                    "time_improvement": 63.57137981686718,
                    "node_improvement": 77.96524804835055,
                    "length_improvement": 1.4586716778820132,
                    "smoothness_improvement": 555.6996628894441,
                    "objective_score": 22.725115266236582
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009074711799621582,
                    "num_nodes_avg": 124.9,
                    "path_length_avg": 251.58839597257443,
                    "smoothness_avg": 0.10077141463831178,
                    "success_improvement": 0.0,
                    "time_improvement": 94.3352914641303,
                    "node_improvement": 91.6078747564335,
                    "length_improvement": 16.01255185389636,
                    "smoothness_improvement": 2492.9210813599107,
                    "objective_score": 50.372723958376454
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01003124713897705,
                    "num_nodes_avg": 215.4,
                    "path_length_avg": 148.33090891427284,
                    "smoothness_avg": 0.13860849885025553,
                    "success_improvement": 0.0,
                    "time_improvement": 79.54962026854608,
                    "node_improvement": 72.6128417037508,
                    "length_improvement": 1.4856730579993105,
                    "smoothness_improvement": 1663.0898743601072,
                    "objective_score": 33.07173928716395
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "LINX-Opt*: Length-Intensive Informed Bi-RRT* with Cost-Optimal Bridge and Monotone Shortcutting. It grows two cost-aware RRT* trees with a decaying, node-count-driven neighbor radius, k-best parent selection, local rewiring, and a bridge that minimizes total cost-to-go across trees. An informed-ellipsoid sampler and admissible gating prune expansions that cannot beat the current best length. The solution is post-processed by deterministic visibility pruning, randomized shortcutting, and length-monotone vertex sliding, guaranteeing non-increasing path length.",
          "planning_mechanism": "Alternate expanding start/goal trees. Each step: sample (goal/line/uniform; switch to informed ellipse after first solution), pick nearest via spatial hash, steer, enforce collision checks, select the lowest-cost parent among neighbors within an adaptive radius, insert node, and rewire cheaper neighbors. Then search the opposite tree for a direct, edge-free connection that minimizes cost_a + dist + cost_b; on success, assemble the path and apply length-only smoothing before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        pts.reverse()\n        return pts\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step=5.0,\n        goal_bias=0.12,\n        line_bias=0.20,\n        informed_bias=0.50,\n        grid_cell_factor=1.25,\n        k_near=56,\n        rewire_cap=24,\n        connect_rad_scale=4.0,\n        dupe_ratio=0.25,\n        gate_ratio=0.6,\n        shortcut_attempts=120,\n        slide_passes=8\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step)\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.k_near = int(max(8, k_near))\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_rad_scale = float(connect_rad_scale)\n        self.dupe_ratio = float(dupe_ratio)\n        self.gate_ratio = float(gate_ratio)\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.slide_passes = int(max(0, slide_passes))\n        self._rng = 1234567\n        self._eindex = {}\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n        self._eindex = {}\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dupe_radius = max(0.25, self.step * self.dupe_ratio)\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            self._edges_add(edges, n0, n1)\n            path = [self.start, self.goal]\n            path = self._finalize_path_length_opt(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize trees and grids\n        Ta, Tb = [], []\n        Ga, Gb = {}, {}\n        ra = Node(self.start, None, 0.0)\n        rb = Node(self.goal, None, 0.0)\n        Ta.append(ra)\n        Tb.append(rb)\n        nodes.extend([ra, rb])\n        self._grid_add(Ga, ra)\n        self._grid_add(Gb, rb)\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            sample = self._sample_target(best_len)\n            if sample is None:\n                continue\n\n            # Expand A then B\n            res = self._expand_and_maybe_bridge(Ta, Ga, Tb, Gb, sample, nodes, edges, best_len)\n            if res is not None:\n                path, L = res\n                if L + 1e-9 < best_len:\n                    best_len = L\n                    best_path = path\n                    final = self._finalize_path_length_opt(best_path)\n                    return PlannerResult(True, final, nodes, edges)\n\n            res = self._expand_and_maybe_bridge(Tb, Gb, Ta, Ga, sample, nodes, edges, best_len)\n            if res is not None:\n                path, L = res\n                if L + 1e-9 < best_len:\n                    best_len = L\n                    best_path = path\n                    final = self._finalize_path_length_opt(best_path)\n                    return PlannerResult(True, final, nodes, edges)\n\n        # If no bridge found, try to return best (if any)\n        if best_path is not None:\n            final = self._finalize_path_length_opt(best_path)\n            return PlannerResult(True, final, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # One expansion on Ta toward target and cost-optimal bridge to Tb\n    def _expand_and_maybe_bridge(self, Ta, Ga, Tb, Gb, target, nodes, edges, best_len):\n        near = self._nearest(Ga, target)\n        if near is None:\n            return None\n\n        q_new = self._steer_adaptive(near.position, target)\n        if (not self._in_bounds(q_new)) or self._point_blocked(q_new):\n            return None\n\n        if self._too_close(Ga, q_new, self.dupe_radius):\n            return None\n\n        # Admissible gating toward better-than-best paths\n        if best_len < float('inf') and self._rand() < self.gate_ratio:\n            root_goal = self.goal if Ta[0].position == self.start else self.start\n            if near.cost + self._dist(near.position, q_new) + self._dist(q_new, root_goal) >= best_len * 0.999:\n                return None\n\n        # Parent selection (k-near within adaptive radius), both checks enforced before add\n        parent = self._select_parent(Ga, q_new, near, len(Ta))\n        if parent is None:\n            return None\n        if self._point_blocked(q_new) or (not self._edge_free(parent.position, q_new)):\n            return None\n\n        cost = parent.cost + self._dist(parent.position, q_new)\n        nn = Node(q_new, parent, cost)\n        parent.add_child(nn)\n        Ta.append(nn)\n        nodes.append(nn)\n        self._grid_add(Ga, nn)\n        self._edges_add(edges, parent, nn)\n\n        # Local rewiring\n        if self.rewire_cap > 0:\n            self._rewire_neighbors(Ga, nn, edges, len(Ta))\n\n        # Cost-optimal direct bridge to opposite tree\n        meet, ok = self._best_direct_bridge(Tb, Gb, nn)\n        if ok and meet is not None:\n            # Insert a clone at meet to keep parenthood coherent\n            if not self._edge_free(nn.position, meet.position):\n                return None\n            if self._point_blocked(meet.position):\n                return None\n            if not self._too_close(Ga, meet.position, 0.75 * self.dupe_radius):\n                cn = Node(meet.position, nn, nn.cost + self._dist(nn.position, meet.position))\n                if (not self._point_blocked(cn.position)) and self._edge_free(nn.position, cn.position):\n                    nn.add_child(cn)\n                    Ta.append(cn)\n                    nodes.append(cn)\n                    self._grid_add(Ga, cn)\n                    self._edges_add(edges, nn, cn)\n                    nn = cn  # meeting node on A\n\n            pa = nn.path_to_root()\n            pb = meet.path_to_root()\n            if Ta[0].position == self.start:\n                path = pa + pb[-2::-1]\n            else:\n                path = pb + pa[-2::-1]\n            path = self._dedup(path)\n            L = self._path_len(path)\n            return (path, L)\n        return None\n\n    # RNG\n    def _seed_rng(self):\n        s = 2166136261\n        for v in self.start + self.goal:\n            s ^= int(v * 10007 + 0.5) & 0xffffffff\n            s = (s * 16777619) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Sampling\n    def _sample_target(self, best_len):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._sample_informed(self.start, self.goal, best_len * 1.01)\n            if p is not None:\n                return p\n        r2 = self._rand()\n        if r2 < self.goal_bias:\n            return self.goal\n        if r2 < self.goal_bias + self.line_bias:\n            t = self._rand()\n            if self.is3:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t,\n                     self.start[2] + (self.goal[2] - self.start[2]) * t)\n            else:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t)\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        # Uniform\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_informed(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (self._in_bounds(p)\n                and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum\n                and (not self._point_blocked(p))):\n                return p\n        return None\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _steer(self, a, b, step_len):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= step_len:\n            return self._clamp(b)\n        r = step_len / d\n        return self._clamp(self._lerp(a, b, r))\n\n    def _steer_adaptive(self, a, b):\n        # Fast long step if fully visible, else nominal step\n        if self._edge_free(a, b):\n            d = self._dist(a, b)\n            max_step = self.step * 2.5\n            step_len = max_step if d > max_step else d\n            return self._steer(a, b, step_len)\n        return self._steer(a, b, self.step)\n\n    # Node grid\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 3):\n            cand = self._grid_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n            if best is not None:\n                return best\n        # fallback scan\n        for lst in grid.values():\n            for n in lst:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n        return best\n\n    def _neighbors_within(self, grid, pos, radius, cap):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        seen = {}\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            i2 = id(n)\n                            if i2 in seen:\n                                continue\n                            seen[i2] = True\n                            p = n.position\n                            d2 = 0.0\n                            for i in range(self.dim):\n                                di = p[i] - pos[i]\n                                d2 += di * di\n                            if d2 <= r2:\n                                out.append(n)\n                                if len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        i2 = id(n)\n                        if i2 in seen:\n                            continue\n                        seen[i2] = True\n                        p = n.position\n                        d2 = 0.0\n                        for i in range(self.dim):\n                            di = p[i] - pos[i]\n                            d2 += di * di\n                        if d2 <= r2:\n                            out.append(n)\n                            if len(out) >= cap:\n                                return out\n        return out\n\n    def _k_nearest(self, grid, pos, k):\n        key = self._cell_key(pos)\n        out = []\n        bestd = []\n        seen = {}\n        # expand rings until gather >= k or up to 4 rings then full scan\n        for r in range(0, 5):\n            cand = self._grid_collect(grid, key, r)\n            for n in cand:\n                i2 = id(n)\n                if i2 in seen:\n                    continue\n                seen[i2] = True\n                d = self._dist(n.position, pos)\n                out.append((d, n))\n            if len(out) >= k:\n                break\n        if len(out) < k:\n            for lst in grid.values():\n                for n in lst:\n                    i2 = id(n)\n                    if i2 in seen:\n                        continue\n                    seen[i2] = True\n                    d = self._dist(n.position, pos)\n                    out.append((d, n))\n        out.sort(key=lambda t: t[0])\n        return [n for _, n in out[:k]]\n\n    def _adaptive_radius(self, n_nodes):\n        # Decays ~ n^{-1/d}, bounded below by 1.1*step\n        n = float(max(1, n_nodes))\n        r0 = 8.0 * self.step\n        r = r0 * pow(n, -1.0 / float(self.dim))\n        if r < 1.1 * self.step:\n            r = 1.1 * self.step\n        return r\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors_within(grid, pos, radius, 1)) > 0\n\n    # Parent selection with RRT*-style radius and k-near fallback\n    def _select_parent(self, grid, newp, fallback, n_nodes):\n        r = self._adaptive_radius(n_nodes)\n        neigh = self._neighbors_within(grid, newp, r, self.k_near)\n        if not neigh:\n            neigh = self._k_nearest(grid, newp, max(8, self.k_near // 2))\n        best = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        for n in neigh:\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                best = n\n                best_cost = c\n        return best\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _rewire_neighbors(self, grid, node, edges, n_nodes):\n        r = self._adaptive_radius(n_nodes)\n        neigh = self._neighbors_within(grid, node.position, r, self.k_near * 2)\n        cnt = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            if self._point_blocked(nb.position) or self._point_blocked(node.position):\n                continue\n            if not self._edge_free(node.position, nb.position):\n                continue\n            newc = node.cost + self._dist(node.position, nb.position)\n            if newc + 1e-12 < nb.cost:\n                self._reparent(nb, node, edges)\n                cnt += 1\n                if cnt >= self.rewire_cap:\n                    break\n\n    def _reparent(self, child, new_parent, edges):\n        if child is new_parent or child.parent is new_parent:\n            return\n        if self._point_blocked(child.position) or self._point_blocked(new_parent.position):\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._edges_remove(edges, old, child)\n        new_parent.add_child(child)\n        self._edges_add(edges, new_parent, child)\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        stack = list(child.children)\n        while stack:\n            n = stack.pop()\n            n.cost = n.parent.cost + self._dist(n.parent.position, n.position)\n            for c in n.children:\n                stack.append(c)\n\n    # Cost-optimal direct bridge: pick b in other tree minimizing cost_a(nn)+|nn-b|+cost_b(b)\n    def _best_direct_bridge(self, T_other, G_other, nn):\n        if not T_other:\n            return None, False\n        # Broad neighbor set based on connection radius\n        conn_r = self.connect_rad_scale * self.step\n        cand = self._neighbors_within(G_other, nn.position, conn_r, self.k_near * 2)\n        if not cand:\n            cand = self._k_nearest(G_other, nn.position, max(8, self.k_near // 2))\n        best = None\n        best_sum = 1e100\n        for b in cand:\n            if self._edge_free(nn.position, b.position):\n                s = nn.cost + self._dist(nn.position, b.position) + b.cost\n                if s < best_sum:\n                    best_sum = s\n                    best = b\n        return best, (best is not None)\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(3.5, self.step * 1.6)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Edge bookkeeping\n    def _edges_add(self, edges, parent, child):\n        key = (id(parent), id(child))\n        if key in self._eindex:\n            return\n        edges.append((parent, child))\n        self._eindex[key] = len(edges) - 1\n\n    def _edges_remove(self, edges, parent, child):\n        key = (id(parent), id(child))\n        idx = self._eindex.get(key)\n        if idx is None:\n            return\n        last = len(edges) - 1\n        if idx != last:\n            edges[idx] = edges[last]\n            pk, ck = id(edges[idx][0]), id(edges[idx][1])\n            self._eindex[(pk, ck)] = idx\n        edges.pop()\n        self._eindex.pop(key, None)\n\n    # Path utilities and length-focused smoothing\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                # always non-increasing by triangle inequality\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _vertex_slide(self, pts, passes):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = list(pts)\n        for _ in range(passes):\n            improved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                b = cur[i]\n                c = cur[i + 1]\n                base = self._dist(a, b) + self._dist(b, c)\n                # target along chord midpoint direction\n                target = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                t = 1.0\n                best = b\n                best_cost = base\n                while t > 1e-3:\n                    cand = tuple(b[k] + (target[k] - b[k]) * t for k in range(self.dim))\n                    cand = self._clamp(cand)\n                    if (not self._point_blocked(cand)) and self._edge_free(a, cand) and self._edge_free(cand, c):\n                        cost = self._dist(a, cand) + self._dist(cand, c)\n                        if cost + 1e-9 < best_cost:\n                            best_cost = cost\n                            best = cand\n                            break\n                    t *= 0.5\n                if best != b:\n                    cur[i] = best\n                    improved = True\n            if not improved:\n                break\n        return cur\n\n    def _finalize_path_length_opt(self, path):\n        if not path or len(path) < 2:\n            return path\n        p = self._dedup(path)\n        p = self._visibility_prune(p)\n        preL = self._path_len(p)\n        p = self._shortcut(p, self.shortcut_attempts)\n        p = self._visibility_prune(p)\n        p = self._vertex_slide(p, self.slide_passes)\n        # Ensure non-increasing length\n        if self._path_len(p) <= preL + 1e-9:\n            return self._dedup(p)\n        return self._dedup(self._visibility_prune(path))",
          "objective": -35.27699,
          "time_improvement": 58.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1281.0,
          "node_improvement": 92.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025435256958007812,
                    "num_nodes_avg": 53.0,
                    "path_length_avg": 144.69673143688058,
                    "smoothness_avg": 0.03314433575334971,
                    "success_improvement": 0.0,
                    "time_improvement": 7.782657816326337,
                    "node_improvement": 86.65323596071518,
                    "length_improvement": 20.689428633008873,
                    "smoothness_improvement": 418.7808286169965,
                    "objective_score": 16.842358667788204
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03843412399291992,
                    "num_nodes_avg": 110.0,
                    "path_length_avg": 230.44795748855236,
                    "smoothness_avg": 0.08709211817757703,
                    "success_improvement": 0.0,
                    "time_improvement": 76.77400950049635,
                    "node_improvement": 92.6090169992609,
                    "length_improvement": 23.069838713645836,
                    "smoothness_improvement": 2140.9429306262177,
                    "objective_score": 47.578820731467495
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.005914950370788574,
                    "num_nodes_avg": 36.0,
                    "path_length_avg": 129.46421361331863,
                    "smoothness_avg": 0.10881121536240616,
                    "success_improvement": 0.0,
                    "time_improvement": 88.59936170652746,
                    "node_improvement": 95.4227590591227,
                    "length_improvement": 14.016033741405511,
                    "smoothness_improvement": 1284.0706278013454,
                    "objective_score": 41.40978189580827
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "FOCUS-IBRRT*: Focused Optimal k-nearest Informed BiRRT* with volume-calibrated neighbor radius, exact prolate hyperspheroid sampling aligned to the start\u2013goal axis, direct line-of-sight strides, k-nearest least-cost parent selection, bounded benefit-ordered rewiring, and aggressive visibility-based shortcutting. It reduces path length by concentrating samples inside the informed lens once an incumbent exists, optimizing parent choice over a theoretically grounded neighbor set, and post-connection path compression.",
          "planning_mechanism": "Alternate growing the two trees. Each iteration: sample a target (goal/corridor/informed/uniform), find the nearest in a hashed grid, take a direct line-of-sight stride if possible else a bounded step, then choose the least-cost parent among a k-nearest (or radius) set derived from free-space volume and log(n)/n. Insert only after node and edge collision checks, then rewire nearby nodes if a shorter collision-free connection exists. Try to connect to the opposite tree. Maintain the best path length to focus informed sampling. On success, assemble and apply visibility pruning and multi-pass shortcuts to minimize length before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = parent\n        if parent is not None:\n            if self not in parent.children:\n                parent.children.append(self)\n\n    def path_from_root(self):\n        out = []\n        cur = self\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        out.reverse()\n        return out\nclass Planner:\n    def __init__(\n        self,\n        max_iter=7000,\n        step_size=6.0,\n        goal_bias=0.18,\n        corridor_bias=0.25,\n        informed_bias=0.55,\n        connect_factor=2.25,\n        k_factor=10.0,\n        k_cap=120,\n        rewire_cap=16,\n        dupe_radius_factor=0.25,\n        grid_cell_factor=1.1,\n        shortcut_passes=3,\n        shortcut_attempts=220\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.connect_factor = float(connect_factor)\n        self.k_factor = float(k_factor)\n        self.k_cap = int(k_cap)\n        self.rewire_cap = int(rewire_cap)\n        self.dupe_rf = float(dupe_radius_factor)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.shortcut_passes = int(shortcut_passes)\n        self.shortcut_attempts = int(shortcut_attempts)\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n        self._seed_rng()\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._build_obs_index()\n\n        if self._inside_obstacle(self.start) or self._inside_obstacle(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight line\n        if self._los(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Derived constants\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dupe_r = max(0.25, self.step * self.dupe_rf)\n        self.connect_dist = max(self.step, self.connect_factor * self.step)\n        self.axis = self._unit(self._sub(self.goal, self.start))\n        self.corridor_w = max(self.step, 0.15 * self._dist(self.start, self.goal))\n\n        # Trees and spatial hash\n        Aroot = Node(self.start, None, 0.0)\n        Broot = Node(self.goal, None, 0.0)\n        nodes = [Aroot, Broot]\n        edges = []\n        Ta, Tb = [Aroot], [Broot]\n        Ga, Gb = {}, {}\n        self._grid_put(Ga, Aroot)\n        self._grid_put(Gb, Broot)\n\n        # Free-space volume for RRT* radius\n        self.mu_free = self._free_volume()\n        self.zeta = 3.141592653589793 if self.dims == 2 else (4.0 * 3.141592653589793 / 3.0)\n        self.gamma_rrt = 2.6 * ((1.0 + 1.0 / self.dims) ** (1.0 / self.dims)) * (max(self.mu_free, 1e-9) / self.zeta) ** (1.0 / self.dims)\n\n        best_len = float('inf')\n        best_path = None\n\n        for it in range(self.max_iter):\n            grow_a = (len(Ta) <= len(Tb))  # grow smaller tree to balance\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            attractor = self.goal if grow_a else self.start\n\n            target = self._sample_target(attractor, best_len)\n            if target is None:\n                continue\n\n            near = self._nearest(G, T, target)\n            if near is None:\n                continue\n\n            new_pos = self._stride(near.position, target)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._inside_obstacle(new_pos):\n                continue\n            if self._too_close(G, new_pos, self.dupe_r):\n                continue\n\n            parent, new_cost = self._select_parent(G, T, new_pos)\n            if parent is None:\n                continue\n            # Both checks before add\n            if self._inside_obstacle(new_pos):\n                continue\n            if not self._los(parent.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, None, new_cost)\n            new_node.attach(parent)\n            T.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_put(G, new_node)\n\n            # Local bounded rewiring (benefit-ordered)\n            self._rewire(G, new_node, edges)\n\n            # Try to connect to the opposite tree\n            other = self._nearest(Gopp, Topp, new_node.position)\n            connected = False\n            end_node = None\n            if other is not None:\n                dno = self._dist(new_node.position, other.position)\n                if dno <= self.connect_dist and self._los(new_node.position, other.position):\n                    connected = True\n                    end_node = other\n                else:\n                    # Single micro-bridge step from opposite tree toward the new node\n                    step_p = self._toward(other.position, new_node.position, self.step)\n                    if self._in_bounds(step_p) and (not self._inside_obstacle(step_p)) and (not self._too_close(Gopp, step_p, self.dupe_r)) and self._los(other.position, step_p):\n                        q = Node(step_p, None, other.cost + self._dist(other.position, step_p))\n                        q.attach(other)\n                        Topp.append(q)\n                        nodes.append(q)\n                        edges.append((other, q))\n                        self._grid_put(Gopp, q)\n                        # Short connection check\n                        if self._los(new_node.position, q.position):\n                            connected = True\n                            end_node = q\n\n            if connected and end_node is not None:\n                path = self._assemble(new_node, end_node, grow_a)\n                path = self._compress(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Maintain incumbent best for informed sampling\n            if other is not None and self._los(new_node.position, other.position):\n                tmp = self._assemble(new_node, other, grow_a)\n                L = self._path_len(tmp)\n                if L < best_len:\n                    best_len = L\n                    best_path = tmp\n\n        if best_path is not None:\n            best_path = self._compress(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0\n        for v in (self.start + self.goal):\n            s = (s * 1664525 + int(997 * v + 0.5) + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        self._rng = s if s != 0 else 123456789\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _add(self, a, b):\n        return tuple(a[i] + b[i] for i in range(self.dims))\n\n    def _sub(self, a, b):\n        return tuple(a[i] - b[i] for i in range(self.dims))\n\n    def _scale(self, a, s):\n        return tuple(a[i] * s for i in range(self.dims))\n\n    def _dot(self, a, b):\n        return sum(a[i] * b[i] for i in range(self.dims))\n\n    def _norm(self, a):\n        return self._dist(a, tuple(0.0 for _ in range(self.dims)))\n\n    def _unit(self, a):\n        n = self._norm(a)\n        if n <= 1e-12:\n            return tuple(0.0 for _ in range(self.dims))\n        inv = 1.0 / n\n        return tuple(a[i] * inv for i in range(self.dims))\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    # Log approximation (for n>=1)\n    def _ln(self, x):\n        if x <= 0.0:\n            return -1e9\n        k = 0\n        while x > 2.0:\n            x *= 0.5\n            k += 1\n        # x in (0,2]\n        y = x - 1.0\n        term = y\n        s = term\n        i = 2.0\n        while abs(term) > 1e-6:\n            term *= -y * (i - 1.0) / i\n            s += term\n            i += 1.0\n            if i > 32.0:\n                break\n        # ln(x) = s + k*ln(2)\n        return s + k * 0.6931471805599453\n\n    # Obstacle index\n    def _build_obs_index(self):\n        self.obs_cell = max(3.0, self.step * 1.3)\n        self.og = {}\n        if self.dims == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.og.get(key)\n                            if b is None:\n                                self.og[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.og.get(key)\n                        if b is None:\n                            self.og[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _inside_obstacle(self, p):\n        if self.dims == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.og.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.og.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    # Segment vs obstacle intersection\n    def _los(self, a, b):\n        return not self._hit_seg(a, b)\n\n    def _hit_seg(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            seen = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        ids = self.og.get((i, j, k))\n                        if ids:\n                            for idx in ids:\n                                if idx in seen:\n                                    continue\n                                seen.add(idx)\n                                ox, oy, oz, w, h, d = self.obstacles[idx]\n                                if self._seg_box(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            seen = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    ids = self.og.get((i, j))\n                    if ids:\n                        for idx in ids:\n                            if idx in seen:\n                                continue\n                            seen.add(idx)\n                            ox, oy, w, h = self.obstacles[idx]\n                            if self._seg_box(a, b, (ox, oy), (ox + w, oy + h)):\n                                return True\n            return False\n\n    def _seg_box(self, p0, p1, bmin, bmax):\n        # Liang-Barsky slab\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Spatial hashing for nodes\n    def _key_of(self, pos):\n        return tuple(int(pos[i] // self.cell) for i in range(self.dims))\n\n    def _grid_put(self, grid, node):\n        k = self._key_of(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _ring_fetch(self, grid, key, radius):\n        out = []\n        if self.dims == 3:\n            for dx in range(-radius, radius + 1):\n                for dy in range(-radius, radius + 1):\n                    for dz in range(-radius, radius + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-radius, radius + 1):\n                for dy in range(-radius, radius + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, tree, pos):\n        key = self._key_of(pos)\n        best, bestd = None, 1e100\n        found = False\n        for r in range(0, 6):\n            cand = self._ring_fetch(grid, key, r)\n            if cand:\n                found = True\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                break\n        if not found:\n            # Random subsample fallback\n            if not tree:\n                return None\n            step = max(1, len(tree) // 32)\n            for i in range(0, len(tree), step):\n                n = tree[i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors_radius(self, grid, pos, radius, cap):\n        key = self._key_of(pos)\n        r = max(1, int(radius // self.cell) + 1)\n        cand = self._ring_fetch(grid, key, r)\n        out = []\n        rr = radius * radius\n        for n in cand:\n            d2 = 0.0\n            np = n.position\n            for i in range(self.dims):\n                dd = np[i] - pos[i]\n                d2 += dd * dd\n            if d2 <= rr:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _neighbors_k(self, grid, tree, pos, k):\n        # Gather from local rings and expand until we have >=k\n        key = self._key_of(pos)\n        picked = []\n        for r in range(0, 6):\n            cand = self._ring_fetch(grid, key, r)\n            if cand:\n                picked.extend(cand)\n            if len(picked) >= k:\n                break\n        if len(picked) < k:\n            # augment with sparse subsample\n            step = max(1, max(len(tree) // (k + 1), 1))\n            for i in range(0, len(tree), step):\n                picked.append(tree[i])\n                if len(picked) >= k:\n                    break\n        # sort by distance\n        picked = list({id(n): n for n in picked}.values())\n        picked.sort(key=lambda n: self._dist(n.position, pos))\n        return picked[:k]\n\n    def _too_close(self, grid, pos, r):\n        neigh = self._neighbors_radius(grid, pos, r, 1)\n        return len(neigh) > 0\n\n    # Parent selection\n    def _select_parent(self, grid, tree, pos):\n        n = max(1, len(tree))\n        ln = self._ln(float(n + 1))\n        # RRT* radius\n        r_rrt = (self.gamma_rrt * (ln / float(n))) ** (1.0 / self.dims) if n > 1 else self.step * 2.0\n        r_rrt = min(max(self.step, r_rrt), self.step * 6.0)\n        k = int(min(self.k_cap, max(2, int(self.k_factor * max(1.0, ln)))))\n        cand = self._neighbors_radius(grid, pos, r_rrt, self.k_cap)\n        if len(cand) < 2:\n            cand = self._neighbors_k(grid, tree, pos, k)\n        best_p = None\n        best_c = 1e100\n        for p in cand:\n            newc = p.cost + self._dist(p.position, pos)\n            if newc + 1e-9 < best_c and self._los(p.position, pos):\n                best_p = p\n                best_c = newc\n        return (best_p, best_c) if best_p is not None else (None, None)\n\n    # Rewiring\n    def _rewire(self, grid, node, edges):\n        # Use the same RRT* radius, prioritize by potential improvement\n        nset = self._neighbors_radius(grid, node.position, max(self.step * 4.0, self.step * 1.5), self.k_cap)\n        cand = []\n        for nb in nset:\n            if nb is node or nb is node.parent:\n                continue\n            # avoid cycles\n            if self._is_ancestor(nb, node):\n                continue\n            alt = node.cost + self._dist(node.position, nb.position)\n            gain = nb.cost - alt\n            if gain > 1e-9:\n                cand.append((gain, nb))\n        cand.sort(key=lambda x: -x[0])\n        changed = 0\n        for gain, nb in cand:\n            if changed >= self.rewire_cap:\n                break\n            if not self._los(node.position, nb.position):\n                continue\n            # Both checks (node already exists and valid)\n            oldp = nb.parent\n            if oldp is node:\n                continue\n            # Reparent\n            if oldp is not None:\n                try:\n                    oldp.children.remove(nb)\n                except:\n                    pass\n                self._remove_edge(edges, oldp, nb)\n            nb.attach(node)\n            edges.append((node, nb))\n            old_cost = nb.cost\n            nb.cost = node.cost + self._dist(node.position, nb.position)\n            # propagate to subtree\n            stack = [nb]\n            while stack:\n                cur = stack.pop()\n                for ch in cur.children:\n                    ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                    stack.append(ch)\n            changed += 1\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is p and e[1] is c:\n                edges.pop(i)\n                return\n\n    # Sampling\n    def _sample_target(self, attractor, best_len):\n        for _ in range(24):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._sample_informed(best_len)\n                if p is not None and not self._inside_obstacle(p):\n                    return p\n            r2 = self._rand()\n            if r2 < self.goal_bias:\n                p = attractor\n            elif r2 < self.goal_bias + self.corridor_bias:\n                p = self._sample_corridor()\n            else:\n                p = self._sample_uniform()\n            if self._in_bounds(p) and (not self._inside_obstacle(p)):\n                return p\n        return None\n\n    def _sample_uniform(self):\n        if self.dims == 3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_corridor(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n        if self.dims == 2:\n            # lateral offset perpendicular to axis\n            n = (-self.axis[1], self.axis[0])\n            off = self._scale(n, self._rand_range(-self.corridor_w, self.corridor_w))\n            p = self._add(base, off)\n        else:\n            # random combination of two orthonormal perpendiculars\n            u1, u2 = self._perp_basis(self.axis)\n            off = self._add(self._scale(u1, self._rand_range(-self.corridor_w, self.corridor_w)),\n                            self._scale(u2, self._rand_range(-self.corridor_w, self.corridor_w)))\n            p = self._add(base, off)\n        return self._clamp(p)\n\n    def _sample_informed(self, c_best):\n        cmin = self._dist(self.start, self.goal)\n        if not (c_best < float('inf')) or c_best <= cmin + 1e-9:\n            return None\n        a = 0.5 * c_best\n        l = 0.5 * cmin\n        if a <= l + 1e-12:\n            return None\n        b = (a * a - l * l) ** 0.5\n        center = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dims))\n        # sample uniformly in unit ball via rejection\n        if self.dims == 2:\n            for _ in range(32):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                if x * x + y * y <= 1.0:\n                    # scale to ellipse aligned with axis\n                    major = a * x\n                    minor = b * y\n                    n = (-self.axis[1], self.axis[0])\n                    p = self._add(center, self._add(self._scale(self.axis, major), self._scale(n, minor)))\n                    if self._in_bounds(p):\n                        return self._clamp(p)\n        else:\n            u1, u2 = self._perp_basis(self.axis)\n            for _ in range(32):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                z = self._rand_range(-1.0, 1.0)\n                if x * x + y * y + z * z <= 1.0:\n                    major = a * x\n                    minor1 = b * y\n                    minor2 = b * z\n                    p = self._add(center,\n                                  self._add(self._scale(self.axis, major),\n                                            self._add(self._scale(u1, minor1), self._scale(u2, minor2))))\n                    if self._in_bounds(p):\n                        return self._clamp(p)\n        return None\n\n    def _perp_basis(self, v):\n        # returns two orthonormal vectors perpendicular to v (3D)\n        if abs(v[0]) < 0.9:\n            tmp = (1.0, 0.0, 0.0)\n        else:\n            tmp = (0.0, 1.0, 0.0)\n        u1 = self._sub(tmp, self._scale(v, self._dot(tmp, v)))\n        n1 = self._norm(u1)\n        if n1 <= 1e-12:\n            u1 = (0.0, 0.0, 1.0)\n            n1 = 1.0\n        u1 = self._scale(u1, 1.0 / n1)\n        # cross v x u1\n        u2 = (v[1] * u1[2] - v[2] * u1[1],\n              v[2] * u1[0] - v[0] * u1[2],\n              v[0] * u1[1] - v[1] * u1[0])\n        n2 = self._norm(u2)\n        if n2 <= 1e-12:\n            u2 = (0.0, 0.0, 1.0)\n            n2 = 1.0\n        u2 = self._scale(u2, 1.0 / n2)\n        return u1, u2\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    # Stepping/steer\n    def _stride(self, a, target):\n        # If line-of-sight, go straight to target (bounded by connect range to avoid duplicates)\n        if self._los(a, target):\n            d = self._dist(a, target)\n            if d <= self.step * 4.0:\n                return self._clamp(target)\n            else:\n                return self._toward(a, target, self.step * 2.0)\n        # Otherwise bounded step\n        return self._toward(a, target, self.step)\n\n    def _toward(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        s = step if d > step else d\n        dirv = tuple((b[i] - a[i]) / d for i in range(self.dims))\n        p = tuple(a[i] + dirv[i] * s for i in range(self.dims))\n        return self._clamp(p)\n\n    # Path assembly\n    def _assemble(self, u, v, a_side):\n        pu = u.path_from_root()\n        pv = v.path_from_root()\n        if a_side:\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    # Path utilities\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _compress(self, path):\n        if len(path) <= 2:\n            return path[:]\n        # 1) Greedy visibility pruning (string pulling)\n        pts = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            extended = False\n            while j > i + 1:\n                if self._los(pts[-1], path[j]):\n                    pts.append(path[j])\n                    i = j\n                    extended = True\n                    break\n                j -= 1\n            if not extended:\n                pts.append(path[i + 1])\n                i += 1\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        # 2) Deterministic shortcut passes then randomized attempts\n        pts = self._shortcut_pass(pts)\n        for _ in range(max(0, self.shortcut_passes - 1)):\n            pts = self._shortcut_random(pts, self.shortcut_attempts)\n        return pts\n\n    def _shortcut_pass(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = list(path)\n        improved = True\n        while improved:\n            improved = False\n            i = 0\n            while i + 2 < len(pts):\n                j = i + 2\n                if self._los(pts[i], pts[j]):\n                    # if using this chord shortens length between i..j\n                    seg_old = 0.0\n                    for k in range(i + 1, j + 1):\n                        seg_old += self._dist(pts[k - 1], pts[k])\n                    seg_new = self._dist(pts[i], pts[j])\n                    if seg_new + 1e-9 < seg_old:\n                        pts = pts[:i + 1] + pts[j:]\n                        improved = True\n                        # stay at same i to try extend further\n                        continue\n                i += 1\n        return pts\n\n    def _shortcut_random(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = list(path)\n        best = self._path_len(pts)\n        n = len(pts)\n        stall = 0\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            a = pts[i]\n            b = pts[j - 1]\n            if self._los(a, b):\n                # check improvement\n                seg_old = 0.0\n                for k in range(i + 1, j):\n                    seg_old += self._dist(pts[k - 1], pts[k])\n                seg_new = self._dist(a, b)\n                if seg_new + 1e-9 < seg_old:\n                    pts = pts[:i + 1] + pts[j - 1:]\n                    n = len(pts)\n                    best = self._path_len(pts)\n                    stall = 0\n                    continue\n            stall += 1\n            if stall > 64:\n                break\n        return pts\n\n    # Volume\n    def _free_volume(self):\n        if self.dims == 2:\n            area = self.bounds[0] * self.bounds[1]\n            occ = 0.0\n            for ox, oy, w, h in self.obstacles:\n                w = max(0.0, min(w, self.bounds[0] - max(0.0, ox)))\n                h = max(0.0, min(h, self.bounds[1] - max(0.0, oy)))\n                if w > 0 and h > 0:\n                    occ += w * h\n            return max(area - occ, 1.0)\n        else:\n            vol = self.bounds[0] * self.bounds[1] * self.bounds[2]\n            occ = 0.0\n            for ox, oy, oz, w, h, d in self.obstacles:\n                w = max(0.0, min(w, self.bounds[0] - max(0.0, ox)))\n                h = max(0.0, min(h, self.bounds[1] - max(0.0, oy)))\n                d = max(0.0, min(d, self.bounds[2] - max(0.0, oz)))\n                if w > 0 and h > 0 and d > 0:\n                    occ += w * h * d\n            return max(vol - occ, 1.0)",
          "objective": -35.21019,
          "time_improvement": 63.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1597.0,
          "node_improvement": 91.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015950322151184082,
                    "num_nodes_avg": 50.0,
                    "path_length_avg": 166.92643526049486,
                    "smoothness_avg": 0.055910285668953376,
                    "success_improvement": 0.0,
                    "time_improvement": 42.170966930511455,
                    "node_improvement": 87.40871317048602,
                    "length_improvement": 8.504975715087154,
                    "smoothness_improvement": 775.1173818477029,
                    "objective_score": 21.62986241744424
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03612496852874756,
                    "num_nodes_avg": 87.0,
                    "path_length_avg": 242.7480790589756,
                    "smoothness_avg": 0.12274371886855026,
                    "success_improvement": 0.0,
                    "time_improvement": 78.16944712989631,
                    "node_improvement": 94.1544043539609,
                    "length_improvement": 18.963704094069396,
                    "smoothness_improvement": 3058.2842952149917,
                    "objective_score": 50.12047807148549
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.015928983688354492,
                    "num_nodes_avg": 69.0,
                    "path_length_avg": 129.74285308846646,
                    "smoothness_avg": 0.08321157406704471,
                    "success_improvement": 0.0,
                    "time_improvement": 69.29803801729228,
                    "node_improvement": 91.2269548633185,
                    "length_improvement": 13.830974669398307,
                    "smoothness_improvement": 958.4450800933132,
                    "objective_score": 33.88022160729324
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "AeroFuse-Connect IRRT*: A dual-informed, bidirectional RRT* with progressive connect, LRU edge-collision caching, grid-accelerated obstacle queries, adaptive step/rewire radii, k-nearest bridging, and two-phase cached shortcutting. It balances fast first-solution discovery with local rewiring and limited connect loops to improve robustness, path length, and smoothness while keeping collision checks low via spatial hashing and cache aging.",
          "planning_mechanism": "Mechanism: Alternate tree growth with a small beam of guided samples (goal-biased, then ellipse-informed after an incumbent). For each sample: steer a bounded step, validate node and edge, pick the cheapest visible parent among nearby nodes plus short ancestor lookback, insert, and locally rewire with cache-backed LOS. Attempt direct bridges to k nearest nodes of the opposite tree; if blocked, run a short progressive connect loop that inserts micro-steps toward the target. When a bridge is found, extract the path and apply randomized plus greedy cached shortcutting. Obstacle slab tests are restricted to candidates from an obstacle grid; an LRU-ish edge cache with quantization reduces repeated checks.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        child.parent = self\n        self.children.append(child)\n\n    def path_to_root(self):\n        pts = []\n        cur = self\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        base_step=8.0,\n        connect_steps=3,\n        beam_width=2,\n        goal_bias=0.22,\n        lookback_depth=5,\n        grid_cell_factor=1.4,\n        per_cell_cap=12,\n        dup_separation_factor=0.6,\n        rewire_radius_factor=2.2,\n        k_bridge=4,\n        edge_cache_capacity=50000,\n        edge_cache_quant_factor=0.5,\n        smooth_rand_attempts=90,\n        smooth_greedy_pass=1\n    ):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.connect_steps = connect_steps\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.lookback_depth = lookback_depth\n        self.grid_cell_factor = grid_cell_factor\n        self.per_cell_cap = per_cell_cap\n        self.dup_separation_factor = dup_separation_factor\n        self.rewire_radius_factor = rewire_radius_factor\n        self.k_bridge = k_bridge\n        self.edge_cache_capacity = edge_cache_capacity\n        self.edge_cache_quant_factor = edge_cache_quant_factor\n        self.smooth_rand_attempts = smooth_rand_attempts\n        self.smooth_greedy_pass = smooth_greedy_pass\n\n        # PRNG state\n        self._rnd = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        # Early identical start/goal\n        if self._dist(self.start, self.goal) <= 1e-12:\n            return PlannerResult(True, [self.start, self.goal], [], [])\n\n        # Edge cache\n        self._tick = 0\n        self._last_pruned = 0\n        self._ecache = {}\n        self._eq = max(0.25, self.base_step * self.edge_cache_quant_factor)\n\n        # Spatial hashing\n        self.cell_size = max(1.0, self.base_step * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.base_step * self.dup_separation_factor)\n\n        # Scene-based seed\n        self._seed_from_scene()\n\n        # Obstacle grid\n        self._build_obstacle_grid()\n\n        # Validate endpoints\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            path = [self.start, self.goal]\n            path = self._shortcut(path)  # cheap cleanup\n            return PlannerResult(True, path, [], [])\n\n        nodes = []\n        edges = []\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        incumbent_len = None\n\n        for it in range(self.max_iter):\n            # Alternate which tree grows first\n            if (it % 2) == 0:\n                sides = [(tree_a, grid_a, tree_b, grid_b, self.goal),\n                         (tree_b, grid_b, tree_a, grid_a, self.start)]\n            else:\n                sides = [(tree_b, grid_b, tree_a, grid_a, self.start),\n                         (tree_a, grid_a, tree_b, grid_b, self.goal)]\n\n            for active_tree, active_grid, other_tree, other_grid, attractor in sides:\n                # Adaptive step and radii\n                step = self.base_step if incumbent_len is None else max(3.0, self.base_step * 0.65)\n                rewire_r = max(step * self.rewire_radius_factor, self.cell_size * 1.2)\n                dup_sep = max(0.5, step * self.dup_separation_factor)\n\n                progressed = False\n                for _b in range(self.beam_width):\n                    q_rand = self._guided_sample(attractor, incumbent_len)\n                    if q_rand is None:\n                        continue\n\n                    nearest = self._nearest_in_grid(active_grid, q_rand, max_ring=6)\n                    if nearest is None:\n                        continue\n\n                    q_new = self._steer(nearest.position, q_rand, step)\n                    if not self._within_bounds(q_new):\n                        continue\n                    # Node collision\n                    if self._point_in_obstacles(q_new):\n                        continue\n                    # Edge collision\n                    if not self._edge_free(nearest.position, q_new):\n                        continue\n                    # Duplicate suppression\n                    if self._has_nearby(active_grid, q_new, dup_sep):\n                        continue\n\n                    # Parent selection: neighbors + short ancestor lookback\n                    parent = self._best_parent(nearest, q_new, active_grid, rewire_r, self.lookback_depth)\n                    new_cost = parent.cost + self._dist(parent.position, q_new)\n\n                    # Per-cell admission with simple gating\n                    if not self._cell_admit(active_grid, q_new, new_cost):\n                        continue\n\n                    # Insert node (after both checks already done)\n                    n_new = Node(q_new, parent, new_cost)\n                    parent.add_child(n_new)\n                    active_tree.append(n_new)\n                    nodes.append(n_new)\n                    edges.append((parent, n_new))\n                    self._grid_insert(active_grid, n_new)\n                    progressed = True\n\n                    # Local rewiring around the new node\n                    neighs = self._neighbors_in_grid(active_grid, q_new, rewire_r)\n                    self._rewire_from(n_new, neighs, edges)\n\n                    # Try bridging to k nearest nodes in the other tree\n                    join_node = None\n                    best_path = None\n                    best_len = 1e100\n\n                    others = self._nearest_k_in_grid(other_grid, q_new, k=self.k_bridge, max_ring=6)\n                    for on in others:\n                        if self._edge_free(n_new.position, on.position):\n                            path = n_new.path_to_root() + on.path_to_root()[::-1]\n                            if len(path) >= 2 and self._dist(path[-1], path[-2]) <= 1e-12:\n                                path.pop()\n                            sm = self._shortcut(path)\n                            L = self._path_len(sm)\n                            if L < best_len:\n                                best_len = L\n                                best_path = sm\n                                join_node = n_new\n                                break  # direct bridge found\n\n                        # Progressive connect if direct bridge blocked\n                        if join_node is None and self.connect_steps > 0:\n                            meet = self._progress_connect(n_new, on.position, active_tree, active_grid, step, dup_sep, rewire_r, nodes, edges)\n                            if meet is not None:\n                                path = meet.path_to_root() + on.path_to_root()[::-1]\n                                if len(path) >= 2 and self._dist(path[-1], path[-2]) <= 1e-12:\n                                    path.pop()\n                                sm = self._shortcut(path)\n                                L = self._path_len(sm)\n                                if L < best_len:\n                                    best_len = L\n                                    best_path = sm\n                                    join_node = meet\n                                    break\n\n                    if best_path is not None:\n                        incumbent_len = best_len\n                        return PlannerResult(True, best_path, nodes, edges)\n\n                if not progressed:\n                    continue\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # ---------- PRNG ----------\n    def _seed_from_scene(self):\n        s = 146959810  # FNV-ish\n        for v in self.start + self.goal:\n            s ^= (int(v * 997 + 0.5) & 0xffffffff)\n            s = (s * 16777619) & 0x7fffffff\n        s ^= (len(self.obstacles) * 374761393) & 0x7fffffff\n        if s == 0:\n            s = 123456789\n        self._rnd = s\n\n    def _rand(self):\n        # LCG\n        self._rnd = (1103515245 * self._rnd + 12345) & 0x7fffffff\n        return self._rnd / 2147483647.0\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= step:\n            return tuple(b)\n        r = step / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, attractor, incumbent_len):\n        # Pre-solution: mild goal bias; Post-solution: ellipse corridor\n        for _ in range(24):\n            if incumbent_len is not None and self._dist(self.start, self.goal) > 1e-9:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                if self._rand() < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            if self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum_dist\n        ext = [half] * self.dims\n        for _ in range(18):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._within_bounds(p) or self._point_in_obstacles(p):\n                continue\n            if self._dist(p, f1) + self._dist(p, f2) <= max_sum_dist:\n                return p\n        return None\n\n    # ---------- Node grid ----------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (\n                int(pos[0] // self.cell_size),\n                int(pos[1] // self.cell_size),\n                int(pos[2] // self.cell_size),\n            )\n        else:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _nearest_in_grid(self, grid, pos, max_ring=6):\n        cell = self._cell_of(pos)\n        best = None\n        best_d = 1e100\n        if self.is_3d:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if not bucket:\n                                continue\n                            for n in bucket:\n                                d = self._dist(n.position, pos)\n                                if d < best_d:\n                                    best_d = d\n                                    best = n\n                                    found = True\n                if found:\n                    return best\n        else:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if not bucket:\n                            continue\n                        for n in bucket:\n                            d = self._dist(n.position, pos)\n                            if d < best_d:\n                                best_d = d\n                                best = n\n                                found = True\n                if found:\n                    return best\n        # Fallback: scan all buckets\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._dist(n.position, pos)\n                if d < best_d:\n                    best_d = d\n                    best = n\n        return best\n\n    def _nearest_k_in_grid(self, grid, pos, k=3, max_ring=6):\n        cell = self._cell_of(pos)\n        cand = []\n        seen = set()\n        if self.is_3d:\n            for ring in range(0, max_ring + 1):\n                any_found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            key = (cell[0] + dx, cell[1] + dy, cell[2] + dz)\n                            if key in seen:\n                                continue\n                            seen.add(key)\n                            bucket = grid.get(key)\n                            if bucket:\n                                any_found = True\n                                for n in bucket:\n                                    cand.append((self._dist(n.position, pos), n))\n                if any_found and len(cand) >= k:\n                    break\n        else:\n            for ring in range(0, max_ring + 1):\n                any_found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        key = (cell[0] + dx, cell[1] + dy)\n                        if key in seen:\n                            continue\n                        seen.add(key)\n                        bucket = grid.get(key)\n                        if bucket:\n                            any_found = True\n                            for n in bucket:\n                                cand.append((self._dist(n.position, pos), n))\n                if any_found and len(cand) >= k:\n                    break\n        if not cand:\n            for bucket in grid.values():\n                for n in bucket:\n                    cand.append((self._dist(n.position, pos), n))\n        cand.sort(key=lambda x: x[0])\n        return [n for _, n in cand[:k]]\n\n    def _neighbors_in_grid(self, grid, pos, radius):\n        out = []\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if not bucket:\n                            continue\n                        for n in bucket:\n                            if self._dist(n.position, pos) <= radius:\n                                out.append(n)\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if not bucket:\n                        continue\n                    for n in bucket:\n                        if self._dist(n.position, pos) <= radius:\n                            out.append(n)\n        return out\n\n    def _has_nearby(self, grid, pos, radius):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if not bucket:\n                            continue\n                        for n in bucket:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if not bucket:\n                        continue\n                    for n in bucket:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    def _cell_admit(self, grid, pos, cand_cost):\n        key = self._cell_of(pos)\n        bucket = grid.get(key)\n        if not bucket or len(bucket) < self.per_cell_cap:\n            return True\n        # Simple cost gate vs best in cell\n        best_cost = 1e100\n        for n in bucket:\n            if n.cost < best_cost:\n                best_cost = n.cost\n        return cand_cost + 1e-9 < best_cost\n\n    # ---------- Obstacle grid and collision ----------\n    def _build_obstacle_grid(self):\n        self._obs_cell = max(4.0, self.base_step * 1.5)\n        self._obs_grid = {}\n        self._obs_is_3d = self.is_3d\n        if self._obs_is_3d:\n            for idx, ob in enumerate(self.obstacles):\n                x, y, z, w, h, d = ob\n                cx0 = int(max(0.0, x) // self._obs_cell)\n                cy0 = int(max(0.0, y) // self._obs_cell)\n                cz0 = int(max(0.0, z) // self._obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self._obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self._obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self._obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            key = (cx, cy, cz)\n                            if key in self._obs_grid:\n                                self._obs_grid[key].append(idx)\n                            else:\n                                self._obs_grid[key] = [idx]\n        else:\n            for idx, ob in enumerate(self.obstacles):\n                x, y, w, h = ob\n                cx0 = int(max(0.0, x) // self._obs_cell)\n                cy0 = int(max(0.0, y) // self._obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self._obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self._obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        key = (cx, cy)\n                        if key in self._obs_grid:\n                            self._obs_grid[key].append(idx)\n                        else:\n                            self._obs_grid[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self._obs_is_3d:\n            cx = int(p[0] // self._obs_cell)\n            cy = int(p[1] // self._obs_cell)\n            cz = int(p[2] // self._obs_cell)\n            bucket = self._obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self._obs_cell)\n            cy = int(p[1] // self._obs_cell)\n            bucket = self._obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self._eq) for i in range(self.dims))\n        qb = tuple(int(b[i] / self._eq) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self._ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self._ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self._ecache[key] = (free, self._tick)\n        if len(self._ecache) - self._last_pruned > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self._ecache:\n            return\n        # Age-based prune: drop entries older than (tick - window), else drop every 3rd\n        window = 2500\n        cutoff = self._tick - window\n        to_del = []\n        for k, v in self._ecache.items():\n            if v[1] < cutoff:\n                to_del.append(k)\n        if not to_del:\n            i = 0\n            for k in list(self._ecache.keys()):\n                if (i % 3) == 0:\n                    to_del.append(k)\n                i += 1\n        for k in to_del:\n            if k in self._ecache:\n                del self._ecache[k]\n        self._last_pruned = len(self._ecache)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self._obs_is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self._obs_cell)\n            cy0 = int(max(0.0, miny) // self._obs_cell)\n            cz0 = int(max(0.0, minz) // self._obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self._obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self._obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self._obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bucket = self._obs_grid.get((cx, cy, cz))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self._obs_cell)\n            cy0 = int(max(0.0, miny) // self._obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self._obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self._obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bucket = self._obs_grid.get((cx, cy))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # ---------- Parent selection and rewiring ----------\n    def _best_parent(self, nearest, q_new, grid, neighbor_radius, lookback):\n        best = nearest\n        best_cost = nearest.cost + self._dist(nearest.position, q_new)\n        # Nearby nodes\n        neighs = self._neighbors_in_grid(grid, q_new, neighbor_radius)\n        for nb in neighs:\n            if self._edge_free(nb.position, q_new):\n                c = nb.cost + self._dist(nb.position, q_new)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best = nb\n        # Short ancestor lookback\n        cur = nearest\n        depth = 0\n        while cur is not None and depth < lookback:\n            if self._edge_free(cur.position, q_new):\n                c = cur.cost + self._dist(cur.position, q_new)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best = cur\n            cur = cur.parent\n            depth += 1\n        return best\n\n    def _rewire_from(self, pivot, neighbors, edges):\n        for nb in neighbors:\n            if nb is pivot or nb.parent is None:\n                continue\n            new_cost = pivot.cost + self._dist(pivot.position, nb.position)\n            if new_cost + 1e-12 < nb.cost and self._edge_free(pivot.position, nb.position):\n                old_parent = nb.parent\n                # Update edges coherence\n                try:\n                    edges.remove((old_parent, nb))\n                except ValueError:\n                    pass\n                if nb in old_parent.children:\n                    old_parent.children.remove(nb)\n                pivot.add_child(nb)\n                delta = new_cost - nb.cost\n                nb.cost = new_cost\n                edges.append((pivot, nb))\n                if abs(delta) > 0.0:\n                    self._propagate_cost(nb, delta)\n\n    def _propagate_cost(self, node, delta):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    # ---------- Progressive connect ----------\n    def _progress_connect(self, from_node, target_pos, active_tree, active_grid, step, dup_sep, rewire_r, nodes, edges):\n        current = from_node\n        for _ in range(self.connect_steps):\n            nxt = self._steer(current.position, target_pos, step)\n            if not self._within_bounds(nxt):\n                return None\n            if self._point_in_obstacles(nxt):\n                return None\n            if not self._edge_free(current.position, nxt):\n                return None\n            if self._has_nearby(active_grid, nxt, dup_sep):\n                return None\n            # Choose parent with quick lookback only (for speed)\n            parent = self._best_parent(current, nxt, active_grid, 0.0, min(2, self.lookback_depth))\n            new_cost = parent.cost + self._dist(parent.position, nxt)\n            if not self._cell_admit(active_grid, nxt, new_cost):\n                return None\n            nn = Node(nxt, parent, new_cost)\n            parent.add_child(nn)\n            active_tree.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_insert(active_grid, nn)\n            # Limited local rewire\n            if rewire_r > 0.0:\n                neighs = self._neighbors_in_grid(active_grid, nxt, rewire_r)\n                self._rewire_from(nn, neighs, edges)\n            current = nn\n            # Early success if LOS to target is free\n            if self._edge_free(current.position, target_pos):\n                return current\n        return None\n\n    # ---------- Smoothing ----------\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        # Random pair contractions using cached LOS\n        for _ in range(self.smooth_rand_attempts):\n            if len(pts) < 3:\n                break\n            i = int(self._rand_range(0, len(pts) - 2))\n            j = int(self._rand_range(i + 2, len(pts)))\n            if self._edge_free(pts[i], pts[j]):\n                del pts[i + 1:j]\n        # Greedy forward pass\n        for _pass in range(self.smooth_greedy_pass):\n            i = 0\n            while i < len(pts) - 2:\n                j = len(pts) - 1\n                improved = False\n                while j > i + 1:\n                    if self._edge_free(pts[i], pts[j]):\n                        del pts[i + 1:j]\n                        improved = True\n                        break\n                    j -= 1\n                if not improved:\n                    i += 1\n        return pts",
          "objective": -34.88191,
          "time_improvement": 58.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1698.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021793293952941894,
                    "num_nodes_avg": 70.0,
                    "path_length_avg": 169.2890388576565,
                    "smoothness_avg": 0.05355523016360862,
                    "success_improvement": 0.0,
                    "time_improvement": 20.98685501444851,
                    "node_improvement": 82.37219843868043,
                    "length_improvement": 7.209995245633105,
                    "smoothness_improvement": 738.2556491041739,
                    "objective_score": 14.313331897235285
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.021245622634887697,
                    "num_nodes_avg": 98.0,
                    "path_length_avg": 242.53571379984956,
                    "smoothness_avg": 0.12285372075383123,
                    "success_improvement": 0.0,
                    "time_improvement": 87.16113239461782,
                    "node_improvement": 93.41530605388698,
                    "length_improvement": 19.034597730160733,
                    "smoothness_improvement": 3061.1147229544267,
                    "objective_score": 52.874671971253925
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017209863662719725,
                    "num_nodes_avg": 115.0,
                    "path_length_avg": 123.12829693538227,
                    "smoothness_avg": 0.10966311568419326,
                    "success_improvement": 0.0,
                    "time_improvement": 66.82923466820458,
                    "node_improvement": 85.37825810553083,
                    "length_improvement": 18.224047914960124,
                    "smoothness_improvement": 1294.9067370137366,
                    "objective_score": 37.45773283450613
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "FLASH-Lite BiRRT: a fast bidirectional planner with obstacle-grid-accelerated collision checks, coarse edge memoization, tight goal/informed sampling, and shallow LOS compression. It limits per-step work via small beams and bounded neighbor searches, while a coarse node grid speeds nearest queries and duplicate suppression. A provisional path triggers ellipse-informed sampling and early return after light shortcutting.",
          "planning_mechanism": "Alternate growing start/goal trees. For each side, draw a small beam of samples (goal/informed/uniform), pick the best g+h candidate using hashed-nearest and bounded parent search, enforce node and edge checks via obstacle-grid slab tests with memoization, insert, apply one-hop LOS compression, then attempt a direct or short greedy connect to the opposite tree. On bridging, extract and lightly smooth the path and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=8.0,\n                 collision_step=1.0,\n                 beam_k=2,\n                 goal_bias=0.3,\n                 informed_bias=0.6,\n                 grid_cell_factor=1.2,\n                 dupe_radius_ratio=0.6,\n                 min_sep_ratio=0.3,\n                 connect_steps=3,\n                 heuristic_weight=0.7,\n                 smoothing_iters=25,\n                 edge_cache_max=40000,\n                 obs_cell_factor=2.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_step = collision_step\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.informed_bias = informed_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.min_sep_ratio = min_sep_ratio\n        self.connect_steps = connect_steps\n        self.heuristic_weight = heuristic_weight\n        self.smoothing_iters = smoothing_iters\n        self.edge_cache_max = edge_cache_max\n        self.obs_cell_factor = obs_cell_factor\n\n        # runtime\n        self.dim = 2\n        self.bounds = None\n        self.start = None\n        self.goal = None\n        self.obstacles = None\n        self.is_3d = False\n\n        # structures\n        self.node_cell = 1.0\n        self.dupe_radius = 1.0\n        self.min_sep = 1.0\n        self.edge_res = 1.0\n        self.cache_bin = 1.0\n        self.edge_cache = None\n        self.edge_cache_order = None\n\n        # obstacle grid\n        self.obs_cell = 4.0\n        self.obs_grid = None  # dict cell->list of obstacle indices\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = map.start\n        self.goal = map.goal\n        self.obstacles = map.obstacles\n\n        # configure discretizations\n        self.node_cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.min_sep = max(0.25, self.step_size * self.min_sep_ratio)\n        self.edge_res = max(0.5, min(self.collision_step, self.step_size * 0.5))\n        self.cache_bin = max(self.edge_res, 1.0)\n        self.edge_cache = {}\n        self.edge_cache_order = []\n        # obstacle spatial grid\n        base_cell = self.step_size * self.obs_cell_factor\n        self.obs_cell = max(2.0, base_cell)\n        self._build_obstacle_grid()\n\n        # validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_collision(self.start) or self._point_in_collision(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # early straight path\n        if not self._edge_blocked_memo(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # init trees\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n\n        dsg = self._dist(self.start, self.goal)\n        c_best = float('inf')\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            Ta = tree_a if active_start else tree_b\n            Tb = tree_b if active_start else tree_a\n            Ga = grid_a if active_start else grid_b\n            Gb = grid_b if active_start else grid_a\n            other_root = self.goal if active_start else self.start\n\n            best = None  # (parent, new_pos, score)\n\n            for _ in range(self.beam_k):\n                # Sampling: goal / informed / uniform\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = other_root\n                elif c_best < float('inf') and self._rand() < self.informed_bias:\n                    x_rand = self._sample_informed(c_best)\n                else:\n                    x_rand = self._sample_free()\n\n                near = self._nearest_hashed(Ga, Ta, x_rand)\n                if near is None:\n                    continue\n\n                new_pos = self._steer(near.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._point_in_collision(new_pos):\n                    continue\n                if self._dist(near.position, new_pos) < self.min_sep:\n                    continue\n                if self._exists_close(Ga, new_pos, self.dupe_radius):\n                    continue\n\n                # bounded parent search (nearest + neighbors within 1 ring)\n                parent = None\n                parent_cost = float('inf')\n                candidates = self._neighbors(Ga, new_pos, 1)\n                if not candidates:\n                    candidates = [near]\n                for p in candidates:\n                    if not self._edge_blocked_memo(p.position, new_pos):\n                        g = p.cost + self._dist(p.position, new_pos)\n                        if g < parent_cost:\n                            parent_cost = g\n                            parent = p\n                if parent is None:\n                    continue\n\n                # score by g + w*h (favor bridging)\n                other_near = self._nearest_hashed(Gb, Tb, new_pos)\n                h = self._dist(new_pos, other_near.position) if other_near is not None else self._dist(new_pos, other_root)\n                score = parent_cost + self.heuristic_weight * h\n                # prefer if direct bridge\n                if other_near is not None and not self._edge_blocked_memo(new_pos, other_near.position):\n                    score *= 0.25\n                if (best is None) or (score < best[2]):\n                    best = (parent, new_pos, score)\n\n            if best is None:\n                continue\n\n            parent, new_pos, _ = best\n\n            # enforce checks before insertion\n            if self._point_in_collision(new_pos):\n                continue\n            if self._edge_blocked_memo(parent.position, new_pos):\n                continue\n\n            # insert\n            new_cost = parent.cost + self._dist(parent.position, new_pos)\n            q_new = Node(new_pos, parent, new_cost)\n            parent.add_child(q_new)\n            Ta.append(q_new)\n            nodes.append(q_new)\n            edges.append((parent, q_new))\n            self._grid_add(Ga, q_new)\n\n            # shallow LOS compression to grandparent\n            gp = parent.parent\n            if gp is not None and not self._edge_blocked_memo(gp.position, q_new.position):\n                # reattach\n                try:\n                    parent.children.remove(q_new)\n                except:\n                    pass\n                self._edges_remove(edges, parent, q_new)\n                gp.add_child(q_new)\n                q_new.cost = gp.cost + self._dist(gp.position, q_new.position)\n                edges.append((gp, q_new))\n\n            # try direct bridge\n            other_near = self._nearest_hashed(Gb, Tb, q_new.position)\n            if other_near is not None and not self._edge_blocked_memo(q_new.position, other_near.position):\n                path = self._extract_path(q_new, other_near)\n                c_best = self._path_length(path)\n                path = self._smooth_path(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # short greedy connect from opposite tree\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                step_pos = self._steer(p.position, q_new.position, self.step_size)\n                if not self._in_bounds(step_pos):\n                    break\n                if self._point_in_collision(step_pos):\n                    break\n                if self._edge_blocked_memo(p.position, step_pos):\n                    break\n                # add micro step (checks passed)\n                q = Node(step_pos, p, p.cost + self._dist(p.position, step_pos))\n                p.add_child(q)\n                Tb.append(q)\n                nodes.append(q)\n                edges.append((p, q))\n                self._grid_add(Gb, q)\n                p = q\n                steps += 1\n                if not self._edge_blocked_memo(q_new.position, p.position):\n                    path = self._extract_path(q_new, p)\n                    c_best = self._path_length(path)\n                    path = self._smooth_path(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        if not hasattr(self, \"_rng\"):\n            self._rng = 2463534242\n        self._rng = (1664525 * self._rng + 1013904223) % (1 << 32)\n        return self._rng / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        if self.dim == 3:\n            return (min(max(p[0], 0.0), self.bounds[0]),\n                    min(max(p[1], 0.0), self.bounds[1]),\n                    min(max(p[2], 0.0), self.bounds[2]))\n        else:\n            return (min(max(p[0], 0.0), self.bounds[0]),\n                    min(max(p[1], 0.0), self.bounds[1]))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # node grid for nearest/dupe\n    def _grid_key(self, pos):\n        if self.dim == 3:\n            return (int(pos[0] // self.node_cell),\n                    int(pos[1] // self.node_cell),\n                    int(pos[2] // self.node_cell))\n        else:\n            return (int(pos[0] // self.node_cell),\n                    int(pos[1] // self.node_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        res = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            res.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        res.extend(b)\n        return res\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # search expanding rings; evaluate within first non-empty ring\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                return best\n        # fallback linear\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _neighbors(self, grid, pos, rings):\n        key = self._grid_key(pos)\n        cand = self._grid_ring_collect(grid, key, rings)\n        return cand\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        rc = int(radius / self.node_cell) + 1\n        cand = self._grid_ring_collect(grid, key, rc)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # obstacle grid\n    def _obs_key(self, pos):\n        if self.dim == 3:\n            return (int(pos[0] // self.obs_cell),\n                    int(pos[1] // self.obs_cell),\n                    int(pos[2] // self.obs_cell))\n        else:\n            return (int(pos[0] // self.obs_cell),\n                    int(pos[1] // self.obs_cell))\n\n    def _build_obstacle_grid(self):\n        self.obs_grid = {}\n        for idx, obs in enumerate(self.obstacles):\n            if self.is_3d:\n                x, y, z, w, h, d = obs\n                i0 = int(x // self.obs_cell)\n                i1 = int((x + w) // self.obs_cell)\n                j0 = int(y // self.obs_cell)\n                j1 = int((y + h) // self.obs_cell)\n                k0 = int(z // self.obs_cell)\n                k1 = int((z + d) // self.obs_cell)\n                for i in range(i0, i1 + 1):\n                    for j in range(j0, j1 + 1):\n                        for k in range(k0, k1 + 1):\n                            key = (i, j, k)\n                            bucket = self.obs_grid.get(key)\n                            if bucket is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                bucket.append(idx)\n            else:\n                x, y, w, h = obs\n                i0 = int(x // self.obs_cell)\n                i1 = int((x + w) // self.obs_cell)\n                j0 = int(y // self.obs_cell)\n                j1 = int((y + h) // self.obs_cell)\n                for i in range(i0, i1 + 1):\n                    for j in range(j0, j1 + 1):\n                        key = (i, j)\n                        bucket = self.obs_grid.get(key)\n                        if bucket is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _collect_obs_aabb(self, a_min, a_max):\n        # gather obstacle indices whose grid cells overlap the aabb\n        res = []\n        seen = {}\n        if self.is_3d:\n            i0 = int(a_min[0] // self.obs_cell)\n            i1 = int(a_max[0] // self.obs_cell)\n            j0 = int(a_min[1] // self.obs_cell)\n            j1 = int(a_max[1] // self.obs_cell)\n            k0 = int(a_min[2] // self.obs_cell)\n            k1 = int(a_max[2] // self.obs_cell)\n            for i in range(i0, i1 + 1):\n                for j in range(j0, j1 + 1):\n                    for k in range(k0, k1 + 1):\n                        bucket = self.obs_grid.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                if idx not in seen:\n                                    seen[idx] = 1\n                                    res.append(idx)\n        else:\n            i0 = int(a_min[0] // self.obs_cell)\n            i1 = int(a_max[0] // self.obs_cell)\n            j0 = int(a_min[1] // self.obs_cell)\n            j1 = int(a_max[1] // self.obs_cell)\n            for i in range(i0, i1 + 1):\n                for j in range(j0, j1 + 1):\n                    bucket = self.obs_grid.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            if idx not in seen:\n                                seen[idx] = 1\n                                res.append(idx)\n        return res\n\n    # collision\n    def _point_in_collision(self, p):\n        # gather candidate obstacles from cell\n        key = self._obs_key(p)\n        cand = self.obs_grid.get(key, [])\n        if self.is_3d:\n            px, py, pz = p\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = p\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_blocked_memo(self, a, b):\n        key = self._edge_key_q(a, b)\n        st = self.edge_cache.get(key)\n        if st is not None:\n            return st == 1\n        blocked = self._segment_blocked(a, b)\n        self.edge_cache[key] = 1 if blocked else 2\n        self.edge_cache_order.append(key)\n        if len(self.edge_cache_order) > self.edge_cache_max:\n            # gentle pruning: drop oldest quarter\n            trim = max(1, self.edge_cache_max // 4)\n            for _ in range(trim):\n                k = self.edge_cache_order.pop(0)\n                try:\n                    del self.edge_cache[k]\n                except:\n                    pass\n        return blocked\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _segment_blocked(self, a, b):\n        # collect candidate obstacles from segment AABB\n        if self.is_3d:\n            a_min = (min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2]))\n            a_max = (max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2]))\n            cand = self._collect_obs_aabb(a_min, a_max)\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            a_min = (min(a[0], b[0]), min(a[1], b[1]))\n            a_max = (max(a[0], b[0]), max(a[1], b[1]))\n            cand = self._collect_obs_aabb(a_min, a_max)\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_2d(self, a, b, bmin, bmax):\n        # slab method\n        t0 = 0.0\n        t1 = 1.0\n        dx = b[0] - a[0]\n        dy = b[1] - a[1]\n        # X\n        if abs(dx) < 1e-12:\n            if a[0] < bmin[0] or a[0] > bmax[0]:\n                return False\n        else:\n            inv = 1.0 / dx\n            tmin = (bmin[0] - a[0]) * inv\n            tmax = (bmax[0] - a[0]) * inv\n            if tmin > tmax:\n                tmin, tmax = tmax, tmin\n            t0 = max(t0, tmin)\n            t1 = min(t1, tmax)\n            if t0 > t1:\n                return False\n        # Y\n        if abs(dy) < 1e-12:\n            if a[1] < bmin[1] or a[1] > bmax[1]:\n                return False\n        else:\n            inv = 1.0 / dy\n            tmin = (bmin[1] - a[1]) * inv\n            tmax = (bmax[1] - a[1]) * inv\n            if tmin > tmax:\n                tmin, tmax = tmax, tmin\n            t0 = max(t0, tmin)\n            t1 = min(t1, tmax)\n            if t0 > t1:\n                return False\n        return True\n\n    def _seg_aabb_3d(self, a, b, bmin, bmax):\n        t0 = 0.0\n        t1 = 1.0\n        for i in range(3):\n            d = b[i] - a[i]\n            if abs(d) < 1e-12:\n                if a[i] < bmin[i] or a[i] > bmax[i]:\n                    return False\n            else:\n                inv = 1.0 / d\n                tmin = (bmin[i] - a[i]) * inv\n                tmax = (bmax[i] - a[i]) * inv\n                if tmin > tmax:\n                    tmin, tmax = tmax, tmin\n                if tmin > t0:\n                    t0 = tmin\n                if tmax < t1:\n                    t1 = tmax\n                if t0 > t1:\n                    return False\n        return True\n\n    # sampling\n    def _sample_free(self):\n        while True:\n            if self.is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._point_in_collision(p):\n                return p\n\n    def _sample_informed(self, c_best):\n        # simple ellipse/hyper-ellipsoid rejection: sum of distances <= c_best\n        tries = 0\n        while tries < 40:\n            tries += 1\n            if self.is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= c_best and not self._point_in_collision(p):\n                return p\n        return self._sample_free()\n\n    # paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node):\n        path_a = self._path_to_root(a_node)\n        path_b = []\n        cur = b_node\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _path_length(self, path):\n        if len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _smooth_path(self, path):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        # random shortcuts\n        iters = self.smoothing_iters\n        for _ in range(iters):\n            if len(pts) < 3:\n                break\n            i = int(self._uniform(0, len(pts) - 2))\n            j = int(self._uniform(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked_memo(a, b):\n                pts = pts[:i + 1] + pts[j:]\n        # forward visibility collapse\n        collapsed = [pts[0]]\n        last = pts[0]\n        k = 1\n        while k < len(pts) - 1:\n            nxt = pts[k + 1]\n            if self._segment_blocked(last, nxt):\n                collapsed.append(pts[k])\n                last = pts[k]\n            k += 1\n        collapsed.append(pts[-1])\n        return collapsed\n\n    # edges bookkeeping\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)",
          "objective": -33.763,
          "time_improvement": 67.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1397.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015280461311340332,
                    "num_nodes_avg": 61.0,
                    "path_length_avg": 185.13604801409235,
                    "smoothness_avg": 0.050288639635450806,
                    "success_improvement": 0.0,
                    "time_improvement": 44.59959528623428,
                    "node_improvement": 84.63863006799295,
                    "length_improvement": -1.4760015849388635,
                    "smoothness_improvement": 687.1264138236365,
                    "objective_score": 15.929909704025151
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.020370221138000487,
                    "num_nodes_avg": 87.7,
                    "path_length_avg": 238.43136748544165,
                    "smoothness_avg": 0.09288723874146164,
                    "success_improvement": 0.0,
                    "time_improvement": 87.6901431990191,
                    "node_improvement": 94.10737082577437,
                    "length_improvement": 20.404746666968464,
                    "smoothness_improvement": 2290.0555567915944,
                    "objective_score": 50.00016874384478
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016862821578979493,
                    "num_nodes_avg": 88.3,
                    "path_length_avg": 127.88732909814462,
                    "smoothness_avg": 0.10332586481221465,
                    "success_improvement": 0.0,
                    "time_improvement": 67.49813314094155,
                    "node_improvement": 88.7730451366815,
                    "length_improvement": 15.063325353212544,
                    "smoothness_improvement": 1214.2973736893703,
                    "objective_score": 35.35892202265684
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "ARC-BiRRT: Adaptive Reuse-Cached, Ring-Hashed, Cost-Gated BiRRT-Connect. It accelerates bidirectional planning with exact edge-collision memoization, ring-hash nearest search, local LOS parent selection, per-cell cost-gated admission, and single-shot tree bridging; upon success it applies cache-reused visibility pruning and bounded shortcut smoothing for shorter, smoother paths.",
          "planning_mechanism": "Alternate expanding start/goal trees with small-beam guided sampling (goal/corridor bias); find a near node via ring-hash, steer one step, enforce node+edge checks and near-duplicate rejection; pick a best-cost parent among nearby ring neighbors that see the new point; admit only if per-cell capacity or cost improves; after insertion, attempt a direct LOS bridge to the opposite tree; on success, extract and cache-prune/shortcut the path and stop early.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=7.5,\n        beam_width=2,\n        goal_bias=0.3,\n        grid_cell_factor=1.6,\n        ring_max=3,\n        max_per_cell=6,\n        min_sep_factor=0.5,\n        los_neighbor_rings=1,\n        smoothing_iters=50,\n        corridor_bias=0.5\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.ring_max = ring_max\n        self.max_per_cell = max_per_cell\n        self.min_sep_factor = min_sep_factor\n        self.los_neighbor_rings = los_neighbor_rings\n        self.smoothing_iters = smoothing_iters\n        self.corridor_bias = corridor_bias\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        # RNG state\n        self._lcg_state = 2463534242\n\n        # Caches\n        self._edge_cache = {}  # exact endpoints (ordered) -> bool blocked\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Derived params\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.3, self.step_size * self.min_sep_factor)\n        self.edge_res = max(0.5, min(1.0, self.step_size * 0.5))\n\n        # Reset caches\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            path = [start, goal]\n            path = self._visibility_prune(path, obstacles, is_3d)\n            path = self._shortcut_smooth(path, obstacles, is_3d, iters=min(10, self.smoothing_iters))\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Initialize trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n        bestcost_start = {}\n        bestcost_goal = {}\n\n        self._grid_add(grid_start, counts_start, bestcost_start, start_root)\n        self._grid_add(grid_goal, counts_goal, bestcost_goal, goal_root)\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n\n            tree_a = start_tree if active_start else goal_tree\n            grid_a = grid_start if active_start else grid_goal\n            counts_a = counts_start if active_start else counts_goal\n            bestcost_a = bestcost_start if active_start else bestcost_goal\n\n            tree_b = goal_tree if active_start else start_tree\n            grid_b = grid_goal if active_start else grid_start\n            counts_b = counts_goal if active_start else counts_start\n            bestcost_b = bestcost_goal if active_start else bestcost_start\n\n            attractor = goal if active_start else start\n\n            for _ in range(self.beam_width):\n                x_rand = self._guided_sample(obstacles, is_3d, attractor)\n\n                nearest = self._nearest_hashed(grid_a, tree_a, x_rand)\n                if nearest is None:\n                    continue\n\n                new_pos = self._steer(nearest.position, x_rand)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._edge_blocked(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                if self._near_duplicate(grid_a, new_pos, self.min_sep):\n                    continue\n\n                # Choose a parent among local neighbors with LOS (limited rings) for better path cost\n                parent = self._choose_parent_local(grid_a, new_pos, nearest, obstacles, is_3d)\n                if self._edge_blocked(parent.position, new_pos, obstacles, is_3d):\n                    continue  # safety\n\n                new_cost = parent.cost + self._dist(parent.position, new_pos)\n\n                # Per-cell cost-gated admission\n                key_new = self._grid_key(new_pos)\n                ccount = counts_a.get(key_new, 0)\n                bestc = bestcost_a.get(key_new, float('inf'))\n                if ccount >= self.max_per_cell and not (new_cost + 1e-9 < bestc):\n                    continue\n\n                # Insert node\n                new_node = Node(new_pos, parent=parent, cost=new_cost)\n                parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((parent, new_node))\n                self._grid_add(grid_a, counts_a, bestcost_a, new_node)\n\n                # Try single-shot direct bridge to the other tree\n                other_near = self._nearest_hashed(grid_b, tree_b, new_node.position)\n                if other_near is not None:\n                    if not self._edge_blocked(new_node.position, other_near.position, obstacles, is_3d):\n                        path = self._extract_path(new_node, other_near, a_is_start_tree=active_start)\n                        path = self._visibility_prune(path, obstacles, is_3d)\n                        path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos):\n        d = self._dist(from_pos, to_pos)\n        if d <= 1e-9:\n            return self._clamp(from_pos)\n        if d <= self.step_size:\n            return self._clamp(to_pos)\n        r = self.step_size / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision and caching\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        if k in self._edge_cache:\n            return self._edge_cache[k]\n        blocked = self._segment_hits(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_hits(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _guided_sample(self, obstacles, is_3d, attractor):\n        # Goal-biased with optional corridor pull (activated only after success; here kept generic)\n        if self._rand() < self.goal_bias:\n            p = attractor\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # Mild blend toward attractor\n        alpha = 0.2\n        if self.dim == 3:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]),\n                   self._uniform(0.0, self.bounds[2]))\n            p = tuple(alpha * attractor[i] + (1.0 - alpha) * rnd[i] for i in range(3))\n        else:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]))\n            p = tuple(alpha * attractor[i] + (1.0 - alpha) * rnd[i] for i in range(2))\n        if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    # Grid / NN\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, bestcost, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n        bc = bestcost.get(k)\n        if bc is None or node.cost < bc:\n            bestcost[k] = node.cost\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.ring_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback to limited random subset to avoid O(N)\n        if not tree:\n            return None\n        trials = min(64, len(tree))\n        for _ in range(trials):\n            idx = int(self._uniform(0, len(tree)))\n            n = tree[idx]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r = 1\n        cand = self._grid_ring_collect(grid, key, r)\n        rr = radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # Parent selection among local neighbors with LOS\n    def _choose_parent_local(self, grid, new_pos, fallback_nearest, obstacles, is_3d):\n        key = self._grid_key(new_pos)\n        best_parent = fallback_nearest\n        best_cost = fallback_nearest.cost + self._dist(fallback_nearest.position, new_pos)\n        max_r = max(1, self.los_neighbor_rings)\n        for r in range(0, max_r + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            for n in cand:\n                if n is fallback_nearest or n is best_parent:\n                    pass\n                # Check LOS\n                if not self._edge_blocked(n.position, new_pos, obstacles, is_3d):\n                    c = n.cost + self._dist(n.position, new_pos)\n                    if c + 1e-9 < best_cost:\n                        best_cost = c\n                        best_parent = n\n        return best_parent\n\n    # Path\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -33.74569,
          "time_improvement": 58.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1051.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010497808456420898,
                    "num_nodes_avg": 34.0,
                    "path_length_avg": 154.57051194099205,
                    "smoothness_avg": 0.03958955729868922,
                    "success_improvement": 0.0,
                    "time_improvement": 58.830179046785545,
                    "node_improvement": 91.4379249559305,
                    "length_improvement": 15.277453078640955,
                    "smoothness_improvement": 519.6625418241595,
                    "objective_score": 29.41383827034103
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.049208974838256835,
                    "num_nodes_avg": 116.0,
                    "path_length_avg": 236.11546529476226,
                    "smoothness_avg": 0.06943512420354042,
                    "success_improvement": 0.0,
                    "time_improvement": 69.28227518814471,
                    "node_improvement": 92.20587247194786,
                    "length_improvement": 21.177861477765767,
                    "smoothness_improvement": 1686.6157578555544,
                    "objective_score": 41.92447823238064
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026494455337524415,
                    "num_nodes_avg": 117.0,
                    "path_length_avg": 122.03531483713664,
                    "smoothness_avg": 0.08227711903121854,
                    "success_improvement": 0.0,
                    "time_improvement": 45.98660915000911,
                    "node_improvement": 85.12396694214877,
                    "length_improvement": 18.94995458240024,
                    "smoothness_improvement": 946.5588810119002,
                    "objective_score": 29.898749899502377
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Adaptive Goal-Biased Grid BiRRT (AG-GBiRRT): a simplified, robust bidirectional RRT with commit-only connection, grid-accelerated nearest search, and light post-connection shortcut smoothing. It alternates growing two trees, uses uniform-with-goal-bias sampling, single-step steering with strict node/edge collision checks, and an early straight-line test. Upon any successful bridge between trees, it extracts the path and performs a few inexpensive shortcuts for smoothness, returning quickly without extra rewiring or bloat.",
          "planning_mechanism": "Mechanism: alternate start/goal tree expansion; sample (goal-biased), find nearest via grid, steer one step, validate node and edge, add node and edge, attempt a direct, collision-free bridge to the opposite tree (commit-only); on success, extract [start\u2192\u2026\u2192meetA, meetB\u2192\u2026\u2192goal] and run brief shortcut smoothing; terminate on success or iteration budget.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size * 2.0)\n        self.edge_res = max(0.5, self.collision_step)\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_res):\n            path = [start, goal]\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Trees and grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = goal if active_start else start\n\n            # Sample with goal/opposite-root bias\n            if self._rand() < self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest and steer\n            nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                continue\n\n            # Insert node (both node and edge validated)\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, new_node)\n\n            # Try commit-only direct connection to the other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None:\n                if not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                    path = self._extract_path(new_node, other_near)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- Random ----------\n    def _rand(self):\n        try:\n            return self._lcg_next()\n        except:\n            return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Sampling ----------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ---------- Grid nearest ----------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    # ---------- Path ----------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # path_a ends at meet_a; we then go straight to meet_b and up to other root\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            # pick two indices i < j with at least one point between\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -32.96764,
          "time_improvement": 69.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1142.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01299290657043457,
                    "num_nodes_avg": 78.8,
                    "path_length_avg": 167.86786188508313,
                    "smoothness_avg": 0.03825680999831742,
                    "success_improvement": 0.0,
                    "time_improvement": 49.04501835909778,
                    "node_improvement": 80.15613195668597,
                    "length_improvement": 7.988964864290817,
                    "smoothness_improvement": 498.8021524662562,
                    "objective_score": 22.000895188635106
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02625594139099121,
                    "num_nodes_avg": 208.9,
                    "path_length_avg": 244.3021244779086,
                    "smoothness_avg": 0.07331771296729457,
                    "success_improvement": 0.0,
                    "time_improvement": 83.61025026480232,
                    "node_improvement": 85.96385137405093,
                    "length_improvement": 18.444919002512343,
                    "smoothness_improvement": 1786.5175632625994,
                    "objective_score": 45.082614297261095
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01305999755859375,
                    "num_nodes_avg": 163.0,
                    "path_length_avg": 140.27860161008172,
                    "smoothness_avg": 0.09759083301298958,
                    "success_improvement": 0.0,
                    "time_improvement": 73.37500455677744,
                    "node_improvement": 79.27527018436109,
                    "length_improvement": 6.833632159773637,
                    "smoothness_improvement": 1141.348192519241,
                    "objective_score": 31.819421625493614
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Algorithm description: SWIFT-BiRRT-LOS \u2014 Simple, Weighted-bias, Informed, Fast Triaged Bi-directional RRT with hashed-near lookup, near-duplicate suppression, on-the-fly line-of-sight grandparent compression, light bounded connect-extend, and capped shortcut smoothing for faster, shorter, and smoother paths.",
          "planning_mechanism": "Planning mechanism: Alternate growing two trees with balanced goal/corridor/informed-biased samples. For each sample, find a hashed-nearest node, steer once, check node and edge collisions, insert if not near-duplicate and the cell is not saturated, then immediately try LOS compression to the grandparent to shorten chains. Attempt to connect to the opposite tree using a costless direct check first, then a few bounded, collision-checked extend steps. On success, merge trees and return a visibility-pruned, lightly-shortcutted path; otherwise stop on budget or stall.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=10.0,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 rings_near=2,\n                 goal_bias=0.2,\n                 corridor_bias=0.4,\n                 informed_bias=0.5,\n                 dupe_radius_ratio=0.6,\n                 cell_cap=10,\n                 connect_radius_factor=4.0,\n                 connect_steps=3,\n                 smoothing_attempts=24,\n                 stall_limit=700,\n                 edge_cache_limit=30000):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.collision_step = float(collision_step)\n        self.grid_cell = grid_cell\n        self.rings_near = int(max(1, rings_near))\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.cell_cap = int(max(2, cell_cap))\n        self.connect_radius_factor = float(max(1.0, connect_radius_factor))\n        self.connect_steps = int(max(0, connect_steps))\n        self.smoothing_attempts = int(max(0, smoothing_attempts))\n        self.stall_limit = int(max(100, stall_limit))\n        self.edge_cache_limit = int(max(2000, edge_cache_limit))\n\n        self.bounds = None\n        self.dim = 2\n        self.start = None\n        self.goal = None\n        self.edge_cache = None\n        self.edge_stamp = 0\n        self.edge_res = 1.0\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.8 * self.step_size)\n        self.edge_res = max(0.5, min(self.collision_step, 0.5 * self.step_size))\n\n        self.edge_cache = {}\n        self.edge_stamp = 0\n\n        # Early direct connection\n        if not self._edge_blocked_memo(self.start, self.goal, obstacles, is_3d):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            edges = [(n0, n1)]\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], edges)\n\n        # Initialize trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n\n        dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        connect_radius = max(self.step_size, self.connect_radius_factor * self.step_size)\n        dsg = self._dist(self.start, self.goal)\n        corridor_base = max(self.step_size, 0.2 * dsg)\n\n        best_path = None\n        best_len = float('inf')\n        last_improve = 0\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            other_root = self.goal if active_start else self.start\n\n            # Sampling strategy\n            if best_path is not None and self._rand() < self.informed_bias:\n                x_rand = self._sample_informed(best_len, obstacles, is_3d)\n            else:\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = other_root\n                elif r < self.goal_bias + self.corridor_bias:\n                    width = max(self.step_size, corridor_base + (0.1 * (best_len - dsg) if best_path is not None else 0.0))\n                    x_rand = self._sample_corridor(width, obstacles, is_3d)\n                else:\n                    x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest and steer\n            nearest = self._nearest(grid1, tree1, x_rand)\n            if nearest is None:\n                continue\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._exists_close(grid1, new_pos, dupe_radius):\n                continue\n            if not self._cell_accept(grid1, new_pos):\n                continue\n            if self._edge_blocked_memo(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Insert node\n            new_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            self._grid_add(grid1, new_node)\n            edges.append((nearest, new_node))\n\n            # LOS grandparent compression\n            gp = nearest.parent\n            if gp is not None and not self._edge_blocked_memo(gp.position, new_pos, obstacles, is_3d):\n                # reparent new_node to grandparent\n                try:\n                    nearest.children.remove(new_node)\n                except:\n                    pass\n                self._remove_edge(edges, nearest, new_node)\n                gp.add_child(new_node)\n                new_node.cost = gp.cost + self._dist(gp.position, new_pos)\n                edges.append((gp, new_node))\n\n            # Try connect to opposite tree (direct first, then bounded extend)\n            qnear = self._nearest(grid2, tree2, new_node.position)\n            if qnear is not None and self._dist(qnear.position, new_node.position) <= connect_radius:\n                if not self._edge_blocked_memo(new_node.position, qnear.position, obstacles, is_3d):\n                    a_end = new_node\n                    b_end = qnear\n                else:\n                    a_end, b_end = self._bounded_connect_extend(new_node, tree2, grid2, dupe_radius, obstacles, is_3d, edges, nodes)\n                if a_end is not None and b_end is not None:\n                    path = self._merge_paths(a_end, b_end) if active_start else self._merge_paths(b_end, a_end)\n                    plen = self._path_length(path)\n                    if plen < best_len:\n                        best_path = path\n                        best_len = plen\n                        last_improve = it\n                    final = self._finalize_path(best_path, obstacles, is_3d)\n                    return PlannerResult(True, final, nodes, edges)\n\n            if best_path is not None and (it - last_improve) >= self.stall_limit:\n                final = self._finalize_path(best_path, obstacles, is_3d)\n                return PlannerResult(True, final, nodes, edges)\n\n        if best_path is not None:\n            final = self._finalize_path(best_path, obstacles, is_3d)\n            return PlannerResult(True, final, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG (deterministic)\n    def _rand(self):\n        if not hasattr(self, \"_rng\"):\n            self._rng = 987654321\n        self._rng = (1103515245 * self._rng + 12345) % (1 << 31)\n        return (self._rng & 0x7fffffff) / float(1 << 31)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp_tuple(b)\n        if d <= 1e-12:\n            return self._clamp_tuple(a)\n        r = step / d\n        return self._clamp_tuple(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_exact(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked_memo(self, a, b, obstacles, is_3d):\n        key = self._edge_key_exact(a, b)\n        st = self.edge_cache.get(key)\n        if st is not None:\n            return st[0] == 1\n        blocked = self._edge_blocked(a, b, obstacles, is_3d)\n        self.edge_stamp += 1\n        self.edge_cache[key] = (1 if blocked else 2, self.edge_stamp)\n        if len(self.edge_cache) > self.edge_cache_limit:\n            cutoff = self.edge_stamp - (self.edge_cache_limit // 2)\n            self.edge_cache = {k: v for k, v in self.edge_cache.items() if v[1] >= cutoff}\n        return blocked\n\n    # Spatial hashing\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.rings_near + 1):\n            cand = self._ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback random subset\n        if tree:\n            k = min(16, len(tree))\n            for _ in range(k):\n                idx = int(self._uniform(0, len(tree)))\n                n = tree[idx % len(tree)]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius // self.grid_cell) + 1\n        cand = self._ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    def _cell_accept(self, grid, pos):\n        key = self._grid_key(pos)\n        lst = grid.get(key)\n        if lst is None:\n            return True\n        return len(lst) < self.cell_cap\n\n    # Connect helpers\n    def _bounded_connect_extend(self, new_node, other_tree, other_grid, dupe_radius, obstacles, is_3d, edges, nodes):\n        q = self._nearest(other_grid, other_tree, new_node.position)\n        if q is None:\n            return (None, None)\n        cur = q\n        for _ in range(self.connect_steps):\n            nxt_pos = self._steer(cur.position, new_node.position, self.step_size)\n            if not self._in_bounds(nxt_pos):\n                break\n            if self._is_in_obstacle(nxt_pos, obstacles, is_3d):\n                break\n            if self._exists_close(other_grid, nxt_pos, dupe_radius):\n                break\n            if self._edge_blocked_memo(cur.position, nxt_pos, obstacles, is_3d):\n                break\n            nxt = Node(nxt_pos, cur, cur.cost + self._dist(cur.position, nxt_pos))\n            cur.add_child(nxt)\n            other_tree.append(nxt)\n            nodes.append(nxt)\n            self._grid_add(other_grid, nxt)\n            edges.append((cur, nxt))\n            # LOS compression toward grandparent\n            gp = cur.parent\n            if gp is not None and not self._edge_blocked_memo(gp.position, nxt_pos, obstacles, is_3d):\n                try:\n                    cur.children.remove(nxt)\n                except:\n                    pass\n                self._remove_edge(edges, cur, nxt)\n                gp.add_child(nxt)\n                nxt.cost = gp.cost + self._dist(gp.position, nxt_pos)\n                edges.append((gp, nxt))\n            cur = nxt\n            if not self._edge_blocked_memo(cur.position, new_node.position, obstacles, is_3d):\n                return (new_node, cur)\n        return (None, None)\n\n    # Path utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_paths(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        pb.reverse()\n        return pa + pb\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _remove_edge(self, edges, a, b):\n        for i in range(len(edges)):\n            if edges[i][0] is a and edges[i][1] is b:\n                edges.pop(i)\n                return\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked_memo(pruned[-1], path[j], obstacles, is_3d):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _smooth_path(self, path, obstacles, is_3d, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return list(path)\n        pts = list(path)\n        best_len = self._path_length(pts)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and n >= 3:\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked_memo(a, b, obstacles, is_3d):\n                new_pts = pts[:i + 1] + pts[j:]\n                new_len = self._path_length(new_pts)\n                if new_len + 1e-9 < best_len:\n                    pts = new_pts\n                    best_len = new_len\n                    n = len(pts)\n            tries += 1\n        return pts\n\n    def _finalize_path(self, path, obstacles, is_3d):\n        if not path:\n            return []\n        pruned = self._visibility_prune(path, obstacles, is_3d)\n        return self._smooth_path(pruned, obstacles, is_3d, self.smoothing_attempts)\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        for _ in range(64):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        if self.dim == 3:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5, self.bounds[2] * 0.5)\n        else:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5)\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        tries = 0\n        while tries < 24:\n            if self.dim == 3:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                else:\n                    tries += 1\n                    continue\n            else:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                else:\n                    tries += 1\n                    continue\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n            tries += 1\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d):\n        for _ in range(48):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if (self._dist(self.start, p) + self._dist(p, self.goal) <= best_len + 1e-9 and\n                not self._is_in_obstacle(p, obstacles, is_3d)):\n                return p\n        return self._sample_corridor(max(self.step_size, 0.2 * self._dist(self.start, self.goal)), obstacles, is_3d)",
          "objective": -32.12619,
          "time_improvement": 59.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 1812.0,
          "node_improvement": 91.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01643836498260498,
                    "num_nodes_avg": 47.5,
                    "path_length_avg": 172.57597716951437,
                    "smoothness_avg": 0.055340882959087935,
                    "success_improvement": 0.0,
                    "time_improvement": 35.532778493067305,
                    "node_improvement": 88.03827751196172,
                    "length_improvement": 5.408372272033185,
                    "smoothness_improvement": 766.2049929605337,
                    "objective_score": 17.73588187594277
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.024622559547424316,
                    "num_nodes_avg": 81.2,
                    "path_length_avg": 250.16418359040821,
                    "smoothness_avg": 0.12448872572717391,
                    "success_improvement": 0.0,
                    "time_improvement": 84.62985642705796,
                    "node_improvement": 94.5441107303635,
                    "length_improvement": 16.487994940743906,
                    "smoothness_improvement": 3103.1845785650153,
                    "objective_score": 50.7976767853888
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.020916748046875,
                    "num_nodes_avg": 75.5,
                    "path_length_avg": 143.54340806097915,
                    "smoothness_avg": 0.13110948178151688,
                    "success_improvement": 0.0,
                    "time_improvement": 57.35770095388541,
                    "node_improvement": 90.40050858232676,
                    "length_improvement": 4.665303168464438,
                    "smoothness_improvement": 1567.7029307656137,
                    "objective_score": 27.845006841072355
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SWIFT-Connect-S: A simplified, fast, and robust bidirectional RRT-Connect with bounded collision memoization, hash-grid nearest search, informed sampling after a provisional path, limited greedy bridging, and shallow multi-ancestor line-of-sight compression. It minimizes redundant checks and data churn for stable, low-latency planning while maintaining high path quality and smoothness.",
          "planning_mechanism": "Alternate expansion of two trees toward sampled targets (goal-biased/uniform; ellipse-informed once a path exists). For each step, pick the nearest by grid, steer once, and add only if both node and edge are free (cached). After insertion, compress up to a few ancestors via LOS to shorten trees, then attempt a short capped greedy connect from the opposite tree; if connected, extract and quickly shortcut-smooth with early stop and return. Bounded caches and light structures keep iterations fast and consistent.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=8.0,\n                 goal_bias=0.15,\n                 informed_bias=0.60,\n                 grid_cell_factor=1.5,\n                 ring_limit=2,\n                 dup_radius_ratio=0.45,\n                 connect_cap=3,\n                 connect_step_factor=1.5,\n                 compress_depth=3,\n                 edge_res=1.0,\n                 edge_cache_max=50000,\n                 point_cache_max=60000,\n                 smoothing_iters=60,\n                 smooth_patience=12):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.informed_bias = informed_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.ring_limit = ring_limit\n        self.dup_radius_ratio = dup_radius_ratio\n        self.connect_cap = connect_cap\n        self.connect_step_factor = connect_step_factor\n        self.compress_depth = compress_depth\n        self.edge_res = edge_res\n        self.edge_cache_max = max(1000, int(edge_cache_max))\n        self.point_cache_max = max(1000, int(point_cache_max))\n        self.smoothing_iters = smoothing_iters\n        self.smooth_patience = smooth_patience\n\n        self.dim = 2\n        self.bounds = None\n        self.is_3d = False\n\n        self.cell = 1.0\n        self.q_point = 0.5\n        self.q_edge = 1.0\n\n        self._edge_cache = {}\n        self._point_cache = {}\n        self._rng_state = 2463534242\n\n        self.start = None\n        self.goal = None\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Quantization and grid\n        self.cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self.q_point = max(0.5, self.edge_res * 0.5)\n        self.q_edge = max(1.0, self.edge_res)\n\n        # reset caches\n        self._edge_cache = {}\n        self._point_cache = {}\n\n        # start/goal validity\n        if not self._point_free(self.start, obstacles) or not self._point_free(self.goal, obstacles):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight connection\n        if self._edge_free(self.start, self.goal, obstacles):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        best_len = float('inf')\n        d_sg = self._dist(self.start, self.goal)\n        dup_radius = max(0.5, self.step_size * self.dup_radius_ratio)\n\n        for it in range(self.max_iter):\n            grow_from_start = (it % 2 == 0)\n            tree1 = tree_a if grow_from_start else tree_b\n            tree2 = tree_b if grow_from_start else tree_a\n            grid1 = grid_a if grow_from_start else grid_b\n            grid2 = grid_b if grow_from_start else grid_a\n            other_root_pos = self.goal if grow_from_start else self.start\n\n            # Sample a target\n            if best_len < float('inf') and self._rand() < self.informed_bias:\n                x_rand = self._sample_informed(best_len, obstacles)\n            else:\n                if self._rand() < self.goal_bias:\n                    x_rand = other_root_pos\n                else:\n                    x_rand = self._sample_free(obstacles)\n\n            # Nearest and steer\n            near = self._nearest_by_grid(tree1, grid1, x_rand)\n            if near is None:\n                continue\n            x_new = self._steer(near.position, x_rand, self.step_size)\n            if not self._in_bounds(x_new):\n                continue\n            if self._has_near_duplicate(grid1, x_new, dup_radius):\n                continue\n\n            # Mandatory checks before insertion\n            if not self._point_free(x_new, obstacles):\n                continue\n            if not self._edge_free(near.position, x_new, obstacles):\n                continue\n\n            # Insert node\n            new_cost = near.cost + self._dist(near.position, x_new)\n            new_node = Node(x_new, near, new_cost)\n            near.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((near, new_node))\n            self._grid_insert(grid1, new_node)\n\n            # Shallow multi-ancestor LOS compression\n            self._compress_chain(new_node, obstacles, edges, self.compress_depth)\n\n            # Attempt to connect the other tree\n            other_near = self._nearest_by_grid(tree2, grid2, new_node.position)\n            connected = False\n            last_other = other_near\n\n            # Direct bridge first\n            if other_near is not None and self._edge_free(new_node.position, other_near.position, obstacles):\n                connected = True\n                last_other = other_near\n            else:\n                # Limited greedy connect from the other tree toward new_node\n                current = other_near\n                for _ in range(self.connect_cap):\n                    if current is None:\n                        break\n                    step = self.step_size * self.connect_step_factor\n                    nxt_pos = self._steer(current.position, new_node.position, step)\n                    if not self._in_bounds(nxt_pos):\n                        break\n                    if self._has_near_duplicate(grid2, nxt_pos, dup_radius):\n                        break\n                    if not self._point_free(nxt_pos, obstacles):\n                        break\n                    if not self._edge_free(current.position, nxt_pos, obstacles):\n                        break\n                    nxt_cost = current.cost + self._dist(current.position, nxt_pos)\n                    nxt_node = Node(nxt_pos, current, nxt_cost)\n                    current.add_child(nxt_node)\n                    tree2.append(nxt_node)\n                    nodes.append(nxt_node)\n                    edges.append((current, nxt_node))\n                    self._grid_insert(grid2, nxt_node)\n                    self._compress_chain(nxt_node, obstacles, edges, self.compress_depth)\n                    last_other = nxt_node\n                    # Try to close the bridge\n                    if self._edge_free(new_node.position, last_other.position, obstacles):\n                        connected = True\n                        break\n                    current = nxt_node\n\n            if connected:\n                path = self._extract_path(new_node, last_other, grow_from_start)\n                best_len = self._path_length(path)\n                path = self._smooth_path(path, obstacles, self.smoothing_iters, self.smooth_patience)\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._rng_state = (1664525 * self._rng_state + 1013904223) % (1 << 32)\n        return self._rng_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp_tuple(b)\n        if d <= 1e-12:\n            return self._clamp_tuple(a)\n        r = step / d\n        return self._clamp_tuple(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    # Collision and caching\n    def _qpos(self, p, q):\n        return tuple(int(p[i] // q) for i in range(self.dim))\n\n    def _edge_key(self, a, b, q):\n        qa = self._qpos(a, q)\n        qb = self._qpos(b, q)\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _point_key(self, p, q):\n        return self._qpos(p, q)\n\n    def _point_free(self, p, obstacles):\n        key = self._point_key(p, self.q_point)\n        cached = self._point_cache.get(key)\n        if cached is not None:\n            return cached\n        free = True\n        if self.is_3d:\n            px, py, pz = p\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    free = False\n                    break\n        else:\n            px, py = p\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    free = False\n                    break\n        self._point_cache[key] = free\n        if len(self._point_cache) > self.point_cache_max:\n            self._prune_half(self._point_cache)\n        return free\n\n    def _edge_free(self, a, b, obstacles):\n        key = self._edge_key(a, b, self.q_edge)\n        cached = self._edge_cache.get(key)\n        if cached is not None:\n            return cached\n        d = self._dist(a, b)\n        steps = int(d / self.edge_res)\n        if steps < 1:\n            steps = 1\n        free = True\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if not self._point_free(p, obstacles):\n                free = False\n                break\n        self._edge_cache[key] = free\n        if len(self._edge_cache) > self.edge_cache_max:\n            self._prune_half(self._edge_cache)\n        return free\n\n    def _prune_half(self, dct):\n        cnt = 0\n        to_del = []\n        for k in dct:\n            if (cnt % 2) == 0:\n                to_del.append(k)\n            cnt += 1\n            if len(to_del) >= len(dct) // 2:\n                break\n        for k in to_del:\n            try:\n                del dct[k]\n            except:\n                pass\n\n    # Spatial hash\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell) for i in range(self.dim))\n\n    def _grid_insert(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _nearest_by_grid(self, tree, grid, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        if self.dim == 3:\n            for r in range(self.ring_limit + 1):\n                found = False\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                            if b:\n                                for n in b:\n                                    d = self._dist(n.position, pos)\n                                    if d < bestd:\n                                        bestd = d\n                                        best = n\n                                        found = True\n                if found and best is not None:\n                    return best\n        else:\n            for r in range(self.ring_limit + 1):\n                found = False\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy))\n                        if b:\n                            for n in b:\n                                d = self._dist(n.position, pos)\n                                if d < bestd:\n                                    bestd = d\n                                    best = n\n                                    found = True\n                if found and best is not None:\n                    return best\n        # fallback\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _has_near_duplicate(self, grid, pos, radius):\n        rng = int(max(1, radius // self.cell)) + 1\n        key = self._grid_key(pos)\n        r2 = radius * radius\n        if self.dim == 3:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            s = 0.0\n                            for i in range(self.dim):\n                                d = n.position[i] - pos[i]\n                                s += d * d\n                            if s <= r2:\n                                return True\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        s = 0.0\n                        for i in range(self.dim):\n                            d = n.position[i] - pos[i]\n                            s += d * d\n                        if s <= r2:\n                            return True\n        return False\n\n    # Sampling\n    def _sample_free(self, obstacles):\n        for _ in range(64):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and self._point_free(p, obstacles):\n                return p\n        return self._clamp_tuple(self.start)\n\n    def _sample_informed(self, best_len, obstacles):\n        # Rejection sample within the prolate ellipse defined by start/goal foci and perimeter best_len\n        for _ in range(48):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= best_len + 1e-9 and self._point_free(p, obstacles):\n                return p\n        # Fallback to uniform free if ellipse sampling failed\n        return self._sample_free(obstacles)\n\n    # Compression utilities\n    def _compress_chain(self, node, obstacles, edges, depth_limit):\n        depth = 0\n        cur = node\n        while depth < depth_limit:\n            p = cur.parent\n            if p is None:\n                break\n            gp = p.parent\n            if gp is None:\n                break\n            if not self._edge_free(gp.position, cur.position, obstacles):\n                break\n            # reparent\n            p.remove_child(cur)\n            self._edges_remove(edges, p, cur)\n            gp.add_child(cur)\n            edges.append((gp, cur))\n            old_cost = cur.cost\n            cur.cost = gp.cost + self._dist(gp.position, cur.position)\n            delta = cur.cost - old_cost\n            if abs(delta) > 1e-12:\n                self._propagate_cost(cur, delta)\n            depth += 1\n\n    def _propagate_cost(self, node, delta):\n        # Update subtree costs after reparenting\n        stack = list(node.children)\n        while stack:\n            n = stack.pop()\n            n.cost += delta\n            for c in n.children:\n                stack.append(c)\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # Paths and smoothing\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a, b, a_from_start):\n        # a is in the active tree (tree1), b in the opposite tree (tree2)\n        pa = self._path_to_root(a)\n        pb = []\n        cur = b\n        while cur is not None:\n            pb.append(cur.position)\n            cur = cur.parent\n        # If growing from start, pb goes b..goal; else b..start; concatenation stays correct\n        return pa + pb\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _smooth_path(self, path, obstacles, iters, patience):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        best_len = self._path_length(pts)\n        no_improve = 0\n        for _ in range(iters):\n            if len(pts) < 3:\n                break\n            i = int(self._uniform(0, len(pts) - 2))\n            j = int(self._uniform(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                continue\n            if self._edge_free(pts[i], pts[j], obstacles):\n                new_pts = pts[:i + 1] + pts[j:]\n                new_len = self._path_length(new_pts)\n                if new_len + 1e-9 < best_len:\n                    pts = new_pts\n                    best_len = new_len\n                    no_improve = 0\n                else:\n                    no_improve += 1\n            else:\n                no_improve += 1\n            if no_improve >= patience:\n                break\n        # forward LOS collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            k = 1\n            while k < len(pts) - 1:\n                nxt = pts[k + 1]\n                if self._edge_free(last, nxt, obstacles):\n                    k += 1\n                else:\n                    collapsed.append(pts[k])\n                    last = pts[k]\n                    k += 1\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
          "objective": -32.04681,
          "time_improvement": 57.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1606.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0160780668258667,
                    "num_nodes_avg": 54.5,
                    "path_length_avg": 178.9081741619695,
                    "smoothness_avg": 0.051583685968640866,
                    "success_improvement": 0.0,
                    "time_improvement": 36.94577918404633,
                    "node_improvement": 86.27549735582977,
                    "length_improvement": 1.9375947603861294,
                    "smoothness_improvement": 707.3967011761849,
                    "objective_score": 15.783274117326503
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027580070495605468,
                    "num_nodes_avg": 100.1,
                    "path_length_avg": 240.86804814126344,
                    "smoothness_avg": 0.10972615466856887,
                    "success_improvement": 0.0,
                    "time_improvement": 82.78368898030901,
                    "node_improvement": 93.27420546932743,
                    "length_improvement": 19.59131252809127,
                    "smoothness_improvement": 2723.332992176965,
                    "objective_score": 50.20655917183229
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024082136154174805,
                    "num_nodes_avg": 106.1,
                    "path_length_avg": 130.6210437346923,
                    "smoothness_avg": 0.11683429429214313,
                    "success_improvement": 0.0,
                    "time_improvement": 50.90452639893067,
                    "node_improvement": 86.50985378258105,
                    "length_improvement": 13.24772225711989,
                    "smoothness_improvement": 1386.1235995855145,
                    "objective_score": 30.150609271878707
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "FALCON-IBiRRT*: Fast AABB-Filtered Adaptive Corridor Informed BiRRT* with local rewiring and heuristic gating. It uses slab-based box-line intersection for collision checks, hash-grid neighbors for parent selection/rewiring, adaptive corridor/ellipse sampling after the first path, and an f-cost gate to prune weak expansions. On connection it prunes by visibility then applies bounded shortcut and a light rubber-band pass for shorter, smoother paths.",
          "planning_mechanism": "Alternate growing from start and goal. Each iteration: sample in a guided corridor (or informed ellipse after a solution), pick a hash-grid nearest, steer one step, do node and slab-precise edge checks, apply a g+h gate versus current best, choose a low-cost, low-angle parent among nearby neighbors and rewire cheaper ones. Attempt a short validated connect to the other tree. Upon bridge, extract, visibility-prune, shortcut, and lightly rubber-band the path, then return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            ch = self.parent.children\n            for i in range(len(ch)-1, -1, -1):\n                if ch[i] is self:\n                    ch.pop(i)\n                    break\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=6.0,\n        goal_bias=0.15,\n        corridor_bias=0.55,\n        grid_cell_factor=1.6,\n        min_sep_factor=0.45,\n        neighbor_factor=2.6,\n        neighbor_max=24,\n        connect_steps=5,\n        heur_gate=1.02,\n        smoothing_iters=80\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.min_sep_factor = min_sep_factor\n        self.neighbor_factor = neighbor_factor\n        self.neighbor_max = neighbor_max\n        self.connect_steps = connect_steps\n        self.heur_gate = heur_gate\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self._edge_cache = {}\n        self._lcg = 1103515245\n        self._seed = 2463534242\n\n        self.cell_size = 1.0\n        self.min_sep = 1.0\n        self.corridor_w = 1.0\n        self.angle_w = 0.1\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        self._edge_cache = {}\n        self._seed = 2463534242\n\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        dsg = self._dist(start, goal)\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step_size * self.min_sep_factor)\n        self.corridor_w = max(self.step_size * 1.2, 0.25 * dsg)\n        self.angle_w = 0.05 * self.step_size\n\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, dsg)\n            s.children.append(g)\n            nodes = [s, g]\n            edges = [(s, g)]\n            return PlannerResult(True, [start, goal], nodes, edges)\n\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        all_nodes = [start_root, goal_root]\n\n        grid_a = {}\n        grid_b = {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n\n        best_path = None\n        c_best = float('inf')\n        informed = False\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            if active_start:\n                nodes_x, nodes_y = tree_a, tree_b\n                grid_x, grid_y = grid_a, grid_b\n                root_x, root_y = start_root, goal_root\n                attractor = goal\n            else:\n                nodes_x, nodes_y = tree_b, tree_a\n                grid_x, grid_y = grid_b, grid_a\n                root_x, root_y = goal_root, start_root\n                attractor = start\n\n            # Sampling\n            r = self._rand()\n            if r < self.goal_bias:\n                x_rand = attractor\n            else:\n                if informed and self._rand() < 0.6:\n                    x_rand = self._ellipse_sample(root_x.position, root_y.position, c_best)\n                elif self._rand() < self.corridor_bias:\n                    x_rand = self._corridor_sample(root_x.position, root_y.position, self.corridor_w)\n                else:\n                    x_rand = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n            # Nearest\n            n_near = self._nearest_hashed(grid_x, nodes_x, x_rand)\n            if n_near is None:\n                continue\n\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n            if not self._in_bounds(x_new_pos):\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                continue\n            if self._near_duplicate(grid_x, x_new_pos, self.min_sep):\n                continue\n\n            g_cost = n_near.cost + self._dist(n_near.position, x_new_pos)\n            f_cost = g_cost + self._dist(x_new_pos, root_y.position)\n            if informed and f_cost >= c_best * self.heur_gate:\n                continue\n\n            if self._edge_blocked(n_near.position, x_new_pos, obstacles, is_3d):\n                continue\n\n            neigh_r = self._neighbor_radius(len(nodes_x))\n            neigh = self._neighbors_in_radius(grid_x, x_new_pos, neigh_r, self.neighbor_max)\n            parent, new_cost = self._choose_best_parent_angle(x_new_pos, n_near, neigh, obstacles, is_3d)\n            if parent is None:\n                continue\n            if self._edge_blocked(parent.position, x_new_pos, obstacles, is_3d):\n                continue\n\n            x_new = Node(x_new_pos, None, new_cost)\n            x_new.attach(parent)\n            nodes_x.append(x_new)\n            all_nodes.append(x_new)\n            self._grid_add(grid_x, x_new)\n\n            self._rewire_neighbors(x_new, neigh, obstacles, is_3d)\n\n            # Try direct connect to other tree\n            other_near = self._nearest_hashed(grid_y, nodes_y, x_new.position)\n            bridged = None\n            if other_near is not None and not self._edge_blocked(x_new.position, other_near.position, obstacles, is_3d):\n                bridged = other_near\n            else:\n                cur = other_near\n                steps = 0\n                while cur is not None and steps < self.connect_steps:\n                    step_pos = self._steer(cur.position, x_new.position, self.step_size)\n                    if not self._in_bounds(step_pos):\n                        break\n                    if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                        break\n                    if self._near_duplicate(grid_y, step_pos, self.min_sep):\n                        break\n                    g2 = cur.cost + self._dist(cur.position, step_pos)\n                    f2 = g2 + self._dist(step_pos, root_x.position)\n                    if informed and f2 >= c_best * self.heur_gate:\n                        break\n                    if self._edge_blocked(cur.position, step_pos, obstacles, is_3d):\n                        break\n\n                    neigh_b = self._neighbors_in_radius(grid_y, step_pos, neigh_r, self.neighbor_max)\n                    p_b, c_b = self._choose_best_parent_angle(step_pos, cur, neigh_b, obstacles, is_3d)\n                    if p_b is None:\n                        break\n                    if self._edge_blocked(p_b.position, step_pos, obstacles, is_3d):\n                        break\n\n                    nxt = Node(step_pos, None, c_b)\n                    nxt.attach(p_b)\n                    nodes_y.append(nxt)\n                    all_nodes.append(nxt)\n                    self._grid_add(grid_y, nxt)\n\n                    self._rewire_neighbors(nxt, neigh_b, obstacles, is_3d)\n\n                    cur = nxt\n                    steps += 1\n\n                    if not self._edge_blocked(cur.position, x_new.position, obstacles, is_3d):\n                        bridged = cur\n                        break\n\n            if bridged is not None:\n                if active_start:\n                    path_a = self._path_to_root(x_new)\n                    path_b = self._path_to_root(bridged)\n                    path = path_a + list(reversed(path_b))\n                else:\n                    path_a = self._path_to_root(x_new)\n                    path_b = self._path_to_root(bridged)\n                    path = path_b + list(reversed(path_a))\n\n                path = self._visibility_prune(path, obstacles, is_3d)\n                path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                path = self._rubber_band(path, obstacles, is_3d, passes=2)\n\n                L = self._path_length(path)\n                if L < c_best:\n                    c_best = L\n                    best_path = path\n                    informed = True\n                    edges = []\n                    for n in all_nodes:\n                        if n.parent is not None:\n                            edges.append((n.parent, n))\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n        edges = []\n        for n in all_nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        return PlannerResult(best_path is not None, best_path if best_path else [], all_nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._seed = (self._lcg * self._seed + 12345) % (1 << 31)\n        return self._seed / float(1 << 31)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5 if s > 0.0 else 0.0\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _clamp(self, p):\n        return tuple(self._clip(p[i], 0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _clip(self, x, lo, hi):\n        if x < lo:\n            return lo\n        if x > hi:\n            return hi\n        return x\n\n    # Collision with slab-based AABB filtering and cache\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        c = self._edge_cache.get(k)\n        if c is not None:\n            return c\n        if is_3d:\n            ax, ay, az = a\n            bx, by, bz = b\n            # quick reject: identical\n            if ax == bx and ay == by and az == bz:\n                blocked = self._is_in_obstacle(a, obstacles, True)\n            else:\n                blocked = False\n                for o in obstacles:\n                    if self._seg_box_intersect_3d(a, b, o):\n                        blocked = True\n                        break\n        else:\n            ax, ay = a\n            bx, by = b\n            if ax == bx and ay == by:\n                blocked = self._is_in_obstacle(a, obstacles, False)\n            else:\n                blocked = False\n                for o in obstacles:\n                    if self._seg_box_intersect_2d(a, b, o):\n                        blocked = True\n                        break\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _is_in_obstacle(self, p, obstacles, is_3d):\n        if is_3d:\n            x, y, z = p\n            for o in obstacles:\n                ox, oy, oz, w, h, d = o\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n        else:\n            x, y = p\n            for o in obstacles:\n                ox, oy, w, h = o\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n        return False\n\n    def _seg_box_intersect_2d(self, a, b, box):\n        x, y, w, h = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        tmin, tmax = 0.0, 1.0\n        ax, ay = a\n        bx, by = b\n        dx = bx - ax\n        dy = by - ay\n\n        if dx == 0.0:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            t1 = (minx - ax) * inv\n            t2 = (maxx - ax) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        if dy == 0.0:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            t1 = (miny - ay) * inv\n            t2 = (maxy - ay) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    def _seg_box_intersect_3d(self, a, b, box):\n        x, y, z, w, h, d = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        minz, maxz = z, z + d\n        tmin, tmax = 0.0, 1.0\n        ax, ay, az = a\n        bx, by, bz = b\n        dx = bx - ax\n        dy = by - ay\n        dz = bz - az\n\n        # X\n        if dx == 0.0:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            t1 = (minx - ax) * inv\n            t2 = (maxx - ax) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        # Y\n        if dy == 0.0:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            t1 = (miny - ay) * inv\n            t2 = (maxy - ay) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        # Z\n        if dz == 0.0:\n            if az < minz or az > maxz:\n                return False\n        else:\n            inv = 1.0 / dz\n            t1 = (minz - az) * inv\n            t2 = (maxz - az) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    # Hash grid\n    def _grid_key(self, pos):\n        if self.dim == 3:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        else:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        seen = set()\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            for n in b:\n                                if n not in seen:\n                                    seen.add(n)\n                                    out.append(n)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        for n in b:\n                            if n not in seen:\n                                seen.add(n)\n                                out.append(n)\n        return out\n\n    def _nearest_hashed(self, grid, nodes, pos):\n        k = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        found = False\n        for r in range(0, 3):\n            cand = self._grid_collect_ring(grid, k, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                found = True\n                break\n        if not found:\n            limit = min(96, len(nodes))\n            if limit == 0:\n                return None\n            step = max(1, len(nodes) // limit)\n            for i in range(0, len(nodes), step):\n                n = nodes[i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius, kmax):\n        ring = int(radius // self.cell_size) + 1\n        k = self._grid_key(pos)\n        cand = self._grid_collect_ring(grid, k, ring)\n        scored = []\n        rr = radius + 1e-9\n        for n in cand:\n            d = self._dist(n.position, pos)\n            if d <= rr:\n                scored.append((d, n))\n        scored.sort(key=lambda x: x[0])\n        res = [n for (_, n) in scored[:kmax]]\n        return res\n\n    def _neighbor_radius(self, ncount):\n        base = self.neighbor_factor * self.step_size\n        if ncount < 300:\n            return base * 2.2\n        if ncount < 1200:\n            return base * 1.8\n        return base * 1.4\n\n    def _near_duplicate(self, grid, pos, radius):\n        k = self._grid_key(pos)\n        cand = self._grid_collect_ring(grid, k, 1)\n        rr = radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # Parent selection with angle penalty\n    def _choose_best_parent_angle(self, new_pos, fallback, neighbors, obstacles, is_3d):\n        best_p = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, new_pos) + self._angle_penalty(fallback, new_pos)\n        for n in neighbors:\n            c = n.cost + self._dist(n.position, new_pos) + self._angle_penalty(n, new_pos)\n            if c + 1e-12 < best_cost:\n                if not self._edge_blocked(n.position, new_pos, obstacles, is_3d):\n                    best_cost = c\n                    best_p = n\n        if best_p is None:\n            return None, float('inf')\n        # remove angle penalty from stored cost; we only store path length\n        true_cost = best_p.cost + self._dist(best_p.position, new_pos)\n        return best_p, true_cost\n\n    def _angle_penalty(self, parent, new_pos):\n        if parent is None or parent.parent is None:\n            return 0.0\n        a = parent.parent.position\n        b = parent.position\n        c = new_pos\n        v1 = tuple(b[i] - a[i] for i in range(self.dim))\n        v2 = tuple(c[i] - b[i] for i in range(self.dim))\n        n1 = 0.0\n        n2 = 0.0\n        dot = 0.0\n        for i in range(self.dim):\n            n1 += v1[i] * v1[i]\n            n2 += v2[i] * v2[i]\n            dot += v1[i] * v2[i]\n        if n1 <= 1e-9 or n2 <= 1e-9:\n            return 0.0\n        cosang = dot / ((n1 ** 0.5) * (n2 ** 0.5))\n        if cosang > 1.0:\n            cosang = 1.0\n        elif cosang < -1.0:\n            cosang = -1.0\n        # penalty increases as angle deviates from straight line: 1 - cos(theta)\n        return self.angle_w * (1.0 - cosang)\n\n    def _rewire_neighbors(self, new_node, neighbors, obstacles, is_3d):\n        for m in neighbors:\n            if m is new_node or m is new_node.parent:\n                continue\n            alt = new_node.cost + self._dist(new_node.position, m.position)\n            if alt + 1e-12 < m.cost:\n                if not self._edge_blocked(new_node.position, m.position, obstacles, is_3d):\n                    old = m.cost\n                    m.attach(new_node)\n                    m.cost = alt\n                    self._propagate_cost(m, alt - old)\n\n    def _propagate_cost(self, node, delta):\n        if delta == 0.0:\n            return\n        q = [node]\n        while q:\n            cur = q.pop()\n            for ch in cur.children:\n                ch.cost += delta\n                q.append(ch)\n\n    # Sampling helpers\n    def _ellipse_sample(self, a, b, c_best):\n        tries = 12\n        for _ in range(tries):\n            p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n            if self._dist(p, a) + self._dist(p, b) <= c_best + 1e-9:\n                return p\n        return self._corridor_sample(a, b, max(self.step_size, 0.15 * c_best))\n\n    def _corridor_sample(self, a, b, width):\n        t = self._uniform(0.0, 1.0)\n        base = tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n        ab = tuple(b[i] - a[i] for i in range(self.dim))\n        abn = self._norm(ab)\n        if abn <= 1e-9:\n            return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n        v = tuple(ab[i] / abn for i in range(self.dim))\n        if self.dim == 2:\n            perp = (-v[1], v[0])\n            off = (self._uniform(-width, width),)\n            jitter = tuple(perp[i] * off[0] for i in range(2))\n            p = tuple(base[i] + jitter[i] for i in range(2))\n        else:\n            # project random vector orthogonal to v\n            r = tuple(self._uniform(-1.0, 1.0) for _ in range(3))\n            dot = r[0]*v[0] + r[1]*v[1] + r[2]*v[2]\n            u = (r[0] - dot*v[0], r[1] - dot*v[1], r[2] - dot*v[2])\n            un = self._norm(u)\n            if un <= 1e-9:\n                u = (v[1], -v[0], 0.0)\n                un = self._norm(u)\n            u = (u[0]/un, u[1]/un, u[2]/un)\n            mag = self._uniform(-width, width)\n            jitter = (u[0]*mag, u[1]*mag, u[2]*mag)\n            p = tuple(base[i] + jitter[i] for i in range(3))\n        return self._clamp(p)\n\n    def _norm(self, v):\n        s = 0.0\n        for i in range(len(v)):\n            s += v[i]*v[i]\n        return s ** 0.5 if s > 0.0 else 0.0\n\n    # Path utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i-1], path[i])\n        return L\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(out[-1], path[j], obstacles, is_3d):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i+1])\n                i += 1\n        return out\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i+1] + pts[j:]\n                n = len(pts)\n        return pts\n\n    def _rubber_band(self, path, obstacles, is_3d, passes=1):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(passes):\n            changed = False\n            for i in range(1, len(pts)-1):\n                prev = pts[i-1]\n                cur = pts[i]\n                nxt = pts[i+1]\n                mid = tuple(0.5*(prev[d] + nxt[d]) for d in range(self.dim))\n                newp = tuple(0.5*cur[d] + 0.5*mid[d] for d in range(self.dim))\n                if self._is_in_obstacle(newp, obstacles, is_3d):\n                    continue\n                if not self._edge_blocked(prev, newp, obstacles, is_3d) and not self._edge_blocked(newp, nxt, obstacles, is_3d):\n                    old_len = self._dist(prev, cur) + self._dist(cur, nxt)\n                    new_len = self._dist(prev, newp) + self._dist(newp, nxt)\n                    if new_len + 1e-9 < old_len:\n                        pts[i] = newp\n                        changed = True\n            if not changed:\n                break\n        return pts",
          "objective": -31.59206,
          "time_improvement": 49.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1496.0,
          "node_improvement": 84.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016694188117980957,
                    "num_nodes_avg": 71.0,
                    "path_length_avg": 163.0992747992678,
                    "smoothness_avg": 0.05614678174204176,
                    "success_improvement": 0.0,
                    "time_improvement": 39.474027697220166,
                    "node_improvement": 82.12037270209015,
                    "length_improvement": 10.602703009124085,
                    "smoothness_improvement": 778.8190589509786,
                    "objective_score": 22.097925409395394
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07330527305603027,
                    "num_nodes_avg": 250.0,
                    "path_length_avg": 238.45185700265174,
                    "smoothness_avg": 0.06942702786006637,
                    "success_improvement": 0.0,
                    "time_improvement": 55.701147868583675,
                    "node_improvement": 83.20231136195659,
                    "length_improvement": 20.397906676365686,
                    "smoothness_improvement": 1686.4074331064066,
                    "objective_score": 37.38112553192654
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025111293792724608,
                    "num_nodes_avg": 102.0,
                    "path_length_avg": 126.23467909600465,
                    "smoothness_avg": 0.16699201676546307,
                    "success_improvement": 0.0,
                    "time_improvement": 51.59980056201074,
                    "node_improvement": 87.0311506675143,
                    "length_improvement": 16.160936793897573,
                    "smoothness_improvement": 2024.1261271881847,
                    "objective_score": 35.297132880882685
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "AURORA-BiRRT*: A*-guided, Unrolled-Rewire, Obstacle-Grid accelerated BiRRT with memoized edges and cell-pair sieve. It couples hashed nearest search, per-cell throttling, duplicate suppression, heuristic parent selection (g+h), bounded rewiring with full cost propagation, multi-step Connect, and quantized edge-collision caching; online LOS compression and cache-aware shortcutting yield smooth, short paths quickly.",
          "planning_mechanism": "Alternate tree growth with k-beam samples. Each beam selects a parent among local candidates minimizing g(parent)+d(parent,qn)+\u03bb\u00b7h(qn,other-tree), enforcing both node and edge validity before insertion. After insertion, LOS-compress to an ancestor, rewire neighbors if cheaper and propagate costs. A limited Connect grows the opposite tree unless a cached blocked cell-pair forbids it; direct edges terminate early. Once an incumbent exists, informed ellipse sampling narrows exploration; final shortcutting and LOS collapse return a concise path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=9.0,\n        collision_res=1.0,\n        beam_k=2,\n        goal_bias=0.2,\n        informed_bias=0.6,\n        grid_cell_factor=1.2,\n        per_cell_cap=6,\n        dupe_radius_ratio=0.45,\n        rewire_radius_factor=2.5,\n        neighbor_cap=24,\n        compress_depth=2,\n        connect_steps=3,\n        edge_cache_capacity=40000,\n        edge_cache_quant=0.8,\n        smoothing_iters=50,\n        no_improve_stop=12\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_res = collision_res\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.informed_bias = informed_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.per_cell_cap = per_cell_cap\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.rewire_radius_factor = rewire_radius_factor\n        self.neighbor_cap = neighbor_cap\n        self.compress_depth = compress_depth\n        self.connect_steps = connect_steps\n        self.edge_cache_capacity = edge_cache_capacity\n        self.edge_cache_quant = edge_cache_quant\n        self.smoothing_iters = smoothing_iters\n        self.no_improve_stop = no_improve_stop\n\n        self._rnd_state = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_from_scene()\n\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n\n        # Edge cache\n        self._tick = 0\n        self.ecache = {}\n        self._last_prune_size = 0\n        self.eq = max(0.25, self.edge_cache_quant)\n        # Collision stepping resolution for fallback sampling checks\n        self.edge_res = max(0.5, self.collision_res)\n\n        # Build obstacle grid\n        self._build_obstacle_grid()\n\n        # Validate endpoints\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        nodes = []\n        edges = []\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        throttles_a, throttles_b = {}, {}\n        anchors_a, anchors_b = [start_root], [goal_root]\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        best_path = None\n        best_len = float('inf')\n        sg = self._dist(self.start, self.goal)\n\n        blocked_pairs = set()\n        anchor_stride = 20\n        max_rings = 4\n\n        for it in range(self.max_iter):\n            side_start = (it % 2 == 0)\n            tree1 = tree_a if side_start else tree_b\n            grid1 = grid_a if side_start else grid_b\n            throttles1 = throttles_a if side_start else throttles_b\n            anchors1 = anchors_a if side_start else anchors_b\n\n            tree2 = tree_b if side_start else tree_a\n            grid2 = grid_b if side_start else grid_a\n            throttles2 = throttles_b if side_start else throttles_a\n            anchors2 = anchors_b if side_start else anchors_a\n\n            attractor = self.goal if side_start else self.start\n\n            progressed = False\n            for _ in range(self.beam_k):\n                sample = self._sample(attractor, best_len, sg)\n                if sample is None:\n                    continue\n                near = self._nearest_hashed(grid1, anchors1, sample, max_rings)\n                if near is None:\n                    continue\n                new_pos = self._steer(near.position, sample)\n                if not self._within_bounds(new_pos):\n                    continue\n                if self._point_in_obstacles(new_pos):\n                    continue\n                if self._has_nearby(grid1, new_pos, self.dupe_radius):\n                    continue\n\n                # Parent selection (A*-guided among local candidates)\n                rewire_r = self._rewire_radius(len(nodes))\n                parents = self._candidate_parents(grid1, anchors1, tree1, new_pos, rewire_r, self.neighbor_cap)\n                best_parent, best_new_cost = None, float('inf')\n                best_score = float('inf')\n                other_near = self._nearest_hashed(grid2, anchors2, new_pos, max_rings)\n                h_term = self._dist(new_pos, other_near.position if other_near else attractor)\n                lam = 0.1\n                for p in parents:\n                    if not self._edge_free(p.position, new_pos):\n                        continue\n                    gc = p.cost + self._dist(p.position, new_pos)\n                    f = gc + lam * h_term\n                    if f + 1e-9 < best_score:\n                        best_score = f\n                        best_parent = p\n                        best_new_cost = gc\n                if best_parent is None:\n                    continue\n\n                # Per-cell cap with cost admission\n                ckey = self._cell_of(new_pos)\n                bucket = grid1.get(ckey)\n                if bucket and len(bucket) >= self.per_cell_cap:\n                    best_bucket_cost = min(n.cost for n in bucket)\n                    if best_new_cost >= best_bucket_cost - 1e-9:\n                        continue\n\n                # Final validity before insertion\n                if self._point_in_obstacles(new_pos):\n                    continue\n                if not self._edge_free(best_parent.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos, best_parent, best_new_cost)\n                best_parent.add_child(new_node)\n                tree1.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                self._grid_insert(grid1, new_node)\n                throttles1[ckey] = throttles1.get(ckey, 0) + 1\n                if (len(tree1) % anchor_stride) == 0:\n                    anchors1.append(new_node)\n                progressed = True\n\n                # LOS compression to ancestors\n                self._compress_to_ancestors(new_node, edges, self.compress_depth)\n\n                # Rewiring around new_node\n                self._rewire_neighbors(grid1, new_node, rewire_r, edges)\n\n                # Try connect to the other tree\n                pair_key = self._pair_key(self._cell_of(new_node.position),\n                                          self._cell_of((other_near.position if other_near else attractor)))\n                if pair_key not in blocked_pairs:\n                    connected, path = self._attempt_connect(new_node, tree2, grid2, throttles2, anchors2, nodes, edges)\n                    if connected:\n                        path = self._shortcut(path)\n                        path = self._los_collapse(path)\n                        best_path = path\n                        best_len = self._path_len(path)\n                        return PlannerResult(True, path, nodes, edges)\n                    else:\n                        blocked_pairs.add(pair_key)\n\n            if not progressed:\n                continue\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= len(self.obstacles) * 2654435761\n        self._rnd_state = (s ^ 0xA5A5A5) & 0xffffffff\n        if self._rnd_state == 0:\n            self._rnd_state = 2463534242\n\n    def _rand(self):\n        self._rnd_state = (1664525 * self._rnd_state + 1013904223) & 0xffffffff\n        return self._rnd_state / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= self.step_size:\n            return self._clamp(b)\n        r = self.step_size / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Sampling\n    def _sample(self, attractor, best_len, sg):\n        for _ in range(24):\n            if best_len < float('inf') and self._rand() < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p and self._within_bounds(p) and not self._point_in_obstacles(p):\n                    return p\n            else:\n                if self._rand() < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n                if self._within_bounds(p) and not self._point_in_obstacles(p):\n                    return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # Node grid (for NN, dupes, neighbors)\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, anchors, pos, max_rings=4):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # fallback scan\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not bucket:\n                            continue\n                        for n in bucket:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((key[0] + dx, key[1] + dy))\n                    if not bucket:\n                        continue\n                    for n in bucket:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    def _candidate_parents(self, grid, anchors, tree, pos, radius, cap):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        if not cand:\n            cand = anchors[:]\n        if len(cand) > cap:\n            # Reservoir-like random subset\n            out = []\n            take = 0\n            for n in cand:\n                take += 1\n                if len(out) < cap:\n                    out.append(n)\n                else:\n                    j = int(self._rand_range(0, take))\n                    if j < len(out):\n                        out[j] = n\n            cand = out\n        return cand\n\n    # Obstacle spatial grid\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    # Edge checks with cache\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.eq) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.eq) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        if len(self.ecache) - self._last_prune_size > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self.ecache:\n            return\n        cutoff = self._tick - 3000\n        to_del = []\n        for k, v in self.ecache.items():\n            if v[1] < cutoff:\n                to_del.append(k)\n        if not to_del:\n            i = 0\n            for k in list(self.ecache.keys()):\n                if (i % 3) == 0:\n                    to_del.append(k)\n                i += 1\n        for k in to_del:\n            if k in self.ecache:\n                del self.ecache[k]\n        self._last_prune_size = len(self.ecache)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Compression and rewiring\n    def _compress_to_ancestors(self, node, edges, depth_limit):\n        depth = 0\n        curp = node.parent\n        while curp is not None and curp.parent is not None and depth < depth_limit:\n            gp = curp.parent\n            if self._edge_free(gp.position, node.position):\n                self._reparent(node, gp, edges)\n                curp = node.parent\n                depth += 1\n            else:\n                break\n\n    def _rewire_radius(self, n_nodes):\n        # simple schedule\n        return max(self.step_size * 1.5, self.rewire_radius_factor * self.step_size)\n\n    def _rewire_neighbors(self, grid, node, radius, edges):\n        key = self._cell_of(node.position)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        neigh = self._grid_ring_nodes(grid, key, r_cells)\n        count = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if d > radius:\n                continue\n            new_cost = node.cost + d\n            if new_cost + 1e-9 < nb.cost and self._edge_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n                count += 1\n                if count >= self.neighbor_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        old_parent = child.parent\n        if old_parent is new_parent:\n            return\n        if old_parent is not None:\n            old_parent.remove_child(child)\n            self._edges_remove(edges, old_parent, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        self._propagate_costs(child)\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                old = ch.cost\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                if abs(ch.cost - old) > 1e-12:\n                    stack.append(ch)\n\n    # Connect attempt\n    def _attempt_connect(self, new_node, other_tree, other_grid, throttles, anchors, nodes, edges):\n        other_near = self._nearest_hashed(other_grid, anchors, new_node.position, 4)\n        if other_near is None:\n            return False, []\n        # Try direct bridge first\n        if self._edge_free(new_node.position, other_near.position):\n            path = self._extract_path(new_node, other_near)\n            return True, self._ensure_bounds_and_valid(path)\n\n        p = other_near\n        steps = 0\n        last_q = None\n        while steps < self.connect_steps:\n            step_pos = self._steer(p.position, new_node.position)\n            if not self._within_bounds(step_pos):\n                break\n            if self._point_in_obstacles(step_pos):\n                break\n            if self._has_nearby(other_grid, step_pos, self.dupe_radius):\n                break\n            if not self._edge_free(p.position, step_pos):\n                break\n            cell = self._cell_of(step_pos)\n            bucket = other_grid.get(cell)\n            if bucket and len(bucket) >= self.per_cell_cap:\n                best_bucket_cost = min(n.cost for n in bucket)\n                new_c = p.cost + self._dist(p.position, step_pos)\n                if new_c >= best_bucket_cost - 1e-9:\n                    break\n\n            q = Node(step_pos, p, p.cost + self._dist(p.position, step_pos))\n            p.add_child(q)\n            other_tree.append(q)\n            nodes.append(q)\n            edges.append((p, q))\n            self._grid_insert(other_grid, q)\n            throttles[cell] = throttles.get(cell, 0) + 1\n            if (len(other_tree) % 20) == 0:\n                anchors.append(q)\n\n            self._compress_to_ancestors(q, edges, 1)\n            # local light rewiring\n            self._rewire_neighbors(other_grid, q, self._rewire_radius(len(nodes)), edges)\n\n            if self._edge_free(new_node.position, q.position):\n                path = self._extract_path(new_node, q)\n                return True, self._ensure_bounds_and_valid(path)\n\n            p = q\n            last_q = q\n            steps += 1\n        return False, []\n\n    def _pair_key(self, c1, c2):\n        return (c1, c2) if c1 <= c2 else (c2, c1)\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return pa + pb[::-1]\n\n    def _ensure_bounds_and_valid(self, path):\n        return [self._clamp(p) for p in path]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # Post smoothing\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        attempts = 0\n        no_improve = 0\n        best_len = self._path_len(pts)\n        while attempts < self.smoothing_iters:\n            i = int(self._rand_range(0, max(1, len(pts) - 2)))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                attempts += 1\n                continue\n            a, b = pts[i], pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= best_len + 1e-12:\n                    pts = new_pts\n                    best_len = L\n                    no_improve = 0\n                else:\n                    no_improve += 1\n            else:\n                no_improve += 1\n            attempts += 1\n            if no_improve >= self.no_improve_stop:\n                break\n        return pts\n\n    def _los_collapse(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = [path[0]]\n        last = path[0]\n        k = 1\n        while k < len(path) - 1:\n            nxt = path[k + 1]\n            if self._edge_free(last, nxt):\n                k += 1\n                continue\n            pts.append(path[k])\n            last = path[k]\n            k += 1\n        pts.append(path[-1])\n        return pts",
          "objective": -29.84258,
          "time_improvement": 46.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1759.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013257336616516114,
                    "num_nodes_avg": 49.0,
                    "path_length_avg": 163.59788282479164,
                    "smoothness_avg": 0.10284552152668414,
                    "success_improvement": 0.0,
                    "time_improvement": 48.00798880221262,
                    "node_improvement": 87.6605389070763,
                    "length_improvement": 10.329408049384693,
                    "smoothness_improvement": 1509.7557445171647,
                    "objective_score": 28.148820192880425
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01610586643218994,
                    "num_nodes_avg": 62.0,
                    "path_length_avg": 241.62656852319907,
                    "smoothness_avg": 0.0921645090196098,
                    "success_improvement": 0.0,
                    "time_improvement": 89.9462328864473,
                    "node_improvement": 95.83417321776524,
                    "length_improvement": 19.338096591802515,
                    "smoothness_improvement": 2271.4592004871693,
                    "objective_score": 49.944023823451545
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.048529839515686034,
                    "num_nodes_avg": 126.0,
                    "path_length_avg": 141.44566627862946,
                    "smoothness_avg": 0.12548275222835503,
                    "success_improvement": 0.0,
                    "time_improvement": 1.0637827328513305,
                    "node_improvement": 83.97965670692943,
                    "length_improvement": 6.058523376571766,
                    "smoothness_improvement": 1496.1313461713685,
                    "objective_score": 11.4349055766553
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "AIR-Connect*: Adaptive Informed Rewire BiRRT-Connect with cached edges and ring-hash neighbors. It alternates tree growth from start/goal, uses ellipse-gated sampling after first solution, cost-gated admission before expensive checks, LOS-cost parent selection with local RRT* rewiring, cached edge validity, and a short validated connect toward the opposite tree. On bridge, it visibility-prunes and applies bounded shortcuts for shorter, smoother paths.",
          "planning_mechanism": "Alternate expanding the two trees. For each sample: find a near node via ring-hash, steer one step, bounds+node-collision check, early cost-gate, then edge-collision. Select the best-cost parent among nearby LOS neighbors; insert and locally rewire cheaper neighbors under edge checks. Attempt a short validated connect to the other tree; if a direct or stepwise bridge succeeds, extract, prune, and shortcut the path. Use informed ellipse sampling after first path to focus and reduce time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=5.0,\n        goal_bias=0.25,\n        line_bias=0.25,\n        grid_cell_factor=1.5,\n        min_sep_factor=0.4,\n        ring_max=3,\n        neighbor_factor=3.0,\n        connect_steps=6,\n        occ_relax=1.05,\n        smoothing_iters=120\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.min_sep_factor = min_sep_factor\n        self.ring_max = ring_max\n        self.neighbor_factor = neighbor_factor\n        self.connect_steps = connect_steps\n        self.occ_relax = occ_relax\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Derived parameters\n        self.edge_res = max(0.5, min(1.0, 0.5 * self.step_size))\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.3, self.step_size * self.min_sep_factor)\n        self.occ_cell = max(0.5, 0.6 * self.step_size)\n\n        # Reset caches\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.append(g)\n            nodes = [s, g]\n            edges = [(s, g)]\n            return PlannerResult(True, [start, goal], nodes, edges)\n\n        # Initialize bi-trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n\n        start_nodes = [start_root]\n        goal_nodes = [goal_root]\n        all_nodes = [start_root, goal_root]\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root, self.cell_size)\n        self._grid_add(grid_goal, goal_root, self.cell_size)\n\n        occ_start = {self._grid_key(start, self.occ_cell): 0.0}\n        occ_goal = {self._grid_key(goal, self.occ_cell): 0.0}\n\n        success = False\n        best_path = None\n        c_best = float('inf')\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n\n            if active_start:\n                nodes_a, nodes_b = start_nodes, goal_nodes\n                grid_a, grid_b = grid_start, grid_goal\n                occ_a, occ_b = occ_start, occ_goal\n                attractor = goal\n                root_a = start_root\n                root_b = goal_root\n            else:\n                nodes_a, nodes_b = goal_nodes, start_nodes\n                grid_a, grid_b = grid_goal, grid_start\n                occ_a, occ_b = occ_goal, occ_start\n                attractor = start\n                root_a = goal_root\n                root_b = start_root\n\n            # Sample\n            if self._rand() < self.goal_bias:\n                x_rand = attractor\n            else:\n                if c_best < float('inf') and self._rand() < 0.6:\n                    x_rand = self._ellipse_sample(root_a.position, root_b.position, c_best)\n                elif self._rand() < self.line_bias:\n                    t = self._uniform(0.0, 1.0)\n                    base = tuple(root_a.position[i] + t * (root_b.position[i] - root_a.position[i]) for i in range(self.dim))\n                    jitter = 0.5 * self.step_size\n                    x_rand = tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n                else:\n                    x_rand = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n            # Nearest in active tree\n            n_near = self._nearest_hashed(grid_a, nodes_a, x_rand)\n            if n_near is None:\n                continue\n\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n            if not self._in_bounds(x_new_pos):\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                continue\n            if self._near_duplicate(grid_a, x_new_pos, self.min_sep):\n                continue\n\n            # Early cost-gated admission (cheap)\n            tentative_cost = n_near.cost + self._dist(n_near.position, x_new_pos)\n            if not self._occ_accept(occ_a, x_new_pos, tentative_cost, self.occ_cell, self.occ_relax):\n                continue\n\n            # Edge collision with nearest\n            if self._edge_blocked(n_near.position, x_new_pos, obstacles, is_3d):\n                continue\n\n            # Choose best parent among neighbors with LOS\n            neigh_r = self._neighbor_radius(len(nodes_a))\n            neigh = self._neighbors_in_radius(grid_a, x_new_pos, neigh_r)\n            parent, new_cost = self._choose_best_parent(x_new_pos, n_near, neigh, obstacles, is_3d)\n            if parent is None:\n                continue\n            if self._edge_blocked(parent.position, x_new_pos, obstacles, is_3d):\n                continue  # safety\n\n            # Insert new node\n            x_new = Node(x_new_pos, None, new_cost)\n            x_new.attach(parent)\n            nodes_a.append(x_new)\n            all_nodes.append(x_new)\n            self._grid_add(grid_a, x_new, self.cell_size)\n            self._occ_update(occ_a, x_new_pos, new_cost, self.occ_cell)\n\n            # Local RRT* rewiring around new node\n            self._rewire_neighbors(x_new, neigh, obstacles, is_3d)\n\n            # Try to connect to the other tree (direct, else short validated steps)\n            other_near = self._nearest_hashed(grid_b, nodes_b, x_new.position)\n            bridged_node_b = None\n\n            # Direct attempt\n            if (other_near is not None) and (not self._edge_blocked(x_new.position, other_near.position, obstacles, is_3d)):\n                bridged_node_b = other_near\n            else:\n                # Short validated connect from other tree toward x_new\n                cur = other_near\n                steps = 0\n                while cur is not None and steps < self.connect_steps:\n                    step_pos = self._steer(cur.position, x_new.position, self.step_size)\n                    if not self._in_bounds(step_pos):\n                        break\n                    if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                        break\n                    if self._near_duplicate(grid_b, step_pos, self.min_sep):\n                        break\n                    connect_cost = cur.cost + self._dist(cur.position, step_pos)\n                    if not self._occ_accept(occ_b, step_pos, connect_cost, self.occ_cell, self.occ_relax):\n                        break\n                    if self._edge_blocked(cur.position, step_pos, obstacles, is_3d):\n                        break\n\n                    # Parent selection for connect step\n                    neigh_b = self._neighbors_in_radius(grid_b, step_pos, neigh_r)\n                    p_b, c_b = self._choose_best_parent(step_pos, cur, neigh_b, obstacles, is_3d)\n                    if p_b is None:\n                        break\n                    if self._edge_blocked(p_b.position, step_pos, obstacles, is_3d):\n                        break\n\n                    nxt = Node(step_pos, None, c_b)\n                    nxt.attach(p_b)\n                    nodes_b.append(nxt)\n                    all_nodes.append(nxt)\n                    self._grid_add(grid_b, nxt, self.cell_size)\n                    self._occ_update(occ_b, step_pos, c_b, self.occ_cell)\n\n                    # light rewire on B-side (cheap subset)\n                    self._rewire_neighbors(nxt, neigh_b, obstacles, is_3d)\n\n                    cur = nxt\n                    steps += 1\n\n                    # Check final bridge\n                    if not self._edge_blocked(cur.position, x_new.position, obstacles, is_3d):\n                        bridged_node_b = cur\n                        break\n\n            if bridged_node_b is not None:\n                # Extract full path\n                if active_start:\n                    path = self._path_to_root(x_new)\n                    path_b = self._path_to_root(bridged_node_b)\n                    path_full = path + list(reversed(path_b))\n                else:\n                    path = self._path_to_root(x_new)\n                    path_b = self._path_to_root(bridged_node_b)\n                    path_full = path_b + list(reversed(path))\n\n                # Prune and smooth\n                path_full = self._visibility_prune(path_full, obstacles, is_3d)\n                path_full = self._shortcut_smooth(path_full, obstacles, is_3d, self.smoothing_iters)\n\n                L = self._path_length(path_full)\n                if L < c_best:\n                    c_best = L\n                    best_path = path_full\n                    success = True\n                    # Early stop on first good bridge to reduce time\n                    edges = []\n                    for n in all_nodes:\n                        if n.parent is not None:\n                            edges.append((n.parent, n))\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n        edges = []\n        for n in all_nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        return PlannerResult(success, best_path if best_path is not None else [], all_nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    def _clamp(self, p):\n        return tuple(self._clip(p[i], 0.0, self.bounds[i]) for i in range(self.dim))\n\n    # Collision and caching\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        cached = self._edge_cache.get(k)\n        if cached is not None:\n            return cached\n        blocked = self._segment_hits(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_hits(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Spatial hashing and neighbors\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        seen = set()\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            for n in b:\n                                if n not in seen:\n                                    seen.add(n)\n                                    cand.append(n)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        for n in b:\n                            if n not in seen:\n                                seen.add(n)\n                                cand.append(n)\n        return cand\n\n    def _nearest_hashed(self, grid, nodes, pos):\n        key = self._grid_key(pos, self.cell_size)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.ring_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback scan limited\n        limit = min(64, len(nodes))\n        if limit == 0:\n            return None\n        step = max(1, len(nodes) // limit)\n        for i in range(0, len(nodes), step):\n            n = nodes[i]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        r = int(radius // self.cell_size) + 1\n        key = self._grid_key(pos, self.cell_size)\n        cand = self._grid_ring_collect(grid, key, r)\n        res = []\n        rr = radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr + 1e-9:\n                res.append(n)\n        return res\n\n    def _neighbor_radius(self, ncount):\n        base = self.neighbor_factor * self.step_size\n        if ncount < 200:\n            return base * 2.5\n        if ncount < 1000:\n            return base * 2.0\n        return base * 1.5\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos, self.cell_size)\n        cand = self._grid_ring_collect(grid, key, 1)\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                return True\n        return False\n\n    # Admission ledger\n    def _occ_accept(self, occ_best, pos, cost, cell, relax):\n        k = self._grid_key(pos, cell)\n        prev = occ_best.get(k, float('inf'))\n        return cost < prev * relax\n\n    def _occ_update(self, occ_best, pos, cost, cell):\n        k = self._grid_key(pos, cell)\n        prev = occ_best.get(k, float('inf'))\n        if cost < prev:\n            occ_best[k] = cost\n\n    # Parent selection and rewiring\n    def _choose_best_parent(self, new_pos, fallback_nearest, neighbors, obstacles, is_3d):\n        best_parent = fallback_nearest\n        best_cost = fallback_nearest.cost + self._dist(fallback_nearest.position, new_pos)\n        # Evaluate neighbors with LOS\n        for n in neighbors:\n            c = n.cost + self._dist(n.position, new_pos)\n            if c + 1e-12 < best_cost:\n                if not self._edge_blocked(n.position, new_pos, obstacles, is_3d):\n                    best_cost = c\n                    best_parent = n\n        if best_parent is None:\n            return None, float('inf')\n        return best_parent, best_cost\n\n    def _rewire_neighbors(self, new_node, neighbors, obstacles, is_3d):\n        for m in neighbors:\n            if m is new_node or m is new_node.parent:\n                continue\n            alt = new_node.cost + self._dist(new_node.position, m.position)\n            if alt + 1e-12 < m.cost:\n                if not self._edge_blocked(new_node.position, m.position, obstacles, is_3d):\n                    old_cost = m.cost\n                    m.attach(new_node)\n                    m.cost = alt\n                    # Propagate cost change to descendants\n                    delta = alt - old_cost\n                    if abs(delta) > 0.0:\n                        self._propagate_cost(m, delta)\n\n    def _propagate_cost(self, node, delta):\n        q = [node]\n        while q:\n            cur = q.pop()\n            for ch in cur.children:\n                ch.cost += delta\n                q.append(ch)\n\n    # Sampling helpers\n    def _ellipse_sample(self, a, b, c_best):\n        # Sample uniformly in bounding box with quick rejection to keep it cheap\n        tries = 20\n        for _ in range(tries):\n            p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n            if self._dist(p, a) + self._dist(p, b) <= c_best + 1e-9:\n                return p\n        # Fallback to line jitter\n        t = self._uniform(0.0, 1.0)\n        base = tuple(a[i] + t * (b[i] - a[i]) for i in range(self.dim))\n        jitter = 0.5 * self.step_size\n        return tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n\n    # Path utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(out[-1], path[j], obstacles, is_3d):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i + 1])\n                i += 1\n        return out\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
          "objective": -29.76423,
          "time_improvement": 24.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 2154.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022998476028442384,
                    "num_nodes_avg": 61.0,
                    "path_length_avg": 156.6750662963223,
                    "smoothness_avg": 0.034451471616090565,
                    "success_improvement": 0.0,
                    "time_improvement": 16.617381254716395,
                    "node_improvement": 84.63863006799295,
                    "length_improvement": 14.123913487686588,
                    "smoothness_improvement": 439.24034335984834,
                    "objective_score": 15.655764185826111
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03999502658843994,
                    "num_nodes_avg": 145.0,
                    "path_length_avg": 236.64219232090036,
                    "smoothness_avg": 0.18735486162713155,
                    "success_improvement": 0.0,
                    "time_improvement": 75.83074593448201,
                    "node_improvement": 90.25734058993481,
                    "length_improvement": 21.002024835444043,
                    "smoothness_improvement": 4720.775535918357,
                    "objective_score": 58.954316361202814
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.062010884284973145,
                    "num_nodes_avg": 228.0,
                    "path_length_avg": 115.36831063996797,
                    "smoothness_avg": 0.11025750170008067,
                    "success_improvement": 0.0,
                    "time_improvement": -19.521486686135614,
                    "node_improvement": 71.01080737444374,
                    "length_improvement": 23.377861321535487,
                    "smoothness_improvement": 1302.4672832628123,
                    "objective_score": 14.682607203394669
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SAGE-BiRRT-Lite: Simple Adaptive Goal/Corridor-Biased Bidirectional RRT with Micro-Rewire and Greedy LOS smoothing. Two sparse trees grow with single-step, commit-only insertions using strict node and edge collision checks, accelerated by a hashed grid and duplicate suppression. After any feasible path is found, sampling narrows to an informed corridor around the start\u2013goal line, and a small local rewiring around each new node reduces path cost. A fast two-stage smoother (greedy line-of-sight collapse, then light random shortcuts) returns short, smooth paths quickly and robustly.",
          "planning_mechanism": "Initialize two trees and per-tree grids. Iteratively: select an active tree, sample a target with goal/corridor bias (corridor narrows after first solution), find grid-accelerated nearest, steer one step, and insert only if both node and edge are collision-free. Attempt a direct bridge to the other tree (and optionally a few commit-only steps from the opposite tree toward the new node). After insertion, rewire nearby nodes to the new node when it shortens their cost and the edge is free. On any successful connection, extract the path and apply greedy line-of-sight compression followed by a few random shortcuts; return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=7000,\n                 step_size=6.0,\n                 goal_bias=0.25,\n                 corridor_bias=0.5,\n                 collision_res=1.0,\n                 grid_cell=None,\n                 dupe_radius_ratio=0.5,\n                 r_max=3,\n                 connect_steps=2,\n                 rewire_radius_ratio=1.2,\n                 rewire_limit=6,\n                 smoothing_iters=60):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.collision_res = max(0.25, float(collision_res))\n        self.grid_cell = grid_cell\n        self.dupe_radius_ratio = max(0.1, float(dupe_radius_ratio))\n        self.r_max = max(1, int(r_max))\n        self.connect_steps = max(0, int(connect_steps))\n        self.rewire_radius_ratio = max(0.5, float(rewire_radius_ratio))\n        self.rewire_limit = max(0, int(rewire_limit))\n        self.smoothing_iters = max(0, int(smoothing_iters))\n\n        self.dim = 2\n        self.bounds = None\n\n        self._lcg_state = 2862933555777941757  # deterministic RNG seed\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = self._as_tuple(map.start)\n        goal = self._as_tuple(map.goal)\n        obstacles = list(map.obstacles)\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 1.5 * self.step_size)\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight line\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.collision_res):\n            n0 = Node(start, None, 0.0)\n            n1 = Node(goal, n0, self._dist(start, goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [start, goal], [n0, n1], [(n0, n1)])\n\n        # Setup\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n        grid_start, grid_goal = {}, {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        dsg = self._dist(start, goal)\n        corridor_w = max(self.step_size, 0.15 * dsg)\n        best_len = None  # incumbent path length once found\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = goal if active_start else start\n\n            # Adaptive corridor width after first solution\n            if best_len is not None:\n                corridor_w = max(self.step_size, 0.05 * dsg)\n\n            # Sample target\n            target = self._sample_target(start, goal, corridor_w, obstacles, is_3d, root_other, best_len)\n\n            # Nearest and steer\n            parent = self._nearest_hashed(grid_a, tree_a, target)\n            if parent is None:\n                continue\n            new_pos = self._steer(parent.position, target, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            # Edge collision check\n            if self._is_edge_in_obstacle(parent.position, new_pos, obstacles, is_3d, self.collision_res):\n                continue\n            # Duplicate suppression\n            if self._exists_close(grid_a, new_pos, self.step_size * self.dupe_radius_ratio):\n                continue\n\n            # Insert node (both node and edge validated)\n            new_node = Node(new_pos, parent, parent.cost + self._dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(grid_a, new_node)\n\n            # Local micro-rewire to shorten cost (commit-only with checks)\n            self._local_rewire(new_node, tree_a, grid_a, obstacles, is_3d, edges)\n\n            # Try direct bridge to the other tree\n            other_near = self._nearest_hashed(grid_b, tree_b, new_node.position)\n            if other_near is not None:\n                if not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.collision_res):\n                    path = self._extract_path(new_node, other_near)\n                    best_len = self._path_length(path)\n                    path = self._smooth_path(path, obstacles, is_3d)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Optional few-step guided connect from other tree (commit-only)\n            if self.connect_steps > 0:\n                p = other_near\n                steps = 0\n                while p is not None and steps < self.connect_steps:\n                    step_to = self._steer(p.position, new_node.position, self.step_size)\n                    if not self._in_bounds(step_to):\n                        break\n                    if self._is_in_obstacle(step_to, obstacles, is_3d):\n                        break\n                    if self._is_edge_in_obstacle(p.position, step_to, obstacles, is_3d, self.collision_res):\n                        break\n                    if self._exists_close(grid_b, step_to, self.step_size * self.dupe_radius_ratio):\n                        break\n                    q = Node(step_to, p, p.cost + self._dist(p.position, step_to))\n                    p.add_child(q)\n                    tree_b.append(q)\n                    edges.append((p, q))\n                    self._grid_add(grid_b, q)\n\n                    # Try final bridge\n                    if not self._is_edge_in_obstacle(q.position, new_node.position, obstacles, is_3d, self.collision_res):\n                        path = self._extract_path(new_node, q)\n                        best_len = self._path_length(path)\n                        path = self._smooth_path(path, obstacles, is_3d)\n                        return PlannerResult(True, path, start_tree + goal_tree, edges)\n                    p = q\n                    steps += 1\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- Random ----------\n    def _rand(self):\n        # 61-bit LCG for determinism\n        self._lcg_state = (6364136223846793005 * self._lcg_state + 1442695040888963407) % (1 << 61)\n        return (self._lcg_state & ((1 << 61) - 1)) / float(1 << 61)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _rand_int(self, a, b):\n        if b <= a:\n            return a\n        r = int(self._uniform(0.0, (b - a + 1)))\n        v = a + r\n        if v > b:\n            v = b\n        return v\n\n    # ---------- Geometry ----------\n    def _as_tuple(self, p):\n        if isinstance(p, tuple):\n            return p\n        return tuple(p[i] for i in range(len(p)))\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / max(1e-9, d)\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        # Coarse AABB overlap early-exit\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Sampling ----------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, start, goal, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            off = (self._uniform(-width, width),\n                   self._uniform(-width, width),\n                   self._uniform(-width, width))\n            p = self._clamp(tuple(base[i] + off[i] for i in range(3)))\n        else:\n            off = (self._uniform(-width, width),\n                   self._uniform(-width, width))\n            p = self._clamp(tuple(base[i] + off[i] for i in range(2)))\n        if not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_target(self, start, goal, corridor_w, obstacles, is_3d, root_other, best_len):\n        r = self._rand()\n        if r < self.goal_bias:\n            return root_other\n        elif r < self.goal_bias + self.corridor_bias:\n            # Narrow corridor after first solution\n            width = corridor_w\n            return self._sample_corridor(start, goal, width, obstacles, is_3d)\n        else:\n            return self._sample_free(obstacles, is_3d)\n\n    # ---------- Grid nearest ----------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        found = False\n        for r in range(0, self.r_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n                    found = True\n            if found:\n                return best\n        # Fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                di = n.position[i] - pos[i]\n                s += di * di\n            if s <= r2:\n                return True\n        return False\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                di = n.position[i] - pos[i]\n                s += di * di\n            if s <= r2:\n                out.append(n)\n        return out\n\n    # ---------- Rewiring ----------\n    def _local_rewire(self, new_node, tree, grid, obstacles, is_3d, edges):\n        if self.rewire_limit <= 0:\n            return\n        radius = self.step_size * self.rewire_radius_ratio\n        neigh = self._neighbors_in_radius(grid, new_node.position, radius)\n        count = 0\n        for v in neigh:\n            if v is new_node or v.parent is None:\n                continue\n            # Node collision check (existing node still valid)\n            if self._is_in_obstacle(v.position, obstacles, is_3d):\n                continue\n            new_cost = new_node.cost + self._dist(new_node.position, v.position)\n            if new_cost + 1e-9 < v.cost:\n                # Edge collision check\n                if not self._is_edge_in_obstacle(new_node.position, v.position, obstacles, is_3d, self.collision_res):\n                    old_parent = v.parent\n                    # Update edge list: remove old, add new\n                    self._remove_edge(edges, old_parent, v)\n                    old_parent.remove_child(v)\n                    new_node.add_child(v)\n                    v.cost = new_cost\n                    edges.append((new_node, v))\n                    self._propagate_cost(v)\n                    count += 1\n                    if count >= self.rewire_limit:\n                        break\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges)):\n            ep, ec = edges[i]\n            if ep is p and ec is c:\n                edges.pop(i)\n                return\n\n    def _propagate_cost(self, node):\n        # After rewiring, update subtree costs\n        for ch in node.children:\n            ch.cost = node.cost + self._dist(node.position, ch.position)\n            self._propagate_cost(ch)\n\n    # ---------- Path utilities ----------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        if not path or len(path) < 2:\n            return path\n        # Greedy LOS compression\n        pts = [path[0]]\n        last = path[0]\n        i = 1\n        while i < len(path):\n            far = i\n            j = i\n            while j < len(path) and not self._is_edge_in_obstacle(last, path[j], obstacles, is_3d, self.collision_res):\n                far = j\n                j += 1\n            last = path[far]\n            pts.append(last)\n            i = far + 1\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        # Light random shortcuts\n        for _ in range(self.smoothing_iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = self._rand_int(0, n - 3)\n            j = self._rand_int(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_res):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -29.19111,
          "time_improvement": 38.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1845.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018200445175170898,
                    "num_nodes_avg": 67.7,
                    "path_length_avg": 171.14563324796245,
                    "smoothness_avg": 0.04601411221187297,
                    "success_improvement": 0.0,
                    "time_improvement": 34.012985070885414,
                    "node_improvement": 82.95139763283808,
                    "length_improvement": 6.192366440685648,
                    "smoothness_improvement": 620.220777359775,
                    "objective_score": 17.020419272475888
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04422030448913574,
                    "num_nodes_avg": 169.5,
                    "path_length_avg": 238.8478777434046,
                    "smoothness_avg": 0.1240318285715561,
                    "success_improvement": 0.0,
                    "time_improvement": 73.27738308439075,
                    "node_improvement": 88.61116710340657,
                    "length_improvement": 20.26570355427738,
                    "smoothness_improvement": 3091.4282856612494,
                    "objective_score": 49.599778486189905
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04792101383209228,
                    "num_nodes_avg": 201.5,
                    "path_length_avg": 126.62498239156014,
                    "smoothness_avg": 0.15128039712234756,
                    "success_improvement": 0.0,
                    "time_improvement": 7.6357177814591655,
                    "node_improvement": 74.3801652892562,
                    "length_improvement": 15.901715929235335,
                    "smoothness_improvement": 1824.2754850388828,
                    "objective_score": 20.953122317173364
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "EC-Guide BiRRT with Edge-Cached LOS Compression and Elliptic Focus (EC-GBiRRT). This planner grows two trees from start and goal using a small beam of guided samples, compresses each new extension via multi-ancestor line-of-sight (LOS) with a shared edge-collision memo cache, and attempts a zero-step direct connect to the other tree. After a first path, sampling narrows to a prolate ellipse corridor to accelerate convergence. Early-terminating forward LOS shortcutting finalizes the path. These choices cut repeated collision checks, reduce tree depth, and avoid micro-step connects, improving planning time and path quality.",
          "planning_mechanism": "Each iteration alternates trees: generate a few biased samples, pick a nearby node via a grid hash, steer one step, and validate node/edge. Select the cheapest LOS-ancestor parent using cached edge checks, insert the node, then try a direct LOS link to the other tree\u2019s nearest node; if it succeeds, extract and lightly shortcut the path. A shared bounded edge-cache stores free/blocked results, multi-ancestor compression shortens chains, a per-cell cap limits redundant local growth, and corridor-biased sampling activates once a provisional path exists.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        beam_width=2,\n        goal_bias=0.2,\n        los_lookback_depth=10,\n        min_separation_factor=0.6,\n        grid_cell_factor=1.2,\n        per_cell_cap=12,\n        edge_cache_capacity=20000,\n        shortcut_attempts=60,\n        no_improve_stop=12\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.los_lookback_depth = los_lookback_depth\n        self.min_separation_factor = min_separation_factor\n        self.grid_cell_factor = grid_cell_factor\n        self.per_cell_cap = per_cell_cap\n        self.edge_cache_capacity = edge_cache_capacity\n        self.shortcut_attempts = shortcut_attempts\n        self.no_improve_stop = no_improve_stop\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dims = len(self.bounds)\n        self.is_3d = self.dims == 3\n        self.obstacles = map.obstacles\n        self.start = map.start\n        self.goal = map.goal\n\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n        self.ecache = {}\n        self._tick = 0\n        self._last_prune = 0\n        self.ecache_quant = max(0.5, self.step_size * 0.5)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(self.start, parent=None, cost=0.0)\n        goal_root = Node(self.goal, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        incumbent_len = None\n        best_path = None\n\n        for _ in range(self.max_iter):\n            # Alternate trees each loop\n            for active_tree, active_grid, other_tree, other_grid, attractor in [\n                (tree_a, grid_a, tree_b, grid_b, self.goal),\n                (tree_b, grid_b, tree_a, grid_a, self.start),\n            ]:\n                progress = False\n                for _b in range(self.beam_width):\n                    sample = self._guided_sample(attractor, incumbent_len)\n                    if sample is None:\n                        continue\n\n                    nearest = self._nearest_in_grid(active_grid, sample)\n                    if nearest is None:\n                        continue\n\n                    new_pos = self._steer(nearest.position, sample)\n                    if not self._within_bounds(new_pos):\n                        continue\n                    if self._in_obstacle(new_pos):\n                        continue\n                    # Check edge to nearest; required before any parent selection\n                    if not self._edge_free(nearest.position, new_pos):\n                        continue\n                    # Duplicate suppression\n                    if self._has_nearby(active_grid, new_pos, self.min_separation):\n                        continue\n\n                    # Parent selection via LOS ancestors using cached edge checks\n                    parent = self._select_parent(nearest, new_pos)\n                    if parent is None:\n                        # Safety: though nearest->new_pos was free, parent selection failed; fallback\n                        parent = nearest\n\n                    # Per-cell growth limit; allow insert if bucket light or cost improves the bucket\n                    cell_key = self._cell_of(new_pos)\n                    bucket = active_grid.get(cell_key)\n                    if bucket and len(bucket) >= self.per_cell_cap:\n                        # Allow only if this is significantly cheaper than the best in bucket\n                        best_bucket_cost = min(n.cost for n in bucket)\n                        cand_cost = parent.cost + self._distance(parent.position, new_pos)\n                        if cand_cost >= best_bucket_cost - 1e-6:\n                            continue\n\n                    new_cost = parent.cost + self._distance(parent.position, new_pos)\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node)\n                    progress = True\n\n                    # Attempt direct LOS connect (no micro-steps)\n                    other_near = self._nearest_in_grid(other_grid, new_node.position)\n                    if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                        path_a = self._path_from_root(new_node)\n                        path_b = self._path_from_root(other_near)\n                        # Merge with direct bridge segment ensured free\n                        raw_path = path_a + path_b[::-1]\n                        # Path might duplicate joint if new_node coincides with other_near; dedup\n                        if len(raw_path) >= 2 and self._distance(raw_path[-1], raw_path[-2]) <= 1e-9:\n                            raw_path.pop()  # remove duplicate\n                        smoothed = self._shortcut(raw_path)\n                        final_path = smoothed if smoothed else raw_path\n                        best_path = final_path\n                        incumbent_len = self._path_length(final_path)\n                        return PlannerResult(True, final_path, nodes, edges)\n\n                # If we found no progress from this side in this alternation, continue to the other\n                if not progress:\n                    continue\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # ---------- Geometry and metrics ----------\n    def _distance(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._distance(a, b)\n        if d <= 1e-12:\n            return a\n        if d <= self.step_size:\n            return b\n        r = self.step_size / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n\n    def _path_from_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        length = 0.0\n        for i in range(1, len(path)):\n            length += self._distance(path[i - 1], path[i])\n        return length\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, attractor, incumbent_len):\n        # Corridor-biased sampling if incumbent exists; else mild goal bias\n        # Try limited attempts to avoid heavy rejection\n        for _ in range(20):\n            if incumbent_len is not None and self._distance(self.start, self.goal) > 1e-9:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.05)\n                if p is None:\n                    continue\n            else:\n                if self._rand() < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            if self._within_bounds(p) and not self._in_obstacle(p):\n                return p\n        # Fallback hard-attractor\n        return attractor if self._within_bounds(attractor) and not self._in_obstacle(attractor) else None\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        # Rejection sample in the bounding box of the ellipse/spheroid\n        # Limited attempts for speed; returns None on failure\n        cx = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum_dist\n        # Direction vector and its norm\n        v = tuple(f2[i] - f1[i] for i in range(self.dims))\n        vd = self._distance(f1, f2)\n        # Bounding box extents\n        ext = [half, half, half] if self.is_3d else [half, half]\n        # Try a few samples\n        for _ in range(12):\n            p = tuple(cx[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._within_bounds(p):\n                continue\n            # ellipse condition: dist(p,f1)+dist(p,f2) <= max_sum_dist\n            if self._distance(p, f1) + self._distance(p, f2) <= max_sum_dist and not self._in_obstacle(p):\n                return p\n        return None\n\n    # ---------- Grid spatial hash ----------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _has_nearby(self, grid, pos, radius):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if bucket:\n                            for n in bucket:\n                                if self._distance(n.position, pos) <= radius:\n                                    return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if bucket:\n                        for n in bucket:\n                            if self._distance(n.position, pos) <= radius:\n                                return True\n        return False\n\n    def _nearest_in_grid(self, grid, pos, max_ring=5):\n        cell = self._cell_of(pos)\n        best = None\n        best_d = 1e100\n        if self.is_3d:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if bucket:\n                                for n in bucket:\n                                    d = self._distance(n.position, pos)\n                                    if d < best_d:\n                                        best = n\n                                        best_d = d\n                                        found = True\n                if found:\n                    return best\n        else:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if bucket:\n                            for n in bucket:\n                                d = self._distance(n.position, pos)\n                                if d < best_d:\n                                    best = n\n                                    best_d = d\n                                    found = True\n                if found:\n                    return best\n        # Rare fallback: scan all buckets\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._distance(n.position, pos)\n                if d < best_d:\n                    best = n\n                    best_d = d\n        return best\n\n    # ---------- Obstacles ----------\n    def _in_obstacle(self, pos):\n        if self.is_3d:\n            px, py, pz = pos\n            for obs in self.obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in self.obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.ecache_quant) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.ecache_quant) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]  # True if free, False if blocked\n        # Compute and cache\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        # Bounded pruning\n        if len(self.ecache) - self._last_prune > self.edge_cache_capacity:\n            self._prune_cache()\n        return free\n\n    def _prune_cache(self):\n        # Drop roughly oldest 40%\n        if not self.ecache:\n            return\n        cutoff = self._tick - 2000\n        to_remove = []\n        for k, v in self.ecache.items():\n            if v[1] < cutoff:\n                to_remove.append(k)\n        if not to_remove:\n            # If nothing older than cutoff, remove every 3rd entry to bound size\n            i = 0\n            for k in list(self.ecache.keys()):\n                if i % 3 == 0:\n                    to_remove.append(k)\n                i += 1\n        for k in to_remove:\n            if k in self.ecache:\n                del self.ecache[k]\n        self._last_prune = len(self.ecache)\n\n    def _segment_hits_obstacle(self, a, b):\n        dist = self._distance(a, b)\n        # Resolution tuned for speed while preserving safety\n        resolution = max(0.5, min(1.0, self.step_size * 0.5))\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            p = tuple(a[d] + (b[d] - a[d]) * t for d in range(self.dims))\n            if self._in_obstacle(p):\n                return True\n        return False\n\n    # ---------- Parent selection ----------\n    def _select_parent(self, nearest, new_pos):\n        best = nearest\n        best_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        cur = nearest\n        depth = 0\n        while cur is not None and depth < self.los_lookback_depth:\n            if self._edge_free(cur.position, new_pos):\n                cand = cur.cost + self._distance(cur.position, new_pos)\n                if cand + 1e-9 < best_cost:\n                    best_cost = cand\n                    best = cur\n            cur = cur.parent\n            depth += 1\n        return best\n\n    # ---------- Shortcut smoothing ----------\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        attempts = 0\n        no_improve = 0\n        i = 0\n        while attempts < self.shortcut_attempts and i < len(pts) - 2:\n            improved = False\n            # Try to jump from i to a farther j\n            j = len(pts) - 1\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    # Remove intermediates\n                    del pts[i + 1:j]\n                    improved = True\n                    no_improve = 0\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n                no_improve += 1\n            attempts += 1\n            if no_improve >= self.no_improve_stop:\n                break\n        return pts\n\n    # ---------- Random helpers ----------\n    def _rand(self):\n        # expects 'random' module available\n        return random.random()\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()",
          "objective": -29.11471,
          "time_improvement": 51.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 1571.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02822730541229248,
                    "num_nodes_avg": 65.6,
                    "path_length_avg": 182.96020324956595,
                    "smoothness_avg": 0.05732726413788967,
                    "success_improvement": 0.0,
                    "time_improvement": -10.700544274551492,
                    "node_improvement": 83.48023167967766,
                    "length_improvement": -0.28338659103527,
                    "smoothness_improvement": 797.2961719045505,
                    "objective_score": 0.6062856225361433
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01984243392944336,
                    "num_nodes_avg": 86.6,
                    "path_length_avg": 243.5413235727727,
                    "smoothness_avg": 0.09042567896577892,
                    "success_improvement": 0.0,
                    "time_improvement": 87.61375486797985,
                    "node_improvement": 94.18128065578178,
                    "length_improvement": 18.698896243086562,
                    "smoothness_improvement": 2226.7178507734366,
                    "objective_score": 48.63705346011307
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01169896125793457,
                    "num_nodes_avg": 78.1,
                    "path_length_avg": 133.4682422714018,
                    "smoothness_avg": 0.1405957321950529,
                    "success_improvement": 0.0,
                    "time_improvement": 76.14970532839176,
                    "node_improvement": 90.06993006993007,
                    "length_improvement": 11.356748558062376,
                    "smoothness_improvement": 1688.3673358236224,
                    "objective_score": 38.100797412473064
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "Segment-Slab Indexed Bi-Connect (SSIBC): a fast bidirectional planner that minimizes planning time via an obstacle grid index and slab-based segment\u2013AABB intersection, performing only necessary collision tests. It grows two RRT-Connect style trees with balanced goal/corridor/uniform sampling, uses a grid-hash nearest, duplicate suppression, per-cell throttling, and immediate bridge attempts. Early visibility compression and bounded shortcutting finalize a short, smooth path with minimal post-processing.",
          "planning_mechanism": "Mechanism: Pre-index obstacles into a coarse grid. Each iteration alternates trees, samples a target (goal/corridor/uniform), picks a nearest via grid rings, steers once, and validates using indexed node and edge checks with slab intersections against only overlapping obstacles. On insertion, attempt grandparent visibility compression and a direct or short greedy connect to the opposite tree. On success, extract, visibility-compress, and lightly shortcut the path; otherwise continue until iteration cap.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=10.0,\n                 goal_bias=0.3,\n                 corridor_bias=0.5,\n                 connect_steps=5,\n                 grid_cell=None,\n                 dupe_radius_ratio=0.6,\n                 max_per_cell=8,\n                 smoothing_iters=6,\n                 obs_cell=None):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.connect_steps = connect_steps\n        self.grid_cell = grid_cell\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.max_per_cell = max_per_cell\n        self.smoothing_iters = smoothing_iters\n        self.obs_cell = obs_cell\n\n        self.dim = 2\n        self.bounds = None\n        self.start = None\n        self.goal = None\n\n        self._lcg_state = 2463534242\n\n        # Obstacle index\n        self._obs_grid = None\n        self._obs_cell = None\n        self._obs_aabbs = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        obstacles = list(map.obstacles)\n        is_3d = (self.dim == 3)\n\n        # Grid cell defaults\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.8 * self.step_size)\n        if self.obs_cell is None:\n            self._obs_cell = max(1.0, 1.5 * self.step_size)\n        else:\n            self._obs_cell = max(1.0, self.obs_cell)\n\n        # Build obstacle AABBs and spatial index\n        self._build_obstacle_index(obstacles, is_3d)\n\n        # Validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obstacle(self.start, is_3d) or self._point_in_obstacle(self.goal, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line check\n        if not self._segment_blocked(self.start, self.goal, is_3d):\n            s_node = Node(self.start, None, 0.0)\n            g_node = Node(self.goal, s_node, self._dist(self.start, self.goal))\n            s_node.add_child(g_node)\n            path = [self.start, self.goal]\n            return PlannerResult(True, path, [s_node, g_node], [(s_node, g_node)])\n\n        # Initialize trees and hashed grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        dupe_radius = self.step_size * self.dupe_radius_ratio\n        min_sep = 0.25 * self.step_size\n\n        # Corridor width\n        dsg = self._dist(self.start, self.goal)\n        base_corridor = max(self.step_size, 0.18 * dsg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            other_root_pos = self.goal if active_start else self.start\n\n            # Sample target\n            r = self._rand()\n            if r < self.goal_bias:\n                x_rand = other_root_pos\n            elif r < self.goal_bias + self.corridor_bias:\n                x_rand = self._sample_corridor(self.start, self.goal, base_corridor, is_3d)\n            else:\n                x_rand = self._sample_free(is_3d)\n\n            # Nearest in active tree\n            nearest = self._nearest_hash(grid_a, x_rand, 3)\n            if nearest is None:\n                nearest = self._nearest_linear(tree_a, x_rand)\n\n            # Steer and validate\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._dist(nearest.position, new_pos) < min_sep:\n                continue\n            if self._exists_close(grid_a, new_pos, dupe_radius):\n                continue\n            if not self._grid_can_add(grid_a, new_pos, self.max_per_cell):\n                continue\n            if self._point_in_obstacle(new_pos, is_3d):\n                continue\n            if self._segment_blocked(nearest.position, new_pos, is_3d):\n                continue\n\n            # Add node\n            new_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, new_node)\n\n            # Grandparent visibility compression\n            gp = nearest.parent\n            if gp is not None:\n                if not self._segment_blocked(gp.position, new_node.position, is_3d):\n                    nearest.remove_child(new_node)\n                    self._edges_remove(edges, nearest, new_node)\n                    gp.add_child(new_node)\n                    new_node.cost = gp.cost + self._dist(gp.position, new_node.position)\n                    edges.append((gp, new_node))\n\n            # Try direct bridge to nearest in the other tree\n            other_near = self._nearest_hash(grid_b, new_node.position, 3)\n            if other_near is None and tree_b:\n                other_near = self._nearest_linear(tree_b, new_node.position)\n\n            if other_near is not None and not self._segment_blocked(new_node.position, other_near.position, is_3d):\n                path = self._extract_path(new_node, other_near)\n                path = self._finalize_path(path, is_3d)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Greedy short connect from the opposite tree\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, new_node.position, self.step_size)\n                if self._dist(p.position, to_pos) < min_sep:\n                    break\n                if not self._in_bounds(to_pos):\n                    break\n                if self._exists_close(grid_b, to_pos, dupe_radius):\n                    break\n                if not self._grid_can_add(grid_b, to_pos, self.max_per_cell):\n                    break\n                if self._point_in_obstacle(to_pos, is_3d):\n                    break\n                if self._segment_blocked(p.position, to_pos, is_3d):\n                    break\n\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                edges.append((p, q))\n                self._grid_add(grid_b, q)\n\n                p = q\n                steps += 1\n\n                if not self._segment_blocked(new_node.position, p.position, is_3d):\n                    path = self._extract_path(new_node, p)\n                    path = self._finalize_path(path, is_3d)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # RNG\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Sampling\n    def _sample_free(self, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._point_in_obstacle(p, is_3d):\n                return p\n\n    def _sample_corridor(self, a, b, width, is_3d):\n        t = self._rand()\n        base = tuple(a[i] + t * (b[i] - a[i]) for i in range(self.dim))\n        if self.dim == 3:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._point_in_obstacle(p, is_3d):\n            return p\n        return self._sample_free(is_3d)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # Grid hashing for nodes\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_bucket_len(self, grid, key):\n        b = grid.get(key)\n        return 0 if b is None else len(b)\n\n    def _grid_can_add(self, grid, pos, cap):\n        key = self._grid_key(pos)\n        return self._grid_bucket_len(grid, key) < cap\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hash(self, grid, pos, rmax):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, rmax + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        return None\n\n    def _nearest_linear(self, nodes, pos):\n        best = None\n        bestd = float('inf')\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                return True\n        return False\n\n    # Obstacle index\n    def _build_obstacle_index(self, obstacles, is_3d):\n        self._obs_grid = {}\n        self._obs_aabbs = []\n        for idx, obs in enumerate(obstacles):\n            if is_3d:\n                x, y, z, w, h, d = obs\n                minx, miny, minz = x, y, z\n                maxx, maxy, maxz = x + w, y + h, z + d\n                aabb = (minx, miny, minz, maxx, maxy, maxz)\n            else:\n                x, y, w, h = obs\n                minx, miny = x, y\n                maxx, maxy = x + w, y + h\n                aabb = (minx, miny, maxx, maxy)\n            self._obs_aabbs.append(aabb)\n            # Index into grid\n            if is_3d:\n                ix0 = int(minx // self._obs_cell)\n                iy0 = int(miny // self._obs_cell)\n                iz0 = int(minz // self._obs_cell)\n                ix1 = int(maxx // self._obs_cell)\n                iy1 = int(maxy // self._obs_cell)\n                iz1 = int(maxz // self._obs_cell)\n                for ix in range(ix0, ix1 + 1):\n                    for iy in range(iy0, iy1 + 1):\n                        for iz in range(iz0, iz1 + 1):\n                            key = (ix, iy, iz)\n                            bucket = self._obs_grid.get(key)\n                            if bucket is None:\n                                self._obs_grid[key] = [idx]\n                            else:\n                                bucket.append(idx)\n            else:\n                ix0 = int(minx // self._obs_cell)\n                iy0 = int(miny // self._obs_cell)\n                ix1 = int(maxx // self._obs_cell)\n                iy1 = int(maxy // self._obs_cell)\n                for ix in range(ix0, ix1 + 1):\n                    for iy in range(iy0, iy1 + 1):\n                        key = (ix, iy)\n                        bucket = self._obs_grid.get(key)\n                        if bucket is None:\n                            self._obs_grid[key] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _obs_keys_for_bbox(self, bmin, bmax, is_3d):\n        if is_3d:\n            ix0 = int(bmin[0] // self._obs_cell)\n            iy0 = int(bmin[1] // self._obs_cell)\n            iz0 = int(bmin[2] // self._obs_cell)\n            ix1 = int(bmax[0] // self._obs_cell)\n            iy1 = int(bmax[1] // self._obs_cell)\n            iz1 = int(bmax[2] // self._obs_cell)\n            keys = []\n            for ix in range(ix0, ix1 + 1):\n                for iy in range(iy0, iy1 + 1):\n                    for iz in range(iz0, iz1 + 1):\n                        keys.append((ix, iy, iz))\n            return keys\n        else:\n            ix0 = int(bmin[0] // self._obs_cell)\n            iy0 = int(bmin[1] // self._obs_cell)\n            ix1 = int(bmax[0] // self._obs_cell)\n            iy1 = int(bmax[1] // self._obs_cell)\n            keys = []\n            for ix in range(ix0, ix1 + 1):\n                for iy in range(iy0, iy1 + 1):\n                    keys.append((ix, iy))\n            return keys\n\n    def _gather_obstacles_bbox(self, bmin, bmax, is_3d):\n        keys = self._obs_keys_for_bbox(bmin, bmax, is_3d)\n        seen = {}\n        out = []\n        for k in keys:\n            bucket = self._obs_grid.get(k)\n            if not bucket:\n                continue\n            for idx in bucket:\n                if seen.get(idx) is None:\n                    seen[idx] = 1\n                    out.append(idx)\n        return out\n\n    # Collision helpers\n    def _point_in_obstacle(self, p, is_3d):\n        if is_3d:\n            bmin = (p[0], p[1], p[2])\n            bmax = (p[0], p[1], p[2])\n        else:\n            bmin = (p[0], p[1])\n            bmax = (p[0], p[1])\n        cand = self._gather_obstacles_bbox(bmin, bmax, is_3d)\n        if self.dim == 3:\n            px, py, pz = p\n            for idx in cand:\n                minx, miny, minz, maxx, maxy, maxz = self._obs_aabbs[idx]\n                if minx <= px <= maxx and miny <= py <= maxy and minz <= pz <= maxz:\n                    return True\n        else:\n            px, py = p\n            for idx in cand:\n                minx, miny, maxx, maxy = self._obs_aabbs[idx]\n                if minx <= px <= maxx and miny <= py <= maxy:\n                    return True\n        return False\n\n    def _segment_blocked(self, a, b, is_3d):\n        # Query only obstacles overlapping the segment's bbox\n        if self.dim == 3:\n            bmin = (min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2]))\n            bmax = (max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2]))\n            cand = self._gather_obstacles_bbox(bmin, bmax, True)\n            for idx in cand:\n                aa = self._obs_aabbs[idx]\n                if self._seg_box_intersect_3d(a, b, aa):\n                    return True\n        else:\n            bmin = (min(a[0], b[0]), min(a[1], b[1]))\n            bmax = (max(a[0], b[0]), max(a[1], b[1]))\n            cand = self._gather_obstacles_bbox(bmin, bmax, False)\n            for idx in cand:\n                aa = self._obs_aabbs[idx]\n                if self._seg_box_intersect_2d(a, b, aa):\n                    return True\n        return False\n\n    def _seg_box_intersect_2d(self, p0, p1, aabb):\n        # Slab method\n        minx, miny, maxx, maxy = aabb\n        tmin = 0.0\n        tmax = 1.0\n        dx = p1[0] - p0[0]\n        dy = p1[1] - p0[1]\n        eps = 1e-12\n\n        # X slab\n        if abs(dx) < eps:\n            if p0[0] < minx or p0[0] > maxx:\n                return False\n        else:\n            tx1 = (minx - p0[0]) / dx\n            tx2 = (maxx - p0[0]) / dx\n            if tx1 > tx2:\n                tx1, tx2 = tx2, tx1\n            if tx1 > tmin:\n                tmin = tx1\n            if tx2 < tmax:\n                tmax = tx2\n            if tmin > tmax:\n                return False\n\n        # Y slab\n        if abs(dy) < eps:\n            if p0[1] < miny or p0[1] > maxy:\n                return False\n        else:\n            ty1 = (miny - p0[1]) / dy\n            ty2 = (maxy - p0[1]) / dy\n            if ty1 > ty2:\n                ty1, ty2 = ty2, ty1\n            if ty1 > tmin:\n                tmin = ty1\n            if ty2 < tmax:\n                tmax = ty2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    def _seg_box_intersect_3d(self, p0, p1, aabb):\n        minx, miny, minz, maxx, maxy, maxz = aabb\n        tmin = 0.0\n        tmax = 1.0\n        dx = p1[0] - p0[0]\n        dy = p1[1] - p0[1]\n        dz = p1[2] - p0[2]\n        eps = 1e-12\n\n        # X slab\n        if abs(dx) < eps:\n            if p0[0] < minx or p0[0] > maxx:\n                return False\n        else:\n            tx1 = (minx - p0[0]) / dx\n            tx2 = (maxx - p0[0]) / dx\n            if tx1 > tx2:\n                tx1, tx2 = tx2, tx1\n            if tx1 > tmin:\n                tmin = tx1\n            if tx2 < tmax:\n                tmax = tx2\n            if tmin > tmax:\n                return False\n\n        # Y slab\n        if abs(dy) < eps:\n            if p0[1] < miny or p0[1] > maxy:\n                return False\n        else:\n            ty1 = (miny - p0[1]) / dy\n            ty2 = (maxy - p0[1]) / dy\n            if ty1 > ty2:\n                ty1, ty2 = ty2, ty1\n            if ty1 > tmin:\n                tmin = ty1\n            if ty2 < tmax:\n                tmax = ty2\n            if tmin > tmax:\n                return False\n\n        # Z slab\n        if abs(dz) < eps:\n            if p0[2] < minz or p0[2] > maxz:\n                return False\n        else:\n            tz1 = (minz - p0[2]) / dz\n            tz2 = (maxz - p0[2]) / dz\n            if tz1 > tz2:\n                tz1, tz2 = tz2, tz1\n            if tz1 > tmin:\n                tmin = tz1\n            if tz2 < tmax:\n                tmax = tz2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    # Edges handling\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _visibility_compress(self, pts, is_3d):\n        if len(pts) <= 2:\n            return pts\n        out = [pts[0]]\n        anchor = pts[0]\n        for i in range(1, len(pts) - 1):\n            nxt = pts[i + 1]\n            if self._segment_blocked(anchor, nxt, is_3d):\n                out.append(pts[i])\n                anchor = pts[i]\n        out.append(pts[-1])\n        return out\n\n    def _shortcut_path(self, pts, is_3d, iters):\n        if len(pts) <= 2:\n            return pts\n        out = list(pts)\n        n = len(out)\n        for _ in range(iters):\n            if n <= 2:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = out[i]\n            b = out[j]\n            if not self._segment_blocked(a, b, is_3d):\n                out = out[:i + 1] + out[j:]\n                n = len(out)\n        return out\n\n    def _finalize_path(self, path, is_3d):\n        path = self._visibility_compress(path, is_3d)\n        path = self._shortcut_path(path, is_3d, self.smoothing_iters)\n        path = self._visibility_compress(path, is_3d)\n        return path",
          "objective": -29.08702,
          "time_improvement": 52.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 1629.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015787076950073243,
                    "num_nodes_avg": 52.2,
                    "path_length_avg": 176.55175032048717,
                    "smoothness_avg": 0.04850662757739136,
                    "success_improvement": 0.0,
                    "time_improvement": 42.76282407571483,
                    "node_improvement": 86.85469654998741,
                    "length_improvement": 3.229188007827852,
                    "smoothness_improvement": 659.2340554138854,
                    "objective_score": 18.06253030448059
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.030048704147338866,
                    "num_nodes_avg": 81.7,
                    "path_length_avg": 253.09902101377867,
                    "smoothness_avg": 0.105831649531053,
                    "success_improvement": 0.0,
                    "time_improvement": 81.84137311996358,
                    "node_improvement": 94.51051535308741,
                    "length_improvement": 15.50826173421144,
                    "smoothness_improvement": 2623.124569890014,
                    "objective_score": 46.972991825966005
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03628108501434326,
                    "num_nodes_avg": 84.6,
                    "path_length_avg": 137.5475279305066,
                    "smoothness_avg": 0.13389689603270416,
                    "success_improvement": 0.0,
                    "time_improvement": 30.07083724895054,
                    "node_improvement": 89.24348378893832,
                    "length_improvement": 8.647481257993979,
                    "smoothness_improvement": 1603.1586342951978,
                    "objective_score": 22.22553310095754
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "LITHE-BRRT: Lightweight Informed Thrifty Heuristic Bidirectional RRT with hashed-nearest lookup, cached exact collision checks, micro-LOS compression, and k-bridge connection. It trims expansions with duplicate gating and incumbent-aware sampling, avoids global rewiring, and returns a smoothed line-of-sight\u2013collapsed path quickly.",
          "planning_mechanism": "Grow two trees in alternation with a tiny guided beam. For each sample, steer from the hashed-nearest and pick a cheap LOS parent from a compact neighborhood; enforce node and edge validity before insertion, then compress the new node to a visible ancestor. Attempt a k-nearest direct bridge to the opposite tree; on success, merge, shortcut briefly with cache-aided checks, and perform forward LOS collapse. Use informed-ellipse/corridor sampling once an incumbent exists and memoized segment\u2013AABB tests to curb collision cost.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        # Keep coherent parent/child relation without duplicates\n        for c in self.children:\n            if c is child:\n                child.parent = self\n                return\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i, c in enumerate(self.children):\n            if c is child:\n                self.children.pop(i)\n                break\nclass Planner:\n    def __init__(self,\n                 max_iter=4500,\n                 step_size=9.0,\n                 beam_k=2,\n                 goal_bias=0.2,\n                 corridor_bias=0.4,\n                 informed_bias=0.65,\n                 grid_cell_factor=1.0,\n                 dupe_radius_ratio=0.5,\n                 parent_ring_cells=2,\n                 parent_cap=8,\n                 connect_k=4,\n                 connect_radius_factor=3.0,\n                 anchor_stride=24,\n                 edge_cache_capacity=30000,\n                 edge_cache_quant=1.0,\n                 smoothing_attempts=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.informed_bias = informed_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.parent_ring_cells = max(1, int(parent_ring_cells))\n        self.parent_cap = max(1, int(parent_cap))\n        self.connect_k = max(1, int(connect_k))\n        self.connect_radius_factor = connect_radius_factor\n        self.anchor_stride = max(1, int(anchor_stride))\n        self.edge_cache_capacity = edge_cache_capacity\n        self.edge_cache_quant = max(0.25, edge_cache_quant)\n        self.smoothing_attempts = smoothing_attempts\n\n        self._rng = 2463534242\n\n    # Entry\n    def plan(self, map):\n        # Scene\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n        self.is_3d = (self.dim == 3)\n\n        # Basic validation\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Build obstacle grid for fast collision\n        self._build_obstacle_grid()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Config derived\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.connect_radius = self.connect_radius_factor * self.step_size\n\n        # Edge cache\n        self._tick = 0\n        self._ecache = {}  # key -> (free_bool, last_tick)\n\n        # Direct early exit\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Trees and structures\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        anchors_a, anchors_b = [start_root], [goal_root]\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n\n        best_len = float('inf')\n        sg = self._dist(self.start, self.goal)\n\n        # Main loop\n        for it in range(self.max_iter):\n            grow_a = (it % 2 == 0)\n            tree1 = tree_a if grow_a else tree_b\n            tree2 = tree_b if grow_a else tree_a\n            grid1 = grid_a if grow_a else grid_b\n            grid2 = grid_b if grow_a else grid_a\n            anchors1 = anchors_a if grow_a else anchors_b\n            anchors2 = anchors_b if grow_a else anchors_a\n            other_root = self.goal if grow_a else self.start\n\n            best_cand = None  # (parent, new_pos, other_hint, g_new)\n\n            # Guided beam: select one best candidate to commit\n            for _ in range(self.beam_k):\n                xr = self._sample(other_root, sg, best_len)\n                if xr is None:\n                    continue\n                nearest = self._nearest(grid1, anchors1, tree1, xr)\n                if nearest is None:\n                    continue\n                xnew = self._steer(nearest.position, xr)\n                if not self._in_bounds(xnew):\n                    continue\n                if self._point_blocked(xnew):\n                    continue\n                if self._has_close(grid1, xnew, self.dupe_radius):\n                    continue\n\n                # Choose a parent among a compact neighborhood\n                parent, gnew = self._choose_parent(grid1, nearest, xnew)\n                if parent is None:\n                    continue\n                # Enforce both node and edge validity before insertion\n                if self._point_blocked(xnew):\n                    continue\n                if not self._edge_free(parent.position, xnew):\n                    continue\n\n                # Heuristic score to rank the beam\n                other_near = self._nearest(grid2, anchors2, tree2, xnew)\n                h = self._dist(xnew, other_near.position if other_near else other_root)\n                # Incumbent-aware pruning\n                if best_len < float('inf') and (gnew + h) >= 1.02 * best_len:\n                    continue\n\n                score = gnew + 0.4 * h\n                if best_cand is None or score < best_cand[4]:\n                    best_cand = (parent, xnew, other_near, gnew, score)\n\n            if best_cand is None:\n                continue\n\n            parent, xnew, hint_other, gnew, _ = best_cand\n\n            # Final validity (both checks) before adding node/edge\n            if self._point_blocked(xnew):\n                continue\n            if not self._edge_free(parent.position, xnew):\n                continue\n\n            # Insert node\n            new_node = Node(xnew, parent, gnew)\n            parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(grid1, new_node)\n\n            # Micro-LOS compression to visible ancestor (node-only)\n            self._compress_new_node(new_node, edges)\n\n            # Periodic anchor for fallback nearest\n            if (len(tree1) % self.anchor_stride) == 0:\n                anchors1.append(new_node)\n\n            # Attempt k-bridge to the opposite tree (direct edges only)\n            candidates = self._k_near(grid2, anchors2, tree2, new_node.position, self.connect_radius, self.connect_k)\n            bridged = None\n            for q in candidates:\n                # Both checks: node q was already valid; check edge only\n                if self._edge_free(new_node.position, q.position):\n                    bridged = q\n                    break\n\n            if bridged is not None:\n                if grow_a:\n                    path = self._merge_path(new_node, bridged)\n                else:\n                    path = self._merge_path(bridged, new_node)\n                best_len = self._path_len(path)\n                path = self._shortcut(path)\n                path = self._forward_los(path)\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= self.step_size:\n            return self._clamp(b)\n        r = self.step_size / max(d, 1e-12)\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Sampling\n    def _sample(self, attractor, sg, best_len):\n        for _ in range(24):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._ellipse_sample(best_len * 1.01)\n                if p and not self._point_blocked(p):\n                    return p\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                elif r < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_sample(sg)\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._in_bounds(p) and not self._point_blocked(p):\n                    return p\n        return None\n\n    def _ellipse_sample(self, max_sum):\n        c = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [half] * self.dim\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dim))\n            if self._in_bounds(p) and (self._dist(p, self.start) + self._dist(p, self.goal)) <= max_sum:\n                return p\n        return None\n\n    def _corridor_sample(self, sg):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        width = max(self.step_size, 0.2 * sg)\n        if self.is_3d:\n            for _ in range(16):\n                ox = self._rand_range(-width, width)\n                oy = self._rand_range(-width, width)\n                oz = self._rand_range(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp((base[0] + ox, base[1] + oy, base[2] + oz))\n                    if not self._point_blocked(p):\n                        return p\n        else:\n            for _ in range(16):\n                ox = self._rand_range(-width, width)\n                oy = self._rand_range(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp((base[0] + ox, base[1] + oy))\n                    if not self._point_blocked(p):\n                        return p\n        return tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n\n    # Node grid for NN/dupes\n    def _cell_key(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _ring_nodes(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, anchors, tree, pos):\n        k = self._cell_key(pos)\n        best, bestd = None, 1e100\n        for r in range(0, 3):\n            cand = self._ring_nodes(grid, k, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallbacks\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _has_close(self, grid, pos, radius):\n        k = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell_size) + 1)\n        r2 = radius * radius\n        cand = self._ring_nodes(grid, k, rc)\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    def _choose_parent(self, grid, nearest, pos):\n        # Evaluate a compact neighborhood around the target cell\n        k = self._cell_key(pos)\n        cand = self._ring_nodes(grid, k, self.parent_ring_cells)\n        if not cand:\n            cand = [nearest]\n        # Reservoir to cap candidates\n        picked = []\n        seen = 0\n        for n in cand:\n            seen += 1\n            if len(picked) < self.parent_cap:\n                picked.append(n)\n            else:\n                j = int(self._rand_range(0, seen))\n                if j < self.parent_cap:\n                    picked[j] = n\n        best_p = None\n        best_g = 1e100\n        for p in picked:\n            d = self._dist(p.position, pos)\n            g = p.cost + d\n            if g < best_g and self._edge_free(p.position, pos):\n                best_g = g\n                best_p = p\n        if best_p is None:\n            # fallback to nearest if edge is free\n            if self._edge_free(nearest.position, pos):\n                return nearest, nearest.cost + self._dist(nearest.position, pos)\n            return None, None\n        return best_p, best_g\n\n    def _k_near(self, grid, anchors, tree, pos, radius, k):\n        key = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell_size) + 1)\n        cand = self._ring_nodes(grid, key, rc)\n        # Filter by radius\n        near = []\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                near.append((s, n))\n        if not near:\n            # fallbacks\n            lst = list(anchors) if anchors else []\n            if not lst:\n                lst = list(tree)\n            for n in lst:\n                s = 0.0\n                for i in range(self.dim):\n                    d = n.position[i] - pos[i]\n                    s += d * d\n                near.append((s, n))\n        near.sort(key=lambda x: x[0])\n        out = []\n        for i in range(min(k, len(near))):\n            out.append(near[i][1])\n        return out\n\n    # Obstacle grid and collisions\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self._obs_grid = {}\n        if self.is_3d:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self._obs_grid.get(k)\n                            if b is None:\n                                self._obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self._obs_grid.get(k)\n                        if b is None:\n                            self._obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            lst = self._obs_grid.get((cx, cy, cz))\n            if not lst:\n                return False\n            px, py, pz = p\n            for idx in lst:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            lst = self._obs_grid.get((cx, cy))\n            if not lst:\n                return False\n            px, py = p\n            for idx in lst:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.edge_cache_quant) for i in range(self.dim))\n        qb = tuple(int(b[i] / self.edge_cache_quant) for i in range(self.dim))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        k = self._edge_key(a, b)\n        hit = self._ecache.get(k)\n        if hit is not None:\n            self._tick += 1\n            self._ecache[k] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._seg_hits_any(a, b)\n        self._tick += 1\n        self._ecache[k] = (free, self._tick)\n        if len(self._ecache) > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self._ecache:\n            return\n        cutoff = self._tick - 3000\n        to_del = []\n        for k, v in self._ecache.items():\n            if v[1] < cutoff:\n                to_del.append(k)\n        if not to_del:\n            # Fallback partial clear\n            i = 0\n            for k in list(self._ecache.keys()):\n                if (i % 3) == 0:\n                    to_del.append(k)\n                i += 1\n        for k in to_del:\n            if k in self._ecache:\n                del self._ecache[k]\n\n    def _seg_hits_any(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self._obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            cand.update(bkt)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self._obs_grid.get((cx, cy))\n                    if bkt:\n                        cand.update(bkt)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_2d(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _seg_aabb_3d(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Compression for the newly inserted node (no subtree propagation needed)\n    def _compress_new_node(self, node, edges):\n        cur_parent = node.parent\n        if cur_parent is None:\n            return\n        gp = cur_parent.parent\n        while gp is not None and self._edge_free(gp.position, node.position):\n            # Update edges coherently\n            cur_parent.remove_child(node)\n            self._remove_edge(edges, cur_parent, node)\n            gp.add_child(node)\n            edges.append((gp, node))\n            node.cost = gp.cost + self._dist(gp.position, node.position)\n            cur_parent = gp\n            gp = cur_parent.parent\n\n    def _remove_edge(self, edges, parent, child):\n        for i, e in enumerate(edges):\n            if e[0] is parent and e[1] is child:\n                edges.pop(i)\n                return\n\n    # Paths\n    def _to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_path(self, a_node, b_node):\n        pa = self._to_root(a_node)\n        pb = self._to_root(b_node)\n        pb.reverse()\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[1:]\n        return pa + pb\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    # Post smoothing\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        tries = 0\n        bestL = self._path_len(pts)\n        while tries < self.smoothing_attempts and len(pts) >= 3:\n            i = int(self._rand_range(0, max(1, len(pts) - 2)))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= bestL + 1e-12:\n                    pts = new_pts\n                    bestL = L\n            tries += 1\n        return pts\n\n    def _forward_los(self, path):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        anchor = path[0]\n        k = 1\n        while k < len(path) - 1:\n            nxt = path[k + 1]\n            if self._edge_free(anchor, nxt):\n                k += 1\n                continue\n            out.append(path[k])\n            anchor = path[k]\n            k += 1\n        out.append(path[-1])\n        return out",
          "objective": -28.8814,
          "time_improvement": 48.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1567.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022646141052246094,
                    "num_nodes_avg": 78.2,
                    "path_length_avg": 170.39434253860537,
                    "smoothness_avg": 0.05185034231215988,
                    "success_improvement": 0.0,
                    "time_improvement": 17.894796895408025,
                    "node_improvement": 80.30722739864015,
                    "length_improvement": 6.604160783447385,
                    "smoothness_improvement": 711.5704520057756,
                    "objective_score": 12.888787798719715
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.037246417999267575,
                    "num_nodes_avg": 115.8,
                    "path_length_avg": 240.92396356066416,
                    "smoothness_avg": 0.1012788889951575,
                    "success_improvement": 0.0,
                    "time_improvement": 77.49174793860553,
                    "node_improvement": 92.2193106228583,
                    "length_improvement": 19.5726463516592,
                    "smoothness_improvement": 2505.978762080556,
                    "objective_score": 47.52100600297996
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026037073135375975,
                    "num_nodes_avg": 75.2,
                    "path_length_avg": 140.84422616719021,
                    "smoothness_avg": 0.12445020180890005,
                    "success_improvement": 0.0,
                    "time_improvement": 49.81542795302638,
                    "node_improvement": 90.43865225683408,
                    "length_improvement": 6.457971261089232,
                    "smoothness_improvement": 1482.997381050845,
                    "objective_score": 26.234398047815677
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "Beam-guided BiRRT with ancestor line-of-sight compression and spatial hashing (BG-Connect-LOS). The planner alternates tree growth from start and goal using a small beam of guided samples, accelerates nearest lookups with a grid hash, suppresses near-duplicate nodes, and selects a parent among recent ancestors that maintains direct line-of-sight to the new point to compress chains. A short, capped greedy connect links the two trees. Upon success, a bounded shortcut pass refines the path. This reduces expansions and collision checks while improving path quality and smoothness.",
          "planning_mechanism": "At each iteration, pick the active tree and generate a small beam of guided samples biased toward the opposite root. For each sample: find a nearby node via spatial hashing, steer by a fixed step, enforce node and edge collision checks, reject near-duplicates, and pick an ancestor parent with clear line-of-sight to minimize added cost. Insert the node and attempt a capped greedy connect from the opposite tree toward it; if the two trees meet, extract and lightly shortcut the path. Alternate trees and stop early on success.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        beam_width=3,\n        goal_bias=0.15,\n        connect_steps_limit=20,\n        min_separation_factor=0.6,\n        grid_cell_factor=1.0,\n        los_lookback_depth=8,\n        shortcut_attempts=40\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.connect_steps_limit = connect_steps_limit\n        self.min_separation_factor = min_separation_factor\n        self.grid_cell_factor = grid_cell_factor\n        self.los_lookback_depth = los_lookback_depth\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dims = len(bounds)\n        is_3d = dims == 3\n\n        # Parameters derived from step_size\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root = Node(goal_position, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root, is_3d)\n        self._grid_insert(grid_b, goal_root, is_3d)\n\n        success_state = False\n        extracted_path = []\n\n        for _ in range(self.max_iter):\n            # Alternate trees by swapping references each loop\n            for active_tree, active_grid, other_tree, other_grid, attractor in [\n                (tree_a, grid_a, tree_b, grid_b, goal_position),\n                (tree_b, grid_b, tree_a, grid_a, start_position),\n            ]:\n                made_progress = False\n\n                for _beam in range(self.beam_width):\n                    sample = self._sample_guided(bounds, obstacles, is_3d, attractor)\n\n                    nearest = self._nearest_by_grid(active_tree, active_grid, sample, is_3d)\n                    if nearest is None:\n                        continue\n\n                    new_pos = self._steer(nearest.position, sample)\n                    if not self._within_bounds(new_pos, bounds):\n                        continue\n                    if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                        continue\n                    if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                        continue\n                    if self._has_near_duplicate(active_grid, new_pos, self.min_separation, is_3d):\n                        continue\n\n                    # Choose parent among LOS-capable ancestors to compress path\n                    parent = self._choose_ancestor_parent(nearest, new_pos, obstacles, is_3d)\n                    new_cost = parent.cost + self._distance(parent.position, new_pos)\n\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node, is_3d)\n                    made_progress = True\n\n                    # Try capped greedy connect from the opposite tree toward new_node\n                    connect_node = self._attempt_connect(\n                        other_tree, other_grid, new_node.position, obstacles, is_3d, nodes, edges, bounds\n                    )\n                    if connect_node is not None:\n                        # Trees meet at new_node.position; extract path\n                        path_a = self._path_from_root(new_node)\n                        path_b = self._path_from_root(connect_node)\n                        # Remove duplicate joint if equal\n                        if path_a and path_b and path_a[-1] == path_b[-1]:\n                            path_b = path_b[:-1]\n                        raw_path = path_a + path_b[::-1]\n                        # Light shortcut smoothing\n                        smoothed = self._shortcut_path(raw_path, obstacles, is_3d, attempts=self.shortcut_attempts)\n                        extracted_path = smoothed if smoothed else raw_path\n                        success_state = True\n                        return PlannerResult(True, extracted_path, nodes, edges)\n\n                # If neither beam sample made progress for this tree, continue with the other\n                if not made_progress:\n                    continue\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # --------- Core Geometry / Utilities ---------\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _within_bounds(self, pos, bounds):\n        for i in range(len(bounds)):\n            if pos[i] < 0.0 or pos[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= 1e-9:\n            return from_pos\n        if dist <= self.step_size:\n            return to_pos\n        r = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * r for d in range(len(from_pos)))\n\n    def _sample_guided(self, bounds, obstacles, is_3d, target):\n        # Mild guidance: with some probability sample exactly target, else blend toward target\n        while True:\n            if random.random() < self.goal_bias:\n                p = target\n            else:\n                rand = tuple(random.uniform(0.0, bounds[d]) for d in range(len(bounds)))\n                alpha = 0.2\n                p = tuple(alpha * target[d] + (1.0 - alpha) * rand[d] for d in range(len(bounds)))\n            if self._within_bounds(p, bounds) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _path_from_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\n\n    # --------- Spatial Hash (Grid) ---------\n\n    def _cell_of(self, pos):\n        # integer grid cell indices\n        if len(pos) == 3:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        else:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node, is_3d):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _has_near_duplicate(self, grid, pos, radius, is_3d):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if bucket:\n                            for n in bucket:\n                                if self._distance(n.position, pos) <= radius:\n                                    return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if bucket:\n                        for n in bucket:\n                            if self._distance(n.position, pos) <= radius:\n                                return True\n        return False\n\n    def _nearest_by_grid(self, tree, grid, pos, is_3d, ring_limit=3):\n        # Search neighborhood rings; fallback to linear scan if not found\n        cell = self._cell_of(pos)\n        best = None\n        best_d = float(\"inf\")\n\n        if is_3d:\n            for ring in range(0, ring_limit + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if bucket:\n                                for n in bucket:\n                                    d = self._distance(n.position, pos)\n                                    if d < best_d:\n                                        best_d = d\n                                        best = n\n                                        found = True\n                if found and best is not None:\n                    return best\n        else:\n            for ring in range(0, ring_limit + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if bucket:\n                            for n in bucket:\n                                d = self._distance(n.position, pos)\n                                if d < best_d:\n                                    best_d = d\n                                    best = n\n                                    found = True\n                if found and best is not None:\n                    return best\n\n        # Fallback\n        if not tree:\n            return None\n        return min(tree, key=lambda n: self._distance(n.position, pos))\n\n    # --------- Parent selection via LOS to ancestors ---------\n\n    def _choose_ancestor_parent(self, nearest, new_pos, obstacles, is_3d):\n        best_parent = nearest\n        best_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        steps = 0\n        cur = nearest\n        while cur is not None and steps < self.los_lookback_depth:\n            if not self._is_edge_in_obstacle(cur.position, new_pos, obstacles, is_3d):\n                cand_cost = cur.cost + self._distance(cur.position, new_pos)\n                if cand_cost < best_cost:\n                    best_cost = cand_cost\n                    best_parent = cur\n            cur = cur.parent\n            steps += 1\n        return best_parent\n\n    # --------- Connect attempt ---------\n\n    def _attempt_connect(self, tree, grid, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest_by_grid(tree, grid, target_pos, is_3d)\n        if nearest is None:\n            return None\n\n        current = nearest\n        for _ in range(self.connect_steps_limit):\n            step_pos = self._steer(current.position, target_pos)\n            if not self._within_bounds(step_pos, bounds):\n                return None\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                return None\n\n            # If close enough to target and direct edge exists, finalize with exact target node\n            if self._distance(step_pos, target_pos) <= 1e-6 or (\n                self._distance(step_pos, target_pos) <= self.step_size and\n                not self._is_edge_in_obstacle(step_pos, target_pos, obstacles, is_3d) and\n                not self._is_in_obstacle(target_pos, obstacles, is_3d)\n            ):\n                # Add intermediate step node if it is not exactly current\n                if self._distance(current.position, step_pos) > 1e-9:\n                    if not self._has_near_duplicate(grid, step_pos, self.min_separation, is_3d):\n                        new_node = Node(step_pos, parent=current, cost=current.cost + self._distance(current.position, step_pos))\n                        current.add_child(new_node)\n                        tree.append(new_node)\n                        nodes.append(new_node)\n                        edges.append((current, new_node))\n                        self._grid_insert(grid, new_node, is_3d)\n                        current = new_node\n                    else:\n                        # If duplicate exists, try using current as is\n                        pass\n                # Add final node at the exact target position to guarantee path merge\n                final_node = Node(target_pos, parent=current, cost=current.cost + self._distance(current.position, target_pos))\n                current.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((current, final_node))\n                self._grid_insert(grid, final_node, is_3d)\n                return final_node\n\n            # Regular step addition with duplicate suppression\n            if self._has_near_duplicate(grid, step_pos, self.min_separation, is_3d):\n                # Progress is negligible; stop trying to avoid loops\n                return None\n\n            new_node = Node(step_pos, parent=current, cost=current.cost + self._distance(current.position, step_pos))\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node, is_3d)\n            current = new_node\n\n        return None\n\n    # --------- Collision Checking ---------\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d):\n        distance = self._distance(from_pos, to_pos)\n        resolution = max(0.5, min(1.0, self.step_size * 0.5))\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    # --------- Shortcut Smoothing (bounded) ---------\n\n    def _shortcut_path(self, path, obstacles, is_3d, attempts=40):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        n = len(pts)\n        tries = 0\n        i = 0\n        # Greedy forward skipping with bounded iterations\n        while i < len(pts) - 2 and tries < attempts:\n            j = len(pts) - 1\n            improved = False\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                    # Remove intermediates\n                    del pts[i + 1:j]\n                    improved = True\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n            tries += 1\n        return pts",
          "objective": -28.86257,
          "time_improvement": 43.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1410.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03400664329528809,
                    "num_nodes_avg": 52.1,
                    "path_length_avg": 171.51876006638196,
                    "smoothness_avg": 0.050501544373221775,
                    "success_improvement": 0.0,
                    "time_improvement": -33.36568499023374,
                    "node_improvement": 86.87987912364643,
                    "length_improvement": 5.987849718937115,
                    "smoothness_improvement": 690.45883529979,
                    "objective_score": -2.964701489208901
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.030187082290649415,
                    "num_nodes_avg": 92.2,
                    "path_length_avg": 234.31486940525366,
                    "smoothness_avg": 0.08620583217892899,
                    "success_improvement": 0.0,
                    "time_improvement": 81.1563136658539,
                    "node_improvement": 93.8050124302896,
                    "length_improvement": 21.77895221296278,
                    "smoothness_improvement": 2118.138153515002,
                    "objective_score": 48.004956195108846
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009754443168640136,
                    "num_nodes_avg": 73.2,
                    "path_length_avg": 124.45355479806292,
                    "smoothness_avg": 0.11960663519260235,
                    "success_improvement": 0.0,
                    "time_improvement": 80.11393158758125,
                    "node_improvement": 90.69294342021614,
                    "length_improvement": 17.343874744565582,
                    "smoothness_improvement": 1421.3875712064366,
                    "objective_score": 41.54744217904591
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Minimal Adaptive BiRRT-Connect+ (MAB-Connect+): a simplified, robust bidirectional planner that alternates short single-step growth with greedy connect, using a lightweight hash-grid for nearest queries, duplicate suppression, shallow visible-ancestor compression, and capped local rewiring. It returns quickly on the first valid bridge and post-processes with shortcutting and bounded relaxation for smooth, short paths.",
          "planning_mechanism": "Alternate expanding start/goal trees with goal-biased uniform sampling. For each sample, steer one step from the nearest node if node and edge are collision-free, then compress to a visible ancestor and optionally rewire nearby nodes. Greedily connect the opposite tree toward the new node by repeated step-and-check; on line-of-sight bridge, extract the path and apply shortcutting plus safe Laplacian relaxation before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=8.0,\n        goal_bias=0.25,\n        collision_step=1.0,\n        grid_cell=3.0,\n        dupe_radius_ratio=0.45,\n        compress_lookback=3,\n        rewire_radius_factor=1.5,\n        rewire_limit=4,\n        shortcut_attempts=80,\n        relax_iters=20,\n        relax_alpha=0.35\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.compress_lookback = compress_lookback\n        self.rewire_radius_factor = rewire_radius_factor\n        self.rewire_limit = rewire_limit\n        self.shortcut_attempts = shortcut_attempts\n        self.relax_iters = relax_iters\n        self.relax_alpha = relax_alpha\n\n        self.bounds = None\n        self.dim = 2\n        self.edge_res = 1.0\n\n        self._rng_s = 987654321\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.edge_res = max(0.5, min(self.collision_step, self.step_size * 0.5))\n        self.grid_cell = max(1.0, self.grid_cell)\n\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Validate start and goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line feasibility\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_res):\n            n0 = Node(start)\n            n1 = Node(goal)\n            return PlannerResult(True, [start, goal], [n0, n1], [])\n\n        # Initialize trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        dupe_radius = self.dupe_radius_ratio * self.step_size\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            grow_tree = tree_a if active_start else tree_b\n            other_tree = tree_b if active_start else tree_a\n            grow_grid = grid_a if active_start else grid_b\n            other_grid = grid_b if active_start else grid_a\n            attractor = goal if active_start else start\n\n            # Sample\n            x_rand = attractor if (self._rand() < self.goal_bias) else self._sample_free(obstacles, is_3d)\n\n            # Extend one step\n            nearest = self._nearest_grid(grow_grid, grow_tree, x_rand)\n            if nearest is None:\n                continue\n            x_new = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(x_new):\n                continue\n            if self._is_in_obstacle(x_new, obstacles, is_3d):\n                continue\n            if self._exists_close(grow_grid, x_new, dupe_radius):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, x_new, obstacles, is_3d, self.edge_res):\n                continue\n\n            # Insert node (BOTH checks done above)\n            new_node = Node(x_new, parent=nearest, cost=nearest.cost + self._dist(nearest.position, x_new))\n            nearest.add_child(new_node)\n            grow_tree.append(new_node)\n            nodes.append(new_node)\n            self._grid_add(grow_grid, new_node)\n            edges.append((nearest, new_node))\n\n            # Visible-ancestor compression (shallow)\n            self._compress_to_visible_ancestor(new_node, obstacles, is_3d, edges, grow_grid)\n\n            # Local rewiring (capped)\n            self._local_rewire(new_node, grow_grid, obstacles, is_3d, edges)\n\n            # Greedy connect from the opposite tree toward new_node\n            bridge = self._connect_toward(other_tree, other_grid, new_node.position, obstacles, is_3d, edges, nodes)\n            if bridge is not None:\n                other_last = bridge\n                # Verify final line-of-sight bridge (both checks)\n                if not self._is_in_obstacle(new_node.position, obstacles, is_3d) and \\\n                   not self._is_in_obstacle(other_last.position, obstacles, is_3d) and \\\n                   not self._is_edge_in_obstacle(new_node.position, other_last.position, obstacles, is_3d, self.edge_res):\n                    if active_start:\n                        path_a = self._collect_root_to(new_node)\n                        path_b = self._collect_to_root(other_last)\n                    else:\n                        path_a = self._collect_root_to(other_last)\n                        path_b = self._collect_to_root(new_node)\n                    raw_path = path_a + path_b\n                    smooth = self._smooth_path(raw_path, obstacles, is_3d)\n                    return PlannerResult(True, smooth, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        # xorshift32\n        x = self._rng_s & 0xFFFFFFFF\n        x ^= (x << 13) & 0xFFFFFFFF\n        x ^= (x >> 17) & 0xFFFFFFFF\n        x ^= (x << 5) & 0xFFFFFFFF\n        self._rng_s = x & 0xFFFFFFFF\n        return (self._rng_s % 1000003) / 1000003.0\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry and bounds\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / (d if d > 1e-12 else 1.0)\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for ox, oy, oz, w, h, d in obstacles:\n                if ox <= px <= ox + w and oy <= py <= oy + h and oz <= pz <= oz + d:\n                    return True\n        else:\n            px, py = pos\n            for ox, oy, w, h in obstacles:\n                if ox <= px <= ox + w and oy <= py <= oy + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = max(1, int(d / max(1e-9, resolution)))\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # Grid hashing for neighbors\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, 3):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # Tree utilities\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if abs(newc - ch.cost) > 1e-9:\n                    ch.cost = newc\n                    stack.append(ch)\n\n    def _compress_to_visible_ancestor(self, node, obstacles, is_3d, edges, grid, lookback=None):\n        if lookback is None:\n            lookback = self.compress_lookback\n        base_p = node.parent\n        if base_p is None:\n            return\n        best_parent = base_p\n        best_cost = base_p.cost + self._dist(base_p.position, node.position)\n        cur = base_p.parent\n        hops = 0\n        while cur is not None and hops < lookback:\n            # BOTH checks (node already valid; ensure edge valid)\n            if not self._is_in_obstacle(node.position, obstacles, is_3d) and \\\n               not self._is_edge_in_obstacle(cur.position, node.position, obstacles, is_3d, self.edge_res):\n                cand_cost = cur.cost + self._dist(cur.position, node.position)\n                if cand_cost + 1e-9 < best_cost:\n                    best_cost = cand_cost\n                    best_parent = cur\n            cur = cur.parent\n            hops += 1\n\n        if best_parent is not base_p:\n            # Rewire parent edge\n            base_p.remove_child(node)\n            for i in range(len(edges)):\n                if edges[i][0] is base_p and edges[i][1] is node:\n                    edges.pop(i)\n                    break\n            best_parent.add_child(node)\n            edges.append((best_parent, node))\n            node.cost = best_parent.cost + self._dist(best_parent.position, node.position)\n            self._propagate_cost(node)\n\n    def _local_rewire(self, new_node, grid, obstacles, is_3d, edges):\n        radius = self.rewire_radius_factor * self.step_size\n        key = self._grid_key(new_node.position)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        near = []\n        r2 = radius * radius\n        for n in cand:\n            if n is new_node or n.parent is None:\n                continue\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - new_node.position[i]\n                s += d * d\n            if s <= r2:\n                near.append((s, n))\n        near.sort(key=lambda x: x[0])\n\n        changed = 0\n        for _, n in near:\n            if changed >= self.rewire_limit:\n                break\n            if self._is_in_obstacle(n.position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.edge_res):\n                continue\n            new_cost = new_node.cost + self._dist(new_node.position, n.position)\n            if new_cost + 1e-9 < n.cost:\n                oldp = n.parent\n                oldp.remove_child(n)\n                for i in range(len(edges)):\n                    if edges[i][0] is oldp and edges[i][1] is n:\n                        edges.pop(i)\n                        break\n                new_node.add_child(n)\n                edges.append((new_node, n))\n                n.cost = new_cost\n                self._propagate_cost(n)\n                changed += 1\n\n    def _connect_toward(self, tree, grid, target, obstacles, is_3d, edges, nodes):\n        # Greedily advance the tree toward 'target'\n        last = None\n        while True:\n            nearest = self._nearest_grid(grid, tree, target)\n            if nearest is None:\n                return last\n            step = self._steer(nearest.position, target, self.step_size)\n            if not self._in_bounds(step):\n                return last\n            if self._is_in_obstacle(step, obstacles, is_3d):\n                return last\n            if self._is_edge_in_obstacle(nearest.position, step, obstacles, is_3d, self.edge_res):\n                return last\n\n            # Insert step node with BOTH checks satisfied\n            node = Node(step, parent=nearest, cost=nearest.cost + self._dist(nearest.position, step))\n            nearest.add_child(node)\n            tree.append(node)\n            nodes.append(node)\n            self._grid_add(grid, node)\n            edges.append((nearest, node))\n\n            # Small compression for connect steps\n            self._compress_to_visible_ancestor(node, obstacles, is_3d, edges, grid, lookback=2)\n\n            last = node\n\n            # If we can directly see the target, stop and return last\n            if not self._is_edge_in_obstacle(node.position, target, obstacles, is_3d, self.edge_res):\n                return last\n\n    # Paths\n    def _collect_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts  # node -> ... -> root\n\n    def _collect_root_to(self, node):\n        pts = self._collect_to_root(node)\n        pts.reverse()\n        return pts  # root -> ... -> node\n\n    # Smoothing\n    def _smooth_path(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return path[:]\n        pts = list(path)\n\n        # Random shortcutting\n        tries = 0\n        while tries < self.shortcut_attempts and len(pts) > 2:\n            n = len(pts)\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            a, b = pts[i], pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n            tries += 1\n\n        # Bounded Laplacian relaxation (keep endpoints)\n        for _ in range(self.relax_iters):\n            changed = False\n            for k in range(1, len(pts) - 1):\n                prevp = pts[k - 1]\n                nextp = pts[k + 1]\n                mid = tuple((prevp[d] + nextp[d]) * 0.5 for d in range(self.dim))\n                cand = tuple(pts[k][d] * (1.0 - self.relax_alpha) + mid[d] * self.relax_alpha for d in range(self.dim))\n                cand = self._clamp(cand)\n                if self._is_in_obstacle(cand, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(prevp, cand, obstacles, is_3d, self.edge_res):\n                    continue\n                if self._is_edge_in_obstacle(cand, nextp, obstacles, is_3d, self.edge_res):\n                    continue\n                if cand != pts[k]:\n                    pts[k] = cand\n                    changed = True\n            if not changed:\n                break\n\n        return pts",
          "objective": -27.96259,
          "time_improvement": 42.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1645.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03130128383636475,
                    "num_nodes_avg": 69.4,
                    "path_length_avg": 184.38976942120655,
                    "smoothness_avg": 0.04906838299292067,
                    "success_improvement": 0.0,
                    "time_improvement": -13.485041927896646,
                    "node_improvement": 82.52329388063461,
                    "length_improvement": -1.0669544626371006,
                    "smoothness_improvement": 668.0267475383287,
                    "objective_score": -1.3455515182596098
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03515186309814453,
                    "num_nodes_avg": 129.2,
                    "path_length_avg": 240.20002554269618,
                    "smoothness_avg": 0.10925730844872428,
                    "success_improvement": 0.0,
                    "time_improvement": 78.75750105537058,
                    "node_improvement": 91.31895451185916,
                    "length_improvement": 19.814317699457394,
                    "smoothness_improvement": 2711.269241244081,
                    "objective_score": 49.07218714250602
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02005038261413574,
                    "num_nodes_avg": 96.7,
                    "path_length_avg": 125.54494350782704,
                    "smoothness_avg": 0.13024333306211655,
                    "success_improvement": 0.0,
                    "time_improvement": 61.35434018882274,
                    "node_improvement": 87.70502225047679,
                    "length_improvement": 16.619026329885873,
                    "smoothness_improvement": 1556.6855829872898,
                    "objective_score": 36.161145769514796
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "FLASH-IBiRRT-C: Fast Heuristic-Accelerated Informed BiRRT-Connect with k-Parent selection, cached collisions, adaptive micro-bridging, and light postprocessing for shorter paths in less time",
          "planning_mechanism": "Alternate growth of start/goal trees using corridor/goal/informed-biased sampling. For each sample: hash-grid nearest, adaptive steer using local obstacle density, strict node+edge checks, then choose a least-cost parent among k local neighbors with LOS. Perform a bounded ancestor leap to relax turns, then attempt a cached-collision micro-bridge to the opposite tree (direct or multi-step). Maintain an incumbent path to focus informed sampling. On success, visibility prune, shortcut, and light elastic smoothing, then return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        pts = []\n        cur = self\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=7.0,\n        goal_bias=0.25,\n        corridor_bias=0.45,\n        informed_bias=0.65,\n        grid_cell_factor=1.35,\n        min_sep_factor=0.45,\n        k_parent_cap=16,\n        ring_max=4,\n        connect_steps=14,\n        micro_trials=2,\n        shortcut_trials=90,\n        smooth_iters=10\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.min_sep_factor = float(min_sep_factor)\n        self.k_parent_cap = int(k_parent_cap)\n        self.ring_max = int(ring_max)\n        self.connect_steps = int(connect_steps)\n        self.micro_trials = int(max(0, micro_trials))\n        self.shortcut_trials = int(max(0, shortcut_trials))\n        self.smooth_iters = int(max(0, smooth_iters))\n\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_rng()\n        self._build_obs_index()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        self._edge_cache = {}\n\n        # Early straight-line\n        if self._segment_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Derived parameters\n        self.cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.4, self.step_size * self.min_sep_factor)\n        self.corridor_w = max(self.step_size, 0.18 * self._dist(self.start, self.goal))\n        self.connect_step = max(0.8 * self.step_size, self.step_size)\n\n        # Trees and grids\n        nodes = []\n        edges = []\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_put(Ga, a_root)\n        self._grid_put(Gb, b_root)\n\n        best_len = float('inf')\n        best_path = None\n\n        for it in range(self.max_iter):\n            grow_a = (it % 2 == 0)\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            attractor = self.goal if grow_a else self.start\n\n            target = self._sample_target(attractor, best_len)\n            if target is None:\n                continue\n\n            near = self._nearest(G, target, T)\n            if near is None:\n                continue\n\n            new_pos = self._steer_adaptive(near.position, target)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._point_blocked(new_pos):\n                continue\n            if self._has_duplicate(G, new_pos, self.min_sep):\n                continue\n\n            parent, new_cost = self._choose_parent_k(G, T, new_pos, near)\n            if parent is None:\n                continue\n\n            # Mandatory checks before insertion\n            if self._point_blocked(new_pos):\n                continue\n            if not self._segment_free(parent.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            T.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_put(G, new_node)\n\n            # Limited ancestor leap to relax heading and reduce length\n            self._limited_ancestor_leap(new_node, edges, max_up=4)\n\n            # Try to connect to the opposite tree\n            connected, end_node = self._connect_toward(new_node, Topp, Gopp, nodes, edges)\n            if connected and end_node is not None:\n                path = self._assemble(new_node, end_node, grow_a)\n                path = self._postprocess(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Maintain incumbent for informed sampling using visible nearest when possible\n            other = self._nearest(Gopp, new_node.position, Topp)\n            if other is not None and self._segment_free(new_node.position, other.position):\n                tmp = self._assemble(new_node, other, grow_a)\n                L = self._path_len(tmp)\n                if L < best_len:\n                    best_len = L\n                    best_path = tmp\n\n        if best_path is not None and len(best_path) >= 2:\n            best_path = self._postprocess(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        base = self.start + self.goal\n        for v in base:\n            s = (s * 2654435761 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 17) * 1103515245\n        self._rng = s if s != 0 else 2463534242\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry and bounds\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    # Steering with clutter-aware step shortening\n    def _steer_adaptive(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        step = self.step_size if d > self.step_size else d\n        dirv = tuple((b[i] - a[i]) / d for i in range(self.dims))\n        trial = tuple(a[i] + dirv[i] * step for i in range(self.dims))\n        dens = self._box_bucket_density(a, trial)\n        if dens > 10 and step > 0.6 * self.step_size:\n            step *= 0.6\n            trial = tuple(a[i] + dirv[i] * step for i in range(self.dims))\n            dens = self._box_bucket_density(a, trial)\n            if dens > 14 and step > 0.4 * self.step_size:\n                step *= 0.6\n                trial = tuple(a[i] + dirv[i] * step for i in range(self.dims))\n        return self._clamp(trial)\n\n    def _steer_fixed(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Sampling\n    def _sample_target(self, attractor, best_len):\n        for _ in range(12):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._sample_informed(best_len * 1.01)\n                if p is not None and not self._point_blocked(p):\n                    return p\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attractor\n            elif r < self.goal_bias + self.corridor_bias:\n                t = self._rand()\n                base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n                if self.dims == 3:\n                    p = (self._rand_range(base[0] - self.corridor_w, base[0] + self.corridor_w),\n                         self._rand_range(base[1] - self.corridor_w, base[1] + self.corridor_w),\n                         self._rand_range(base[2] - self.corridor_w, base[2] + self.corridor_w))\n                else:\n                    p = (self._rand_range(base[0] - self.corridor_w, base[0] + self.corridor_w),\n                         self._rand_range(base[1] - self.corridor_w, base[1] + self.corridor_w))\n            else:\n                if self.dims == 3:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n            p = self._clamp(p)\n            if not self._point_blocked(p):\n                return p\n        return None\n\n    def _sample_informed(self, max_sum):\n        c = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        for _ in range(18):\n            if self.dims == 3:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half),\n                     self._rand_range(c[2] - half, c[2] + half))\n            else:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half))\n            if self._in_bounds(p) and (self._dist(p, self.start) + self._dist(p, self.goal)) <= max_sum:\n                return p\n        return None\n\n    # Node hash grid\n    def _cell_of(self, pos):\n        return tuple(int(pos[i] // self.cell) for i in range(self.dims))\n\n    def _grid_put(self, grid, node):\n        k = self._cell_of(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _ring_nodes(self, grid, key, r):\n        out = []\n        if self.dims == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos, tree):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        for r in range(0, self.ring_max + 1):\n            cand = self._ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback subsampling\n        if not tree:\n            return None\n        step = max(1, len(tree) // 64)\n        for i in range(0, len(tree), step):\n            n = tree[i]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, cap):\n        key = self._cell_of(pos)\n        r = max(1, int(radius // self.cell) + 1)\n        cand = self._ring_nodes(grid, key, r)\n        out = []\n        rr = radius * radius\n        for n in cand:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= rr:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _has_duplicate(self, grid, pos, radius):\n        return len(self._neighbors(grid, pos, radius, self.k_parent_cap)) > 0\n\n    def _choose_parent_k(self, grid, tree, new_pos, fallback_near):\n        # Local radius tuned by tree size for efficiency\n        n = max(1, len(tree))\n        base_r = 2.2 * self.step_size\n        dyn_r = base_r * (1.0 + 0.2 / (1.0 + n ** 0.5))\n        neigh = self._neighbors(grid, new_pos, dyn_r, self.k_parent_cap)\n        if not neigh:\n            neigh = [fallback_near] if fallback_near is not None else []\n        best_p = None\n        best_c = 1e100\n        for p in neigh:\n            d = self._dist(p.position, new_pos)\n            gc = p.cost + d\n            # Edge check inside selection for cost-valid parents\n            if gc + 1e-9 < best_c and self._segment_free(p.position, new_pos):\n                best_c = gc\n                best_p = p\n        if best_p is None:\n            return None, None\n        return best_p, best_c\n\n    # Limited ancestor leap (bounded depth)\n    def _limited_ancestor_leap(self, node, edges, max_up=4):\n        cur = node.parent\n        if cur is None:\n            return\n        bestp = cur\n        bestc = node.cost\n        steps = 0\n        while cur is not None and steps < max_up:\n            anc = cur.parent\n            if anc is None:\n                break\n            if self._segment_free(anc.position, node.position):\n                c = anc.cost + self._dist(anc.position, node.position)\n                if c + 1e-9 < bestc:\n                    bestc = c\n                    bestp = anc\n            cur = anc\n            steps += 1\n        if bestp is not node.parent:\n            self._reparent(node, bestp, edges)\n\n    def _reparent(self, child, new_parent, edges):\n        if child.parent is new_parent:\n            return\n        if not self._segment_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._remove_edge(edges, old, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        # Update costs along subtree\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        stack = [child]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                stack.append(ch)\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is p and e[1] is c:\n                edges.pop(i)\n                return\n\n    # Connect attempt toward opposite tree\n    def _connect_toward(self, u, Topp, Gopp, nodes, edges):\n        other = self._nearest(Gopp, u.position, Topp)\n        if other is None:\n            return False, None\n        # Direct attempt first\n        if self._segment_free(u.position, other.position):\n            return True, other\n        # Micro-bridge by extending opposite tree toward u\n        head = other\n        for _ in range(self.micro_trials):\n            success = False\n            for _s in range(self.connect_steps):\n                step_p = self._steer_fixed(head.position, u.position, self.connect_step)\n                if not self._in_bounds(step_p) or self._point_blocked(step_p):\n                    break\n                if self._has_duplicate(Gopp, step_p, self.min_sep):\n                    break\n                if not self._segment_free(head.position, step_p):\n                    break\n                q = Node(step_p, head, head.cost + self._dist(head.position, step_p))\n                # Safety checks on insertion\n                if self._point_blocked(q.position):\n                    break\n                if not self._segment_free(head.position, q.position):\n                    break\n                head.add_child(q)\n                Topp.append(q)\n                nodes.append(q)\n                edges.append((head, q))\n                self._grid_put(Gopp, q)\n                self._limited_ancestor_leap(q, edges, max_up=3)\n                head = q\n                success = True\n                if self._segment_free(u.position, head.position):\n                    return True, head\n            if not success:\n                break\n        return False, None\n\n    # Obstacles and collision with spatial index and cache\n    def _build_obs_index(self):\n        self.obs_cell = max(4.0, self.step_size * 1.6)\n        self.obs_grid = {}\n        if self.dims == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obs_grid.get(key)\n                            if b is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obs_grid.get(key)\n                        if b is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_blocked(self, p):\n        if self.dims == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _segment_free(self, a, b):\n        k = self._edge_key(a, b)\n        cached = self._edge_cache.get(k)\n        if cached is not None:\n            return not cached\n        hit = self._segment_hits(a, b)\n        self._edge_cache[k] = hit\n        return not hit\n\n    def _segment_hits(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obs_grid.get((i, j, k))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit3d(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obs_grid.get((i, j))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit2d(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit2d(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _seg_box_hit3d(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Path utilities\n    def _assemble(self, u, v, a_side):\n        pu = u.path_from_root()\n        pv = v.path_from_root()\n        if a_side:\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _postprocess(self, path):\n        if len(path) < 2:\n            return path[:]\n        p = self._visibility_prune(path)\n        p = self._shortcut(p, self.shortcut_trials)\n        p = self._elastic_smooth(p, self.smooth_iters)\n        return p\n\n    def _visibility_prune(self, path):\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._segment_free(out[-1], path[j]):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i + 1])\n                i += 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = list(path)\n        n = len(pts)\n        best = self._path_len(pts)\n        fails = 0\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            a = pts[i]\n            b = pts[j - 1]\n            if self._segment_free(a, b):\n                cand = pts[:i + 1] + pts[j - 1:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    pts = cand\n                    best = L\n                    n = len(pts)\n                    fails = 0\n                else:\n                    fails += 1\n            else:\n                fails += 1\n            if fails > 48:\n                break\n        return pts\n\n    def _elastic_smooth(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return path[:]\n        pts = list(path)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(pts) - 1):\n                a, b, c = pts[i - 1], pts[i], pts[i + 1]\n                mid = tuple(0.25 * a[k] + 0.5 * b[k] + 0.25 * c[k] for k in range(self.dims))\n                if self._point_blocked(mid):\n                    continue\n                if self._segment_free(a, mid) and self._segment_free(mid, c):\n                    if mid != b:\n                        pts[i] = mid\n                        moved = True\n                if self._segment_free(a, c):\n                    pts[i] = c\n                    moved = True\n            comp = [pts[0]]\n            for p in pts[1:]:\n                if p != comp[-1]:\n                    comp.append(p)\n            pts = comp\n            if not moved or len(pts) < 3:\n                break\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        return pts\n\n    # Obstacle density along a-b AABB\n    def _box_bucket_density(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            s = 0\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obs_grid.get((i, j, k))\n                        if bkt:\n                            s += len(bkt)\n            return s\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            s = 0\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obs_grid.get((i, j))\n                    if bkt:\n                        s += len(bkt)\n            return s",
          "objective": -27.86338,
          "time_improvement": 25.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 2370.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0424515962600708,
                    "num_nodes_avg": 143.0,
                    "path_length_avg": 162.35311614705023,
                    "smoothness_avg": 0.06623267526845242,
                    "success_improvement": 0.0,
                    "time_improvement": -53.911296631332725,
                    "node_improvement": 63.988919667590025,
                    "length_improvement": 11.011684390045003,
                    "smoothness_improvement": 936.6851945076496,
                    "objective_score": -4.882952382834568
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06204507350921631,
                    "num_nodes_avg": 151.0,
                    "path_length_avg": 245.7376738196909,
                    "smoothness_avg": 0.1923320380130888,
                    "success_improvement": 0.0,
                    "time_improvement": 62.505759513823556,
                    "node_improvement": 89.85419606262178,
                    "length_improvement": 17.965691312228653,
                    "smoothness_improvement": 4848.841869244284,
                    "objective_score": 53.775351987705676
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01795949935913086,
                    "num_nodes_avg": 73.0,
                    "path_length_avg": 129.31952666159532,
                    "smoothness_avg": 0.11187409278711753,
                    "success_improvement": 0.0,
                    "time_improvement": 65.38436617550083,
                    "node_improvement": 90.71837253655436,
                    "length_improvement": 14.112127925487872,
                    "smoothness_improvement": 1323.0302025655794,
                    "objective_score": 34.697737620770866
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SIMBA-Connect: Simple Informed Minimal-Bias Bidirectional RRT-Connect with One-Hop Compression and Visibility Smoothing. It alternates growth between start and goal trees using a light grid for nearest lookup, mixes goal and uniform sampling with informed ellipsoid focus once a bound exists, and performs strict node and edge collision checks before insertion. Each accepted node attempts a one-hop visible-ancestor compression to shorten chains. A capped RRT-Connect-style greedy extension tries to meet the opposite tree. On success, the path is shortcut and visibility-collapsed for shorter, smoother results, emphasizing robustness and generalization with few parameters.",
          "planning_mechanism": "Initialize two trees at start and goal; per iteration sample (goal-biased, informed if c_best known, else uniform), pick nearest, steer one step, and if both node and edge are collision-free and not a near-duplicate, add the node and apply one-hop compression. Try a bounded greedy connect from the other tree toward the new node; if a direct bridge becomes free, merge paths and run shortcut+visibility smoothing, then return. A simple hash grid accelerates neighbor queries; all sampling stays within bounds and respects 2D/3D boxes.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        for c in self.children:\n            if c is child:\n                child.parent = self\n                return\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        i = -1\n        for k in range(len(self.children)):\n            if self.children[k] is child:\n                i = k\n                break\n        if i >= 0:\n            self.children.pop(i)\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=6.0,\n                 goal_bias=0.2,\n                 connect_steps=10,\n                 collision_step=1.0,\n                 dupe_radius_ratio=0.4,\n                 smoothing_iters=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.connect_steps = max(1, int(connect_steps))\n        self.collision_step = max(0.25, collision_step)\n        self.dupe_radius_ratio = max(0.1, dupe_radius_ratio)\n        self.smoothing_iters = max(0, int(smoothing_iters))\n\n        self.dim = 2\n        self.bounds = None\n        self.grid_cell = 1.0\n        self.edge_res = 1.0\n\n        # RNG state\n        self._rng = 2463534242 & 0xFFFFFFFF\n\n    def plan(self, map) -> PlannerResult:\n        # Setup environment\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = self._as_tuple(map.start)\n        goal = self._as_tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Parameterize\n        self.grid_cell = self._max(1.0, self.step_size * 0.9)\n        self.edge_res = self._max(0.5, self._min(self.collision_step, self.step_size * 0.4))\n\n        # Validate endpoints\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight line\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_res):\n            n0 = Node(start, None, 0.0)\n            n1 = Node(goal, n0, self._dist(start, goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [start, goal], [n0, n1], [(n0, n1)])\n\n        # Initialize trees and grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start, grid_goal = {}, {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Informed sampling state\n        dsg = self._dist(start, goal)\n        c_best = 1e100\n        basis = self._basis_for_informed(start, goal)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = goal if active_start else start\n\n            # Sample\n            s = self._rand()\n            if s < self.goal_bias:\n                sample = root_other\n            else:\n                sample = None\n                if c_best < 1e90:\n                    sample = self._sample_informed(c_best, dsg, basis, obstacles, is_3d)\n                if sample is None:\n                    sample = self._sample_free(obstacles, is_3d)\n\n            near = self._nearest_grid(grid_a, tree_a, sample)\n            if near is None:\n                continue\n\n            new_pos = self._steer(near.position, sample, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            # Duplicate suppression\n            if self._exists_close(grid_a, new_pos, self.step_size * self.dupe_radius_ratio):\n                continue\n            # Edge safety (both checks enforced: node free above, edge free here)\n            if self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d, self.edge_res):\n                continue\n\n            # Insert node\n            new_cost = near.cost + self._dist(near.position, new_pos)\n            new_node = Node(new_pos, near, new_cost)\n            near.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((near, new_node))\n            self._grid_add(grid_a, new_node)\n\n            # One-hop visible-ancestor compression\n            self._one_hop_compress(new_node, obstacles, is_3d, edges)\n\n            # Try immediate direct bridge\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None and not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                path = self._merge_paths(new_node, other_near)\n                c_best = self._path_length(path)\n                path = self._smooth(path, obstacles, is_3d)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Greedy bounded connect from other tree toward new_node\n            meet_b = self._connect_toward(tree_b, grid_b, new_node.position, obstacles, is_3d, edges)\n            if meet_b is not None:\n                if not self._is_edge_in_obstacle(new_node.position, meet_b.position, obstacles, is_3d, self.edge_res):\n                    path = self._merge_paths(new_node, meet_b)\n                    c_best = self._path_length(path)\n                    path = self._smooth(path, obstacles, is_3d)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        # Failure\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # RNG: xorshift32\n    def _rand(self):\n        x = self._rng\n        x ^= (x << 13) & 0xFFFFFFFF\n        x ^= (x >> 17) & 0xFFFFFFFF\n        x ^= (x << 5) & 0xFFFFFFFF\n        self._rng = x & 0xFFFFFFFF\n        return (self._rng % 1000000) / 1000000.0\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry helpers\n    def _as_tuple(self, p):\n        if isinstance(p, tuple):\n            return p\n        return tuple(p[i] for i in range(len(p)))\n\n    def _abs(self, v):\n        return -v if v < 0.0 else v\n\n    def _min(self, a, b):\n        return a if a < b else b\n\n    def _max(self, a, b):\n        return a if a > b else b\n\n    def _sqrt(self, v):\n        if v <= 0.0:\n            return 0.0\n        x = v\n        for _ in range(10):\n            x = 0.5 * (x + v / x)\n        return x\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return self._sqrt(s)\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_pt(self, p):\n        return tuple(self._min(self._max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp_pt(to_pos)\n        r = step / d\n        return self._clamp_pt(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision checks\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / (resolution if resolution > 1e-9 else 1e-9))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Hash grid\n    def _grid_key(self, pos):\n        if self.dim == 2:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell))\n        else:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell), int(pos[2] // self.grid_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        return out\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 3):\n            cand = self._grid_collect_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback linear\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_collect_ring(grid, key, cells)\n        r2 = radius * radius\n        for n in cand:\n            dd = 0.0\n            for i in range(self.dim):\n                di = n.position[i] - pos[i]\n                dd += di * di\n            if dd <= r2:\n                return True\n        return False\n\n    # Informed sampling\n    def _basis_for_informed(self, start, goal):\n        c = tuple((start[i] + goal[i]) * 0.5 for i in range(self.dim))\n        v = tuple(goal[i] - start[i] for i in range(self.dim))\n        nv = self._dist(start, goal)\n        if nv == 0.0:\n            if self.dim == 2:\n                return (c, (1.0, 0.0), (0.0, 1.0), None)\n            else:\n                return (c, (1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0))\n        e1 = tuple(v[i] / nv for i in range(self.dim))\n        if self.dim == 2:\n            e2 = (-e1[1], e1[0])\n            return (c, e1, e2, None)\n        else:\n            # Simple orthonormal completion\n            ref = (1.0, 0.0, 0.0) if self._abs(e1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            u = (e1[1]*ref[2] - e1[2]*ref[1],\n                 e1[2]*ref[0] - e1[0]*ref[2],\n                 e1[0]*ref[1] - e1[1]*ref[0])\n            nu = self._sqrt(u[0]*u[0] + u[1]*u[1] + u[2]*u[2])\n            if nu == 0.0:\n                u = (0.0, 1.0, 0.0)\n                nu = 1.0\n            e2 = (u[0]/nu, u[1]/nu, u[2]/nu)\n            e3 = (e1[1]*e2[2] - e1[2]*e2[1],\n                  e1[2]*e2[0] - e1[0]*e2[2],\n                  e1[0]*e2[1] - e1[1]*e2[0])\n            return (c, e1, e2, e3)\n\n    def _sample_informed(self, c_best, dsg, basis, obstacles, is_3d):\n        if not (c_best < 1e90) or c_best <= dsg:\n            return None\n        c, e1, e2, e3 = basis\n        a = 0.5 * c_best\n        f = 0.5 * dsg\n        b2 = a * a - f * f\n        if b2 <= 0.0:\n            return None\n        b = self._sqrt(b2)\n        for _ in range(12):\n            if self.dim == 2:\n                rx = self._uniform(-1.0, 1.0)\n                ry = self._uniform(-1.0, 1.0)\n                if rx*rx + ry*ry > 1.0:\n                    continue\n                px = a * rx\n                py = b * ry\n                x = c[0] + px * e1[0] + py * e2[0]\n                y = c[1] + px * e1[1] + py * e2[1]\n                p = (self._min(self._max(x, 0.0), self.bounds[0]),\n                     self._min(self._max(y, 0.0), self.bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            else:\n                rx = self._uniform(-1.0, 1.0)\n                ry = self._uniform(-1.0, 1.0)\n                rz = self._uniform(-1.0, 1.0)\n                if rx*rx + ry*ry + rz*rz > 1.0:\n                    continue\n                px = a * rx\n                py = b * ry\n                pz = b * rz\n                x = c[0] + px * e1[0] + py * e2[0] + pz * e3[0]\n                y = c[1] + px * e1[1] + py * e2[1] + pz * e3[1]\n                z = c[2] + px * e1[2] + py * e2[2] + pz * e3[2]\n                p = (self._min(self._max(x, 0.0), self.bounds[0]),\n                     self._min(self._max(y, 0.0), self.bounds[1]),\n                     self._min(self._max(z, 0.0), self.bounds[2]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n        return None\n\n    # Structural helpers\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is parent and e[1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                nc = cur.cost + self._dist(cur.position, ch.position)\n                if self._abs(nc - ch.cost) > 1e-9:\n                    ch.cost = nc\n                    stack.append(ch)\n\n    def _one_hop_compress(self, node, obstacles, is_3d, edges):\n        p = node.parent\n        if p is None:\n            return\n        g = p.parent\n        if g is None:\n            return\n        if not self._is_edge_in_obstacle(g.position, node.position, obstacles, is_3d, self.edge_res):\n            cand_cost = g.cost + self._dist(g.position, node.position)\n            if cand_cost + 1e-9 < node.cost:\n                p.remove_child(node)\n                self._edges_remove(edges, p, node)\n                g.add_child(node)\n                node.cost = cand_cost\n                edges.append((g, node))\n                self._propagate_cost(node)\n\n    # Connect routine (keeps created nodes)\n    def _connect_toward(self, tree, grid, target_pos, obstacles, is_3d, edges):\n        cur = self._nearest_grid(grid, tree, target_pos)\n        steps = 0\n        last = cur\n        while last is not None and steps < self.connect_steps:\n            to = self._steer(last.position, target_pos, self.step_size)\n            if not self._in_bounds(to):\n                break\n            if self._is_in_obstacle(to, obstacles, is_3d):\n                break\n            if self._exists_close(grid, to, self.step_size * self.dupe_radius_ratio):\n                break\n            if self._is_edge_in_obstacle(last.position, to, obstacles, is_3d, self.edge_res):\n                break\n            nxt = Node(to, last, last.cost + self._dist(last.position, to))\n            last.add_child(nxt)\n            tree.append(nxt)\n            edges.append((last, nxt))\n            self._grid_add(grid, nxt)\n            # try to compress one hop on the connect side too\n            self._one_hop_compress(nxt, obstacles, is_3d, edges)\n            last = nxt\n            steps += 1\n            # check direct bridge possibility outside (caller also checks), but return last for bridge test\n            if self._dist(last.position, target_pos) <= self.step_size + 1e-6:\n                return last\n        return last if last is not cur else None\n\n    # Path utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_paths(self, meet_a, meet_b):\n        pa = self._path_to_root(meet_a)\n        pb = []\n        cur = meet_b\n        while cur is not None:\n            pb.append(cur.position)\n            cur = cur.parent\n        return pa + pb\n\n    def _path_length(self, path):\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    # Smoothing: random shortcuts + bidirectional visibility collapse\n    def _smooth(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n\n        # Random shortcuts\n        iters = self.smoothing_iters\n        k = 0\n        while k < iters and len(pts) >= 3:\n            n = len(pts)\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                k += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n            k += 1\n\n        # Forward visibility collapse\n        collapsed = [pts[0]]\n        anchor = pts[0]\n        idx = 1\n        while idx < len(pts) - 1:\n            nxt = pts[idx + 1]\n            if self._is_edge_in_obstacle(anchor, nxt, obstacles, is_3d, self.edge_res):\n                collapsed.append(pts[idx])\n                anchor = pts[idx]\n            idx += 1\n        collapsed.append(pts[-1])\n        pts = collapsed\n\n        # Backward visibility collapse\n        collapsed = [pts[-1]]\n        anchor = pts[-1]\n        idx = len(pts) - 2\n        while idx > 0:\n            prv = pts[idx - 1]\n            if self._is_edge_in_obstacle(prv, anchor, obstacles, is_3d, self.edge_res):\n                collapsed.append(pts[idx])\n                anchor = pts[idx]\n            idx -= 1\n        collapsed.append(pts[0])\n        collapsed.reverse()\n        return collapsed\n\n    # Sampling free space\n    def _sample_free(self, obstacles, is_3d):\n        for _ in range(200):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # fallback center\n        if self.dim == 3:\n            return (self.bounds[0]*0.5, self.bounds[1]*0.5, self.bounds[2]*0.5)\n        else:\n            return (self.bounds[0]*0.5, self.bounds[1]*0.5)",
          "objective": -26.73508,
          "time_improvement": 31.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1768.0,
          "node_improvement": 83.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02016465663909912,
                    "num_nodes_avg": 64.1,
                    "path_length_avg": 171.45724667303594,
                    "smoothness_avg": 0.04589629178687834,
                    "success_improvement": 0.0,
                    "time_improvement": 26.891596008875695,
                    "node_improvement": 83.85797028456308,
                    "length_improvement": 6.021566184572161,
                    "smoothness_improvement": 618.376631857461,
                    "objective_score": 14.77230167269331
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0470217227935791,
                    "num_nodes_avg": 152.6,
                    "path_length_avg": 239.0705889035882,
                    "smoothness_avg": 0.12077277225264674,
                    "success_improvement": 0.0,
                    "time_improvement": 71.58446782668581,
                    "node_improvement": 89.7466908553383,
                    "length_improvement": 20.191356158622785,
                    "smoothness_improvement": 3007.570419172328,
                    "objective_score": 48.62800613904105
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05426342487335205,
                    "num_nodes_avg": 204.2,
                    "path_length_avg": 126.00273947913608,
                    "smoothness_avg": 0.13982150949955016,
                    "success_improvement": 0.0,
                    "time_improvement": -4.5888199842379604,
                    "node_improvement": 74.03687221869039,
                    "length_improvement": 16.31498004364398,
                    "smoothness_improvement": 1678.5192802840022,
                    "objective_score": 16.80493843233501
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Balanced Informed BiRRT*-Lite (BIB-Lite): a simplified, robust bidirectional planner that couples light g+h beam guidance, informed-ellipsoid sampling once a path bound is known, shallow ancestor line-of-sight compression, and capped neighbor rewiring. It uses a grid hash to accelerate nearest/duplicate queries, avoids rollback-heavy connects by attempting only direct bridges, and finishes with shortcutting plus safe Laplacian relaxation for smooth, short paths.",
          "planning_mechanism": "Alternate expanding the start/goal trees. For each side, draw a small beam of samples from goal-bias, informed ellipsoid (if c_best exists), or uniform free space; score candidates by g + w\u00b7h, insert the best after node/edge checks, compress to a visible ancestor, and locally rewire cheaper neighbors. Attempt a direct LOS bridge to the opposite tree; on success, extract and smooth the path and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=7.5,\n        goal_bias=0.15,\n        beam_k=3,\n        heuristic_weight=0.7,\n        rewire_radius_factor=1.6,\n        rewire_limit=6,\n        dupe_radius_ratio=0.5,\n        min_sep_ratio=0.28,\n        collision_step=1.0,\n        shortcut_attempts=60,\n        relax_iters=25,\n        relax_alpha=0.5\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.beam_k = beam_k\n        self.heuristic_weight = heuristic_weight\n        self.rewire_radius_factor = rewire_radius_factor\n        self.rewire_limit = rewire_limit\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.min_sep_ratio = min_sep_ratio\n        self.collision_step = collision_step\n        self.shortcut_attempts = shortcut_attempts\n        self.relax_iters = relax_iters\n        self.relax_alpha = relax_alpha\n\n        self.bounds = None\n        self.dim = 2\n        self.edge_res = 1.0\n        self.grid_cell = 1.0\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.edge_res = max(0.6, min(self.collision_step, max(0.4, self.step_size * 0.45)))\n        self.grid_cell = max(1.0, self.step_size * 0.8)\n\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early LOS check\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_res):\n            nodes = [Node(start), Node(goal)]\n            return PlannerResult(True, [start, goal], nodes, [])\n\n        # Initialize trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        edges = []\n        nodes = [start_root, goal_root]\n\n        grid_a = {}\n        grid_b = {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n\n        # Informed sampling params\n        dsg = self._dist(start, goal)\n        c_best = float('inf')\n        basis = self._compute_basis(start, goal)\n\n        # RNG state\n        self._rng_s = 2463534242\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            grow_tree = tree_a if active_start else tree_b\n            other_tree = tree_b if active_start else tree_a\n            grow_grid = grid_a if active_start else grid_b\n            other_grid = grid_b if active_start else grid_a\n            attractor = goal if active_start else start\n\n            # Beam candidate selection with g+h scoring\n            best_pair = None\n            best_score = float('inf')\n            for _ in range(self.beam_k):\n                x_rand = None\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = attractor\n                else:\n                    if c_best < float('inf') and self._rand() < 0.7:\n                        xr = self._sample_informed(c_best, dsg, basis, obstacles, is_3d)\n                        if xr is not None:\n                            x_rand = xr\n                    if x_rand is None:\n                        x_rand = self._sample_free(obstacles, is_3d)\n\n                nearest = self._nearest_grid(grow_grid, grow_tree, x_rand)\n                if nearest is None:\n                    continue\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._dist(nearest.position, new_pos) < self.step_size * self.min_sep_ratio:\n                    continue\n                if self._exists_close(grow_grid, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                    continue\n\n                g = nearest.cost + self._dist(nearest.position, new_pos)\n                other_near = self._nearest_grid(other_grid, other_tree, new_pos)\n                if other_near is not None:\n                    h = self._dist(new_pos, other_near.position)\n                else:\n                    h = self._dist(new_pos, attractor)\n                score = g + self.heuristic_weight * h\n\n                # Favor immediate bridge potential\n                if other_near is not None and not self._is_edge_in_obstacle(new_pos, other_near.position, obstacles, is_3d, self.edge_res):\n                    score *= 0.35\n\n                if score < best_score:\n                    best_score = score\n                    best_pair = (nearest, new_pos)\n\n            if best_pair is None:\n                continue\n\n            parent, pos = best_pair\n\n            # Final checks before insertion (both node and edge already checked above)\n            new_cost = parent.cost + self._dist(parent.position, pos)\n            new_node = Node(pos, parent=parent, cost=new_cost)\n            parent.add_child(new_node)\n            grow_tree.append(new_node)\n            nodes.append(new_node)\n            self._edges_add(edges, parent, new_node)\n            self._grid_add(grow_grid, new_node)\n\n            # Shallow ancestor LOS compression\n            self._compress_to_visible_ancestor(new_node, obstacles, is_3d, edges)\n\n            # Local rewiring (bounded)\n            self._local_rewire(new_node, grow_grid, obstacles, is_3d, edges)\n\n            # Attempt direct bridge to opposite tree\n            other_near = self._nearest_grid(other_grid, other_tree, new_node.position)\n            if other_near is not None:\n                if not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                    # Build path without mutating structures further\n                    if active_start:\n                        path_a = self._collect_root_to(new_node)\n                        path_b = self._collect_to_root(other_near)\n                    else:\n                        path_a = self._collect_root_to(other_near)\n                        path_b = self._collect_to_root(new_node)\n                    raw_path = path_a + path_b\n                    c_best = self._path_length(raw_path)\n                    # Smoothing\n                    smooth = self._smooth_path(raw_path, obstacles, is_3d)\n                    return PlannerResult(True, smooth, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG utilities\n    def _rand(self):\n        # xorshift32\n        x = self._rng_s & 0xFFFFFFFF\n        x ^= (x << 13) & 0xFFFFFFFF\n        x ^= (x >> 17) & 0xFFFFFFFF\n        x ^= (x << 5) & 0xFFFFFFFF\n        self._rng_s = x & 0xFFFFFFFF\n        return (self._rng_s % 1000003) / 1000003.0\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / (d if d > 1e-12 else 1.0)\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = max(1, int(d / max(1e-9, resolution)))\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _compute_basis(self, start, goal):\n        # center and orthonormal basis (e1 along start->goal)\n        c = tuple((start[i] + goal[i]) * 0.5 for i in range(self.dim))\n        v = tuple(goal[i] - start[i] for i in range(self.dim))\n        nv = self._norm(v)\n        if nv < 1e-12:\n            if self.dim == 3:\n                return (c, (1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0))\n            else:\n                return (c, (1.0, 0.0), (0.0, 1.0), None)\n        e1 = self._scale(v, 1.0 / nv)\n        if self.dim == 2:\n            e2 = (-e1[1], e1[0])\n            return (c, e1, e2, None)\n        else:\n            ref = (1.0, 0.0, 0.0) if abs(e1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            u = self._cross(e1, ref)\n            nu = self._norm(u)\n            if nu < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                u = self._cross(e1, ref)\n                nu = self._norm(u)\n                if nu < 1e-12:\n                    u = (0.0, 1.0, 0.0)\n                    nu = 1.0\n            e2 = self._scale(u, 1.0 / nu)\n            e3 = self._cross(e1, e2)\n            return (c, e1, e2, e3)\n\n    def _sample_informed(self, c_best, dsg, basis, obstacles, is_3d):\n        if not (c_best < float('inf')) or c_best <= dsg + 1e-9:\n            return None\n        c, e1, e2, e3 = basis\n        a = c_best * 0.5\n        f = dsg * 0.5\n        b_sq = a * a - f * f\n        if b_sq <= 0.0:\n            return None\n        b = b_sq ** 0.5\n        for _ in range(10):\n            if self.dim == 2:\n                rx = self._uniform(-1.0, 1.0)\n                ry = self._uniform(-1.0, 1.0)\n                if rx * rx + ry * ry > 1.0:\n                    continue\n                px = a * rx\n                py = b * ry\n                x = c[0] + px * e1[0] + py * e2[0]\n                y = c[1] + px * e1[1] + py * e2[1]\n                p = (self._clamp_val(x, 0.0, self.bounds[0]),\n                     self._clamp_val(y, 0.0, self.bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            else:\n                rx = self._uniform(-1.0, 1.0)\n                ry = self._uniform(-1.0, 1.0)\n                rz = self._uniform(-1.0, 1.0)\n                if rx * rx + ry * ry + rz * rz > 1.0:\n                    continue\n                px = a * rx\n                py = b * ry\n                pz = b * rz\n                x = c[0] + px * e1[0] + py * e2[0] + pz * e3[0]\n                y = c[1] + px * e1[1] + py * e2[1] + pz * e3[1]\n                z = c[2] + px * e1[2] + py * e2[2] + pz * e3[2]\n                p = (self._clamp_val(x, 0.0, self.bounds[0]),\n                     self._clamp_val(y, 0.0, self.bounds[1]),\n                     self._clamp_val(z, 0.0, self.bounds[2]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n        return None\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    def _norm(self, v):\n        s = 0.0\n        for i in range(len(v)):\n            s += v[i] * v[i]\n        return s ** 0.5\n\n    def _scale(self, v, k):\n        return tuple(v[i] * k for i in range(len(v)))\n\n    def _cross(self, a, b):\n        return (a[1]*b[2] - a[2]*b[1],\n                a[2]*b[0] - a[0]*b[2],\n                a[0]*b[1] - a[1]*b[0])\n\n    # Grid hashing\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # Edges bookkeeping\n    def _edges_add(self, edges, parent, child):\n        edges.append((parent, child))\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # Compression and rewiring\n    def _compress_to_visible_ancestor(self, node, obstacles, is_3d, edges, lookback=6):\n        base_parent = node.parent\n        if base_parent is None:\n            return\n        best_parent = base_parent\n        best_cost = base_parent.cost + self._dist(base_parent.position, node.position)\n\n        cur = base_parent.parent\n        hops = 0\n        while cur is not None and hops < lookback:\n            if not self._is_edge_in_obstacle(cur.position, node.position, obstacles, is_3d, self.edge_res):\n                cand_cost = cur.cost + self._dist(cur.position, node.position)\n                if cand_cost + 1e-9 < best_cost:\n                    best_cost = cand_cost\n                    best_parent = cur\n            cur = cur.parent\n            hops += 1\n\n        if best_parent is not base_parent:\n            base_parent.remove_child(node)\n            self._edges_remove(edges, base_parent, node)\n            best_parent.add_child(node)\n            self._edges_add(edges, best_parent, node)\n            node.cost = best_parent.cost + self._dist(best_parent.position, node.position)\n            self._propagate_cost(node)\n\n    def _local_rewire(self, new_node, grid, obstacles, is_3d, edges):\n        radius = self.rewire_radius_factor * self.step_size\n        key = self._grid_key(new_node.position)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        near = []\n        for n in cand:\n            if n is new_node or n.parent is None:\n                continue\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - new_node.position[i]\n                s += d * d\n            if s <= r2:\n                near.append((s, n))\n        near.sort(key=lambda x: x[0])\n        count = 0\n        for _, n in near:\n            if count >= self.rewire_limit:\n                break\n            if not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.edge_res):\n                new_cost = new_node.cost + self._dist(new_node.position, n.position)\n                if new_cost + 1e-9 < n.cost:\n                    oldp = n.parent\n                    oldp.remove_child(n)\n                    self._edges_remove(edges, oldp, n)\n                    new_node.add_child(n)\n                    self._edges_add(edges, new_node, n)\n                    n.cost = new_cost\n                    self._propagate_cost(n)\n                    count += 1\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if abs(newc - ch.cost) > 1e-9:\n                    ch.cost = newc\n                    stack.append(ch)\n\n    # Paths\n    def _collect_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts  # node -> ... -> root\n\n    def _collect_root_to(self, node):\n        pts = self._collect_to_root(node)\n        pts.reverse()\n        return pts  # root -> ... -> node\n\n    # Smoothing\n    def _smooth_path(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return path[:]\n        pts = list(path)\n\n        # Random shortcuts\n        tries = 0\n        while tries < self.shortcut_attempts and len(pts) > 2:\n            n = len(pts)\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n            tries += 1\n\n        # Laplacian relaxation with collision safety\n        for _ in range(self.relax_iters):\n            changed = False\n            for k in range(1, len(pts) - 1):\n                prevp = pts[k - 1]\n                nextp = pts[k + 1]\n                mid = tuple((prevp[d] + nextp[d]) * 0.5 for d in range(self.dim))\n                cand = tuple(pts[k][d] * (1.0 - self.relax_alpha) + mid[d] * self.relax_alpha for d in range(self.dim))\n                # keep inside bounds\n                cand = self._clamp(cand)\n                # node collision and both edges collision-free\n                if self._is_in_obstacle(cand, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(prevp, cand, obstacles, is_3d, self.edge_res):\n                    continue\n                if self._is_edge_in_obstacle(cand, nextp, obstacles, is_3d, self.edge_res):\n                    continue\n                if self._dist(prevp, cand) < 1e-9 or self._dist(cand, nextp) < 1e-9:\n                    continue\n                if cand != pts[k]:\n                    pts[k] = cand\n                    changed = True\n            if not changed:\n                break\n\n        return pts",
          "objective": -26.53885,
          "time_improvement": 26.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1613.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02773728370666504,
                    "num_nodes_avg": 50.0,
                    "path_length_avg": 148.14139939109947,
                    "smoothness_avg": 0.038889716104644936,
                    "success_improvement": 0.0,
                    "time_improvement": -0.5635047071098136,
                    "node_improvement": 87.40871317048602,
                    "length_improvement": 18.80135154304476,
                    "smoothness_improvement": 508.7085074078895,
                    "objective_score": 13.65530205073336
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05453083515167236,
                    "num_nodes_avg": 136.0,
                    "path_length_avg": 233.57329972447172,
                    "smoothness_avg": 0.12064490526046863,
                    "success_improvement": 0.0,
                    "time_improvement": 67.04666250761811,
                    "node_improvement": 90.86205738090439,
                    "length_improvement": 22.026509517307545,
                    "smoothness_improvement": 3004.2803093647135,
                    "objective_score": 48.35130600949353
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0451768159866333,
                    "num_nodes_avg": 142.0,
                    "path_length_avg": 132.75101670047405,
                    "smoothness_avg": 0.11214834129410785,
                    "success_improvement": 0.0,
                    "time_improvement": 12.92496030770433,
                    "node_improvement": 81.94532739987285,
                    "length_improvement": 11.833095631661012,
                    "smoothness_improvement": 1326.518623331577,
                    "objective_score": 17.609938587965793
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "HB-EdgeSieve BiRRT (HB-ESBiRRT): A heuristic-biased, bidirectional RRT that uses an obstacle grid with slab-based segment checks, quantized edge-collision caching, and cost-gated sparse hashing to minimize planning time while preserving robustness and path quality. It grows two trees toward each other with a single, high-yield sample per side, selects a cheap line-of-sight ancestor over a short lookback, and attempts direct bridging to the other tree. After the first solution, informed ellipse sampling narrows exploration and a cache-reusing greedy shortcutting finalizes the path.",
          "planning_mechanism": "Mechanism: Each iteration alternates trees. A guided sample (goal-biased or ellipse-informed) is steered from the nearest grid-bucket node. Before inserting, both node and edge are collision-checked. Edge checks use a memoized cache and fast slab intersections against only nearby obstacles fetched from an obstacle spatial grid. Parent compression considers a few visible ancestors to cut depth and cost. On each insertion, the planner tries a zero-step line-of-sight connect to the other tree's nearest node. A per-cell cap with cost admission curbs local redundancy. If a path appears, shortcutting reuses the same cached edge tests to converge quickly.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        goal_bias=0.35,\n        beam_width=1,\n        lookback_depth=4,\n        grid_cell_factor=1.5,\n        per_cell_cap=10,\n        min_separation_factor=0.6,\n        edge_cache_capacity=30000,\n        edge_cache_quant_factor=0.6,\n        shortcut_attempts=60,\n        no_improve_stop=10\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.beam_width = beam_width\n        self.lookback_depth = lookback_depth\n        self.grid_cell_factor = grid_cell_factor\n        self.per_cell_cap = per_cell_cap\n        self.min_separation_factor = min_separation_factor\n        self.edge_cache_capacity = edge_cache_capacity\n        self.edge_cache_quant_factor = edge_cache_quant_factor\n        self.shortcut_attempts = shortcut_attempts\n        self.no_improve_stop = no_improve_stop\n\n        # PRNG state\n        self._rnd_state = 1234567\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        # Early exit if trivial\n        if self._dist(self.start, self.goal) <= 1e-9:\n            path = [self.start, self.goal]\n            return PlannerResult(True, path, [], [])\n\n        # Initialize parameters\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n\n        # Initialize PRNG with scene-dependent seed\n        self._seed_from_scene()\n\n        # Edge collision cache (LRU-ish via ticks)\n        self._tick = 0\n        self._last_prune_size = 0\n        self.ecache = {}\n        self.ecache_quant = max(0.25, self.step_size * self.edge_cache_quant_factor)\n\n        # Build obstacle spatial grid for fast queries\n        self._build_obstacle_grid()\n\n        nodes = []\n        edges = []\n\n        # Validate start/goal points\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        start_root = Node(self.start, parent=None, cost=0.0)\n        goal_root = Node(self.goal, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        best_path = None\n        incumbent_len = None\n\n        for _ in range(self.max_iter):\n            # Alternate growth between the two trees\n            for active_tree, active_grid, other_tree, other_grid, attractor in [\n                (tree_a, grid_a, tree_b, grid_b, self.goal),\n                (tree_b, grid_b, tree_a, grid_a, self.start)\n            ]:\n                progressed = False\n                for _b in range(self.beam_width):\n                    sample = self._sample(attractor, incumbent_len)\n                    if sample is None:\n                        continue\n\n                    nearest = self._nearest_in_grid(active_grid, sample)\n                    if nearest is None:\n                        continue\n\n                    new_pos = self._steer(nearest.position, sample)\n                    if not self._within_bounds(new_pos):\n                        continue\n                    # Node collision check\n                    if self._point_in_obstacles(new_pos):\n                        continue\n                    # Edge collision check to nearest\n                    if not self._edge_free(nearest.position, new_pos):\n                        continue\n                    # Suppress near-duplicates\n                    if self._has_nearby(active_grid, new_pos, self.min_separation):\n                        continue\n\n                    # Limited lookback LOS parent selection\n                    parent = self._best_parent_los(nearest, new_pos)\n                    new_cost = parent.cost + self._dist(parent.position, new_pos)\n\n                    # Per-cell cap with cost admission\n                    cell_key = self._cell_of(new_pos)\n                    bucket = active_grid.get(cell_key)\n                    if bucket and len(bucket) >= self.per_cell_cap:\n                        best_bucket_cost = min(n.cost for n in bucket)\n                        if new_cost >= best_bucket_cost - 1e-9:\n                            continue\n\n                    # Insert node\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node)\n                    progressed = True\n\n                    # Try direct bridge to the other tree\n                    other_near = self._nearest_in_grid(other_grid, new_node.position)\n                    if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                        # Build raw path\n                        path_a = self._path_to_root(new_node)\n                        path_b = self._path_to_root(other_near)\n                        raw_path = path_a + path_b[::-1]\n                        # Deduplicate meeting point if coincident\n                        if len(raw_path) >= 2 and self._dist(raw_path[-1], raw_path[-2]) <= 1e-12:\n                            raw_path.pop()\n                        # Shortcut with cached collision checks\n                        final_path = self._shortcut(raw_path)\n                        best_path = final_path\n                        incumbent_len = self._path_len(final_path)\n                        return PlannerResult(True, final_path, nodes, edges)\n\n                if not progressed:\n                    continue\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # ---------- PRNG ----------\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 1000 + 0.5)) & 0x7fffffff\n        s ^= len(self.obstacles) * 2654435761\n        self._rnd_state = (s ^ 0xA5A5A5) & 0x7fffffff\n        if self._rnd_state == 0:\n            self._rnd_state = 1234567\n\n    def _rand(self):\n        # LCG: x_{n+1} = (a x_n + c) mod m\n        self._rnd_state = (1103515245 * self._rnd_state + 12345) & 0x7fffffff\n        return (self._rnd_state / 2147483647.0)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return a\n        if d <= self.step_size:\n            return b\n        r = self.step_size / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # ---------- Sampling ----------\n    def _sample(self, attractor, incumbent_len):\n        # Guided: ellipse if incumbent known, else uniform with goal bias\n        for _ in range(20):\n            if incumbent_len is not None and self._dist(self.start, self.goal) > 1e-9:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.03)\n            else:\n                if self._rand() < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            if p is None:\n                continue\n            if self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        # Fallback\n        return attractor if self._within_bounds(attractor) and not self._point_in_obstacles(attractor) else None\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        # Rejection sample around the segment f1-f2\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum_dist\n        ext = [half] * self.dims\n        for _ in range(16):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._within_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum_dist and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # ---------- Grid spatial hash for nodes ----------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _nearest_in_grid(self, grid, pos, max_ring=5):\n        cell = self._cell_of(pos)\n        best = None\n        best_d = 1e100\n        if self.is_3d:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if not bucket:\n                                continue\n                            for n in bucket:\n                                d = self._dist(n.position, pos)\n                                if d < best_d:\n                                    best_d = d\n                                    best = n\n                                    found = True\n                if found:\n                    return best\n        else:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if not bucket:\n                            continue\n                        for n in bucket:\n                            d = self._dist(n.position, pos)\n                            if d < best_d:\n                                best_d = d\n                                best = n\n                                found = True\n                if found:\n                    return best\n        # Fallback: scan all\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._dist(n.position, pos)\n                if d < best_d:\n                    best_d = d\n                    best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if not bucket:\n                            continue\n                        for n in bucket:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if not bucket:\n                        continue\n                    for n in bucket:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    # ---------- Obstacle spatial grid ----------\n    def _build_obstacle_grid(self):\n        # Choose obstacle cell size proportional to step for balanced performance\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}  # cell -> list of obstacle indices\n        self._obs_is_3d = self.is_3d\n        for idx, obs in enumerate(self.obstacles):\n            if self._obs_is_3d:\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            key = (cx, cy, cz)\n                            bucket = self.obs_grid.get(key)\n                            if bucket is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                bucket.append(idx)\n            else:\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        key = (cx, cy)\n                        bucket = self.obs_grid.get(key)\n                        if bucket is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self._obs_is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    # ---------- Edge checks with cache ----------\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.ecache_quant) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.ecache_quant) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        if len(self.ecache) - self._last_prune_size > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self.ecache:\n            return\n        # Drop the oldest ~40%\n        cutoff = self._tick - 2000\n        to_del = []\n        for k, v in self.ecache.items():\n            if v[1] < cutoff:\n                to_del.append(k)\n        if not to_del:\n            # Fallback: remove every 3rd entry to bound size\n            i = 0\n            for k in list(self.ecache.keys()):\n                if (i % 3) == 0:\n                    to_del.append(k)\n                i += 1\n        for k in to_del:\n            if k in self.ecache:\n                del self.ecache[k]\n        self._last_prune_size = len(self.ecache)\n\n    # ---------- Segment vs obstacle (slab) accelerated by obstacle grid ----------\n    def _segment_hits_obstacle(self, a, b):\n        # Gather obstacles intersecting the bounding box of segment\n        if self._obs_is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bucket = self.obs_grid.get((cx, cy, cz))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bucket = self.obs_grid.get((cx, cy))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # ---------- Parent selection (short LOS lookback) ----------\n    def _best_parent_los(self, nearest, new_pos):\n        best = nearest\n        best_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        cur = nearest\n        depth = 0\n        while cur is not None and depth < self.lookback_depth:\n            if self._edge_free(cur.position, new_pos):\n                c = cur.cost + self._dist(cur.position, new_pos)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best = cur\n            cur = cur.parent\n            depth += 1\n        return best\n\n    # ---------- Shortcut smoothing ----------\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        attempts = 0\n        no_improve = 0\n        i = 0\n        while attempts < self.shortcut_attempts and i < len(pts) - 2:\n            improved = False\n            j = len(pts) - 1\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    del pts[i + 1:j]\n                    improved = True\n                    no_improve = 0\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n                no_improve += 1\n            attempts += 1\n            if no_improve >= self.no_improve_stop:\n                break\n        return pts",
          "objective": -26.29094,
          "time_improvement": 61.0,
          "length_improvement": -0.0,
          "smoothness_improvement": 1630.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024515295028686525,
                    "num_nodes_avg": 73.0,
                    "path_length_avg": 235.8280485058371,
                    "smoothness_avg": 0.03800756828685148,
                    "success_improvement": 0.0,
                    "time_improvement": 3.857046817335618,
                    "node_improvement": 81.6167212289096,
                    "length_improvement": -29.261090320615313,
                    "smoothness_improvement": 494.90097844477503,
                    "objective_score": -13.925035254944627
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023125672340393068,
                    "num_nodes_avg": 110.0,
                    "path_length_avg": 245.0393031205978,
                    "smoothness_avg": 0.12370286737465501,
                    "success_improvement": 0.0,
                    "time_improvement": 85.56425852446206,
                    "node_improvement": 92.6090169992609,
                    "length_improvement": 18.19882755307195,
                    "smoothness_improvement": 3082.9638771238115,
                    "objective_score": 52.003393474800845
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0030002355575561523,
                    "num_nodes_avg": 35.0,
                    "path_length_avg": 135.33178973135438,
                    "smoothness_avg": 0.1109750714335361,
                    "success_improvement": 0.0,
                    "time_improvement": 93.88351661704843,
                    "node_improvement": 95.54990464081374,
                    "length_improvement": 10.119069067755975,
                    "smoothness_improvement": 1311.5947173068773,
                    "objective_score": 40.7944700123025
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "QUICKSILVER-IBiRRT*: Quick Informed BiRRT* with coherent-cost rewiring, cached AABB edge checks, and lazy f-gating. It alternates bidirectional growth, uses hash-grid nearest and bounded neighbor sets, selects the lowest-length parent with a light angle tie-breaker, locally rewires for shorter costs, and attempts a short validated connect. After the first bridge it performs visibility-pruning and bounded shortcutting to reduce length, then returns.",
          "planning_mechanism": "Each iteration: sample via goal/corridor/uniform (ellipse after first path), pick a hash-grid nearest, steer one step, apply node check and lazy f-cost gate, choose best-cost parent among nearby neighbors with cached edge checks, attach and locally rewire. Try a short, validated connection to the other tree. On bridge, extract start-to-goal path, prune by visibility, shortcut a few times, and return with nodes and edges.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = set()\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.add(self)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=5.0,\n        goal_bias=0.12,\n        corridor_bias=0.5,\n        grid_cell_factor=1.5,\n        min_sep_factor=0.4,\n        neighbor_factor=2.2,\n        neighbor_max=16,\n        connect_steps=3,\n        heur_gate=1.01,\n        shortcut_trials=60,\n        rubber_passes=1\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.min_sep_factor = min_sep_factor\n        self.neighbor_factor = neighbor_factor\n        self.neighbor_max = neighbor_max\n        self.connect_steps = connect_steps\n        self.heur_gate = heur_gate\n        self.shortcut_trials = shortcut_trials\n        self.rubber_passes = rubber_passes\n\n        self.dim = 2\n        self.bounds = None\n        self.cell_size = 1.0\n        self.min_sep = 1.0\n        self.corridor_w = 1.0\n        self.angle_tie_w = 0.02\n\n        self._edge_cache = {}\n        self._lcg_a = 1103515245\n        self._lcg_c = 12345\n        self._lcg_m = 1 << 31\n        self._seed = 987654321\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # init\n        self._edge_cache = {}\n        self._seed = 987654321\n\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obs(start, obstacles, is_3d) or self._point_in_obs(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        sg_dist = self._dist(start, goal)\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step_size * self.min_sep_factor)\n        self.corridor_w = max(self.step_size * 1.5, 0.25 * sg_dist)\n\n        # direct path check\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, sg_dist)\n            s.children.add(g)\n            nodes = [s, g]\n            edges = [(s, g)]\n            return PlannerResult(True, [start, goal], nodes, edges)\n\n        # setup trees\n        a_root = Node(start, None, 0.0)\n        b_root = Node(goal, None, 0.0)\n        tree_a = [a_root]\n        tree_b = [b_root]\n        all_nodes = [a_root, b_root]\n\n        grid_a = {}\n        grid_b = {}\n        self._grid_add(grid_a, a_root)\n        self._grid_add(grid_b, b_root)\n\n        best_path = None\n        c_best = float('inf')\n        informed = False\n\n        for it in range(self.max_iter):\n            active_from_start = (it % 2 == 0)\n            if active_from_start:\n                tree_x, tree_y = tree_a, tree_b\n                grid_x, grid_y = grid_a, grid_b\n                root_x, root_y = a_root, b_root\n                attractor = goal\n            else:\n                tree_x, tree_y = tree_b, tree_a\n                grid_x, grid_y = grid_b, grid_a\n                root_x, root_y = b_root, a_root\n                attractor = start\n\n            # sampling\n            r = self._rand()\n            if r < self.goal_bias:\n                x_rand = attractor\n            else:\n                if informed and self._rand() < 0.6:\n                    x_rand = self._ellipse_sample(root_x.position, root_y.position, c_best)\n                elif self._rand() < self.corridor_bias:\n                    x_rand = self._corridor_sample(root_x.position, root_y.position, self.corridor_w)\n                else:\n                    x_rand = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n            # nearest\n            n_near = self._nearest_hashed(grid_x, tree_x, x_rand)\n            if n_near is None:\n                continue\n\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n            if not self._in_bounds(x_new_pos):\n                continue\n            if self._point_in_obs(x_new_pos, obstacles, is_3d):\n                continue\n            if self._near_duplicate(grid_x, x_new_pos, self.min_sep):\n                continue\n\n            # lazy f-gate before edge checks\n            tentative_g = n_near.cost + self._dist(n_near.position, x_new_pos)\n            f_cost = tentative_g + self._dist(x_new_pos, root_y.position)\n            if informed and f_cost >= self.heur_gate * c_best:\n                continue\n\n            # select best parent among neighbors\n            radius = self._neighbor_radius(len(tree_x))\n            neighbors = self._neighbors_in_radius(grid_x, x_new_pos, radius, self.neighbor_max)\n            parent, new_cost = self._choose_best_parent(x_new_pos, n_near, neighbors, obstacles, is_3d)\n            if parent is None:\n                continue\n            # enforce edge check (cached)\n            if self._edge_blocked(parent.position, x_new_pos, obstacles, is_3d):\n                continue\n\n            x_new = Node(x_new_pos, None, new_cost)\n            x_new.attach(parent)\n            tree_x.append(x_new)\n            all_nodes.append(x_new)\n            self._grid_add(grid_x, x_new)\n\n            # local rewiring for length reduction\n            self._rewire_neighbors(x_new, neighbors, obstacles, is_3d)\n\n            # try to connect quickly to the other tree\n            other_near = self._nearest_hashed(grid_y, tree_y, x_new.position)\n            bridged = None\n            if other_near is not None and not self._edge_blocked(x_new.position, other_near.position, obstacles, is_3d):\n                bridged = other_near\n            else:\n                cur = other_near\n                steps = 0\n                while cur is not None and steps < self.connect_steps:\n                    step_pos = self._steer(cur.position, x_new.position, self.step_size)\n                    if not self._in_bounds(step_pos):\n                        break\n                    if self._point_in_obs(step_pos, obstacles, is_3d):\n                        break\n                    if self._near_duplicate(grid_y, step_pos, self.min_sep):\n                        break\n                    g2 = cur.cost + self._dist(cur.position, step_pos)\n                    f2 = g2 + self._dist(step_pos, root_x.position)\n                    if informed and f2 >= self.heur_gate * c_best:\n                        break\n                    # choose parent for new step in other tree (cur as fallback)\n                    neigh_b = self._neighbors_in_radius(grid_y, step_pos, radius, self.neighbor_max)\n                    p_b, c_b = self._choose_best_parent(step_pos, cur, neigh_b, obstacles, is_3d)\n                    if p_b is None:\n                        break\n                    if self._edge_blocked(p_b.position, step_pos, obstacles, is_3d):\n                        break\n                    nxt = Node(step_pos, None, c_b)\n                    nxt.attach(p_b)\n                    tree_y.append(nxt)\n                    all_nodes.append(nxt)\n                    self._grid_add(grid_y, nxt)\n                    self._rewire_neighbors(nxt, neigh_b, obstacles, is_3d)\n                    cur = nxt\n                    steps += 1\n                    if not self._edge_blocked(cur.position, x_new.position, obstacles, is_3d):\n                        bridged = cur\n                        break\n\n            if bridged is not None:\n                # assemble path\n                if active_from_start:\n                    pa = self._path_to_root(x_new)\n                    pb = self._path_to_root(bridged)\n                    path = pa + list(reversed(pb))\n                else:\n                    pa = self._path_to_root(x_new)\n                    pb = self._path_to_root(bridged)\n                    path = pb + list(reversed(pa))\n\n                path = self._visibility_prune(path, obstacles, is_3d)\n                path = self._shortcut(path, obstacles, is_3d, self.shortcut_trials)\n                path = self._rubber_band(path, obstacles, is_3d, self.rubber_passes)\n\n                L = self._path_length(path)\n                if L < c_best:\n                    c_best = L\n                    best_path = path\n                    informed = True\n                    edges = []\n                    for n in all_nodes:\n                        if n.parent is not None:\n                            edges.append((n.parent, n))\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n        edges = []\n        for n in all_nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        return PlannerResult(best_path is not None, best_path if best_path else [], all_nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._seed = (self._lcg_a * self._seed + self._lcg_c) % self._lcg_m\n        return self._seed / float(self._lcg_m)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5 if s > 0.0 else 0.0\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _clamp(self, p):\n        out = []\n        for i in range(self.dim):\n            v = p[i]\n            if v < 0.0:\n                v = 0.0\n            if v > self.bounds[i]:\n                v = self.bounds[i]\n            out.append(v)\n        return tuple(out)\n\n    # Obstacles\n    def _point_in_obs(self, p, obstacles, is_3d):\n        if is_3d:\n            x, y, z = p\n            for o in obstacles:\n                ox, oy, oz, w, h, d = o\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n        else:\n            x, y = p\n            for o in obstacles:\n                ox, oy, w, h = o\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        cached = self._edge_cache.get(k)\n        if cached is not None:\n            return cached\n        if is_3d:\n            ax, ay, az = a\n            bx, by, bz = b\n            blocked = False\n            if ax == bx and ay == by and az == bz:\n                blocked = self._point_in_obs(a, obstacles, True)\n            else:\n                for box in obstacles:\n                    if self._seg_box_intersect_3d(a, b, box):\n                        blocked = True\n                        break\n        else:\n            ax, ay = a\n            bx, by = b\n            blocked = False\n            if ax == bx and ay == by:\n                blocked = self._point_in_obs(a, obstacles, False)\n            else:\n                for box in obstacles:\n                    if self._seg_box_intersect_2d(a, b, box):\n                        blocked = True\n                        break\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _seg_box_intersect_2d(self, a, b, box):\n        x, y, w, h = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        tmin, tmax = 0.0, 1.0\n        ax, ay = a\n        bx, by = b\n        dx = bx - ax\n        dy = by - ay\n\n        if dx == 0.0:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            t1 = (minx - ax) * inv\n            t2 = (maxx - ax) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        if dy == 0.0:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            t1 = (miny - ay) * inv\n            t2 = (maxy - ay) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    def _seg_box_intersect_3d(self, a, b, box):\n        x, y, z, w, h, d = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        minz, maxz = z, z + d\n        tmin, tmax = 0.0, 1.0\n        ax, ay, az = a\n        bx, by, bz = b\n        dx = bx - ax\n        dy = by - ay\n        dz = bz - az\n\n        if dx == 0.0:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            t1 = (minx - ax) * inv\n            t2 = (maxx - ax) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        if dy == 0.0:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            t1 = (miny - ay) * inv\n            t2 = (maxy - ay) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        if dz == 0.0:\n            if az < minz or az > maxz:\n                return False\n        else:\n            inv = 1.0 / dz\n            t1 = (minz - az) * inv\n            t2 = (maxz - az) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    # Hash grid neighbors\n    def _grid_key(self, pos):\n        if self.dim == 3:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        else:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _collect_cells(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, nodes, pos):\n        k = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        found = False\n        for r in range(0, 3):\n            cand = self._collect_cells(grid, k, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                found = True\n                break\n        if not found:\n            limit = min(96, len(nodes))\n            if limit == 0:\n                return None\n            step = max(1, len(nodes) // max(1, limit))\n            for i in range(0, len(nodes), step):\n                n = nodes[i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius, kmax):\n        ring = int(radius // self.cell_size) + 1\n        cand = self._collect_cells(grid, self._grid_key(pos), ring)\n        arr = []\n        rr = radius + 1e-9\n        for n in cand:\n            d = self._dist(n.position, pos)\n            if d <= rr:\n                arr.append((d, n))\n        arr.sort(key=lambda x: x[0])\n        res = [n for (_, n) in arr[:kmax]]\n        return res\n\n    def _neighbor_radius(self, ncount):\n        base = self.neighbor_factor * self.step_size\n        if ncount < 300:\n            return base * 2.0\n        if ncount < 1200:\n            return base * 1.6\n        return base * 1.3\n\n    def _near_duplicate(self, grid, pos, radius):\n        cand = self._collect_cells(grid, self._grid_key(pos), 1)\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                return True\n        return False\n\n    # Parent selection with length cost and angle tie-breaker\n    def _choose_best_parent(self, new_pos, fallback, neighbors, obstacles, is_3d):\n        best_p = None\n        best_cost = float('inf')\n        best_tie = float('inf')\n\n        def angle_tie(p):\n            if p is None or p.parent is None:\n                return 0.0\n            a = p.parent.position\n            b = p.position\n            c = new_pos\n            v1 = tuple(b[i] - a[i] for i in range(self.dim))\n            v2 = tuple(c[i] - b[i] for i in range(self.dim))\n            n1 = 0.0\n            n2 = 0.0\n            dot = 0.0\n            for i in range(self.dim):\n                n1 += v1[i] * v1[i]\n                n2 += v2[i] * v2[i]\n                dot += v1[i] * v2[i]\n            if n1 <= 1e-9 or n2 <= 1e-9:\n                return 0.0\n            cosang = dot / ((n1 ** 0.5) * (n2 ** 0.5))\n            if cosang > 1.0:\n                cosang = 1.0\n            if cosang < -1.0:\n                cosang = -1.0\n            return (1.0 - cosang)\n\n        cand = [fallback] + neighbors\n        seen = set()\n        for p in cand:\n            if p in seen:\n                continue\n            seen.add(p)\n            if self._edge_blocked(p.position, new_pos, obstacles, is_3d):\n                continue\n            cost = p.cost + self._dist(p.position, new_pos)\n            tie = angle_tie(p)\n            if cost + self.angle_tie_w * tie < best_cost + self.angle_tie_w * best_tie - 1e-12:\n                best_cost = cost\n                best_tie = tie\n                best_p = p\n        if best_p is None:\n            return None, float('inf')\n        return best_p, best_cost\n\n    def _rewire_neighbors(self, new_node, neighbors, obstacles, is_3d):\n        for m in neighbors:\n            if m is new_node or m is new_node.parent:\n                continue\n            alt = new_node.cost + self._dist(new_node.position, m.position)\n            if alt + 1e-12 < m.cost:\n                if not self._edge_blocked(new_node.position, m.position, obstacles, is_3d):\n                    delta = alt - m.cost\n                    m.attach(new_node)\n                    m.cost = alt\n                    self._propagate_cost(m, delta)\n\n    def _propagate_cost(self, node, delta):\n        if delta == 0.0:\n            return\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    # Sampling helpers\n    def _ellipse_sample(self, a, b, c_best):\n        # rejection sampling inside bounds using triangle inequality gate\n        tries = 10\n        for _ in range(tries):\n            p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n            if self._dist(p, a) + self._dist(p, b) <= c_best + 1e-9:\n                return p\n        # fallback to corridor sampling\n        width = max(self.step_size, 0.15 * c_best)\n        return self._corridor_sample(a, b, width)\n\n    def _corridor_sample(self, a, b, width):\n        t = self._uniform(0.0, 1.0)\n        base = tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n        ab = tuple(b[i] - a[i] for i in range(self.dim))\n        abn = 0.0\n        for i in range(self.dim):\n            abn += ab[i] * ab[i]\n        abn = abn ** 0.5 if abn > 0.0 else 0.0\n        if abn <= 1e-9:\n            return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n        v = tuple(ab[i] / abn for i in range(self.dim))\n        if self.dim == 2:\n            perp = (-v[1], v[0])\n            mag = self._uniform(-width, width)\n            p = (base[0] + perp[0] * mag, base[1] + perp[1] * mag)\n            return self._clamp(p)\n        else:\n            # random vector orthogonal to v\n            r = (self._uniform(-1.0, 1.0), self._uniform(-1.0, 1.0), self._uniform(-1.0, 1.0))\n            dot = r[0]*v[0] + r[1]*v[1] + r[2]*v[2]\n            u = (r[0] - dot*v[0], r[1] - dot*v[1], r[2] - dot*v[2])\n            un = (u[0]*u[0] + u[1]*u[1] + u[2]*u[2]) ** 0.5\n            if un <= 1e-9:\n                u = (v[1], -v[0], 0.0)\n                un = (u[0]*u[0] + u[1]*u[1] + u[2]*u[2]) ** 0.5\n            u = (u[0]/un, u[1]/un, u[2]/un)\n            mag = self._uniform(-width, width)\n            p = (base[0] + u[0]*mag, base[1] + u[1]*mag, base[2] + u[2]*mag)\n            return self._clamp(p)\n\n    # Path utilities\n    def _path_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        out.reverse()\n        return out\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i-1], path[i])\n        return L\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(out[-1], path[j], obstacles, is_3d):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i+1])\n                i += 1\n        return out\n\n    def _shortcut(self, path, obstacles, is_3d, trials):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(trials):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i+1] + pts[j:]\n                n = len(pts)\n        return pts\n\n    def _rubber_band(self, path, obstacles, is_3d, passes=1):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(passes):\n            changed = False\n            for i in range(1, len(pts)-1):\n                a = pts[i-1]\n                b = pts[i]\n                c = pts[i+1]\n                mid = tuple(0.5*(a[d] + c[d]) for d in range(self.dim))\n                newp = tuple(0.5*b[d] + 0.5*mid[d] for d in range(self.dim))\n                if self._point_in_obs(newp, obstacles, is_3d):\n                    continue\n                if not self._edge_blocked(a, newp, obstacles, is_3d) and not self._edge_blocked(newp, c, obstacles, is_3d):\n                    old_len = self._dist(a, b) + self._dist(b, c)\n                    new_len = self._dist(a, newp) + self._dist(newp, c)\n                    if new_len + 1e-9 < old_len:\n                        pts[i] = newp\n                        changed = True\n            if not changed:\n                break\n        return pts",
          "objective": -26.26141,
          "time_improvement": 30.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1189.0,
          "node_improvement": 81.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.005929088592529297,
                    "num_nodes_avg": 55.0,
                    "path_length_avg": 158.77867304436205,
                    "smoothness_avg": 0.037578166426473804,
                    "success_improvement": 0.0,
                    "time_improvement": 78.50366550346754,
                    "node_improvement": 86.14958448753463,
                    "length_improvement": 12.97089329530396,
                    "smoothness_improvement": 488.1799068688001,
                    "objective_score": 33.774535162566636
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0597461462020874,
                    "num_nodes_avg": 192.0,
                    "path_length_avg": 227.64213746487638,
                    "smoothness_avg": 0.08682024463255004,
                    "success_improvement": 0.0,
                    "time_improvement": 63.89501620155921,
                    "node_improvement": 87.09937512598268,
                    "length_improvement": 24.00650219860034,
                    "smoothness_improvement": 2133.9474284900743,
                    "objective_score": 44.24214332207834
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07891616821289063,
                    "num_nodes_avg": 241.0,
                    "path_length_avg": 121.2698125030847,
                    "smoothness_avg": 0.08214019867730854,
                    "success_improvement": 0.0,
                    "time_improvement": -52.105196646316955,
                    "node_improvement": 69.35791481246027,
                    "length_improvement": 19.458364783373543,
                    "smoothness_improvement": 944.8172642165742,
                    "objective_score": 0.7675461972119111
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "HASTE-BiRRT (Heuristically Accelerated Sparse Tree Expansion BiRRT): a bidirectional planner that couples tiny-beam, corridor/informed sampling with dual-anchored hashed nearest search, bounded per-cell growth, and a two-sided edge memo caching both blocked and free checks. It inserts single-parent nodes with multi-ancestor LOS compression to keep trees shallow, uses a short single-step greedy connect to limit overhead, and maintains an early-updating best path to focus informed sampling. A bounded shortcut with forward LOS collapse returns smooth, short paths quickly.",
          "planning_mechanism": "Alternate growth of start/goal trees. Each side samples a small beam (goal/corridor/uniform, switching to informed ellipse after a provisional path). For each sample, find a near node via grid+anchors, steer once, enforce node and edge validity (with memoized edge checks), suppress near-duplicates and throttle per-cell growth; keep the candidate that minimizes a heuristic combining distance to the opposite tree and cost-to-come. Insert the node, apply multi-ancestor LOS compression, then attempt a direct bridge or a single-step greedy connect from the opposite tree. On success, extract and bounded-shortcut the path with LOS collapse; otherwise iterate to a cap.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=10.0,\n                 collision_step=1.0,\n                 beam_k=2,\n                 goal_bias=0.15,\n                 corridor_bias=0.55,\n                 informed_bias=0.65,\n                 grid_cell=None,\n                 max_rings=3,\n                 dupe_radius_ratio=0.45,\n                 min_sep_ratio=0.30,\n                 cell_expand_limit=2,\n                 anchor_stride=20,\n                 connect_attempts=1,\n                 compress_depth=3,\n                 smoothing_iters=24,\n                 edge_cache_max=20000):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_step = collision_step\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.informed_bias = informed_bias\n        self.grid_cell = grid_cell\n        self.max_rings = max_rings\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.min_sep_ratio = min_sep_ratio\n        self.cell_expand_limit = max(1, int(cell_expand_limit))\n        self.anchor_stride = max(1, int(anchor_stride))\n        self.connect_attempts = max(1, int(connect_attempts))\n        self.compress_depth = max(1, int(compress_depth))\n        self.smoothing_iters = smoothing_iters\n        self.edge_cache_max = max(1000, int(edge_cache_max))\n\n        # runtime\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.cache_bin = 1.0\n        self.edge_cache = None  # key -> 1(blocked) or 2(free)\n\n        self.start = None\n        self.goal = None\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # setup discretizations\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.9 * self.step_size)\n        self.edge_res = max(0.75, min(self.collision_step, max(0.5, self.step_size * 0.5)))\n        self.cache_bin = max(1.0, self.edge_res)\n        self.edge_cache = {}\n\n        # validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # early straight connection\n        if not self._edge_blocked_memo(self.start, self.goal, obstacles, is_3d):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # initialize trees and structures\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        edges = []\n        nodes = [start_root, goal_root]\n\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        anchors_a, anchors_b = [start_root], [goal_root]\n        cell_expands_a, cell_expands_b = {}, {}\n\n        best_path_len = float('inf')\n        d_sg = self._dist(self.start, self.goal)\n        base_corridor_w = max(self.step_size, 0.2 * d_sg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            anchors1 = anchors_a if active_start else anchors_b\n            anchors2 = anchors_b if active_start else anchors_a\n            throttles1 = cell_expands_a if active_start else cell_expands_b\n            throttles2 = cell_expands_b if active_start else cell_expands_a\n            other_root = self.goal if active_start else self.start\n\n            best_parent = None\n            best_new = None\n            best_score = float('inf')\n\n            for _ in range(self.beam_k):\n                # sampling strategy\n                r = self._rand()\n                if best_path_len < float('inf') and r < self.informed_bias:\n                    x_rand = self._sample_informed(best_path_len, obstacles, is_3d)\n                else:\n                    r2 = self._rand()\n                    if r2 < self.goal_bias:\n                        x_rand = other_root\n                    elif r2 < self.goal_bias + self.corridor_bias:\n                        width = base_corridor_w\n                        if best_path_len < float('inf'):\n                            slack = max(0.0, best_path_len - d_sg)\n                            width = max(self.step_size, 0.2 * slack + base_corridor_w)\n                        x_rand = self._sample_corridor(width, obstacles, is_3d)\n                    else:\n                        x_rand = self._sample_free(obstacles, is_3d)\n\n                near = self._nearest_hashed(grid1, tree1, anchors1, x_rand)\n                if near is None:\n                    continue\n\n                new_pos = self._steer(near.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                # Node collision check before any insertion\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n\n                # duplicate suppression and throttle\n                if self._dist(near.position, new_pos) < self.step_size * self.min_sep_ratio:\n                    continue\n                if self._exists_close(grid1, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                kcell = self._grid_key(new_pos)\n                if throttles1.get(kcell, 0) >= self.cell_expand_limit:\n                    continue\n\n                # Edge collision check before considering\n                if self._edge_blocked_memo(near.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Heuristic score: distance to opposite-tree nearest + mild cost term\n                other_near = self._nearest_hashed(grid2, tree2, anchors2, new_pos)\n                to_other = self._dist(new_pos, other_near.position) if other_near is not None else self._dist(new_pos, other_root)\n                cost_term = (near.cost + self._dist(near.position, new_pos)) * 0.05\n                score = to_other + cost_term\n\n                if score < best_score:\n                    best_score = score\n                    best_parent = near\n                    best_new = new_pos\n\n            if best_parent is None:\n                continue\n\n            # Final validity before insertion (both checks)\n            if self._is_in_obstacle(best_new, obstacles, is_3d):\n                continue\n            if self._edge_blocked_memo(best_parent.position, best_new, obstacles, is_3d):\n                continue\n\n            # Insert node\n            new_cost = best_parent.cost + self._dist(best_parent.position, best_new)\n            new_node = Node(best_new, best_parent, new_cost)\n            best_parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            self._grid_add(grid1, new_node)\n            kc = self._grid_key(best_new)\n            throttles1[kc] = throttles1.get(kc, 0) + 1\n            if len(tree1) % self.anchor_stride == 0:\n                anchors1.append(new_node)\n\n            # Multi-ancestor LOS compression (up to compress_depth)\n            self._compress_to_ancestors(new_node, obstacles, is_3d, edges, self.compress_depth)\n\n            # Try direct bridge\n            other_near = self._nearest_hashed(grid2, tree2, anchors2, new_node.position)\n            if other_near is not None and not self._edge_blocked_memo(new_node.position, other_near.position, obstacles, is_3d):\n                path = self._extract_path(new_node, other_near)\n                best_path_len = self._path_length(path)\n                path = self._smooth_path(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Short greedy connect from the other side (single-step attempts)\n            p = other_near\n            attempts = 0\n            while p is not None and attempts < self.connect_attempts:\n                step_pos = self._steer(p.position, new_node.position, self.step_size)\n                if not self._in_bounds(step_pos):\n                    break\n                if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._exists_close(grid2, step_pos, self.step_size * self.dupe_radius_ratio):\n                    break\n                if self._edge_blocked_memo(p.position, step_pos, obstacles, is_3d):\n                    break\n\n                # Insert micro-step node (both checks passed)\n                q = Node(step_pos, p, p.cost + self._dist(p.position, step_pos))\n                p.add_child(q)\n                tree2.append(q)\n                nodes.append(q)\n                edges.append((p, q))\n                self._grid_add(grid2, q)\n                if len(tree2) % self.anchor_stride == 0:\n                    anchors2.append(q)\n                throttles2[self._grid_key(step_pos)] = throttles2.get(self._grid_key(step_pos), 0) + 1\n\n                # optional small compression on the micro-step\n                self._compress_to_ancestors(q, obstacles, is_3d, edges, 2)\n\n                # Check bridge to new_node\n                if not self._edge_blocked_memo(new_node.position, q.position, obstacles, is_3d):\n                    path = self._extract_path(new_node, q)\n                    best_path_len = self._path_length(path)\n                    path = self._smooth_path(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, nodes, edges)\n\n                p = q\n                attempts += 1\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp_tuple(to_pos)\n        if d <= 1e-12:\n            return self._clamp_tuple(from_pos)\n        r = step / d\n        return self._clamp_tuple(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Edge memo (blocked and free)\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked_memo(self, a, b, obstacles, is_3d):\n        key = self._edge_key_q(a, b)\n        state = self.edge_cache.get(key)\n        if state is not None:\n            return state == 1\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d)\n        self.edge_cache[key] = 1 if blocked else 2\n        # bounded cache pruning to limit rechecks without frequent full clears\n        if len(self.edge_cache) > self.edge_cache_max:\n            self._prune_edge_cache()\n        return blocked\n\n    def _prune_edge_cache(self):\n        # remove roughly half of items deterministically\n        to_remove = []\n        count = 0\n        for k in self.edge_cache:\n            if (count % 2) == 0:\n                to_remove.append(k)\n            count += 1\n            if len(to_remove) >= self.edge_cache_max // 2:\n                break\n        for k in to_remove:\n            try:\n                del self.edge_cache[k]\n            except:\n                pass\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            # rejection within sphere\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n        else:\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d):\n        # prolate ellipse: sum of distances to foci <= best_len\n        for _ in range(48):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= best_len and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # fallback\n        return self._sample_corridor(max(self.step_size, 0.2 * self._dist(self.start, self.goal)), obstacles, is_3d)\n\n    # Grid hashing\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, tree, anchors, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # anchor fallback\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # rare: full scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(max(1, radius / self.grid_cell)) + 1\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # Compression\n    def _compress_to_ancestors(self, node, obstacles, is_3d, edges, depth_limit):\n        cur_parent = node.parent\n        depth = 0\n        while cur_parent is not None and depth < depth_limit:\n            gp = cur_parent.parent\n            if gp is None:\n                break\n            if not self._edge_blocked_memo(gp.position, node.position, obstacles, is_3d):\n                # update parent-child relations\n                cur_parent.remove_child(node)\n                self._edges_remove(edges, cur_parent, node)\n                gp.add_child(node)\n                edges.append((gp, node))\n                node.cost = gp.cost + self._dist(gp.position, node.position)\n                cur_parent = gp\n                depth += 1\n            else:\n                break\n\n    # Edges helpers\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node):\n        path_a = self._path_to_root(a_node)\n        path_b = []\n        cur = b_node\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _smooth_path(self, path, obstacles, is_3d, iters):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        no_improve = 0\n        last_len = self._path_length(pts)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d):\n                new_pts = pts[:i + 1] + pts[j:]\n                new_len = self._path_length(new_pts)\n                if new_len <= last_len:\n                    pts = new_pts\n                    last_len = new_len\n                    no_improve = 0\n                else:\n                    no_improve += 1\n            else:\n                no_improve += 1\n            if no_improve >= 8:\n                break\n        # Forward LOS collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            k = 1\n            while k < len(pts) - 1:\n                nxt = pts[k + 1]\n                if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d):\n                    collapsed.append(pts[k])\n                    last = pts[k]\n                k += 1\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
          "objective": -26.1688,
          "time_improvement": 35.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1792.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027369928359985352,
                    "num_nodes_avg": 65.0,
                    "path_length_avg": 171.28307479198807,
                    "smoothness_avg": 0.05148806664012615,
                    "success_improvement": 0.0,
                    "time_improvement": -7.338122500577379,
                    "node_improvement": 83.63132712163183,
                    "length_improvement": 6.11703255250457,
                    "smoothness_improvement": 705.9000510442344,
                    "objective_score": 4.9982830365507
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04116971492767334,
                    "num_nodes_avg": 116.3,
                    "path_length_avg": 248.99030586642007,
                    "smoothness_avg": 0.12529040112374196,
                    "success_improvement": 0.0,
                    "time_improvement": 74.30062345562982,
                    "node_improvement": 92.18571524558222,
                    "length_improvement": 16.879869113207995,
                    "smoothness_improvement": 3123.8122639421595,
                    "objective_score": 48.037169824324536
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.030934453010559082,
                    "num_nodes_avg": 94.2,
                    "path_length_avg": 133.85366176833466,
                    "smoothness_avg": 0.12940331913875977,
                    "success_improvement": 0.0,
                    "time_improvement": 36.934929218056986,
                    "node_improvement": 88.02288620470438,
                    "length_improvement": 11.10077127990379,
                    "smoothness_improvement": 1546.0006678855698,
                    "objective_score": 25.470944872787218
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SWIFT-BiRRT*: Streamlined Weighted-Informed Fast-cached Bi-directional RRT*. It grows two cost-consistent trees with a tiny beam of heuristic-ranked proposals, adaptive neighbor radii, coarse grid hashing, and a large reusable edge-collision cache. Each insertion validates node and edge, picks the cheapest feasible parent locally, rewires near neighbors with queue-based cost updates, and attempts a k-nearest bridge to the opposite tree. An anytime early connection is immediately line-of-sight collapsed and shortcut-smoothed. Simple throttles and duplicate suppression curb redundant growth for speed and robustness.",
          "planning_mechanism": "Alternate expanding start/goal trees. Per iteration, draw a small set of guided targets (informed ellipse/corridor/goal/uniform), steer from the hashed-grid nearest, and choose a feasible parent among nearby neighbors that minimizes geometric cost. After both node and edge checks, insert, rewire locally, and probe a few nearest nodes of the opposite tree for a cheapest valid bridge using a coarse LRU edge cache. On first success, merge roots-to-meet, greedily collapse LOS, apply a few shortcuts, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        for c in self.children:\n            if c is child:\n                child.parent = self\n                return\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        i = 0\n        while i < len(self.children):\n            if self.children[i] is child:\n                self.children.pop(i)\n                return\n            i += 1\n\n    def path_to_root(self):\n        pts = []\n        cur = self\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\nclass Planner:\n    def __init__(self,\n                 max_iter=4500,\n                 step_size=8.0,\n                 edge_resolution=1.0,\n                 beam_k=2,\n                 goal_bias=0.25,\n                 corridor_bias=0.45,\n                 informed_bias=0.65,\n                 grid_cell=None,\n                 parent_radius_factor=2.4,\n                 connect_radius_factor=3.2,\n                 neighbor_limit=48,\n                 rewire_limit=18,\n                 connect_k=8,\n                 dupe_radius_ratio=0.45,\n                 cell_expand_limit=3,\n                 smoothing_attempts=32,\n                 edge_cache_limit=80000):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.edge_resolution = float(edge_resolution)\n        self.beam_k = int(beam_k)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell = grid_cell\n        self.parent_radius_factor = float(parent_radius_factor)\n        self.connect_radius_factor = float(connect_radius_factor)\n        self.neighbor_limit = int(neighbor_limit)\n        self.rewire_limit = int(rewire_limit)\n        self.connect_k = int(connect_k)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.cell_expand_limit = int(cell_expand_limit)\n        self.smoothing_attempts = int(smoothing_attempts)\n        self.edge_cache_limit = int(edge_cache_limit)\n\n        self.dim = 2\n        self.bounds = None\n        self.start = None\n        self.goal = None\n\n        # Edge cache (quantized endpoints -> 1 blocked, 2 free) with FIFO keys\n        self.edge_cache = None\n        self.edge_keys = None\n        self.cache_bin = 1.0\n        self.inv_cache_bin = 1.0\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Parameters derived from map/step\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.9 * self.step_size)\n        self.cache_bin = max(0.75, 0.5 * max(self.edge_resolution, 0.5 * self.step_size))\n        self.inv_cache_bin = 1.0 / self.cache_bin\n        self.edge_cache = {}\n        self.edge_keys = []\n\n        # Validate endpoints\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight connection (both checks)\n        if not self._edge_blocked_memo(self.start, self.goal, obstacles, is_3d):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Initialize trees and structures\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        tree_a = [root_a]\n        tree_b = [root_b]\n        nodes = [root_a, root_b]\n        edges = []\n\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, root_a)\n        self._grid_add(grid_b, root_b)\n\n        # Per-cell throttles\n        throttle_a, throttle_b = {}, {}\n\n        # Recent frontiers for fast fallback nearest\n        frontier_a, frontier_b = [root_a], [root_b]\n        frontier_cap = 128\n\n        # Blocked cell-pair memory for bridges\n        blocked_pairs = {}\n\n        best_path_len = float('inf')\n        dupe_radius = max(0.5, self.dupe_radius_ratio * self.step_size)\n        sg_dist = self._dist(self.start, self.goal)\n        base_corridor_w = max(self.step_size, 0.25 * sg_dist)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            throttle1 = throttle_a if active_start else throttle_b\n            frontier1 = frontier_a if active_start else frontier_b\n            frontier2 = frontier_b if active_start else frontier_a\n            other_root = self.goal if active_start else self.start\n\n            # Adaptive radii (shrink slowly as trees grow)\n            n1 = max(1, len(tree1))\n            shrink = 1.0 / (1.0 + 0.01 * n1)\n            parent_radius = max(1.2 * self.step_size, self.parent_radius_factor * self.step_size * (0.7 + 0.3 * shrink))\n            connect_radius = max(1.6 * self.step_size, self.connect_radius_factor * self.step_size * (0.8 + 0.2 * shrink))\n\n            # Beam of proposals, choose best by f = g + 0.5*h\n            best_parent = None\n            best_pos = None\n            best_g = float('inf')\n            best_score = float('inf')\n\n            for _ in range(self.beam_k):\n                target = self._sample_guided(best_path_len, base_corridor_w, obstacles, is_3d)\n                near = self._nearest(grid1, frontier1, tree1, target)\n                if near is None:\n                    continue\n\n                new_pos = self._steer(near.position, target, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                # Node collision check\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                # Duplicate suppression\n                if self._exists_close(grid1, new_pos, dupe_radius):\n                    continue\n                # Per-cell throttle\n                ck = self._grid_key(new_pos)\n                if throttle1.get(ck, 0) >= self.cell_expand_limit:\n                    continue\n\n                # Choose parent among nearby neighbors (bounded)\n                parent, new_cost = self._choose_parent(grid1, new_pos, parent_radius, self.neighbor_limit, obstacles, is_3d, near)\n                if parent is None:\n                    continue\n\n                # Edge collision check (parent -> new_pos)\n                if self._edge_blocked_memo(parent.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Score against other side\n                onear = self._nearest(grid2, frontier2, tree2, new_pos)\n                h = self._dist(new_pos, onear.position) if onear is not None else self._dist(new_pos, other_root)\n                score = new_cost + 0.5 * h\n                if score < best_score:\n                    best_parent = parent\n                    best_pos = new_pos\n                    best_g = new_cost\n                    best_score = score\n\n            if best_parent is None:\n                continue\n\n            # Final safety before insertion (both checks)\n            if self._is_in_obstacle(best_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked_memo(best_parent.position, best_pos, obstacles, is_3d):\n                continue\n\n            # Insert node\n            new_node = Node(best_pos, best_parent, best_g)\n            best_parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            self._grid_add(grid1, new_node)\n            ck = self._grid_key(best_pos)\n            throttle1[ck] = throttle1.get(ck, 0) + 1\n            frontier1.append(new_node)\n            if len(frontier1) > frontier_cap:\n                del frontier1[:16]\n\n            # Local rewiring\n            self._rewire_local(new_node, grid1, parent_radius, self.rewire_limit, obstacles, is_3d, edges)\n\n            # Attempt k-nearest bridge to opposite tree\n            near_other = self._neighbors_within(grid2, new_node.position, connect_radius, self.neighbor_limit)\n            if near_other:\n                # Rank candidates by estimated total cost\n                tmp = []\n                for q in near_other:\n                    tc = new_node.cost + self._dist(new_node.position, q.position) + q.cost\n                    tmp.append((tc, q))\n                # Partial selection up to connect_k best\n                self._partial_sort(tmp, self.connect_k)\n                tried = 0\n                best_bridge = None\n                for tc, q in tmp[:self.connect_k]:\n                    # cell-pair skip if known repeatedly blocked\n                    pk = (self._grid_key(new_node.position), self._grid_key(q.position))\n                    if blocked_pairs.get(pk, 0) >= 2:\n                        continue\n                    # Node checks (both ends already valid), Edge collision check\n                    if not self._edge_blocked_memo(new_node.position, q.position, obstacles, is_3d):\n                        if (best_bridge is None) or (tc < best_bridge[0]):\n                            best_bridge = (tc, q)\n                    else:\n                        blocked_pairs[pk] = blocked_pairs.get(pk, 0) + 1\n                    tried += 1\n                    if tried >= self.connect_k:\n                        break\n\n                if best_bridge is not None:\n                    meet = best_bridge[1]\n                    if active_start:\n                        path = self._merge_paths(new_node, meet)\n                    else:\n                        path = self._merge_paths(meet, new_node)\n                    best_path_len = self._path_length(path)\n                    # Refine: LOS collapse then random shortcuts\n                    path = self._los_collapse(path, obstacles, is_3d)\n                    path = self._shortcut(path, obstacles, is_3d, self.smoothing_attempts)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG (xorshift32)\n    def _rand(self):\n        if not hasattr(self, \"_rng\"):\n            self._rng = 2463534242\n        x = self._rng & 0xFFFFFFFF\n        x ^= (x << 13) & 0xFFFFFFFF\n        x ^= (x >> 17) & 0xFFFFFFFF\n        x ^= (x << 5) & 0xFFFFFFFF\n        self._rng = x & 0xFFFFFFFF\n        return (self._rng & 0xFFFFFFFF) / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp_tuple(b)\n        if d <= 1e-12:\n            return self._clamp_tuple(a)\n        r = step / d\n        return self._clamp_tuple(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        res = max(0.5, min(self.edge_resolution, 0.5 * self.step_size))\n        steps = int(d / max(1e-9, res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] * self.inv_cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] * self.inv_cache_bin) for i in range(self.dim))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_blocked_memo(self, a, b, obstacles, is_3d):\n        key = self._edge_key_q(a, b)\n        st = self.edge_cache.get(key)\n        if st is not None:\n            return st == 1\n        blocked = self._edge_blocked(a, b, obstacles, is_3d)\n        self.edge_cache[key] = 1 if blocked else 2\n        self.edge_keys.append(key)\n        if len(self.edge_keys) > self.edge_cache_limit:\n            cut = int(self.edge_cache_limit * 0.25)\n            for i in range(cut):\n                k = self.edge_keys[i]\n                if k in self.edge_cache:\n                    del self.edge_cache[k]\n            self.edge_keys = self.edge_keys[cut:]\n        return blocked\n\n    # Grid hashing\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, frontier, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Search up to 2 rings for speed\n        for r in range(0, 3):\n            cand = self._collect_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Frontier-assisted fallback\n        if frontier:\n            limit = min(16, len(frontier))\n            for i in range(1, limit + 1):\n                n = frontier[-i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            if best is not None:\n                return best\n        # Rare: stride through tree\n        if tree:\n            stride = max(1, len(tree) // 32)\n            i = 0\n            while i < len(tree):\n                n = tree[i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n                i += stride\n        return best\n\n    def _neighbors_within(self, grid, pos, radius, limit):\n        key = self._grid_key(pos)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._collect_ring(grid, key, r_cells)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                out.append(n)\n                if len(out) >= limit:\n                    break\n        return out\n\n    def _choose_parent(self, grid, new_pos, radius, limit, obstacles, is_3d, fallback):\n        neigh = self._neighbors_within(grid, new_pos, radius, limit)\n        if fallback is not None and (fallback not in neigh):\n            neigh.append(fallback)\n        best = None\n        best_cost = float('inf')\n        for p in neigh:\n            # Edge collision check required for candidate parent\n            if self._edge_blocked_memo(p.position, new_pos, obstacles, is_3d):\n                continue\n            c = p.cost + self._dist(p.position, new_pos)\n            if c < best_cost:\n                best_cost = c\n                best = p\n        if best is None:\n            return None, float('inf')\n        return best, best_cost\n\n    def _rewire_local(self, new_node, grid, radius, limit, obstacles, is_3d, edges):\n        neigh = self._neighbors_within(grid, new_node.position, radius, limit * 2)\n        count = 0\n        for n in neigh:\n            if n is new_node or n is new_node.parent:\n                continue\n            # Ensure node validity (node check) before adding edge\n            if self._is_in_obstacle(n.position, obstacles, is_3d):\n                continue\n            new_cost = new_node.cost + self._dist(new_node.position, n.position)\n            if new_cost + 1e-9 < n.cost:\n                # Edge collision check\n                if self._edge_blocked_memo(new_node.position, n.position, obstacles, is_3d):\n                    continue\n                oldp = n.parent\n                if oldp is not None:\n                    oldp.remove_child(n)\n                    self._remove_edge(edges, oldp, n)\n                new_node.add_child(n)\n                n.cost = new_cost\n                edges.append((new_node, n))\n                self._propagate_costs(n)\n                count += 1\n                if count >= limit:\n                    break\n\n    def _propagate_costs(self, node):\n        q = [node]\n        head = 0\n        while head < len(q):\n            cur = q[head]\n            head += 1\n            for ch in cur.children:\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                q.append(ch)\n\n    def _remove_edge(self, edges, a, b):\n        i = 0\n        while i < len(edges):\n            e = edges[i]\n            if e[0] is a and e[1] is b:\n                edges.pop(i)\n                return\n            i += 1\n\n    # Path utilities\n    def _merge_paths(self, a_node, b_node):\n        pa = a_node.path_to_root()\n        pb = b_node.path_to_root()\n        pb.reverse()\n        return pa + pb\n\n    def _path_length(self, path):\n        if len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _los_collapse(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        anchor = path[0]\n        i = 1\n        while i < len(path) - 1:\n            nxt = path[i + 1]\n            if self._edge_blocked_memo(anchor, nxt, obstacles, is_3d):\n                out.append(path[i])\n                anchor = path[i]\n            i += 1\n        out.append(path[-1])\n        return out\n\n    def _shortcut(self, path, obstacles, is_3d, attempts):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        tries = 0\n        while tries < attempts and len(pts) >= 3:\n            i = int(self._uniform(0, len(pts) - 2))\n            j = int(self._uniform(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked_memo(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n            tries += 1\n        return pts\n\n    # Sampling\n    def _sample_guided(self, best_len, base_w, obstacles, is_3d):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            return self._sample_informed(best_len, obstacles, is_3d)\n        r2 = self._rand()\n        if r2 < self.goal_bias:\n            return self.goal if self._rand() < 0.5 else self.start\n        if r2 < self.goal_bias + self.corridor_bias:\n            return self._sample_corridor(base_w, obstacles, is_3d)\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_free(self, obstacles, is_3d):\n        for _ in range(60):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        if self.dim == 3:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5, self.bounds[2] * 0.5)\n        else:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5)\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        tries = 0\n        while tries < 24:\n            if self.dim == 3:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz > width * width:\n                    tries += 1\n                    continue\n                p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n            else:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy > width * width:\n                    tries += 1\n                    continue\n                p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n            tries += 1\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d):\n        # rejection inside prolate ellipse: dist to foci sum <= best_len\n        for _ in range(48):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if (self._dist(p, self.start) + self._dist(p, self.goal) <= best_len and\n                not self._is_in_obstacle(p, obstacles, is_3d)):\n                return p\n        # fallback to corridor\n        width = max(self.step_size, 0.2 * self._dist(self.start, self.goal))\n        return self._sample_corridor(width, obstacles, is_3d)\n\n    # Utility\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._collect_ring(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    def _partial_sort(self, arr, k):\n        # Select k smallest (by first element) using simple passes; k is small\n        k = min(k, len(arr))\n        i = 0\n        while i < k:\n            best_i = i\n            best_v = arr[i][0]\n            j = i + 1\n            while j < len(arr):\n                if arr[j][0] < best_v:\n                    best_v = arr[j][0]\n                    best_i = j\n                j += 1\n            if best_i != i:\n                tmp = arr[i]\n                arr[i] = arr[best_i]\n                arr[best_i] = tmp\n            i += 1",
          "objective": -26.09838,
          "time_improvement": 36.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1406.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019464588165283202,
                    "num_nodes_avg": 55.6,
                    "path_length_avg": 173.2831488382647,
                    "smoothness_avg": 0.041864776057241024,
                    "success_improvement": 0.0,
                    "time_improvement": 29.429744300770967,
                    "node_improvement": 85.99848904558046,
                    "length_improvement": 5.02076027453894,
                    "smoothness_improvement": 555.2746561121082,
                    "objective_score": 14.617752735515195
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.054977035522460936,
                    "num_nodes_avg": 127.8,
                    "path_length_avg": 233.0354877168877,
                    "smoothness_avg": 0.09164623398970691,
                    "success_improvement": 0.0,
                    "time_improvement": 66.77702072848665,
                    "node_improvement": 91.41302156823221,
                    "length_improvement": 22.206046645499416,
                    "smoothness_improvement": 2258.1236106693527,
                    "objective_score": 44.6473522591924
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04646706581115723,
                    "num_nodes_avg": 100.0,
                    "path_length_avg": 128.30372969205285,
                    "smoothness_avg": 0.11834256261777662,
                    "success_improvement": 0.0,
                    "time_improvement": 10.438097251294163,
                    "node_improvement": 87.28544183089637,
                    "length_improvement": 14.786771905604216,
                    "smoothness_improvement": 1405.3086613587855,
                    "objective_score": 19.030035625544706
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "SPARK-Connect BiRRT: Spatially-Partitioned ANN RRT-Connect with Probe-Commit extension. It speeds planning via fine obstacle spatial hashing, ring-based approximate nearest with k-candidate early stop, adaptive long-step line-of-sight motions, and a probe-then-commit connect that validates a short multi-step bridge without bloating the opposite tree. A fast greedy visibility prune plus a few shortcuts returns a short, smooth path with minimal overhead.",
          "planning_mechanism": "Mechanism: Alternate expanding start/goal trees. Each iteration samples (goal/line/uniform), finds a near neighbor via hashed rings, and moves by a direct LOS long step or a capped step; insert only after node/edge checks. Then probe-connect the other tree toward the new node for up to K steps, validating nodes/edges but committing nodes only if the full bridge succeeds; on success, merge paths, prune by LOS, lightly shortcut, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=7.0,\n                 goal_bias=0.35,\n                 line_bias=0.25,\n                 k_nn=12,\n                 r_limit=4,\n                 connect_steps=12,\n                 smoothing_iters=6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.k_nn = k_nn\n        self.r_limit = r_limit\n        self.connect_steps = connect_steps\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self._is_3d = False\n\n        # RNG\n        self._lcg_state = 2463534242\n\n        # Obstacle spatial hash\n        self._obs_grid = {}\n        self._obstacles = []\n        self._obs_cell = 8.0\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self._is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        self._obstacles = list(map.obstacles)\n\n        # RNG reset\n        self._lcg_state = 2463534242\n\n        # Build obstacle spatial hash with finer resolution\n        min_side = min(self.bounds)\n        self._obs_cell = max(4.0, self.step_size, min_side / 40.0)\n        self._build_obstacle_grid()\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obstacles(start) or self._point_in_obstacles(goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight line\n        if not self._edge_blocked(start, goal):\n            n0 = Node(start)\n            n1 = Node(goal, parent=n0, cost=self._dist(start, goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [start, goal], [n0, n1], [(n0, n1)])\n\n        # Trees and node grids\n        node_cell = max(1.0, self.step_size * 0.9)\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges_all = []\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root, node_cell)\n        self._grid_add(grid_goal, goal_root, node_cell)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = goal if active_start else start\n\n            # Sampling: goal bias, line-of-sight line bias, else uniform free\n            r = self._rand()\n            if r < self.goal_bias:\n                x_rand = root_other\n            elif r < self.goal_bias + self.line_bias:\n                x_rand = self._sample_on_line(start, goal)\n            else:\n                x_rand = self._sample_free()\n\n            nearest = self._nearest_hashed_k(grid_a, tree_a, x_rand, node_cell, self.k_nn, self.r_limit)\n            if nearest is None:\n                continue\n\n            # Try long step directly to sample if visible; else capped step\n            d_ns = self._dist(nearest.position, x_rand)\n            long_ok = (d_ns <= self.step_size * 2.5) and (not self._edge_blocked(nearest.position, x_rand))\n            new_pos = x_rand if long_ok else self._steer(nearest.position, x_rand, self.step_size)\n\n            # Bounds and collision checks before insertion\n            if not self._in_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if self._edge_blocked(nearest.position, new_pos):\n                continue\n            if self._near_dup(grid_a, new_pos, node_cell, max(0.1 * self.step_size, 1e-6)):\n                continue\n\n            # Insert node\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            edges_all.append((nearest, new_node))\n            self._grid_add(grid_a, new_node, node_cell)\n\n            # Quick direct-goal hook\n            if not self._edge_blocked(new_node.position, root_other) and self._dist(new_node.position, root_other) <= self.step_size * self.connect_steps:\n                # Probe-connect directly to the root of the opposite tree\n                meet = self._probe_connect(tree_b, grid_b, root_other, node_cell, self.connect_steps)\n                if meet is not None:\n                    # If probe-connect succeeded to the root line, also ensure cross-edge free\n                    if not self._edge_blocked(new_node.position, meet.position):\n                        path = self._extract_path(new_node, meet, active_start)\n                        path = self._visibility_prune(path)\n                        path = self._shortcut_smooth(path, self.smoothing_iters)\n                        edges_all.append((meet, new_node))\n                        return PlannerResult(True, path, start_tree + goal_tree, edges_all)\n\n            # Probe-then-commit connect from other tree toward new_node\n            meet = self._probe_connect(tree_b, grid_b, new_node.position, node_cell, self.connect_steps)\n            if meet is not None:\n                if not self._edge_blocked(new_node.position, meet.position):\n                    # Commit cross-edge for reporting\n                    edges_all.append((meet, new_node))\n                    path = self._extract_path(new_node, meet, active_start)\n                    path = self._visibility_prune(path)\n                    path = self._shortcut_smooth(path, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges_all)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges_all)\n\n    # ---------------- RNG ----------------\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------- Geometry --------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / max(d, 1e-9)\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # --------- Obstacle grid -------------\n    def _obs_key(self, p):\n        if self._is_3d:\n            return (int(p[0] // self._obs_cell), int(p[1] // self._obs_cell), int(p[2] // self._obs_cell))\n        else:\n            return (int(p[0] // self._obs_cell), int(p[1] // self._obs_cell))\n\n    def _build_obstacle_grid(self):\n        self._obs_grid = {}\n        cell = self._obs_cell\n        if self._is_3d:\n            for idx, o in enumerate(self._obstacles):\n                x, y, z, w, h, d = o\n                x0 = int(x // cell); x1 = int((x + w) // cell)\n                y0 = int(y // cell); y1 = int((y + h) // cell)\n                z0 = int(z // cell); z1 = int((z + d) // cell)\n                for i in range(x0, x1 + 1):\n                    for j in range(y0, y1 + 1):\n                        for k in range(z0, z1 + 1):\n                            self._obs_grid.setdefault((i, j, k), []).append(idx)\n        else:\n            for idx, o in enumerate(self._obstacles):\n                x, y, w, h = o\n                x0 = int(x // cell); x1 = int((x + w) // cell)\n                y0 = int(y // cell); y1 = int((y + h) // cell)\n                for i in range(x0, x1 + 1):\n                    for j in range(y0, y1 + 1):\n                        self._obs_grid.setdefault((i, j), []).append(idx)\n\n    def _point_in_obstacles(self, p):\n        key = self._obs_key(p)\n        idxs = self._obs_grid.get(key, [])\n        if self._is_3d:\n            px, py, pz = p\n            for idx in idxs:\n                x, y, z, w, h, d = self._obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = p\n            for idx in idxs:\n                x, y, w, h = self._obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_candidates(self, a, b):\n        cell = self._obs_cell\n        if self._is_3d:\n            minx = min(a[0], b[0]); maxx = max(a[0], b[0])\n            miny = min(a[1], b[1]); maxy = max(a[1], b[1])\n            minz = min(a[2], b[2]); maxz = max(a[2], b[2])\n            x0 = int(minx // cell); x1 = int(maxx // cell)\n            y0 = int(miny // cell); y1 = int(maxy // cell)\n            z0 = int(minz // cell); z1 = int(maxz // cell)\n            seen = set()\n            res = []\n            for i in range(x0, x1 + 1):\n                for j in range(y0, y1 + 1):\n                    for k in range(z0, z1 + 1):\n                        lst = self._obs_grid.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                if idx not in seen:\n                                    seen.add(idx)\n                                    res.append(idx)\n            return res\n        else:\n            minx = min(a[0], b[0]); maxx = max(a[0], b[0])\n            miny = min(a[1], b[1]); maxy = max(a[1], b[1])\n            x0 = int(minx // cell); x1 = int(maxx // cell)\n            y0 = int(miny // cell); y1 = int(maxy // cell)\n            seen = set()\n            res = []\n            for i in range(x0, x1 + 1):\n                for j in range(y0, y1 + 1):\n                    lst = self._obs_grid.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            if idx not in seen:\n                                seen.add(idx)\n                                res.append(idx)\n            return res\n\n    def _edge_blocked(self, a, b):\n        cand = self._segment_candidates(a, b)\n        if not cand:\n            return False\n        if self._is_3d:\n            for idx in cand:\n                x, y, z, w, h, d = self._obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n        else:\n            for idx in cand:\n                x, y, w, h = self._obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x, y), (x + w, y + h)):\n                    return True\n        return False\n\n    def _seg_aabb_intersect(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(self.dim):\n            a = p0[i]\n            b = p1[i]\n            d = b - a\n            if abs(d) < 1e-12:\n                if a < bmin[i] or a > bmax[i]:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (bmin[i] - a) * inv\n                t2 = (bmax[i] - a) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return (tmin <= tmax) and (tmax >= 0.0) and (tmin <= 1.0)\n\n    # ------------- Sampling --------------\n    def _sample_free(self):\n        for _ in range(64):\n            if self._is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._point_in_obstacles(p):\n                return p\n        while True:\n            if self._is_3d:\n                p = (self.bounds[0] * self._rand(),\n                     self.bounds[1] * self._rand(),\n                     self.bounds[2] * self._rand())\n            else:\n                p = (self.bounds[0] * self._rand(),\n                     self.bounds[1] * self._rand())\n            if not self._point_in_obstacles(p):\n                return p\n\n    def _sample_on_line(self, s, g):\n        t = self._rand()\n        p = tuple(s[i] + (g[i] - s[i]) * t for i in range(self.dim))\n        p = self._clamp(p)\n        if not self._point_in_obstacles(p):\n            return p\n        return self._sample_free()\n\n    # ------------- Node grid -------------\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        res = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        res.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            res.extend(b)\n        return res\n\n    def _nearest_hashed_k(self, grid, tree, pos, cell, k_nn, r_limit):\n        key = self._grid_key(pos, cell)\n        best = None\n        bestd = float('inf')\n        seen = 0\n        for r in range(0, r_limit + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    seen += 1\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if seen >= k_nn:\n                    break\n        if best is not None:\n            return best\n        # fallback random probing\n        if tree:\n            trials = min(24, len(tree))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(tree)))\n                n = tree[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _near_dup(self, grid, pos, cell, radius):\n        key = self._grid_key(pos, cell)\n        cand = self._grid_ring_collect(grid, key, 1)\n        rr = max(radius, 1e-6)\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # ------------- Connect & Path -------------\n    def _probe_connect(self, tree_b, grid_b, target, cell, max_steps):\n        # Identify anchor in other tree\n        cur = self._nearest_hashed_k(grid_b, tree_b, target, cell, self.k_nn, self.r_limit)\n        if cur is None:\n            return None\n        # Simulate steps without committing; collect positions\n        path_positions = []\n        steps = 0\n        cur_pos = cur.position\n        while steps < max_steps:\n            if self._dist(cur_pos, target) <= self.step_size:\n                # Final leg must be collision-free; target point already validated on insertion\n                if not self._edge_blocked(cur_pos, target):\n                    # Commit buffered positions as nodes now\n                    last_node = cur\n                    for p in path_positions:\n                        if self._point_in_obstacles(p):\n                            return None\n                        if self._edge_blocked(last_node.position, p):\n                            return None\n                        nxt = Node(p, parent=last_node, cost=last_node.cost + self._dist(last_node.position, p))\n                        last_node.add_child(nxt)\n                        tree_b.append(nxt)\n                        self._grid_add(grid_b, nxt, cell)\n                        last_node = nxt\n                    return last_node\n                else:\n                    return None\n            nxt_pos = self._steer(cur_pos, target, self.step_size)\n            if not self._in_bounds(nxt_pos):\n                return None\n            # Validate both node and edge during probing\n            if self._point_in_obstacles(nxt_pos):\n                return None\n            if self._edge_blocked(cur_pos, nxt_pos):\n                return None\n            path_positions.append(nxt_pos)\n            cur_pos = nxt_pos\n            steps += 1\n        return None\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    # ------------- Smoothing -------------\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            took = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j]):\n                    res.append(path[j])\n                    i = j\n                    took = True\n                    break\n                j -= 1\n            if not took:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, iters):\n        if len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 2, n))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j - 1]\n            if not self._edge_blocked(a, b):\n                pts = pts[:i + 1] + pts[j - 1:]\n        return pts",
          "objective": -25.89225,
          "time_improvement": 40.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 1733.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02574169635772705,
                    "num_nodes_avg": 82.0,
                    "path_length_avg": 174.94928838355008,
                    "smoothness_avg": 0.05819164945651465,
                    "success_improvement": 0.0,
                    "time_improvement": 6.6716398687143785,
                    "node_improvement": 79.35028959959708,
                    "length_improvement": 4.107522788097411,
                    "smoothness_improvement": 810.825679183794,
                    "objective_score": 8.52013402939173
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03158848285675049,
                    "num_nodes_avg": 130.0,
                    "path_length_avg": 252.78312828781904,
                    "smoothness_avg": 0.12274002489065365,
                    "success_improvement": 0.0,
                    "time_improvement": 80.91087485538182,
                    "node_improvement": 91.26520190821743,
                    "length_improvement": 15.613715818604735,
                    "smoothness_improvement": 3058.189246503047,
                    "objective_score": 48.93243818029262
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.034743332862854005,
                    "num_nodes_avg": 190.0,
                    "path_length_avg": 141.35503508266783,
                    "smoothness_avg": 0.112304722040054,
                    "success_improvement": 0.0,
                    "time_improvement": 33.034743108705186,
                    "node_improvement": 75.84233947870311,
                    "length_improvement": 6.1187163015357005,
                    "smoothness_improvement": 1328.5077748771862,
                    "objective_score": 20.224191587918906
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -25.748381214705063,
          "time_improvement": 87.0,
          "length_improvement": -1.0,
          "smoothness_improvement": 66.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0027012348175048826,
                    "num_nodes_avg": 63.9,
                    "path_length_avg": 172.25635822358078,
                    "smoothness_avg": 0.011148465868680943,
                    "success_improvement": 0.0,
                    "time_improvement": 89.40642189739663,
                    "node_improvement": 83.90833543188114,
                    "length_improvement": 5.5835604809856925,
                    "smoothness_improvement": 74.49770012597358,
                    "objective_score": 30.54455135844027
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.010209250450134277,
                    "num_nodes_avg": 240.4,
                    "path_length_avg": 302.26366463445993,
                    "smoothness_avg": 0.006453038743054631,
                    "success_improvement": 0.0,
                    "time_improvement": 93.62707825364559,
                    "node_improvement": 83.84734260565746,
                    "length_improvement": -0.9043114321748058,
                    "smoothness_improvement": 66.04133479473131,
                    "objective_score": 27.87574329076245
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010564541816711426,
                    "num_nodes_avg": 191.9,
                    "path_length_avg": 163.11362081791123,
                    "smoothness_avg": 0.012350799571145165,
                    "success_improvement": 0.0,
                    "time_improvement": 78.46240962391397,
                    "node_improvement": 75.60076287349014,
                    "length_improvement": -8.332300311300978,
                    "smoothness_improvement": 57.10125890377211,
                    "objective_score": 18.824848994912465
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "QUARK-BiRRTX: Quick Aware Rewiring Kernel for Bi-directional eXtension. A bidirectional, beam-guided planner with hashed-nearest lookup, bounded per-cell growth, and O(1) edge bookkeeping. Each accepted step performs ancestor line-of-sight jump and limited-radius RRT*-style rewiring with full subtree cost updates. A compact LRU-like edge-collision memo reduces expensive checks. Early bridge attempts and micro-connects yield fast convergence; two-pass LOS compaction with bounded shortcutting returns short, smooth paths.",
          "planning_mechanism": "Alternate start/goal tree growth. For each side, draw a tiny beam of samples from a goal/corridor/uniform mix, switching to an informed ellipse after a path is found. Choose the candidate that minimizes f = cost-to-come + distance to the opposite tree. Before insertion, enforce both node and edge collision checks. After insertion, try an ancestor LOS jump and locally rewire cheaper neighbors (with subtree cost updates) to improve length. Attempt a direct bridge or a few greedy steps from the opposite tree; on success, extract and lightly smooth via two-pass LOS and shortcutting.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self,\n                 max_iter=2500,\n                 step_size=10.0,\n                 collision_step=1.0,\n                 beam_k=3,\n                 goal_bias=0.18,\n                 corridor_bias=0.55,\n                 informed_bias=0.65,\n                 grid_cell=None,\n                 max_rings=3,\n                 dupe_radius_ratio=0.45,\n                 min_sep_ratio=0.30,\n                 cell_expand_limit=2,\n                 anchor_stride=20,\n                 connect_attempts=2,\n                 compress_depth=2,\n                 rewire_radius_ratio=1.75,\n                 rewire_max=12,\n                 smoothing_iters=20,\n                 edge_cache_max=20000):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_step = collision_step\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.informed_bias = informed_bias\n        self.grid_cell = grid_cell\n        self.max_rings = max_rings\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.min_sep_ratio = min_sep_ratio\n        self.cell_expand_limit = max(1, int(cell_expand_limit))\n        self.anchor_stride = max(1, int(anchor_stride))\n        self.connect_attempts = max(1, int(connect_attempts))\n        self.compress_depth = max(1, int(compress_depth))\n        self.rewire_radius_ratio = rewire_radius_ratio\n        self.rewire_max = max(1, int(rewire_max))\n        self.smoothing_iters = smoothing_iters\n        self.edge_cache_max = max(1000, int(edge_cache_max))\n\n        # runtime\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.cache_bin = 1.0\n        self.edge_cache = None\n        self.edge_order = None  # insertion order for pruning\n\n        self.start = None\n        self.goal = None\n\n        # edges bookkeeping\n        self.edges = None\n        self.edge_index = None  # (id(parent), id(child)) -> index\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # setup discretizations\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.9 * self.step_size)\n        self.edge_res = max(0.75, min(self.collision_step, max(0.5, self.step_size * 0.5)))\n        self.cache_bin = max(1.0, self.edge_res)\n        self.edge_cache = {}\n        self.edge_order = []\n\n        # validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # early straight connection\n        if not self._edge_blocked_memo(self.start, self.goal, obstacles, is_3d):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # initialize trees and structures\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        self.edges = []\n        self.edge_index = {}\n\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        anchors_a, anchors_b = [start_root], [goal_root]\n        cell_expands_a, cell_expands_b = {}, {}\n\n        best_path_len = float('inf')\n        d_sg = self._dist(self.start, self.goal)\n        base_corridor_w = max(self.step_size, 0.2 * d_sg)\n        rewire_radius = max(self.step_size * self.rewire_radius_ratio, self.step_size + 1.0)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            anchors1 = anchors_a if active_start else anchors_b\n            anchors2 = anchors_b if active_start else anchors_a\n            throttles1 = cell_expands_a if active_start else cell_expands_b\n            throttles2 = cell_expands_b if active_start else cell_expands_a\n            other_root = self.goal if active_start else self.start\n\n            best_parent = None\n            best_new = None\n            best_score = float('inf')\n\n            # micro-beam sampling and selection\n            for _ in range(self.beam_k):\n                r = self._rand()\n                if best_path_len < float('inf') and r < self.informed_bias:\n                    x_rand = self._sample_informed(best_path_len, obstacles, is_3d)\n                else:\n                    r2 = self._rand()\n                    if r2 < self.goal_bias:\n                        x_rand = other_root\n                    elif r2 < self.goal_bias + self.corridor_bias:\n                        width = base_corridor_w\n                        if best_path_len < float('inf'):\n                            slack = max(0.0, best_path_len - d_sg)\n                            width = max(self.step_size, 0.2 * slack + base_corridor_w)\n                        x_rand = self._sample_corridor(width, obstacles, is_3d)\n                    else:\n                        x_rand = self._sample_free(obstacles, is_3d)\n\n                near = self._nearest_hashed(grid1, tree1, anchors1, x_rand)\n                if near is None:\n                    continue\n\n                new_pos = self._steer(near.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                # Both checks: node validity and edge validity\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._edge_blocked_memo(near.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # duplicate suppression and per-cell throttle\n                if self._dist(near.position, new_pos) < self.step_size * self.min_sep_ratio:\n                    continue\n                if self._exists_close(grid1, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                kcell = self._grid_key(new_pos)\n                if throttles1.get(kcell, 0) >= self.cell_expand_limit:\n                    continue\n\n                other_near = self._nearest_hashed(grid2, tree2, anchors2, new_pos)\n                to_other = self._dist(new_pos, other_near.position) if other_near is not None else self._dist(new_pos, other_root)\n                g = near.cost + self._dist(near.position, new_pos)\n                score = to_other + 0.05 * g\n                if score < best_score:\n                    best_score = score\n                    best_parent = near\n                    best_new = new_pos\n\n            if best_parent is None:\n                continue\n\n            # Final validity before insertion (both checks)\n            if self._is_in_obstacle(best_new, obstacles, is_3d):\n                continue\n            if self._edge_blocked_memo(best_parent.position, best_new, obstacles, is_3d):\n                continue\n\n            # Insert node\n            new_cost = best_parent.cost + self._dist(best_parent.position, best_new)\n            new_node = Node(best_new, best_parent, new_cost)\n            best_parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            self._edge_add(best_parent, new_node)\n            self._grid_add(grid1, new_node)\n            kc = self._grid_key(best_new)\n            throttles1[kc] = throttles1.get(kc, 0) + 1\n            if len(tree1) % self.anchor_stride == 0:\n                anchors1.append(new_node)\n\n            # Ancestor LOS jump (compression)\n            self._compress_to_ancestors(new_node, obstacles, is_3d)\n\n            # Local RRT*-style rewiring around new_node\n            self._local_rewire(new_node, grid1, obstacles, is_3d, rewire_radius, self.rewire_max)\n\n            # Try direct bridge to nearest in other tree\n            other_near = self._nearest_hashed(grid2, tree2, anchors2, new_node.position)\n            if other_near is not None and not self._edge_blocked_memo(new_node.position, other_near.position, obstacles, is_3d):\n                path = self._extract_path(new_node, other_near)\n                best_path_len = self._path_length(path)\n                path = self._smooth_path(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, nodes, self.edges)\n\n            # Short greedy connect from the other side\n            p = other_near\n            attempts = 0\n            while p is not None and attempts < self.connect_attempts:\n                step_pos = self._steer(p.position, new_node.position, self.step_size)\n                if not self._in_bounds(step_pos):\n                    break\n                # Both checks: node and edge\n                if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._exists_close(grid2, step_pos, self.step_size * self.dupe_radius_ratio):\n                    break\n                if self._edge_blocked_memo(p.position, step_pos, obstacles, is_3d):\n                    break\n\n                q = Node(step_pos, p, p.cost + self._dist(p.position, step_pos))\n                p.add_child(q)\n                tree2.append(q)\n                nodes.append(q)\n                self._edge_add(p, q)\n                self._grid_add(grid2, q)\n                throttles2[self._grid_key(step_pos)] = throttles2.get(self._grid_key(step_pos), 0) + 1\n                if len(tree2) % self.anchor_stride == 0:\n                    anchors2.append(q)\n\n                # small ancestor compression\n                self._compress_to_ancestors(q, obstacles, is_3d)\n\n                if not self._edge_blocked_memo(new_node.position, q.position, obstacles, is_3d):\n                    path = self._extract_path(new_node, q)\n                    best_path_len = self._path_length(path)\n                    path = self._smooth_path(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, nodes, self.edges)\n\n                p = q\n                attempts += 1\n\n        return PlannerResult(False, [], nodes, self.edges)\n\n    # RNG\n    def _rand(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp_tuple(to_pos)\n        if d <= 1e-12:\n            return self._clamp_tuple(from_pos)\n        r = step / d\n        return self._clamp_tuple(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Edge memo (blocked and free) with simple FIFO pruning\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked_memo(self, a, b, obstacles, is_3d):\n        key = self._edge_key_q(a, b)\n        state = self.edge_cache.get(key)\n        if state is not None:\n            return state == 1\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d)\n        self.edge_cache[key] = 1 if blocked else 2\n        self.edge_order.append(key)\n        if len(self.edge_cache) > self.edge_cache_max:\n            self._prune_edge_cache()\n        return blocked\n\n    def _prune_edge_cache(self):\n        # drop oldest ~20% keys\n        drop = max(1, self.edge_cache_max // 5)\n        count = 0\n        while count < drop and self.edge_order:\n            k = self.edge_order.pop(0)\n            if k in self.edge_cache:\n                del self.edge_cache[k]\n                count += 1\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n        else:\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d):\n        # prolate ellipse: sum of distances to foci <= best_len\n        for _ in range(48):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= best_len and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        return self._sample_corridor(max(self.step_size, 0.2 * self._dist(self.start, self.goal)), obstacles, is_3d)\n\n    # Grid hashing\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, tree, anchors, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # anchor fallback\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # rare: full scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(max(1, radius / self.grid_cell)) + 1\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # Neighbor search for rewiring\n    def _neighbors_in_radius(self, grid, pos, radius, limit):\n        key = self._grid_key(pos)\n        r_cells = int(max(1, radius / self.grid_cell)) + 1\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                out.append((s, n))\n        out.sort(key=lambda x: x[0])\n        return [n for (_, n) in out[:limit]]\n\n    # Compression with subtree cost fix\n    def _compress_to_ancestors(self, node, obstacles, is_3d):\n        cur_parent = node.parent\n        depth = 0\n        while cur_parent is not None and depth < self.compress_depth:\n            gp = cur_parent.parent\n            if gp is None:\n                break\n            # Both checks: node (already free), and new edge LOS\n            if not self._is_in_obstacle(node.position, obstacles, is_3d) and not self._edge_blocked_memo(gp.position, node.position, obstacles, is_3d):\n                # update parent-child relations and edge list\n                cur_parent.remove_child(node)\n                self._edge_remove(cur_parent, node)\n                gp.add_child(node)\n                self._edge_add(gp, node)\n                node.cost = gp.cost + self._dist(gp.position, node.position)\n                self._update_subtree_costs(node)\n                cur_parent = gp\n                depth += 1\n            else:\n                break\n\n    # Rewiring utilities\n    def _is_ancestor(self, maybe_ancestor, node):\n        cur = node\n        while cur is not None:\n            if cur is maybe_ancestor:\n                return True\n            cur = cur.parent\n        return False\n\n    def _local_rewire(self, new_node, grid, obstacles, is_3d, radius, limit):\n        neigh = self._neighbors_in_radius(grid, new_node.position, radius, limit)\n        for nb in neigh:\n            if nb is new_node or self._is_ancestor(nb, new_node):\n                continue\n            new_cost = new_node.cost + self._dist(new_node.position, nb.position)\n            if new_cost + 1e-9 < nb.cost:\n                # Both checks before adding edge (node check redundant but enforced)\n                if self._is_in_obstacle(nb.position, obstacles, is_3d):\n                    continue\n                if self._edge_blocked_memo(new_node.position, nb.position, obstacles, is_3d):\n                    continue\n                old_parent = nb.parent\n                if old_parent is not None:\n                    old_parent.remove_child(nb)\n                    self._edge_remove(old_parent, nb)\n                new_node.add_child(nb)\n                self._edge_add(new_node, nb)\n                nb.cost = new_cost\n                self._update_subtree_costs(nb)\n\n    def _update_subtree_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                stack.append(ch)\n\n    # Edges helpers with O(1) remove\n    def _edge_add(self, parent, child):\n        key = (id(parent), id(child))\n        if key in self.edge_index:\n            return\n        self.edges.append((parent, child))\n        self.edge_index[key] = len(self.edges) - 1\n\n    def _edge_remove(self, parent, child):\n        key = (id(parent), id(child))\n        idx = self.edge_index.get(key)\n        if idx is None:\n            return\n        last_idx = len(self.edges) - 1\n        if idx != last_idx:\n            last_edge = self.edges[last_idx]\n            self.edges[idx] = last_edge\n            self.edge_index[(id(last_edge[0]), id(last_edge[1]))] = idx\n        self.edges.pop()\n        del self.edge_index[key]\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node):\n        path_a = self._path_to_root(a_node)\n        path_b = []\n        cur = b_node\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _smooth_path(self, path, obstacles, is_3d, iters):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        # forward LOS collapse\n        collapsed = [pts[0]]\n        last = pts[0]\n        k = 1\n        while k < len(pts) - 1:\n            nxt = pts[k + 1]\n            if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d):\n                collapsed.append(pts[k])\n                last = pts[k]\n            k += 1\n        collapsed.append(pts[-1])\n        pts = collapsed\n        # backward LOS collapse\n        rev = list(reversed(pts))\n        collapsed = [rev[0]]\n        last = rev[0]\n        k = 1\n        while k < len(rev) - 1:\n            nxt = rev[k + 1]\n            if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d):\n                collapsed.append(rev[k])\n                last = rev[k]\n            k += 1\n        collapsed.append(rev[-1])\n        pts = list(reversed(collapsed))\n        # bounded random shortcutting\n        n_iter = max(1, iters)\n        cur_len = self._path_length(pts)\n        no_improve = 0\n        for _ in range(n_iter):\n            if len(pts) < 3:\n                break\n            i = int(self._uniform(0, len(pts) - 2))\n            j = int(self._uniform(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                continue\n            a, b = pts[i], pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d):\n                new_pts = pts[:i + 1] + pts[j:]\n                new_len = self._path_length(new_pts)\n                if new_len <= cur_len:\n                    pts = new_pts\n                    cur_len = new_len\n                    no_improve = 0\n                else:\n                    no_improve += 1\n            else:\n                no_improve += 1\n            if no_improve >= 8:\n                break\n        return pts",
          "objective": -25.68568,
          "time_improvement": 34.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1787.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03223862648010254,
                    "num_nodes_avg": 63.3,
                    "path_length_avg": 173.81157947496695,
                    "smoothness_avg": 0.053956084390304346,
                    "success_improvement": 0.0,
                    "time_improvement": -16.883444682923802,
                    "node_improvement": 84.05943087383531,
                    "length_improvement": 4.731119069043158,
                    "smoothness_improvement": 744.5298882208475,
                    "objective_score": 1.4962874776529924
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04249320030212402,
                    "num_nodes_avg": 107.5,
                    "path_length_avg": 247.86817642660594,
                    "smoothness_avg": 0.11950558793242956,
                    "success_improvement": 0.0,
                    "time_improvement": 74.32108335050262,
                    "node_improvement": 92.77699388564133,
                    "length_improvement": 17.254468218923027,
                    "smoothness_improvement": 2974.9648538971664,
                    "objective_score": 47.523830205990436
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.028577184677124022,
                    "num_nodes_avg": 82.9,
                    "path_length_avg": 134.63465016939634,
                    "smoothness_avg": 0.13697916693816994,
                    "success_improvement": 0.0,
                    "time_improvement": 44.919546990852965,
                    "node_improvement": 89.4596312778131,
                    "length_improvement": 10.582075970589893,
                    "smoothness_improvement": 1642.36489270315,
                    "objective_score": 28.036934143125574
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -24.971436625701273,
          "time_improvement": 62.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 168.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009481477737426757,
                    "num_nodes_avg": 112.0,
                    "path_length_avg": 170.25136521926942,
                    "smoothness_avg": 0.017004537999713392,
                    "success_improvement": 0.0,
                    "time_improvement": 62.815977978432855,
                    "node_improvement": 71.7955175018887,
                    "length_improvement": 6.682528917796031,
                    "smoothness_improvement": 166.15794564080122,
                    "objective_score": 23.68510047241148
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0245816707611084,
                    "num_nodes_avg": 299.2,
                    "path_length_avg": 258.5973544494462,
                    "smoothness_avg": 0.010851066788952054,
                    "success_improvement": 0.0,
                    "time_improvement": 84.6553804394982,
                    "node_improvement": 79.89652623798965,
                    "length_improvement": 13.67275977263268,
                    "smoothness_improvement": 179.20576418723118,
                    "objective_score": 34.496298816365226
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.030178475379943847,
                    "num_nodes_avg": 287.8,
                    "path_length_avg": 139.5271231166937,
                    "smoothness_avg": 0.020290033291575655,
                    "success_improvement": 0.0,
                    "time_improvement": 38.47611641047452,
                    "node_improvement": 63.40750158931977,
                    "length_improvement": 7.332728393521491,
                    "smoothness_improvement": 158.08772581437248,
                    "objective_score": 16.732910588327112
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "ARROW-Connect: An Adaptive Corridor-Guided BiRRT-Connect that focuses sampling within a start\u2013goal corridor, uses goal bias and a coarse spatial grid for fast nearest queries, performs bounded connect extensions with strict node/edge validity checks, and returns a line-of-sight collapsed and shortcut-smoothed path immediately upon bridging.",
          "planning_mechanism": "Mechanism: Alternate tree growth; sample from a corridor/goal/uniform mixture; steer once from the nearest and insert if valid; then attempt a capped RRT-Connect from the opposite tree toward the new node; on a successful bridge, assemble start\u2013bridge\u2013goal, apply LOS collapse and a few shortcuts, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        for c in self.children:\n            if c is child:\n                return\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.25,\n                 corridor_bias=0.55,\n                 corridor_margin=20.0,\n                 grid_cell=None,\n                 cell_cap=24,\n                 connect_steps=8,\n                 edge_res=1.0,\n                 smoothing_attempts=60):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.corridor_margin = float(corridor_margin)\n        self.grid_cell = grid_cell\n        self.cell_cap = int(cell_cap)\n        self.connect_steps = int(connect_steps)\n        self.edge_res = float(edge_res)\n        self.smoothing_attempts = int(smoothing_attempts)\n\n        self.dim = 2\n        self.bounds = None\n        self._rng = 1469598103934665603  # simple 64-bit state\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Quick straight-line solution\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            n0 = Node(start, None, 0.0)\n            n1 = Node(goal, n0, self._dist(start, goal))\n            n0.add_child(n1)\n            nodes = [n0, n1]\n            edges = [(n0, n1)]\n            return PlannerResult(True, [start, goal], nodes, edges)\n\n        # Setup\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size)\n        self.edge_res = max(0.5, min(self.edge_res, max(0.5, 0.5 * self.step_size)))\n\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a, grid_b = {}, {}\n        count_a, count_b = {}, {}\n\n        self._grid_add(grid_a, count_a, start_root)\n        self._grid_add(grid_b, count_b, goal_root)\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            count1 = count_a if active_start else count_b\n            count2 = count_b if active_start else count_a\n            other_root_pos = goal if active_start else start\n\n            # Sample from corridor/goal/uniform\n            r = self._rand()\n            if r < self.goal_bias:\n                sample = other_root_pos\n            elif r < self.goal_bias + self.corridor_bias:\n                sample = self._sample_corridor(start, goal, obstacles, is_3d)\n            else:\n                sample = self._sample_free(obstacles, is_3d)\n\n            # Nearest and single-step steer\n            near = self._nearest(grid1, tree1, sample)\n            new_pos = self._steer(near.position, sample, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            # Node and edge validity before adding\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked(near.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Per-cell cap\n            cell_key = self._grid_key(new_pos)\n            if count1.get(cell_key, 0) >= self.cell_cap:\n                continue\n\n            # Insert node into active tree\n            new_node = Node(new_pos, near, near.cost + self._dist(near.position, new_pos))\n            near.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            self._grid_add(grid1, count1, new_node)\n            edges.append((near, new_node))\n\n            # Try bounded RRT-Connect from the opposite tree toward new_node\n            bridger = self._nearest(grid2, tree2, new_node.position)\n            last = bridger\n            success = False\n            for _ in range(self.connect_steps):\n                step_pos = self._steer(last.position, new_node.position, self.step_size)\n                if not self._in_bounds(step_pos):\n                    break\n                if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._edge_blocked(last.position, step_pos, obstacles, is_3d):\n                    break\n                # Per-cell cap for other tree\n                if count2.get(self._grid_key(step_pos), 0) >= self.cell_cap:\n                    break\n                # Commit step in opposite tree\n                step_node = Node(step_pos, last, last.cost + self._dist(last.position, step_pos))\n                last.add_child(step_node)\n                tree2.append(step_node)\n                nodes.append(step_node)\n                self._grid_add(grid2, count2, step_node)\n                edges.append((last, step_node))\n                last = step_node\n                # Check if we can directly bridge now\n                if not self._edge_blocked(last.position, new_node.position, obstacles, is_3d):\n                    # Add the bridge edge (existing nodes, so only edge check required)\n                    edges.append((last, new_node))\n                    # Assemble start to goal path\n                    if active_start:\n                        path_a = self._path_to_root(new_node)           # start..new_node\n                        path_b = self._path_to_root(last)               # goal..last\n                        tail = list(reversed(path_b))                   # last..goal\n                    else:\n                        path_a = self._path_to_root(last)               # start..last\n                        path_b = self._path_to_root(new_node)           # goal..new_node\n                        tail = list(reversed(path_b))                   # new_node..goal\n                    # Merge: path_a + [opposite end] + tail[1:]\n                    merged = []\n                    for p in path_a:\n                        if not merged or merged[-1] != p:\n                            merged.append(p)\n                    if merged[-1] != last.position if active_start else new_node.position:\n                        merged.append(last.position if active_start else new_node.position)\n                    for i in range(1, len(tail)):\n                        if merged[-1] != tail[i]:\n                            merged.append(tail[i])\n                    # Smooth\n                    merged = self._forward_los_collapse(merged, obstacles, is_3d)\n                    merged = self._shortcut(merged, obstacles, is_3d, self.smoothing_attempts)\n                    return PlannerResult(True, merged, nodes, edges)\n            # continue iterations if not bridged\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG and math utilities\n    def _rand(self):\n        # xorshift64*\n        x = self._rng & 0xFFFFFFFFFFFFFFFF\n        x ^= (x >> 12) & 0xFFFFFFFFFFFFFFFF\n        x ^= (x << 25) & 0xFFFFFFFFFFFFFFFF\n        x ^= (x >> 27) & 0xFFFFFFFFFFFFFFFF\n        self._rng = (x * 2685821657736338717) & 0xFFFFFFFFFFFFFFFF\n        return (self._rng % 1000003) / 1000003.0\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    # Bounds and validity\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        steps = int(max(1, d / max(1e-9, self.edge_res)))\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if not self._in_bounds(p) or self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Spatial grid\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, count, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n            count[k] = 1\n        else:\n            lst.append(node)\n            count[k] = count.get(k, 0) + 1\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, 3):\n            cand = self._collect_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        for _ in range(80):\n            if is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # fallback center\n        if is_3d:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5, self.bounds[2] * 0.5)\n        else:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5)\n\n    def _sample_corridor(self, start, goal, obstacles, is_3d):\n        # Axis-aligned corridor box around the line segment [start, goal]\n        mins = [min(start[i], goal[i]) - self.corridor_margin for i in range(self.dim)]\n        maxs = [max(start[i], goal[i]) + self.corridor_margin for i in range(self.dim)]\n        for i in range(self.dim):\n            mins[i] = max(0.0, mins[i])\n            maxs[i] = min(self.bounds[i], maxs[i])\n        for _ in range(60):\n            if is_3d:\n                p = (self._uniform(mins[0], maxs[0]),\n                     self._uniform(mins[1], maxs[1]),\n                     self._uniform(mins[2], maxs[2]))\n            else:\n                p = (self._uniform(mins[0], maxs[0]),\n                     self._uniform(mins[1], maxs[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        return self._sample_free(obstacles, is_3d)\n\n    # Geometry helpers\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp_tuple(b)\n        if d <= 1e-12:\n            return self._clamp_tuple(a)\n        r = step / d\n        return self._clamp_tuple(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _forward_los_collapse(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        anchor_idx = 0\n        j = 2\n        while j < len(path):\n            if self._edge_blocked(path[anchor_idx], path[j], obstacles, is_3d):\n                out.append(path[j - 1])\n                anchor_idx = j - 1\n            j += 1\n        out.append(path[-1])\n        return out\n\n    def _shortcut(self, path, obstacles, is_3d, attempts):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and n >= 3:\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n            tries += 1\n        return pts",
          "objective": -24.88507,
          "time_improvement": 29.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1613.0,
          "node_improvement": 69.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013300108909606933,
                    "num_nodes_avg": 80.3,
                    "path_length_avg": 175.6350020519091,
                    "smoothness_avg": 0.044724898900033665,
                    "success_improvement": 0.0,
                    "time_improvement": 51.779504471992034,
                    "node_improvement": 79.77839335180055,
                    "length_improvement": 3.7316722606414157,
                    "smoothness_improvement": 600.0417894579745,
                    "objective_score": 20.773063645272334
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03392486572265625,
                    "num_nodes_avg": 220.9,
                    "path_length_avg": 230.76931104129872,
                    "smoothness_avg": 0.10994392939538869,
                    "success_improvement": 0.0,
                    "time_improvement": 79.49898353045592,
                    "node_improvement": 85.15756231942484,
                    "length_improvement": 22.962561648089945,
                    "smoothness_improvement": 2728.9364927548345,
                    "objective_score": 51.27191451176492
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07420210838317871,
                    "num_nodes_avg": 459.2,
                    "path_length_avg": 130.56346782754767,
                    "smoothness_avg": 0.12648503102791364,
                    "success_improvement": 0.0,
                    "time_improvement": -43.01918786461194,
                    "node_improvement": 41.61474888747616,
                    "length_improvement": 13.28596143317528,
                    "smoothness_improvement": 1508.8802585212286,
                    "objective_score": 2.610221793127729
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "FLASH-Connect BiRRT: Fast, Lazy-cached Hashed BiRRT with Bounded Greedy Connect. It accelerates bidirectional planning using a hashed grid nearest search with leader fallback, safe collision caching (exact for frees, quantized only for blocked), frontier-balanced sampling with adaptive goal bias, and a bounded greedy connect that extends the opposite tree in a few validated steps to raise connection success while minimizing checks. A quick visibility prune plus micro-shortcutting produces a short, smooth path with negligible overhead.",
          "planning_mechanism": "Alternate expanding start/goal trees. For each sample (goal/frontier/uniform), find hashed-nearest, steer one step, and insert only if node-free and edge-free. After each insertion, attempt a bounded greedy connect: extend the other tree toward the new node for up to K steps, validating each node and edge; if within reach and line-of-sight holds, extract and lightly smooth the path. Safe caches and early exits reduce collision calls and failed connects, improving planning time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=6.0,\n                 goal_bias=0.25,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=20,\n                 max_per_cell=10,\n                 dup_radius_factor=0.6,\n                 search_r_max=2,\n                 connect_steps=4,\n                 frontier_bias=0.25,\n                 leader_stride=20):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n        self.max_per_cell = max_per_cell\n        self.dup_radius_factor = dup_radius_factor\n        self.search_r_max = search_r_max\n        self.connect_steps = connect_steps\n        self.frontier_bias = frontier_bias\n        self.leader_stride = leader_stride\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        # Caches\n        self._edge_exact_cache = {}        # exact endpoint pairs -> bool (safe for free and blocked)\n        self._edge_blocked_quant = set()   # quantized blocked segments only (safe reuse)\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Derived params\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size * 2.0)\n        self.edge_res = max(0.5, self.collision_step)\n\n        # Reset caches\n        self._edge_exact_cache = {}\n        self._edge_blocked_quant = set()\n        self._lcg_state = 2463534242\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line path\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            path = [start, goal]\n            nodes = [Node(start), Node(goal)]\n            return PlannerResult(True, path, nodes, [])\n\n        # Initialize trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes_all = [start_root, goal_root]\n        edges_all = []\n\n        # Grids and counts\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n        self._grid_add(grid_start, counts_start, start_root)\n        self._grid_add(grid_goal, counts_goal, goal_root)\n\n        # Leaders for fallback NN and frontier sampling\n        leaders_start = [start_root]\n        leaders_goal = [goal_root]\n        ins_since_leader_start = 0\n        ins_since_leader_goal = 0\n\n        # Adaptive goal bias control\n        no_progress = 0\n        best_gap = self._dist(start, goal)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            counts_a = counts_start if active_start else counts_goal\n            counts_b = counts_goal if active_start else counts_start\n            leaders_a = leaders_start if active_start else leaders_goal\n            leaders_b = leaders_goal if active_start else leaders_start\n            root_other = goal if active_start else start\n\n            # Sample: goal bias, frontier-biased around leaders, else uniform free\n            r = self._rand()\n            if r < self.goal_bias:\n                x_rand = root_other\n            elif r < self.goal_bias + self.frontier_bias and leaders_a:\n                x_rand = self._sample_near(leaders_a[int(self._uniform(0, len(leaders_a)))].position,\n                                           radius=self.step_size * 3.0,\n                                           obstacles=obstacles,\n                                           is_3d=is_3d)\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest via hashed grid with leader fallback\n            nearest = self._nearest_hashed(grid_a, leaders_a, tree_a, x_rand)\n            if nearest is None:\n                continue\n\n            # Steer\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Per-cell throttling and duplicate suppression\n            key_new = self._grid_key(new_pos)\n            if self._cell_count(counts_a, key_new) >= self.max_per_cell:\n                continue\n            if self._near_duplicate(grid_a, new_pos, dup_radius=self.dup_radius_factor * self.step_size):\n                continue\n\n            # Insert node and edge\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes_all.append(new_node)\n            edges_all.append((nearest, new_node))\n            self._grid_add(grid_a, counts_a, new_node)\n\n            # Leader updates\n            if active_start:\n                ins_since_leader_start += 1\n                if ins_since_leader_start >= self.leader_stride:\n                    leaders_start.append(new_node)\n                    ins_since_leader_start = 0\n            else:\n                ins_since_leader_goal += 1\n                if ins_since_leader_goal >= self.leader_stride:\n                    leaders_goal.append(new_node)\n                    ins_since_leader_goal = 0\n\n            # Try bounded greedy connect to the other tree\n            meet = self._bounded_connect(new_node, tree_b, grid_b, counts_b, leaders_b, obstacles, is_3d, nodes_all, edges_all)\n            if meet is not None:\n                # Path extraction\n                path = self._extract_path(new_node, meet, a_is_start_tree=active_start)\n                # Quick smoothing\n                path = self._visibility_prune(path, obstacles, is_3d)\n                path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges_all)\n\n            # Adapt goal bias based on progress (gap reduced)\n            near_other = self._nearest_hashed(grid_b, leaders_b, tree_b, new_node.position)\n            if near_other is not None:\n                gap = self._dist(new_node.position, near_other.position)\n                if gap + 1e-6 < best_gap:\n                    best_gap = gap\n                    no_progress = 0\n                else:\n                    no_progress += 1\n            else:\n                no_progress += 1\n            if no_progress > 200:\n                self.goal_bias = min(0.55, self.goal_bias + 0.05)\n                no_progress = 0\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges_all)\n\n    # -------- RNG ----------\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # -------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / max(d, 1e-9)\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # -------- Collision & caches ----------\n    def _quant(self, p, q=2.0):\n        if self.dim == 3:\n            return (int(p[0] // q), int(p[1] // q), int(p[2] // q))\n        else:\n            return (int(p[0] // q), int(p[1] // q))\n\n    def _seg_key_exact(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _seg_key_quant_blocked(self, a, b):\n        qa = self._quant(a)\n        qb = self._quant(b)\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        # Exact cache\n        k = self._seg_key_exact(a, b)\n        cached = self._edge_exact_cache.get(k)\n        if cached is not None:\n            return cached\n        # Quantized blocked reuse\n        kq = self._seg_key_quant_blocked(a, b)\n        if kq in self._edge_blocked_quant:\n            self._edge_exact_cache[k] = True\n            return True\n        # Compute\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_exact_cache[k] = blocked\n        if blocked:\n            self._edge_blocked_quant.add(kq)\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # -------- Sampling ----------\n    def _sample_free(self, obstacles, is_3d):\n        # Bounded attempts to mitigate stalls; then fallback to near-start/goal mid region\n        for _ in range(64):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # Fallback uniformly (still free-checked)\n        while True:\n            if self.dim == 3:\n                p = (self.bounds[0] * self._rand(),\n                     self.bounds[1] * self._rand(),\n                     self.bounds[2] * self._rand())\n            else:\n                p = (self.bounds[0] * self._rand(),\n                     self.bounds[1] * self._rand())\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_near(self, center, radius, obstacles, is_3d):\n        for _ in range(16):\n            if self.dim == 3:\n                dx = (self._rand() * 2.0 - 1.0) * radius\n                dy = (self._rand() * 2.0 - 1.0) * radius\n                dz = (self._rand() * 2.0 - 1.0) * radius\n                p = (center[0] + dx, center[1] + dy, center[2] + dz)\n            else:\n                dx = (self._rand() * 2.0 - 1.0) * radius\n                dy = (self._rand() * 2.0 - 1.0) * radius\n                p = (center[0] + dx, center[1] + dy)\n            p = self._clamp(p)\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        return self._sample_free(obstacles, is_3d)\n\n    # -------- Grid / NN ----------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n\n    def _cell_count(self, counts, key):\n        return counts.get(key, 0)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, leaders, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Local rings\n        for r in range(0, self.search_r_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Leader fallback\n        if leaders:\n            for n in leaders:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            if best is not None:\n                lk = self._grid_key(best.position)\n                for r in range(0, min(2, self.search_r_max) + 1):\n                    cand = self._grid_ring_collect(grid, lk, r)\n                    for n in cand:\n                        d = self._dist(n.position, pos)\n                        if d < bestd:\n                            bestd = d\n                            best = n\n                if best is not None:\n                    return best\n        # Sparse random subset\n        if tree:\n            trials = min(48, len(tree))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(tree)))\n                n = tree[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _near_duplicate(self, grid, pos, dup_radius):\n        key = self._grid_key(pos)\n        cand = self._grid_ring_collect(grid, key, 1)\n        for n in cand:\n            if self._dist(n.position, pos) <= dup_radius:\n                return True\n        return False\n\n    # -------- Connect & Path ----------\n    def _bounded_connect(self, new_node, tree_b, grid_b, counts_b, leaders_b, obstacles, is_3d, nodes_all, edges_all):\n        target = new_node.position\n        cur = self._nearest_hashed(grid_b, leaders_b, tree_b, target)\n        if cur is None:\n            return None\n        # If already within one step and visible, connect immediately\n        if self._dist(cur.position, target) <= self.step_size:\n            if not self._edge_blocked(cur.position, target, obstacles, is_3d):\n                return cur\n        # Greedy extend from other tree toward target with limited steps\n        for _ in range(self.connect_steps):\n            if self._dist(cur.position, target) <= self.step_size:\n                if not self._edge_blocked(cur.position, target, obstacles, is_3d):\n                    return cur\n                else:\n                    break\n            nxt_pos = self._steer(cur.position, target, self.step_size)\n            if not self._in_bounds(nxt_pos):\n                break\n            if self._is_in_obstacle(nxt_pos, obstacles, is_3d):\n                break\n            if self._edge_blocked(cur.position, nxt_pos, obstacles, is_3d):\n                break\n            # Per-cell throttle and dedup for other tree as well\n            k = self._grid_key(nxt_pos)\n            if self._cell_count(counts_b, k) >= self.max_per_cell:\n                break\n            if self._near_duplicate(grid_b, nxt_pos, dup_radius=self.dup_radius_factor * self.step_size):\n                break\n            # Insert into other tree\n            nxt = Node(nxt_pos, parent=cur, cost=cur.cost + self._dist(cur.position, nxt_pos))\n            cur.add_child(nxt)\n            tree_b.append(nxt)\n            nodes_all.append(nxt)\n            edges_all.append((cur, nxt))\n            self._grid_add(grid_b, counts_b, nxt)\n            cur = nxt\n        return None\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -24.28164,
          "time_improvement": 31.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1365.0,
          "node_improvement": 80.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.046230649948120116,
                    "num_nodes_avg": 147.0,
                    "path_length_avg": 186.64979908840695,
                    "smoothness_avg": 0.03913771733685313,
                    "success_improvement": 0.0,
                    "time_improvement": -67.61252589969288,
                    "node_improvement": 62.98161672122892,
                    "length_improvement": -2.305712535691461,
                    "smoothness_improvement": 512.5902652352431,
                    "objective_score": -19.104233965146527
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.034335207939147946,
                    "num_nodes_avg": 178.0,
                    "path_length_avg": 232.43425118913282,
                    "smoothness_avg": 0.0882833073745883,
                    "success_improvement": 0.0,
                    "time_improvement": 79.25101106662305,
                    "node_improvement": 88.0400456897131,
                    "length_improvement": 22.406756704097912,
                    "smoothness_improvement": 2171.593086644217,
                    "objective_score": 48.077322775666744
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010368776321411134,
                    "num_nodes_avg": 92.0,
                    "path_length_avg": 118.40175112398113,
                    "smoothness_avg": 0.1187026504183581,
                    "success_improvement": 0.0,
                    "time_improvement": 80.01493487246768,
                    "node_improvement": 88.30260648442466,
                    "length_improvement": 21.363194588967396,
                    "smoothness_improvement": 1409.888951603265,
                    "objective_score": 43.87184197313707
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "Adaptive Informed Rewire Bi-Connect (AIRB): a fast, robust bidirectional planner that combines adaptive goal/corridor/informed sampling, grid-accelerated nearest lookup, best-parent selection, and local rewiring to improve path length and smoothness. It performs commit-safe expansion with strict node and edge checks, micro-connection toward the opposite tree, and switches to informed sampling once any solution is found. A multi-pass shortcut and string-pull smoother produces short, kink-free paths quickly.",
          "planning_mechanism": "Mechanism: alternate tree growth; sample (goal/corridor/informed), find nearest via grid, steer one step, validate node and edge, choose best parent among nearby neighbors, insert and locally rewire cheaper neighbors, then attempt a short greedy micro-connect to the opposite tree; on any connection, extract and smooth the path; early LOS check and grid hashing minimize wasted work.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        i = -1\n        for k in range(len(self.children)):\n            if self.children[k] is child:\n                i = k\n                break\n        if i >= 0:\n            self.children.pop(i)\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=8.0,\n                 collision_step=1.0,\n                 goal_bias=0.25,\n                 corridor_bias=0.5,\n                 beam_k=2,\n                 grid_cell=None,\n                 rewire_radius_mult=2.5,\n                 connect_steps=3,\n                 min_sep_ratio=0.25,\n                 dupe_radius_ratio=0.6,\n                 max_per_cell=10,\n                 smoothing_iters=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_step = collision_step\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.beam_k = beam_k\n        self.grid_cell = grid_cell\n        self.rewire_radius_mult = rewire_radius_mult\n        self.connect_steps = connect_steps\n        self.min_sep_ratio = min_sep_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.max_per_cell = max_per_cell\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.start = None\n        self.goal = None\n\n    def plan(self, map) -> PlannerResult:\n        # Setup\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size)\n        self.edge_res = max(0.5, min(self.collision_step, 0.5 * self.step_size))\n\n        # Validate start and goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if not self._is_edge_in_obstacle(self.start, self.goal, obstacles, is_3d, self.edge_res):\n            path = [self.start, self.goal]\n            nodes = [Node(self.start), Node(self.goal)]\n            return PlannerResult(True, path, nodes, [])\n\n        # Initialize trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Tunables derived\n        dupe_radius = self.step_size * self.dupe_radius_ratio\n        min_sep = self.step_size * self.min_sep_ratio\n        rewire_radius = max(self.step_size * self.rewire_radius_mult, self.grid_cell * 2.0)\n        dsg = self._dist(self.start, self.goal)\n        base_corridor = max(self.step_size, 0.12 * dsg)\n\n        # Informed sampling variables\n        have_solution = False\n        best_len = float('inf')\n        best_path = []\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = self.goal if active_start else self.start\n\n            # Beam sampling to pick a promising candidate\n            best_cand = None\n            best_score = float('inf')\n            for _ in range(self.beam_k):\n                x_rand = None\n                r = self._rand()\n                if have_solution and r < 0.7:\n                    x_rand = self._sample_informed(best_len, obstacles, is_3d)\n                else:\n                    if r < self.goal_bias:\n                        x_rand = root_other\n                    elif r < self.goal_bias + self.corridor_bias:\n                        x_rand = self._sample_corridor(base_corridor, obstacles, is_3d)\n                    else:\n                        x_rand = self._sample_free(obstacles, is_3d)\n\n                nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n                if nearest is None:\n                    nearest = tree_a[0]\n\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._dist(nearest.position, new_pos) < min_sep:\n                    continue\n                if self._exists_close(grid_a, new_pos, dupe_radius):\n                    continue\n                if not self._grid_can_add(grid_a, new_pos, self.max_per_cell):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                    continue\n\n                # Score by proximity to other tree or goal as a heuristic\n                other_near = self._nearest_grid(grid_b, tree_b, new_pos)\n                if other_near is not None:\n                    score = self._dist(new_pos, other_near.position)\n                else:\n                    score = self._dist(new_pos, root_other)\n                if have_solution:\n                    # Bias toward reducing current best length\n                    score += 0.3 * self._dist(new_pos, root_other)\n                if score < best_score:\n                    best_score = score\n                    best_cand = (nearest, new_pos)\n\n            if best_cand is None:\n                continue\n\n            parent_node, new_pos = best_cand\n\n            # Best-parent selection among neighbors (local RRT* step)\n            best_parent = parent_node\n            best_cost = parent_node.cost + self._dist(parent_node.position, new_pos)\n            neigh = self._neighbors_within(grid_a, new_pos, rewire_radius)\n            for n in neigh:\n                if n is parent_node:\n                    continue\n                # Ensure the connecting edge is collision-free\n                if not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.edge_res):\n                    cand_cost = n.cost + self._dist(n.position, new_pos)\n                    if cand_cost < best_cost:\n                        best_cost = cand_cost\n                        best_parent = n\n\n            # Add node (after both node and edge checks)\n            new_node = Node(new_pos, parent=best_parent, cost=best_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((best_parent, new_node))\n            self._grid_add(grid_a, new_node)\n\n            # Local rewiring: try to improve nearby nodes using new_node\n            for n in neigh:\n                if n is new_node or n is best_parent:\n                    continue\n                # Check if new path via new_node is cheaper and feasible\n                new_cost = new_node.cost + self._dist(new_node.position, n.position)\n                if new_cost + 1e-9 < n.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.edge_res):\n                        # Rewire n to new_node\n                        old_parent = n.parent\n                        if old_parent is not None:\n                            old_parent.remove_child(n)\n                            self._remove_edge(edges, old_parent, n)\n                        new_node.add_child(n)\n                        edges.append((new_node, n))\n                        delta = new_cost - n.cost\n                        n.cost = new_cost\n                        self._update_subtree_costs(n, edges, delta)\n\n            # Try direct connection to other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None and not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                path = self._extract_path(new_node, other_near)\n                path = self._post_smooth(path, obstacles, is_3d)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Micro-connect greedy steps from other tree toward new_node\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, new_node.position, self.step_size)\n                if not self._in_bounds(to_pos):\n                    break\n                if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                    break\n                if self._dist(p.position, to_pos) < min_sep:\n                    break\n                if self._exists_close(grid_b, to_pos, dupe_radius):\n                    break\n                if not self._grid_can_add(grid_b, to_pos, self.max_per_cell):\n                    break\n                if self._is_edge_in_obstacle(p.position, to_pos, obstacles, is_3d, self.edge_res):\n                    break\n\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                edges.append((p, q))\n                self._grid_add(grid_b, q)\n\n                p = q\n                steps += 1\n\n                if not self._is_edge_in_obstacle(new_node.position, p.position, obstacles, is_3d, self.edge_res):\n                    path = self._extract_path(new_node, p)\n                    # Record solution length and enable informed sampling; return early\n                    have_solution = True\n                    best_len = self._path_length(path)\n                    path = self._post_smooth(path, obstacles, is_3d)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        # No path\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # RNG\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        # Sample near the line segment start->goal with bounded lateral noise\n        for _ in range(16):\n            t = self._rand()\n            base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n            if self.dim == 3:\n                p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                     self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                     self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n            else:\n                p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                     self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, c_best, obstacles, is_3d):\n        # Rejection sample inside the prolate ellipse/ellipsoid with foci at start and goal and perimeter/contour length c_best\n        if c_best <= 0.0 or c_best == float('inf'):\n            return self._sample_free(obstacles, is_3d)\n        for _ in range(32):\n            p = self._sample_free(obstacles, is_3d)\n            ds = self._dist(p, self.start)\n            dg = self._dist(p, self.goal)\n            if ds + dg <= c_best + 1e-9:\n                return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # Grid hashing and neighbors\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_bucket_len(self, grid, key):\n        b = grid.get(key)\n        return 0 if b is None else len(b)\n\n    def _grid_can_add(self, grid, pos, cap):\n        key = self._grid_key(pos)\n        return self._grid_bucket_len(grid, key) < cap\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Try small rings; fall back to full scan if needed\n        for r in range(0, 3):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _neighbors_within(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        res = []\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                res.append(n)\n        return res\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                return True\n        return False\n\n    # Edges and costs\n    def _remove_edge(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _update_subtree_costs(self, node, edges, delta):\n        # Propagate cost delta to descendants\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            cur.cost += delta\n            for ch in cur.children:\n                stack.append(ch)\n\n    # Paths and smoothing\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _post_smooth(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        # Random shortcuts\n        for _ in range(self.smoothing_iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        # Multi-pass string pull (deterministic LOS collapse)\n        changed = True\n        while changed:\n            changed = False\n            k = 0\n            while k + 2 < len(pts):\n                a = pts[k]\n                c = pts[k + 2]\n                if not self._is_edge_in_obstacle(a, c, obstacles, is_3d, self.edge_res):\n                    pts.pop(k + 1)\n                    changed = True\n                else:\n                    k += 1\n        return pts",
          "objective": -23.66545,
          "time_improvement": 25.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1446.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025913333892822264,
                    "num_nodes_avg": 55.7,
                    "path_length_avg": 167.99517295660516,
                    "smoothness_avg": 0.05435459408917749,
                    "success_improvement": 0.0,
                    "time_improvement": 6.049355716776434,
                    "node_improvement": 85.97330647192143,
                    "length_improvement": 7.919183648616565,
                    "smoothness_improvement": 750.7674303858743,
                    "objective_score": 10.32015405613224
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05255372524261474,
                    "num_nodes_avg": 109.1,
                    "path_length_avg": 239.95235067349617,
                    "smoothness_avg": 0.09800212501594732,
                    "success_improvement": 0.0,
                    "time_improvement": 68.24144285366441,
                    "node_improvement": 92.66948867835787,
                    "length_improvement": 19.896998699722197,
                    "smoothness_improvement": 2421.665264737782,
                    "objective_score": 44.51895839962155
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05175285339355469,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 124.84233939422715,
                    "smoothness_avg": 0.09954131102714667,
                    "success_improvement": 0.0,
                    "time_improvement": 0.2501246487432826,
                    "node_improvement": 87.0692943420216,
                    "length_improvement": 17.085662527726324,
                    "smoothness_improvement": 1166.1581288900081,
                    "objective_score": 16.15722555570882
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "FALCON-BRRT*: Filtered A*-Guided Bidirectional RRT with Local Rewire and Visibility Smoothing \u2014 a fast bi-tree planner that accelerates edge checks via obstacle-bin filtering and memoized rays, steers using a small A*-scored beam per side, gates insertions by per-cell best g and incumbent f-pruning, and performs lightweight neighbor rewiring for shorter, smoother paths. Bridging selects the lowest total-cost feasible link across multiple opposite-tree neighbors; the final path undergoes visibility collapse and bounded shortcutting.",
          "planning_mechanism": "Each iteration grows the smaller tree. It samples goal/corridor/uniform (or an informed ellipse after an incumbent), collects a few nearby parents, and proposes one step that minimizes f = g + w\u00b7h. Before committing, it enforces node- and edge-collision using a cached, obstacle-filtered ray test. The node is inserted coherently, nearby nodes are optionally rewired if cheaper with LOS, and several opposite-tree neighbors are evaluated to bridge by minimal total cost. On success, the concatenated path is visibility-compressed and shortcut-smoothed and returned.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.edge_index = -1\n\n    def add_child(self, child):\n        # Avoid duplicate append\n        for c in self.children:\n            if c is child:\n                child.parent = self\n                return\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=8.0,\n                 collision_step=1.0,\n                 beam_k=3,\n                 goal_bias=0.18,\n                 corridor_bias=0.52,\n                 informed_bias=0.65,\n                 grid_cell_factor=0.85,\n                 cell_cost_relax=1.08,\n                 dupe_radius_ratio=0.6,\n                 parent_search_rings=2,\n                 max_rings=3,\n                 connect_k=6,\n                 connect_radius_factor=4.0,\n                 rewire_radius_factor=2.2,\n                 smoothing_attempts=60,\n                 prune_margin=1.02):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_step = collision_step\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.informed_bias = informed_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.cell_cost_relax = cell_cost_relax\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.parent_search_rings = parent_search_rings\n        self.max_rings = max_rings\n        self.connect_k = max(1, int(connect_k))\n        self.connect_radius_factor = connect_radius_factor\n        self.rewire_radius_factor = rewire_radius_factor\n        self.smoothing_attempts = smoothing_attempts\n        self.prune_margin = prune_margin\n\n        # Runtime\n        self.dim = 2\n        self.bounds = None\n        self.start = None\n        self.goal = None\n        self.edge_res = 1.0\n        self.cell_size = 1.0\n        self.dupe_radius = 1.0\n        self.cache_bin = 1.0\n        self.inv_cache_bin = 1.0\n        self.edge_cache = None\n\n        # Obstacle bins\n        self.obs_cell = 4.0\n        self.obs_bins = None\n        self.obstacles = None\n\n    def plan(self, map) -> PlannerResult:\n        # Initialize\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        self.obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Validate bounds and endpoints\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, self.obstacles, is_3d) or self._is_in_obstacle(self.goal, self.obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Resolutions and structures\n        self.edge_res = max(0.75, min(self.collision_step, max(0.5, self.step_size * 0.5)))\n        self.cache_bin = max(0.5, 0.5 * self.edge_res)\n        self.inv_cache_bin = 1.0 / self.cache_bin\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.edge_cache = {}\n        self.obs_cell = max(2.0, self.step_size)\n        self.obs_bins = self._build_obs_bins(self.obstacles, is_3d)\n\n        # Early straight line\n        if not self._edge_blocked_memo_filtered(self.start, self.goal, self.obstacles, is_3d):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes = [n0, n1]\n            edges = [(n0, n1)]\n            n1.edge_index = 0\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Initialize trees\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        grid_start, grid_goal = {}, {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n        best_cost_start, best_cost_goal = {}, {}\n\n        nodes = [start_root, goal_root]\n        edges = []\n        edgeset = {}  # (parent, child) -> index\n\n        # Metrics for guidance\n        best_path_len = float('inf')\n        d_sg = self._dist(self.start, self.goal)\n        base_corridor_w = max(self.step_size, 0.18 * d_sg)\n\n        for it in range(self.max_iter):\n            # Pick smaller tree to grow\n            if len(tree_start) <= len(tree_goal):\n                active_is_start = True\n                T1, T2 = tree_start, tree_goal\n                G1, G2 = grid_start, grid_goal\n                bestcell1 = best_cost_start\n                other_root = self.goal\n            else:\n                active_is_start = False\n                T1, T2 = tree_goal, tree_start\n                G1, G2 = grid_goal, grid_start\n                bestcell1 = best_cost_goal\n                other_root = self.start\n\n            # Beam of candidates: keep best by f = g + w*h\n            best_cand = None  # (parent, new_pos, new_cost, fscore)\n            width = base_corridor_w\n            if best_path_len < float('inf'):\n                slack = max(0.0, best_path_len - d_sg)\n                width = max(self.step_size, base_corridor_w + 0.15 * slack)\n\n            for _ in range(self.beam_k):\n                x_rand = None\n                r = self._rand()\n                if best_path_len < float('inf') and r < self.informed_bias:\n                    x_rand = self._sample_informed(best_path_len, is_3d)\n                else:\n                    r2 = self._rand()\n                    if r2 < self.goal_bias:\n                        x_rand = other_root\n                    elif r2 < self.goal_bias + self.corridor_bias:\n                        x_rand = self._sample_corridor(width, is_3d)\n                    else:\n                        x_rand = self._sample_free(is_3d)\n\n                if x_rand is None:\n                    continue\n\n                near = self._nearest(G1, T1, x_rand)\n                if near is None:\n                    continue\n\n                new_pos = self._steer(near.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, self.obstacles, is_3d):\n                    continue\n                if self._exists_close(G1, new_pos, self.dupe_radius):\n                    continue\n\n                parent = self._choose_parent(near, G1, new_pos, is_3d)\n                if parent is None:\n                    continue\n\n                if self._edge_blocked_memo_filtered(parent.position, new_pos, self.obstacles, is_3d):\n                    continue\n\n                new_cost = parent.cost + self._dist(parent.position, new_pos)\n                # Per-cell best gate\n                kcell = self._grid_key(new_pos)\n                prev_best = bestcell1.get(kcell, float('inf'))\n                if new_cost > prev_best * self.cell_cost_relax:\n                    continue\n\n                # Incumbent prune\n                if best_path_len < float('inf'):\n                    est_total = new_cost + self._dist(new_pos, other_root)\n                    if est_total >= best_path_len * self.prune_margin:\n                        continue\n\n                w_h = 0.9\n                fscore = new_cost + w_h * self._dist(new_pos, other_root)\n                if best_cand is None or fscore < best_cand[3]:\n                    best_cand = (parent, new_pos, new_cost, fscore)\n\n            if best_cand is None:\n                continue\n\n            parent, new_pos, new_cost, _ = best_cand\n\n            # Final safety checks (both)\n            if self._is_in_obstacle(new_pos, self.obstacles, is_3d):\n                continue\n            if self._edge_blocked_memo_filtered(parent.position, new_pos, self.obstacles, is_3d):\n                continue\n\n            # Insert node\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            T1.append(new_node)\n            nodes.append(new_node)\n            self._grid_add(G1, new_node)\n\n            # Record edge coherently\n            if (parent, new_node) not in edgeset:\n                edges.append((parent, new_node))\n                idx = len(edges) - 1\n                edgeset[(parent, new_node)] = idx\n                new_node.edge_index = idx\n\n            # Update per-cell best\n            kc = self._grid_key(new_pos)\n            prev = bestcell1.get(kc, float('inf'))\n            if new_cost < prev:\n                bestcell1[kc] = new_cost\n\n            # Local neighbor rewiring (lightweight)\n            rewire_radius = self.rewire_radius_factor * self.step_size\n            neigh = self._nearby(G1, new_node.position, rewire_radius, T1)\n            for q in neigh:\n                if q is new_node or q.parent is None:\n                    continue\n                # Check feasible new edge and node validity\n                if self._is_in_obstacle(q.position, self.obstacles, is_3d):\n                    continue\n                cand_cost = new_node.cost + self._dist(new_node.position, q.position)\n                if cand_cost + 1e-12 < q.cost:\n                    if not self._edge_blocked_memo_filtered(new_node.position, q.position, self.obstacles, is_3d):\n                        # Rewire q under new_node\n                        old_parent = q.parent\n                        # Update parent-child lists\n                        if old_parent is not None:\n                            # remove q from old_parent.children\n                            ch = old_parent.children\n                            for i in range(len(ch) - 1, -1, -1):\n                                if ch[i] is q:\n                                    del ch[i]\n                                    break\n                        new_node.add_child(q)\n                        q.parent = new_node\n                        # Update edge book-keeping\n                        old_key = (old_parent, q)\n                        if old_key in edgeset:\n                            idx = edgeset.pop(old_key)\n                            edges[idx] = (new_node, q)\n                            edgeset[(new_node, q)] = idx\n                            q.edge_index = idx\n                        else:\n                            # If missing (shouldn't), append\n                            edges.append((new_node, q))\n                            idx = len(edges) - 1\n                            edgeset[(new_node, q)] = idx\n                            q.edge_index = idx\n                        # Update costs down the subtree\n                        delta = cand_cost - q.cost\n                        self._update_subtree_costs(q, delta)\n\n            # Attempt bridge to opposite tree: choose best-cost connection among nearby\n            connect_radius = self.connect_radius_factor * self.step_size\n            cand2 = self._nearby(G2, new_node.position, connect_radius, T2)\n            if len(cand2) > 0:\n                # Sort by estimated total path cost\n                # score = g(new_node) + dist(new, q) + g(q)\n                best_conn = None\n                best_total = float('inf')\n                # If too many, take up to connect_k nearest by distance\n                if len(cand2) > self.connect_k:\n                    cand2 = self._k_nearest(cand2, new_node.position, self.connect_k)\n                for q in cand2:\n                    est_total = new_node.cost + self._dist(new_node.position, q.position) + q.cost\n                    if est_total < best_total:\n                        best_total = est_total\n                        best_conn = q\n                connected = None\n                # Verify in cost order (only the best here)\n                if best_conn is not None:\n                    if not self._edge_blocked_memo_filtered(new_node.position, best_conn.position, self.obstacles, is_3d):\n                        connected = best_conn\n\n                if connected is not None:\n                    # Build path in correct order\n                    if active_is_start:\n                        path_a = self._path_to_root(new_node)          # start -> ... -> new\n                        path_b = self._path_to_root(connected)         # goal -> ... -> connected\n                        path_b.reverse()                                # connected -> ... -> goal\n                        path = path_a + path_b\n                    else:\n                        path_a = self._path_to_root(connected)         # start -> ... -> connected\n                        path_b = self._path_to_root(new_node)          # goal -> ... -> new\n                        path_b.reverse()                                # new -> ... -> goal\n                        path = path_a + path_b\n\n                    best_path_len = self._path_length(path)\n                    path = self._smooth_path(path, is_3d, self.smoothing_attempts)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        if not hasattr(self, \"_rng\"):\n            self._rng = 2463534242\n        self._rng = (1664525 * self._rng + 1013904223) % (1 << 32)\n        return self._rng / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry and bounds\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp_tuple(b)\n        if d <= 1e-12:\n            return self._clamp_tuple(a)\n        r = step / d\n        return self._clamp_tuple(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    # Collision primitives\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_blocked(self, a, b, obstacles, is_3d, cand_idx=None):\n        # Sample along segment; test only candidate obstacles if provided\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if cand_idx is None:\n                if self._is_in_obstacle(p, obstacles, is_3d):\n                    return True\n            else:\n                if self._point_hits_any(p, cand_idx, is_3d):\n                    return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] * self.inv_cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] * self.inv_cache_bin) for i in range(self.dim))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_blocked_memo_filtered(self, a, b, obstacles, is_3d):\n        key = self._edge_key_q(a, b)\n        st = self.edge_cache.get(key)\n        if st is not None:\n            return st == 1\n        cand_idx = self._segment_candidate_obstacles(a, b, is_3d)\n        blocked = self._edge_blocked(a, b, obstacles, is_3d, cand_idx)\n        self.edge_cache[key] = 1 if blocked else 2\n        if len(self.edge_cache) > 120000:\n            # Light cleanup\n            self.edge_cache.clear()\n        return blocked\n\n    # Obstacle bins for filtering\n    def _build_obs_bins(self, obstacles, is_3d):\n        bins = {}\n        if is_3d:\n            for idx, o in enumerate(obstacles):\n                x, y, z, w, h, d = o\n                xa = int(x // self.obs_cell)\n                xb = int((x + w) // self.obs_cell)\n                ya = int(y // self.obs_cell)\n                yb = int((y + h) // self.obs_cell)\n                za = int(z // self.obs_cell)\n                zb = int((z + d) // self.obs_cell)\n                for i in range(xa, xb + 1):\n                    for j in range(ya, yb + 1):\n                        for k in range(za, zb + 1):\n                            key = (i, j, k)\n                            lst = bins.get(key)\n                            if lst is None:\n                                bins[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(obstacles):\n                x, y, w, h = o\n                xa = int(x // self.obs_cell)\n                xb = int((x + w) // self.obs_cell)\n                ya = int(y // self.obs_cell)\n                yb = int((y + h) // self.obs_cell)\n                for i in range(xa, xb + 1):\n                    for j in range(ya, yb + 1):\n                        key = (i, j)\n                        lst = bins.get(key)\n                        if lst is None:\n                            bins[key] = [idx]\n                        else:\n                            lst.append(idx)\n        return bins\n\n    def _segment_candidate_obstacles(self, a, b, is_3d):\n        if is_3d:\n            minx = min(a[0], b[0]); maxx = max(a[0], b[0])\n            miny = min(a[1], b[1]); maxy = max(a[1], b[1])\n            minz = min(a[2], b[2]); maxz = max(a[2], b[2])\n            xa = int(minx // self.obs_cell); xb = int(maxx // self.obs_cell)\n            ya = int(miny // self.obs_cell); yb = int(maxy // self.obs_cell)\n            za = int(minz // self.obs_cell); zb = int(maxz // self.obs_cell)\n            cand = []\n            seen = {}\n            for i in range(xa, xb + 1):\n                for j in range(ya, yb + 1):\n                    for k in range(za, zb + 1):\n                        lst = self.obs_bins.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                if idx not in seen:\n                                    seen[idx] = True\n                                    cand.append(idx)\n            return cand\n        else:\n            minx = min(a[0], b[0]); maxx = max(a[0], b[0])\n            miny = min(a[1], b[1]); maxy = max(a[1], b[1])\n            xa = int(minx // self.obs_cell); xb = int(maxx // self.obs_cell)\n            ya = int(miny // self.obs_cell); yb = int(maxy // self.obs_cell)\n            cand = []\n            seen = {}\n            for i in range(xa, xb + 1):\n                for j in range(ya, yb + 1):\n                    lst = self.obs_bins.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            if idx not in seen:\n                                seen[idx] = True\n                                cand.append(idx)\n            return cand\n\n    def _point_hits_any(self, p, cand_idx, is_3d):\n        if is_3d:\n            px, py, pz = p\n            for idx in cand_idx:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = p\n            for idx in cand_idx:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    # Grid hashing for nodes\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.max_rings + 1):\n            cand = self._ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback approximate: sample a few random nodes\n        if len(tree) == 0:\n            return None\n        trials = min(48, len(tree))\n        for _ in range(trials):\n            idx = int(self._rand() * len(tree))\n            n = tree[idx]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _nearby(self, grid, pos, radius, fallback_tree):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.cell_size) + 1\n        cand = self._ring_collect(grid, key, r_cells)\n        if not cand:\n            return list(fallback_tree)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                out.append(n)\n        if not out:\n            return list(fallback_tree)\n        return out\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.cell_size) + 1\n        cand = self._ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    def _k_nearest(self, nodes, pos, k):\n        if len(nodes) <= k:\n            return list(nodes)\n        best = []\n        bestd = []\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if len(best) < k:\n                best.append(n)\n                bestd.append(d)\n            else:\n                wi = 0\n                wv = bestd[0]\n                for i in range(1, len(bestd)):\n                    if bestd[i] > wv:\n                        wi = i\n                        wv = bestd[i]\n                if d < wv:\n                    best[wi] = n\n                    bestd[wi] = d\n        return best\n\n    # Parent selection with LOS among local neighborhood\n    def _nearby_candidates(self, grid, pos, rings):\n        key = self._grid_key(pos)\n        cand = []\n        for r in range(0, rings + 1):\n            cand.extend(self._ring_collect(grid, key, r))\n        return cand\n\n    def _choose_parent(self, nearest, grid, new_pos, is_3d):\n        best_parent = None\n        best_cost = float('inf')\n        candidates = self._nearby_candidates(grid, new_pos, self.parent_search_rings)\n        if not candidates:\n            candidates = [nearest]\n        for cand in candidates:\n            if cand is None:\n                continue\n            # LOS check\n            if not self._edge_blocked_memo_filtered(cand.position, new_pos, self.obstacles, is_3d):\n                c = cand.cost + self._dist(cand.position, new_pos)\n                if c + 1e-12 < best_cost:\n                    best_cost = c\n                    best_parent = cand\n        if best_parent is None:\n            # fallback to nearest if LOS\n            if not self._edge_blocked_memo_filtered(nearest.position, new_pos, self.obstacles, is_3d):\n                return nearest\n            return None\n        return best_parent\n\n    def _update_subtree_costs(self, root, delta):\n        # Propagate cost change by delta to subtree\n        stack = [root]\n        while stack:\n            n = stack.pop()\n            n.cost += delta\n            for ch in n.children:\n                # recompute exact cost for robustness\n                ch.cost = n.cost + self._dist(n.position, ch.position)\n                stack.append(ch)\n\n    # Sampling\n    def _sample_free(self, is_3d):\n        for _ in range(80):\n            if is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, self.obstacles, is_3d):\n                return p\n        # fallback to center\n        if is_3d:\n            return (self.bounds[0]*0.5, self.bounds[1]*0.5, self.bounds[2]*0.5)\n        else:\n            return (self.bounds[0]*0.5, self.bounds[1]*0.5)\n\n    def _sample_corridor(self, width, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        tries = 0\n        while tries < 25:\n            if is_3d:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox*ox + oy*oy + oz*oz <= width*width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                else:\n                    tries += 1\n                    continue\n            else:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox*ox + oy*oy <= width*width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                else:\n                    tries += 1\n                    continue\n            if not self._is_in_obstacle(p, self.obstacles, is_3d):\n                return p\n            tries += 1\n        return self._sample_free(is_3d)\n\n    def _sample_informed(self, best_len, is_3d):\n        for _ in range(60):\n            if is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if (self._dist(p, self.start) + self._dist(p, self.goal) <= best_len and\n                not self._is_in_obstacle(p, self.obstacles, is_3d)):\n                return p\n        return self._sample_corridor(max(self.step_size, 0.2 * self._dist(self.start, self.goal)), is_3d)\n\n    # Paths and smoothing\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _smooth_path(self, path, is_3d, attempts):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        # Visibility collapse forward\n        i = 0\n        while i + 2 < len(pts):\n            if not self._edge_blocked_memo_filtered(pts[i], pts[i + 2], self.obstacles, is_3d):\n                del pts[i + 1]\n            else:\n                i += 1\n        # Random shortcuts\n        tries = 0\n        while tries < attempts and len(pts) >= 3:\n            n = len(pts)\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            if not self._edge_blocked_memo_filtered(pts[i], pts[j], self.obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n            tries += 1\n        return pts",
          "objective": -23.46853,
          "time_improvement": 28.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1425.0,
          "node_improvement": 91.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022071528434753417,
                    "num_nodes_avg": 56.4,
                    "path_length_avg": 166.45970206388355,
                    "smoothness_avg": 0.0476716901822279,
                    "success_improvement": 0.0,
                    "time_improvement": 19.978096012765512,
                    "node_improvement": 85.79702845630824,
                    "length_improvement": 8.76079957601059,
                    "smoothness_improvement": 646.1654720840041,
                    "objective_score": 14.480735909856028
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0705045223236084,
                    "num_nodes_avg": 102.2,
                    "path_length_avg": 243.32622758330552,
                    "smoothness_avg": 0.0936986145028956,
                    "success_improvement": 0.0,
                    "time_improvement": 57.39365970818463,
                    "node_improvement": 93.13310488476785,
                    "length_improvement": 18.770701475565488,
                    "smoothness_improvement": 2310.932839543629,
                    "objective_score": 40.03518299551283
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04920260906219483,
                    "num_nodes_avg": 57.0,
                    "path_length_avg": 131.132255199198,
                    "smoothness_avg": 0.11155847372659573,
                    "success_improvement": 0.0,
                    "time_improvement": 5.165535828759045,
                    "node_improvement": 92.75270184361094,
                    "length_improvement": 12.908199943669233,
                    "smoothness_improvement": 1319.0155514123178,
                    "objective_score": 15.889658471890844
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "SWIFT-Bridge: Sparse Weighted Informed Fast Trees with Targeted Bridge. A bidirectional, cost-aware sampler that uses obstacle-indexed collision checks, hash-grid nearest neighbors, lazy parent selection, limited rewiring, and a targeted bridge connection (direct or single-turn midpoint) to close gaps quickly. It returns the first feasible path early, then applies visibility compression, bounded shortcuts, and light elastic smoothing for high smoothness and shorter length.",
          "planning_mechanism": "Alternate growing two sparse trees. Each iteration: sample with corridor/goal/informed bias, pick nearest via a node hash-grid, steer once (with a single fallback shrink), enforce node and edge collision using an obstacle grid, select a low-cost parent lazily from local neighbors, insert, and perform capped rewiring. Attempt a targeted bridge to the opposite tree by checking direct visibility to its nearest (and a few neighbors); if blocked, try a single midpoint join. On success, merge root-to-meet paths and post-smooth (visibility prune \u2192 limited shortcuts \u2192 elastic relaxation).",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.edge_index = -1\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=8.0,\n                 collision_step=1.0,\n                 goal_bias=0.18,\n                 corridor_bias=0.55,\n                 informed_bias=0.6,\n                 grid_cell_factor=1.0,\n                 dup_radius_ratio=0.6,\n                 parent_radius_factor=3.0,\n                 rewire_radius_factor=3.0,\n                 max_rewire=12,\n                 connect_k=5,\n                 prune_margin=1.02,\n                 smoothing_shortcuts=60,\n                 elastic_iters=16):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_step = collision_step\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.informed_bias = informed_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.dup_radius_ratio = dup_radius_ratio\n        self.parent_radius_factor = parent_radius_factor\n        self.rewire_radius_factor = rewire_radius_factor\n        self.max_rewire = max_rewire\n        self.connect_k = connect_k\n        self.prune_margin = prune_margin\n        self.smoothing_shortcuts = smoothing_shortcuts\n        self.elastic_iters = elastic_iters\n\n        # runtime\n        self.dim = 2\n        self.bounds = None\n        self.start = None\n        self.goal = None\n\n        # caches and grids\n        self.edge_cache = None\n        self.edge_res = 1.0\n        self.cache_bin = 0.5\n        self.inv_cache_bin = 2.0\n        self.node_cell = 1.0\n        self.dupe_radius = 1.0\n\n        # obstacle index\n        self.obs_cell = 2.0\n        self.obs_grid = None\n        self.obstacles_all = None\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        self.obstacles_all = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Basic validation\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        # Prepare discretizations\n        self.edge_res = max(0.6, min(self.collision_step, 0.5 * self.step_size))\n        self.cache_bin = max(0.25, 0.25 * self.edge_res)\n        self.inv_cache_bin = 1.0 / self.cache_bin\n        self.node_cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dup_radius_ratio)\n        self.obs_cell = max(1.0, self.collision_step * 2.0)\n        self.edge_cache = {}\n\n        # Build obstacle index\n        self.obs_grid = {}\n        self._build_obstacle_grid(self.obstacles_all, is_3d)\n\n        # Endpoint collision\n        if self._is_in_obstacle(self.start, is_3d) or self._is_in_obstacle(self.goal, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight line\n        if not self._edge_blocked_memo(self.start, self.goal, is_3d):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes = [n0, n1]\n            edges = [(n0, n1)]\n            n1.edge_index = 0\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Trees and node grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n        grid_a = {}\n        grid_b = {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n\n        # Per-cell best costs for pruning\n        best_cell_a, best_cell_b = {}, {}\n\n        best_path = None\n        best_len = float('inf')\n        d_sg = self._dist(self.start, self.goal)\n        base_corridor_w = max(self.step_size, 0.2 * d_sg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            bestcell1 = best_cell_a if active_start else best_cell_b\n            other_root = self.goal if active_start else self.start\n\n            # Sample target\n            if best_len < float('inf') and self._rand() < self.informed_bias:\n                x_rand = self._sample_informed(best_len, is_3d)\n            else:\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = other_root\n                elif r < self.goal_bias + self.corridor_bias:\n                    slack = 0.0 if best_len == float('inf') else max(0.0, best_len - d_sg)\n                    width = max(self.step_size, base_corridor_w + 0.15 * slack)\n                    x_rand = self._sample_corridor(width, is_3d)\n                else:\n                    x_rand = self._sample_free(is_3d)\n\n            # Nearest anchor\n            nearest = self._nearest(grid1, tree1, x_rand)\n            if nearest is None:\n                continue\n\n            # Steer once, with a single fallback shrink\n            step_try = self.step_size\n            new_pos = self._steer(nearest.position, x_rand, step_try)\n            if (not self._in_bounds(new_pos)) or self._is_in_obstacle(new_pos, is_3d) or self._edge_blocked_memo(nearest.position, new_pos, is_3d):\n                step_try *= 0.5\n                new_pos = self._steer(nearest.position, x_rand, step_try)\n                if (not self._in_bounds(new_pos)) or self._is_in_obstacle(new_pos, is_3d) or self._edge_blocked_memo(nearest.position, new_pos, is_3d):\n                    continue\n\n            # Duplicate suppression\n            if self._exists_close(grid1, new_pos, self.dupe_radius):\n                continue\n\n            # Choose parent lazily among nearby by ascending tentative cost (check few)\n            parent = self._lazy_choose_parent(grid1, tree1, nearest, new_pos, is_3d)\n\n            # Final enforce before insertion\n            if not self._in_bounds(new_pos) or self._is_in_obstacle(new_pos, is_3d):\n                continue\n            if self._edge_blocked_memo(parent.position, new_pos, is_3d):\n                continue\n\n            # Ancestor visibility compression (early LOS)\n            anc = parent\n            while anc is not None and anc.parent is not None:\n                gp = anc.parent\n                if not self._edge_blocked_memo(gp.position, new_pos, is_3d):\n                    anc = gp\n                else:\n                    break\n            parent = anc\n\n            # Incumbent f-prune and per-cell gate\n            new_cost = parent.cost + self._dist(parent.position, new_pos)\n            if best_len < float('inf'):\n                if new_cost + self._dist(new_pos, other_root) >= best_len * self.prune_margin:\n                    continue\n            kc = self._grid_key(new_pos)\n            prev_best = bestcell1.get(kc, float('inf'))\n            if new_cost > prev_best * 1.04:\n                continue\n\n            # Insert node\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            self._grid_add(grid1, new_node)\n            edges.append((parent, new_node))\n            new_node.edge_index = len(edges) - 1\n            if new_node.cost < bestcell1.get(kc, float('inf')):\n                bestcell1[kc] = new_node.cost\n\n            # Local capped rewiring\n            self._rewire_capped(new_node, grid1, tree1, is_3d, edges)\n\n            # Targeted bridge connect\n            merged = self._targeted_bridge(new_node, tree2, grid2, is_3d)\n            if merged is not None:\n                path = merged\n                plen = self._path_length(path)\n                if plen < best_len:\n                    best_len = plen\n                    best_path = path\n                    # Postprocess: visibility prune -> limited shortcuts -> elastic relax\n                    path2 = self._visibility_prune(best_path, is_3d)\n                    path3 = self._shortcut_biased(path2, is_3d, self.smoothing_shortcuts)\n                    path4 = self._elastic_smooth(path3, is_3d, self.elastic_iters)\n                    return PlannerResult(True, path4, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        if not hasattr(self, \"_rng\"):\n            self._rng = 2463534242\n        self._rng ^= (self._rng << 13) & 0xFFFFFFFF\n        self._rng ^= (self._rng >> 17)\n        self._rng ^= (self._rng << 5) & 0xFFFFFFFF\n        return ((self._rng & 0xFFFFFFFF) / 4294967296.0)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp_tuple(b)\n        if d <= 1e-12:\n            return self._clamp_tuple(a)\n        r = step / d\n        return self._clamp_tuple(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    # Obstacle indexing\n    def _build_obstacle_grid(self, obstacles, is_3d):\n        cell = self.obs_cell\n        if is_3d:\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                x2, y2, z2 = x + w, y + h, z + d\n                gx0 = int((x) // cell)\n                gy0 = int((y) // cell)\n                gz0 = int((z) // cell)\n                gx1 = int((x2 - 1e-9) // cell)\n                gy1 = int((y2 - 1e-9) // cell)\n                gz1 = int((z2 - 1e-9) // cell)\n                for gx in range(gx0, gx1 + 1):\n                    for gy in range(gy0, gy1 + 1):\n                        for gz in range(gz0, gz1 + 1):\n                            key = (gx, gy, gz)\n                            lst = self.obs_grid.get(key)\n                            if lst is None:\n                                self.obs_grid[key] = [o]\n                            else:\n                                lst.append(o)\n        else:\n            for o in obstacles:\n                x, y, w, h = o\n                x2, y2 = x + w, y + h\n                gx0 = int((x) // cell)\n                gy0 = int((y) // cell)\n                gx1 = int((x2 - 1e-9) // cell)\n                gy1 = int((y2 - 1e-9) // cell)\n                for gx in range(gx0, gx1 + 1):\n                    for gy in range(gy0, gy1 + 1):\n                        key = (gx, gy)\n                        lst = self.obs_grid.get(key)\n                        if lst is None:\n                            self.obs_grid[key] = [o]\n                        else:\n                            lst.append(o)\n\n    def _obs_key(self, pos):\n        if self.dim == 3:\n            return (int(pos[0] // self.obs_cell),\n                    int(pos[1] // self.obs_cell),\n                    int(pos[2] // self.obs_cell))\n        else:\n            return (int(pos[0] // self.obs_cell),\n                    int(pos[1] // self.obs_cell))\n\n    def _is_in_obstacle(self, pos, is_3d):\n        key = self._obs_key(pos)\n        bucket = self.obs_grid.get(key)\n        if bucket is None:\n            obs_list = self.obstacles_all\n        else:\n            obs_list = bucket\n        if is_3d:\n            px, py, pz = pos\n            for o in obs_list:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obs_list:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    # Collision along edge using indexed obstacles and memoization\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] * self.inv_cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] * self.inv_cache_bin) for i in range(self.dim))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_blocked(self, a, b, is_3d):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, is_3d):\n                return True\n        return False\n\n    def _edge_blocked_memo(self, a, b, is_3d):\n        key = self._edge_key_q(a, b)\n        st = self.edge_cache.get(key)\n        if st is not None:\n            return st == 1\n        blocked = self._edge_blocked(a, b, is_3d)\n        self.edge_cache[key] = 1 if blocked else 2\n        if len(self.edge_cache) > 50000:\n            self.edge_cache.clear()\n        return blocked\n\n    # Node hash grid for NN\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.node_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, 3):\n            cand = self._ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback random subset\n        if tree:\n            trials = min(64, len(tree))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(tree)))\n                n = tree[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _nearby(self, grid, pos, radius, fallback_tree):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.node_cell) + 1\n        cand = self._ring_collect(grid, key, r_cells)\n        if not cand:\n            return list(fallback_tree)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                out.append(n)\n        if not out:\n            return list(fallback_tree)\n        return out\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.node_cell) + 1\n        cand = self._ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # Lazy parent selection\n    def _lazy_choose_parent(self, grid, tree, nearest, new_pos, is_3d):\n        best_parent = nearest\n        best_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        ncount = max(1, len(tree))\n        # shrinking radius schedule (no log to avoid imports)\n        shrink = (ncount + 1) ** (-0.33)\n        base_r = self.parent_radius_factor * self.step_size\n        radius = max(self.step_size, base_r * max(0.35, shrink))\n        candidates = self._nearby(grid, new_pos, radius, tree)\n        scored = []\n        for cand in candidates:\n            c = cand.cost + self._dist(cand.position, new_pos)\n            scored.append((c, cand))\n        scored.sort(key=lambda t: t[0])\n        # check few best\n        limit = min(16, len(scored))\n        for i in range(limit):\n            c, cand = scored[i]\n            if c + 1e-12 < best_cost:\n                if not self._edge_blocked_memo(cand.position, new_pos, is_3d):\n                    best_parent = cand\n                    best_cost = c\n                    break\n        return best_parent\n\n    # Rewiring with cap\n    def _rewire_capped(self, new_node, grid, tree, is_3d, edges):\n        ncount = max(1, len(tree))\n        shrink = (ncount + 1) ** (-0.33)\n        base_r = self.rewire_radius_factor * self.step_size\n        radius = max(self.step_size, base_r * max(0.35, shrink))\n        neigh = self._nearby(grid, new_node.position, radius, tree)\n        # sort neighbors by potential gain\n        scored = []\n        for nb in neigh:\n            if nb is new_node:\n                continue\n            alt_cost = new_node.cost + self._dist(new_node.position, nb.position)\n            gain = nb.cost - alt_cost\n            if gain > 1e-9:\n                scored.append((gain, nb, alt_cost))\n        scored.sort(key=lambda t: -t[0])\n        rewired = 0\n        for _, nb, alt_cost in scored:\n            if rewired >= self.max_rewire:\n                break\n            if self._edge_blocked_memo(new_node.position, nb.position, is_3d):\n                continue\n            # rewire\n            oldp = nb.parent\n            if oldp is not None:\n                try:\n                    oldp.children.remove(nb)\n                except:\n                    pass\n            nb.parent = new_node\n            new_node.children.append(nb)\n            nb.cost = alt_cost\n            if 0 <= nb.edge_index < len(edges):\n                edges[nb.edge_index] = (new_node, nb)\n            else:\n                edges.append((new_node, nb))\n                nb.edge_index = len(edges) - 1\n            self._update_subtree_costs(nb)\n            rewired += 1\n\n    def _update_subtree_costs(self, node):\n        q = [node]\n        while q:\n            cur = q.pop()\n            for ch in cur.children:\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                q.append(ch)\n\n    # Targeted bridge connect (direct or via single midpoint) without growing other tree\n    def _targeted_bridge(self, new_node, other_tree, other_grid, is_3d):\n        pos = new_node.position\n        other_near = self._nearest(other_grid, other_tree, pos)\n        if other_near is None:\n            return None\n\n        # Try direct connect to a few nearest/nearby\n        candidates = [other_near]\n        # collect additional nearby nodes from other tree\n        radius = 3.0 * self.step_size\n        extra = self._nearby(other_grid, pos, radius, other_tree)\n        # simple selection of closest few\n        extra.sort(key=lambda n: self._dist(n.position, pos))\n        for n in extra:\n            if n is other_near:\n                continue\n            candidates.append(n)\n            if len(candidates) >= self.connect_k:\n                break\n\n        for cand in candidates:\n            if not self._edge_blocked_memo(pos, cand.position, is_3d):\n                return self._merge_paths(new_node, cand, a_from_start=True)\n\n        # Single-turn midpoint bridge to the closest\n        cpos = other_near.position\n        mid = tuple((pos[i] + cpos[i]) * 0.5 for i in range(self.dim))\n        if self._in_bounds(mid) and (not self._is_in_obstacle(mid, is_3d)):\n            if (not self._edge_blocked_memo(pos, mid, is_3d)) and (not self._edge_blocked_memo(mid, cpos, is_3d)):\n                path_a = self._path_to_root(new_node)\n                path_b = self._path_to_root(other_near)\n                path_b.reverse()\n                return path_a + [mid] + path_b\n\n        return None\n\n    # Sampling\n    def _sample_free(self, is_3d):\n        for _ in range(80):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, is_3d):\n                return p\n        if self.dim == 3:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5, self.bounds[2] * 0.5)\n        else:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5)\n\n    def _sample_corridor(self, width, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        tries = 0\n        while tries < 40:\n            if self.dim == 3:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                else:\n                    tries += 1\n                    continue\n            else:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                else:\n                    tries += 1\n                    continue\n            if self._in_bounds(p) and not self._is_in_obstacle(p, is_3d):\n                return p\n            tries += 1\n        return self._sample_free(is_3d)\n\n    def _sample_informed(self, best_len, is_3d):\n        # Rejection in prolate ellipse: dist(start,p)+dist(p,goal) <= best_len\n        for _ in range(100):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if (self._dist(self.start, p) + self._dist(p, self.goal) <= best_len and\n                not self._is_in_obstacle(p, is_3d)):\n                return p\n        # fallback to corridor\n        w = max(self.step_size, 0.2 * self._dist(self.start, self.goal))\n        return self._sample_corridor(w, is_3d)\n\n    # Paths and merging\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_paths(self, a_node, b_node, a_from_start=True):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if a_from_start:\n            pb.reverse()\n            return pa + pb\n        else:\n            pa.reverse()\n            return pb + pa\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    # Smoothing\n    def _visibility_prune(self, path, is_3d):\n        if len(path) < 3:\n            return list(path)\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked_memo(res[-1], path[j], is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_biased(self, path, is_3d, attempts):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and n >= 3:\n            i = int(self._uniform(0, n - 2))\n            span = n - i - 2\n            if span <= 0:\n                tries += 1\n                continue\n            j = i + 2 + int(self._uniform(0, span))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if not self._edge_blocked_memo(pts[i], pts[j], is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n            tries += 1\n        return pts\n\n    def _elastic_smooth(self, path, is_3d, iters):\n        if len(path) < 3:\n            return list(path)\n        pts = [tuple(path[i]) for i in range(len(path))]\n        for _ in range(iters):\n            changed = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple((a[k] + c[k]) * 0.5 for k in range(self.dim))\n                if not self._in_bounds(mid) or self._is_in_obstacle(mid, is_3d):\n                    continue\n                if (not self._edge_blocked_memo(a, mid, is_3d)) and (not self._edge_blocked_memo(mid, c, is_3d)):\n                    if self._dist(pts[i], mid) > 1e-6:\n                        pts[i] = mid\n                        changed = True\n            if not changed:\n                break\n        return self._visibility_prune(pts, is_3d)",
          "objective": -22.89719,
          "time_improvement": 29.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1606.0,
          "node_improvement": 91.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02843170166015625,
                    "num_nodes_avg": 47.2,
                    "path_length_avg": 170.68655864338206,
                    "smoothness_avg": 0.047473344520554364,
                    "success_improvement": 0.0,
                    "time_improvement": -3.0811666336752626,
                    "node_improvement": 88.11382523293881,
                    "length_improvement": 6.4439925059587875,
                    "smoothness_improvement": 643.060931764315,
                    "objective_score": 6.157350172294269
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07638118267059327,
                    "num_nodes_avg": 103.3,
                    "path_length_avg": 247.94712276058672,
                    "smoothness_avg": 0.10328954195113749,
                    "success_improvement": 0.0,
                    "time_improvement": 53.84235573120252,
                    "node_improvement": 93.05919505476047,
                    "length_improvement": 17.228113660296014,
                    "smoothness_improvement": 2557.714310852708,
                    "objective_score": 39.278146469801904
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03382706642150879,
                    "num_nodes_avg": 67.7,
                    "path_length_avg": 138.7028941601985,
                    "smoothness_avg": 0.13502844992551505,
                    "success_improvement": 0.0,
                    "time_improvement": 34.80078028964462,
                    "node_improvement": 91.39224411951685,
                    "length_improvement": 7.880142020860354,
                    "smoothness_improvement": 1617.551916289132,
                    "objective_score": 23.256078880855256
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "STRIDE-BF-BiRRT: Score-Tempered, Proxy-Guided, Edge-Cached Best-First Bidirectional RRT. It grows two trees with small best-first beams scored f = g + w*h, where h is distance to a rotating proxy set from the opposite tree. It uses a hashed grid for approximate nearest search, progressive step shrinking for viable extensions, duplicate suppression, and bounded edge-collision memoization. After each insertion it tries a direct bridge and a short greedy connect; on success it returns a lightly shortcutted path for speed and smoothness.",
          "planning_mechanism": "Initialize start/goal roots, two hash-grids, and bounded free/blocked edge caches. Each iteration alternates trees, refreshes a small proxy set from the opposite tree, samples a few targets (goal/corridor/uniform), chooses the candidate with minimum f = (parent.g + \u0394g) + w*min_dist_to_proxies, and extends via progressive step shrinking. Only free nodes/edges are added. It then attempts a direct bridge and a brief guided connect. On first feasible connection it assembles and shortcuttens the path and returns.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=8.0,\n                 min_step=2.0,\n                 beam_k=3,\n                 goal_bias=0.3,\n                 corridor_bias=0.5,\n                 connect_steps=8,\n                 collision_res=1.0,\n                 grid_cell=None,\n                 dupe_radius_ratio=0.45,\n                 r_max=3,\n                 random_nn_samples=16,\n                 cache_capacity=80000,\n                 shortcut_iters=28,\n                 proxy_k=8,\n                 proxy_refresh=12,\n                 score_weight=1.0):\n        self.max_iter = max(1, int(max_iter))\n        self.step_size = float(step_size)\n        self.min_step = max(0.5, float(min_step))\n        self.beam_k = max(1, int(beam_k))\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.connect_steps = max(0, int(connect_steps))\n        self.collision_res = max(0.25, float(collision_res))\n        self.grid_cell = grid_cell\n        self.dupe_radius_ratio = max(0.1, float(dupe_radius_ratio))\n        self.r_max = max(1, int(r_max))\n        self.random_nn_samples = max(4, int(random_nn_samples))\n        self.cache_capacity = max(1000, int(cache_capacity))\n        self.shortcut_iters = max(0, int(shortcut_iters))\n        self.proxy_k = max(1, int(proxy_k))\n        self.proxy_refresh = max(1, int(proxy_refresh))\n        self.score_weight = max(0.5, float(score_weight))\n\n        self.dim = 2\n        self.bounds = None\n\n        self._lcg_state = 88172645463393265\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        start = self._as_tuple(map.start)\n        goal = self._as_tuple(map.goal)\n        obstacles = list(map.obstacles)\n        is_3d = (self.dim == 3)\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.9 * self.step_size)\n        self.cache_bin = max(0.5, min(self.collision_res, self.step_size * 0.5))\n\n        self._free_edges = {}\n        self._blocked_edges = {}\n        self._cache_keys = []\n\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        if self._is_edge_free_cached(start, goal, obstacles, is_3d):\n            n0 = Node(start, None, 0.0)\n            n1 = Node(goal, n0, self._dist(start, goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [start, goal], [n0, n1], [(n0, n1)])\n\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start, grid_goal = {}, {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        dsg = self._dist(start, goal)\n        corridor_w = max(self.step_size, 0.12 * dsg)\n        best_iter = -1\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = goal if active_start else start\n\n            if it % self.proxy_refresh == 0 or len(tree_b) <= self.proxy_k:\n                proxies = self._select_proxies(tree_b, self.proxy_k)\n            else:\n                proxies = self._select_proxies(tree_b, self.proxy_k)\n\n            winner = None\n            winner_parent = None\n            best_f = float('inf')\n\n            for _ in range(self.beam_k):\n                target = self._sample_biased(start, goal, corridor_w, obstacles, is_3d, root_other)\n                parent = self._nearest_hashed(grid_a, tree_a, target)\n                if parent is None:\n                    continue\n                new_pos = self._progressive_steer(parent.position, target, obstacles, is_3d)\n                if new_pos is None:\n                    continue\n                if self._exists_close(grid_a, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                g_new = parent.cost + self._dist(parent.position, new_pos)\n                h = self._min_dist_to_set(new_pos, proxies) if proxies else self._dist(new_pos, root_other)\n                f = g_new + self.score_weight * h\n                if f < best_f:\n                    best_f = f\n                    winner = new_pos\n                    winner_parent = parent\n\n            if winner is None:\n                continue\n\n            new_node = Node(winner, winner_parent, winner_parent.cost + self._dist(winner_parent.position, winner))\n            winner_parent.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((winner_parent, new_node))\n            self._grid_add(grid_a, new_node)\n\n            other_near = self._nearest_hashed(grid_b, tree_b, new_node.position)\n            if other_near is not None and self._is_edge_free_cached(new_node.position, other_near.position, obstacles, is_3d):\n                path = self._extract_path(new_node, other_near)\n                smooth = self._shortcut(path, obstacles, is_3d, self.shortcut_iters)\n                return PlannerResult(True, smooth, start_tree + goal_tree, edges)\n\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._progressive_steer(p.position, new_node.position, obstacles, is_3d)\n                if to_pos is None:\n                    break\n                if self._exists_close(grid_b, to_pos, self.step_size * self.dupe_radius_ratio):\n                    break\n                q = Node(to_pos, p, p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                edges.append((p, q))\n                self._grid_add(grid_b, q)\n\n                if self._is_edge_free_cached(q.position, new_node.position, obstacles, is_3d):\n                    path = self._extract_path(new_node, q)\n                    smooth = self._shortcut(path, obstacles, is_3d, self.shortcut_iters)\n                    return PlannerResult(True, smooth, start_tree + goal_tree, edges)\n\n                p = q\n                steps += 1\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _rand(self):\n        self._lcg_state = (6364136223846793005 * self._lcg_state + 1442695040888963407) % (1 << 61)\n        return (self._lcg_state & ((1 << 61) - 1)) / float(1 << 61)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _rand_int(self, a, b):\n        if b <= a:\n            return a\n        r = int(self._uniform(0.0, (b - a + 1)))\n        v = a + r\n        if v > b:\n            v = b\n        return v\n\n    def _as_tuple(self, p):\n        if isinstance(p, tuple):\n            return p\n        return tuple(p[i] for i in range(len(p)))\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    def _clamp(self, p):\n        return tuple(self._clamp_val(p[i], 0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / max(1e-9, d)\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _seg_aabb_overlap(self, a, b, obs, is_3d):\n        if is_3d:\n            x, y, z, w, h, d = obs\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            if maxx < x or minx > x + w or maxy < y or miny > y + h or maxz < z or minz > z + d:\n                return False\n            return True\n        else:\n            x, y, w, h = obs\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            if maxx < x or minx > x + w or maxy < y or miny > y + h:\n                return False\n            return True\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(max(1, d / max(1e-9, resolution)))\n        for obs in obstacles:\n            if not self._seg_aabb_overlap(a, b, obs, is_3d):\n                continue\n            for i in range(steps + 1):\n                t = i / float(steps)\n                p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n                if self._is_in_obstacle(p, obstacles, is_3d):\n                    return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _cache_put(self, key, free):\n        self._cache_keys.append(key)\n        if free:\n            self._free_edges[key] = True\n        else:\n            self._blocked_edges[key] = True\n        if len(self._cache_keys) > self.cache_capacity:\n            drop = int(max(1, self.cache_capacity * 0.1))\n            for _ in range(drop):\n                if not self._cache_keys:\n                    break\n                k = self._cache_keys.pop(0)\n                self._free_edges.pop(k, None)\n                self._blocked_edges.pop(k, None)\n\n    def _is_edge_free_cached(self, a, b, obstacles, is_3d):\n        key = self._edge_key_q(a, b)\n        if key in self._blocked_edges:\n            return False\n        if key in self._free_edges:\n            return True\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_res)\n        if blocked:\n            self._cache_put(key, False)\n            return False\n        else:\n            self._cache_put(key, True)\n            return True\n\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        found = False\n        for r in range(0, self.r_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n                    found = True\n            if found:\n                return best\n        if len(tree) > 0:\n            trials = min(self.random_nn_samples, len(tree))\n            for _ in range(trials):\n                idx = self._rand_int(0, len(tree) - 1)\n                n = tree[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                di = n.position[i] - pos[i]\n                s += di * di\n            if s <= r2:\n                return True\n        return False\n\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, start, goal, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_biased(self, start, goal, corridor_w, obstacles, is_3d, root_other):\n        r = self._rand()\n        if r < self.goal_bias:\n            return root_other\n        elif r < self.goal_bias + self.corridor_bias:\n            return self._sample_corridor(start, goal, corridor_w, obstacles, is_3d)\n        else:\n            return self._sample_free(obstacles, is_3d)\n\n    def _progressive_steer(self, from_pos, to_pos, obstacles, is_3d):\n        step = self.step_size\n        while step >= self.min_step:\n            cand = self._steer(from_pos, to_pos, step)\n            if not self._in_bounds(cand):\n                step *= 0.5\n                continue\n            if self._is_in_obstacle(cand, obstacles, is_3d):\n                step *= 0.5\n                continue\n            if not self._is_edge_free_cached(from_pos, cand, obstacles, is_3d):\n                step *= 0.5\n                continue\n            return cand\n        return None\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _shortcut(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = self._rand_int(0, n - 3)\n            j = self._rand_int(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            if self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_res):\n                continue\n            pts = pts[:i + 1] + pts[j:]\n        out = [pts[0]]\n        last = pts[0]\n        i = 1\n        while i < len(pts):\n            far = i\n            j = i\n            while j < len(pts) and not self._is_edge_in_obstacle(last, pts[j], obstacles, is_3d, self.collision_res):\n                far = j\n                j += 1\n            last = pts[far]\n            out.append(last)\n            i = far + 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _min_dist_to_set(self, p, pts):\n        best = float('inf')\n        for q in pts:\n            d = self._dist(p, q)\n            if d < best:\n                best = d\n        return best\n\n    def _select_proxies(self, tree, k):\n        if not tree:\n            return []\n        out = []\n        n = len(tree)\n        if n <= k:\n            for node in tree:\n                out.append(node.position)\n            return out\n        stride = max(1, n // k)\n        idx = n - 1\n        cnt = 0\n        while idx >= 0 and cnt < k:\n            out.append(tree[idx].position)\n            idx -= stride\n            cnt += 1\n        return out",
          "objective": -22.67068,
          "time_improvement": 28.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1478.0,
          "node_improvement": 85.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01907973289489746,
                    "num_nodes_avg": 58.6,
                    "path_length_avg": 164.53758766363492,
                    "smoothness_avg": 0.04579305398539159,
                    "success_improvement": 0.0,
                    "time_improvement": 25.17398365773817,
                    "node_improvement": 85.24301183580961,
                    "length_improvement": 9.814340936638626,
                    "smoothness_improvement": 616.7607360797193,
                    "objective_score": 16.524603339703223
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06179916858673096,
                    "num_nodes_avg": 163.2,
                    "path_length_avg": 247.82573249877174,
                    "smoothness_avg": 0.09381710615283037,
                    "success_improvement": 0.0,
                    "time_improvement": 61.42309689465787,
                    "node_improvement": 89.03446885708526,
                    "length_improvement": 17.26863722371481,
                    "smoothness_improvement": 2313.9817150425365,
                    "objective_score": 40.35801997783892
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05005335807800293,
                    "num_nodes_avg": 150.1,
                    "path_length_avg": 139.95745090666273,
                    "smoothness_avg": 0.12600553281359275,
                    "success_improvement": 0.0,
                    "time_improvement": -2.042165380642809,
                    "node_improvement": 80.91544818817546,
                    "length_improvement": 7.046925165431393,
                    "smoothness_improvement": 1502.7810766279433,
                    "objective_score": 11.12941086820571
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "EdgeCached Hash-BiConnect (EC-HBC): a time-optimized bidirectional planner that couples hashed nearest lookup with sparse \u201cleader\u201d fallbacks, quantized edge-collision memoization, and per-cell expansion throttling. It grows two trees with a tiny beam of candidates guided by goal/corridor bias, inserts only deduplicated, collision-free steps, and attempts immediate bridging with a short, duplicate-aware greedy connect. Early exit on first path and light shortcutting minimize end-to-end latency.",
          "planning_mechanism": "Mechanism: Maintain grid-hashed trees and sparse leader sets. Each iteration, sample a few targets (goal/corridor/uniform), pick an approximate nearest via grid rings or leaders, steer once, and validate node and edge using a cached edge test. Enforce per-cell caps and duplicate suppression. On insertion, attempt grandparent LOS compression and try to connect to the opposite tree (direct or short greedy). On success, extract and lightly shortcut the path; otherwise continue until the iteration cap.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=3500,\n                 step_size=10.0,\n                 goal_bias=0.25,\n                 corridor_bias=0.55,\n                 beam_k=2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=10,\n                 connect_steps=4,\n                 dupe_radius_ratio=0.5,\n                 min_sep_ratio=0.25,\n                 max_per_cell=6,\n                 leader_sep_mult=3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.beam_k = beam_k\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n        self.connect_steps = connect_steps\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.min_sep_ratio = min_sep_ratio\n        self.max_per_cell = max_per_cell\n        self.leader_sep_mult = leader_sep_mult\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.start = None\n        self.goal = None\n\n        self._edge_cache = None\n        self._cache_q = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.7 * self.step_size)\n        self.edge_res = max(0.75, min(self.collision_step, max(0.5, self.step_size * 0.5)))\n        self._edge_cache = {}\n        self._cache_q = max(1.0, self.step_size * 0.5)\n\n        # Validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight LOS\n        if not self._edge_blocked_cached(self.start, self.goal, obstacles, is_3d):\n            path = [self.start, self.goal]\n            nodes = [Node(self.start), Node(self.goal)]\n            return PlannerResult(True, path, nodes, [])\n\n        # Initialize trees, grids, leaders\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        leaders_start = [start_root]\n        leaders_goal = [goal_root]\n        grid_leaders_start = {}\n        grid_leaders_goal = {}\n        self._grid_add(grid_leaders_start, start_root)\n        self._grid_add(grid_leaders_goal, goal_root)\n\n        dupe_radius = self.step_size * self.dupe_radius_ratio\n        min_sep = self.step_size * self.min_sep_ratio\n        leader_sep = max(self.step_size * self.leader_sep_mult, self.grid_cell * 2.0)\n\n        # Corridor width\n        dsg = self._dist(self.start, self.goal)\n        base_corridor = max(self.step_size, 0.12 * dsg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            leaders_a = leaders_start if active_start else leaders_goal\n            leaders_b = leaders_goal if active_start else leaders_start\n            grid_leaders_a = grid_leaders_start if active_start else grid_leaders_goal\n            grid_leaders_b = grid_leaders_goal if active_start else grid_leaders_start\n            root_other = self.goal if active_start else self.start\n\n            best_cand = None\n            best_score = float('inf')\n\n            for _ in range(self.beam_k):\n                # Sampling policy\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = root_other\n                elif r < self.goal_bias + self.corridor_bias:\n                    x_rand = self._sample_corridor(base_corridor, obstacles, is_3d)\n                else:\n                    x_rand = self._sample_free(obstacles, is_3d)\n\n                nearest = self._nearest_approx(grid_a, leaders_a, grid_leaders_a, x_rand)\n                if nearest is None:\n                    nearest = tree_a[0]\n\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._dist(nearest.position, new_pos) < min_sep:\n                    continue\n                if self._exists_close(grid_a, new_pos, dupe_radius):\n                    continue\n                if not self._grid_can_add(grid_a, new_pos, self.max_per_cell):\n                    continue\n                if self._edge_blocked_cached(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Score vs nearest in other tree (approximate)\n                other_near = self._nearest_approx(grid_b, leaders_b, grid_leaders_b, new_pos)\n                if other_near is None:\n                    score = self._dist(new_pos, root_other)\n                else:\n                    score = self._dist(new_pos, other_near.position)\n                if score < best_score:\n                    best_score = score\n                    best_cand = (nearest, new_pos)\n\n            if best_cand is None:\n                continue\n\n            parent_node, new_pos = best_cand\n            new_cost = parent_node.cost + self._dist(parent_node.position, new_pos)\n            new_node = Node(new_pos, parent=parent_node, cost=new_cost)\n            parent_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((parent_node, new_node))\n            self._grid_add(grid_a, new_node)\n\n            # Consider leader insertion\n            if not self._exists_close(grid_leaders_a, new_node.position, leader_sep):\n                leaders_a.append(new_node)\n                self._grid_add(grid_leaders_a, new_node)\n\n            # Grandparent LOS compression (requires edge check)\n            gp = parent_node.parent\n            if gp is not None:\n                if not self._edge_blocked_cached(gp.position, new_node.position, obstacles, is_3d):\n                    # rewire to grandparent\n                    parent_node.remove_child(new_node)\n                    # remove old edge\n                    self._edges_remove(edges, parent_node, new_node)\n                    gp.add_child(new_node)\n                    edges.append((gp, new_node))\n                    new_node.cost = gp.cost + self._dist(gp.position, new_node.position)\n\n            # Try direct bridge to nearest in the other tree\n            other_near = self._nearest_approx(grid_b, leaders_b, grid_leaders_b, new_node.position)\n            if other_near is not None and not self._edge_blocked_cached(new_node.position, other_near.position, obstacles, is_3d):\n                path = self._extract_path(new_node, other_near)\n                path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Short greedy connect toward new_node from the other tree\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, new_node.position, self.step_size)\n                if self._dist(p.position, to_pos) < min_sep:\n                    break\n                if not self._in_bounds(to_pos):\n                    break\n                if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                    break\n                if self._exists_close(grid_b, to_pos, dupe_radius):\n                    break\n                if not self._grid_can_add(grid_b, to_pos, self.max_per_cell):\n                    break\n                if self._edge_blocked_cached(p.position, to_pos, obstacles, is_3d):\n                    break\n\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                edges.append((p, q))\n                self._grid_add(grid_b, q)\n\n                # consider leader insertion on tree_b\n                if not self._exists_close(grid_leaders_b, q.position, leader_sep):\n                    leaders_b.append(q)\n                    self._grid_add(grid_leaders_b, q)\n\n                p = q\n                steps += 1\n\n                if not self._edge_blocked_cached(new_node.position, p.position, obstacles, is_3d):\n                    path = self._extract_path(new_node, p)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # RNG\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_blocked_cached(self, a, b, obstacles, is_3d):\n        qa = self._quantize(a, self._cache_q)\n        qb = self._quantize(b, self._cache_q)\n        if qa <= qb:\n            key = (qa, qb)\n        else:\n            key = (qb, qa)\n        val = self._edge_cache.get(key)\n        if val is None:\n            blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res)\n            self._edge_cache[key] = blocked\n            return blocked\n        return val\n\n    def _quantize(self, p, q):\n        if self.dim == 3:\n            return (int(p[0] // q), int(p[1] // q), int(p[2] // q))\n        else:\n            return (int(p[0] // q), int(p[1] // q))\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # Grid hashing and neighbors\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_bucket_len(self, grid, key):\n        b = grid.get(key)\n        return 0 if b is None else len(b)\n\n    def _grid_can_add(self, grid, pos, cap):\n        key = self._grid_key(pos)\n        return self._grid_bucket_len(grid, key) < cap\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hash(self, grid, pos, rmax):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, rmax + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        return None\n\n    def _nearest_approx(self, grid, leaders, grid_leaders, pos):\n        n = self._nearest_hash(grid, pos, 3)\n        if n is not None:\n            return n\n        # fallback to leaders (hashed first, then small linear)\n        n = self._nearest_hash(grid_leaders, pos, 3)\n        if n is not None:\n            return n\n        if leaders:\n            best = None\n            bestd = float('inf')\n            for m in leaders:\n                d = self._dist(m.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = m\n            return best\n        return None\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                return True\n        return False\n\n    # Edges\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked_cached(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        # Forward collapse with LOS\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            anchor = pts[0]\n            for k in range(1, len(pts) - 1):\n                nxt = pts[k + 1]\n                if self._edge_blocked_cached(anchor, nxt, obstacles, is_3d):\n                    collapsed.append(pts[k])\n                    anchor = pts[k]\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
          "objective": -22.09245,
          "time_improvement": 29.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 1613.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03273851871490478,
                    "num_nodes_avg": 60.2,
                    "path_length_avg": 170.18282906538553,
                    "smoothness_avg": 0.053188049389708406,
                    "success_improvement": 0.0,
                    "time_improvement": -18.69583971191156,
                    "node_improvement": 84.84009065726518,
                    "length_improvement": 6.720094669764644,
                    "smoothness_improvement": 732.508472646823,
                    "objective_score": 2.085847251519433
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05397622585296631,
                    "num_nodes_avg": 100.1,
                    "path_length_avg": 257.40583012932314,
                    "smoothness_avg": 0.10142937028598975,
                    "success_improvement": 0.0,
                    "time_improvement": 67.38181650527541,
                    "node_improvement": 93.27420546932743,
                    "length_improvement": 14.070524886815711,
                    "smoothness_improvement": 2509.8507540809624,
                    "objective_score": 41.20611365407686
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03156077861785889,
                    "num_nodes_avg": 75.8,
                    "path_length_avg": 142.39168435753868,
                    "smoothness_avg": 0.13328052112613284,
                    "success_improvement": 0.0,
                    "time_improvement": 39.16888583553718,
                    "node_improvement": 90.36236490781945,
                    "length_improvement": 5.430223213100318,
                    "smoothness_improvement": 1595.3183909796737,
                    "objective_score": 22.985391633419713
               }
          ],
          "success_rate": 1.0
     }
]