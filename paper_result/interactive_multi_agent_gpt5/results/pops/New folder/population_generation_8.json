[
     {
          "operator": "m1",
          "algorithm_description": "LION-ABiRT*: Lazy Informed Ordered-Neighbors Anytime Bi-directional RRT*. It alternates growth of two trees using ring-hash nearest lookup, adaptive step steering, and lazy parent selection that orders k-nearest candidates by a cost+smoothness surrogate and collision-checks only until a feasible parent is found. A dynamic A*-like f=g+h gate with informed (elliptical) and corridor-biased sampling focuses search once an incumbent path exists. Local, bounded rewiring improves costs with capped subtree propagation. Cross-tree connection ranks opposite-tree candidates by estimated total cost and tests only the best few, with short micro-bridges when needed. On success, a light visibility prune, targeted shortcuts, and curvature-aware elastic smoothing produce a short, smooth path. It warm-starts from a previously valid solution when possible and returns the first improved feasible path to reduce time.",
          "planning_mechanism": "Mechanism: Initialize two trees at start/goal. Per iteration: sample (goal/informed-ellipse/corridor/low-discrepancy/uniform), find a near node via ring-hash, adaptively steer with decreasing step until a valid edge is found, gate by f-bound, and lazily choose a smooth, low-cost parent among ordered k-neighbors with a single successful collision test. Insert, then locally rewire k neighbors with capped cost propagation. Try to connect to the opposite tree by testing the top-ranked beam candidates; otherwise, insert a few guided micro-steps from the other tree toward the new node and retry. When bridged, assemble, prune, shortcut around largest bends, smooth elastically under collision and bounds, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = set()\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.add(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_min=3.0,\n                 step_max=7.0,\n                 neighbor_k=14,\n                 ring_max=2,\n                 goal_bias=0.18,\n                 informed_bias=0.65,\n                 corridor_bias=0.55,\n                 beam_k=8,\n                 connect_steps=3,\n                 grid_cell_factor=1.10,\n                 gate_init=1.25,\n                 gate_final=1.05,\n                 angle_weight=0.035,\n                 dupe_ratio_far=0.50,\n                 dupe_ratio_near=0.22,\n                 anchor_stride=16,\n                 smoothing_trials=60,\n                 smooth_passes=3,\n                 edge_cache_max=20000):\n        self.max_iter = max_iter\n        self.step_min = step_min\n        self.step_max = step_max\n        self.neighbor_k = neighbor_k\n        self.ring_max = ring_max\n        self.goal_bias = goal_bias\n        self.informed_bias = informed_bias\n        self.corridor_bias = corridor_bias\n        self.beam_k = beam_k\n        self.connect_steps = connect_steps\n        self.grid_cell_factor = grid_cell_factor\n        self.gate_init = gate_init\n        self.gate_final = gate_final\n        self.angle_weight = angle_weight\n        self.dupe_ratio_far = dupe_ratio_far\n        self.dupe_ratio_near = dupe_ratio_near\n        self.anchor_stride = max(1, int(anchor_stride))\n        self.smoothing_trials = smoothing_trials\n        self.smooth_passes = smooth_passes\n        self.edge_cache_max = max(2000, int(edge_cache_max))\n\n        # runtime state\n        self.dim = 2\n        self.bounds = None\n        self.cell = 1.0\n        self._seed = 7\n        self._halton_idx = 1\n        self._edge_cache = {}\n        self._cache_bin = 1.0\n        self.prev_path = None\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obs(start, obstacles, is_3d) or self._point_in_obs(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # warm-start with previous solution if still valid\n        if self.prev_path and self._same_ends(self.prev_path, start, goal):\n            if self._path_free(self.prev_path, obstacles, is_3d):\n                nodes = []\n                edges = []\n                s = Node(start, None, 0.0)\n                nodes.append(s)\n                last = s\n                cost = 0.0\n                for i in range(1, len(self.prev_path)):\n                    p = self.prev_path[i]\n                    n = Node(p, None, 0.0)\n                    cost += self._dist(last.position, p)\n                    n.cost = cost\n                    n.attach(last)\n                    nodes.append(n)\n                    last = n\n                for n in nodes:\n                    if n.parent is not None:\n                        edges.append((n.parent, n))\n                return PlannerResult(True, list(self.prev_path), nodes, edges)\n\n        # direct LOS early exit\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.add(g)\n            nodes = [s, g]\n            edges = [(s, g)]\n            path = [start, goal]\n            self.prev_path = path\n            return PlannerResult(True, path, nodes, edges)\n\n        # setup discretizations and caches\n        self.cell = max(1.0, self.step_max * self.grid_cell_factor)\n        self._seed = 7\n        self._halton_idx = 1\n        self._edge_cache = {}\n        self._cache_bin = max(0.5, 0.1 * self.step_max)\n\n        # init trees\n        a_root = Node(start, None, 0.0)\n        b_root = Node(goal, None, 0.0)\n        tree_a, tree_b = [a_root], [b_root]\n        grid_a, grid_b = {}, {}\n        anchors_a, anchors_b = [a_root], [b_root]\n        self._grid_add(grid_a, a_root)\n        self._grid_add(grid_b, b_root)\n        all_nodes = [a_root, b_root]\n\n        best_path = None\n        c_best = float('inf')\n        sg_dist = self._dist(start, goal)\n\n        for it in range(self.max_iter):\n            from_start = (it % 2 == 0)\n            if from_start:\n                tree_x, tree_y = tree_a, tree_b\n                grid_x, grid_y = grid_a, grid_b\n                anchors_x, anchors_y = anchors_a, anchors_b\n                root_x, root_y = a_root, b_root\n                attractor = goal\n            else:\n                tree_x, tree_y = tree_b, tree_a\n                grid_x, grid_y = grid_b, grid_a\n                anchors_x, anchors_y = anchors_b, anchors_a\n                root_x, root_y = b_root, a_root\n                attractor = start\n\n            # sample\n            r = self._rand()\n            if r < self.goal_bias:\n                x_rand = attractor\n            else:\n                used_informed = (c_best < float('inf') and self._rand() < self.informed_bias)\n                if used_informed:\n                    x_rand = self._ellipse_sample(root_x.position, root_y.position, c_best, 8)\n                else:\n                    if self._rand() < self.corridor_bias:\n                        width = max(self.step_max, 0.2 * (sg_dist if c_best == float('inf') else c_best))\n                        x_rand = self._corridor_sample(root_x.position, root_y.position, width, obstacles, is_3d)\n                    else:\n                        if self._rand() < 0.6:\n                            x_rand = self._halton_sample()\n                        else:\n                            x_rand = self._uniform_free(obstacles, is_3d)\n\n            # nearest\n            n_near = self._nearest_hashed(grid_x, tree_x, anchors_x, x_rand)\n            if n_near is None:\n                continue\n\n            # adaptive steer (shortening until feasible)\n            tried = False\n            x_new_pos = None\n            for scale in (1.1, 1.0, 0.7, 0.45):\n                step = max(self.step_min, min(self.step_max, scale * self.step_max))\n                tgt = self._steer(n_near.position, x_rand, step)\n                if not self._in_bounds(tgt) or self._point_in_obs(tgt, obstacles, is_3d):\n                    continue\n                tried = True\n                if not self._edge_blocked(n_near.position, tgt, obstacles, is_3d):\n                    x_new_pos = tgt\n                    break\n            if not tried or x_new_pos is None:\n                continue\n\n            # heuristic gate\n            if c_best < float('inf'):\n                g_tent = n_near.cost + self._dist(n_near.position, x_new_pos)\n                f_tent = g_tent + self._dist(x_new_pos, root_y.position)\n                if f_tent >= self._interp_gate(it) * c_best:\n                    continue\n\n            # per-cell throttle via duplicate suppression radius\n            kcell = self._grid_key(x_new_pos)\n            near_ratio = self.dupe_ratio_near if c_best < float('inf') else self.dupe_ratio_far\n            if self._exists_close(grid_x, x_new_pos, self.step_max * near_ratio):\n                continue\n\n            # choose parent lazily among ordered neighbors\n            neigh = self._k_nearest_nodes(grid_x, x_new_pos, self.neighbor_k)\n            parent, new_cost = self._lazy_choose_parent(x_new_pos, n_near, neigh, obstacles, is_3d, attractor)\n\n            if parent is None:\n                continue\n\n            # final checks before insertion\n            if self._point_in_obs(x_new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked(parent.position, x_new_pos, obstacles, is_3d):\n                continue\n\n            # insert\n            x_new = Node(x_new_pos, None, new_cost)\n            x_new.attach(parent)\n            tree_x.append(x_new)\n            all_nodes.append(x_new)\n            self._grid_add(grid_x, x_new)\n            if len(tree_x) % self.anchor_stride == 0:\n                anchors_x.append(x_new)\n\n            # local rewiring with capped propagation\n            self._rewire_local(x_new, neigh, obstacles, is_3d, cap_updates=48)\n\n            # attempt to connect to other tree\n            bridge = None\n            beam = self._k_nearest_nodes(grid_y, x_new.position, min(self.beam_k, max(1, len(tree_y))))\n            # rank beam by estimated total cost\n            scored = []\n            for cand in beam:\n                est = x_new.cost + self._dist(x_new.position, cand.position) + cand.cost\n                scored.append((est, cand))\n            scored.sort(key=lambda t: t[0])\n\n            best_total = float('inf')\n            best_cand = None\n            for _, cand in scored:\n                if not self._edge_blocked(x_new.position, cand.position, obstacles, is_3d):\n                    total = x_new.cost + self._dist(x_new.position, cand.position) + cand.cost\n                    if total < best_total:\n                        best_total = total\n                        best_cand = cand\n                        bridge = cand\n                        break  # accept first feasible best-ranked\n            # guided micro-bridge from other tree if no direct bridge\n            if bridge is None and scored:\n                cur = scored[0][1]\n                steps = 0\n                while steps < self.connect_steps and bridge is None:\n                    step_try = self._steer(cur.position, x_new.position, max(self.step_min, 0.8 * self.step_max))\n                    if not self._in_bounds(step_try) or self._point_in_obs(step_try, obstacles, is_3d):\n                        break\n                    # heuristic gate on other side\n                    if c_best < float('inf'):\n                        g2 = cur.cost + self._dist(cur.position, step_try)\n                        f2 = g2 + self._dist(step_try, root_x.position)\n                        if f2 >= self._interp_gate(it) * c_best:\n                            break\n                    # dupe suppression for other side\n                    if self._exists_close(grid_y, step_try, self.step_max * near_ratio):\n                        break\n                    neigh_b = self._k_nearest_nodes(grid_y, step_try, self.neighbor_k)\n                    p_b, c_b = self._lazy_choose_parent(step_try, cur, neigh_b, obstacles, is_3d, x_new.position)\n                    if p_b is None:\n                        break\n                    if self._point_in_obs(step_try, obstacles, is_3d) or self._edge_blocked(p_b.position, step_try, obstacles, is_3d):\n                        break\n                    nxt = Node(step_try, None, c_b)\n                    nxt.attach(p_b)\n                    tree_y.append(nxt)\n                    all_nodes.append(nxt)\n                    self._grid_add(grid_y, nxt)\n                    if len(tree_y) % self.anchor_stride == 0:\n                        anchors_y.append(nxt)\n                    self._rewire_local(nxt, neigh_b, obstacles, is_3d, cap_updates=32)\n                    if not self._edge_blocked(nxt.position, x_new.position, obstacles, is_3d):\n                        bridge = nxt\n                        break\n                    cur = nxt\n                    steps += 1\n\n            if bridge is not None:\n                # assemble path\n                pa = self._trace_positions(x_new)\n                pb = self._trace_positions(bridge)\n                if from_start:\n                    path = pa + list(reversed(pb))\n                else:\n                    path = pb + list(reversed(pa))\n                # post-process\n                path = self._vis_prune(path, obstacles, is_3d)\n                path = self._shortcut_curvature_focused(path, obstacles, is_3d, self.smoothing_trials)\n                path = self._elastic_smooth(path, obstacles, is_3d, self.smooth_passes)\n                L = self._path_length(path)\n                if L < c_best:\n                    c_best = L\n                    best_path = path\n                # build coherent edges\n                edges = []\n                for n in all_nodes:\n                    if n.parent is not None:\n                        edges.append((n.parent, n))\n                self.prev_path = best_path\n                return PlannerResult(True, best_path, all_nodes, edges)\n\n        edges = []\n        for n in all_nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        ok = best_path is not None\n        if ok:\n            self.prev_path = best_path\n        return PlannerResult(ok, best_path if ok else [], all_nodes, edges)\n\n    # RNG / sampling\n    def _rand(self):\n        self._seed = (1103515245 * self._seed + 12345) % (1 << 31)\n        return self._seed / float(1 << 31)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _halton(self, index, base):\n        f = 1.0\n        r = 0.0\n        i = index\n        while i > 0:\n            f *= 1.0 / base\n            r += f * (i % base)\n            i //= base\n        return r\n\n    def _halton_sample(self):\n        bases = [2, 3, 5]\n        idx = self._halton_idx\n        self._halton_idx += 1\n        coords = []\n        for d in range(self.dim):\n            u = self._halton(idx, bases[d])\n            coords.append(u * self.bounds[d])\n        return tuple(coords)\n\n    def _uniform_free(self, obstacles, is_3d):\n        for _ in range(8):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._point_in_obs(p, obstacles, is_3d):\n                return p\n        return self._halton_sample()\n\n    def _ellipse_sample(self, a, b, c_best, tries):\n        if c_best == float('inf'):\n            return self._halton_sample()\n        for _ in range(tries):\n            p = self._halton_sample()\n            if self._dist(p, a) + self._dist(p, b) <= c_best + 1e-9:\n                return p\n        return self._halton_sample()\n\n    def _corridor_sample(self, a, b, width, obstacles, is_3d):\n        t = self._uniform(0.0, 1.0)\n        base = tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n        if self.dim == 2:\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp((base[0] + ox, base[1] + oy))\n                    if not self._point_in_obs(p, obstacles, is_3d):\n                        return p\n        else:\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp((base[0] + ox, base[1] + oy, base[2] + oz))\n                    if not self._point_in_obs(p, obstacles, is_3d):\n                        return p\n        return self._uniform_free(obstacles, is_3d)\n\n    # Geometry / utilities\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5 if s > 0.0 else 0.0\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        out = []\n        for i in range(self.dim):\n            v = p[i]\n            if v < 0.0:\n                v = 0.0\n            if v > self.bounds[i]:\n                v = self.bounds[i]\n            out.append(v)\n        return tuple(out)\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _same_ends(self, path, start, goal):\n        if not path or len(path) < 2:\n            return False\n        return path[0] == start and path[-1] == goal\n\n    # Obstacles/collisions\n    def _point_in_obs(self, p, obstacles, is_3d):\n        if is_3d:\n            x, y, z = p\n            for o in obstacles:\n                ox, oy, oz, w, h, d = o\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n        else:\n            x, y = p\n            for o in obstacles:\n                ox, oy, w, h = o\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        q = self._cache_bin\n        if self.dim == 3:\n            qa = (int(a[0] / q + 0.5), int(a[1] / q + 0.5), int(a[2] / q + 0.5))\n            qb = (int(b[0] / q + 0.5), int(b[1] / q + 0.5), int(b[2] / q + 0.5))\n        else:\n            qa = (int(a[0] / q + 0.5), int(a[1] / q + 0.5))\n            qb = (int(b[0] / q + 0.5), int(b[1] / q + 0.5))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        key = self._edge_key(a, b)\n        state = self._edge_cache.get(key)\n        if state is not None:\n            return state == 1\n        blocked = False\n        if is_3d:\n            ax, ay, az = a\n            bx, by, bz = b\n            minx = ax if ax < bx else bx\n            maxx = ax if ax > bx else bx\n            miny = ay if ay < by else by\n            maxy = ay if ay > by else by\n            minz = az if az < bz else bz\n            maxz = az if az > bz else bz\n            for box in obstacles:\n                ox, oy, oz, w, h, d = box\n                bx0, bx1 = ox, ox + w\n                by0, by1 = oy, oy + h\n                bz0, bz1 = oz, oz + d\n                if maxx < bx0 or bx1 < minx or maxy < by0 or by1 < miny or maxz < bz0 or bz1 < minz:\n                    continue\n                if self._seg_box_intersect_3d(a, b, box):\n                    blocked = True\n                    break\n        else:\n            ax, ay = a\n            bx, by = b\n            minx = ax if ax < bx else bx\n            maxx = ax if ax > bx else bx\n            miny = ay if ay < by else by\n            maxy = ay if ay > by else by\n            for box in obstacles:\n                ox, oy, w, h = box\n                bx0, bx1 = ox, ox + w\n                by0, by1 = oy, oy + h\n                if maxx < bx0 or bx1 < minx or maxy < by0 or by1 < miny:\n                    continue\n                if self._seg_box_intersect_2d(a, b, box):\n                    blocked = True\n                    break\n        self._edge_cache[key] = 1 if blocked else 2\n        if len(self._edge_cache) > self.edge_cache_max:\n            self._prune_edge_cache()\n        return blocked\n\n    def _prune_edge_cache(self):\n        # remove roughly half of entries by skipping every other key\n        to_del = []\n        c = 0\n        for k in self._edge_cache:\n            if (c & 1) == 0:\n                to_del.append(k)\n            c += 1\n            if len(to_del) >= self.edge_cache_max // 2:\n                break\n        for k in to_del:\n            try:\n                del self._edge_cache[k]\n            except:\n                pass\n\n    def _seg_box_intersect_2d(self, a, b, box):\n        x, y, w, h = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        ax, ay = a\n        bx, by = b\n        dx = bx - ax\n        dy = by - ay\n        tmin, tmax = 0.0, 1.0\n\n        if dx == 0.0:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            t1 = (minx - ax) * inv\n            t2 = (maxx - ax) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        if dy == 0.0:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            t1 = (miny - ay) * inv\n            t2 = (maxy - ay) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    def _seg_box_intersect_3d(self, a, b, box):\n        x, y, z, w, h, d = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        minz, maxz = z, z + d\n        ax, ay, az = a\n        bx, by, bz = b\n        dx = bx - ax\n        dy = by - ay\n        dz = bz - az\n        tmin, tmax = 0.0, 1.0\n\n        # X\n        if dx == 0.0:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            t1 = (minx - ax) * inv\n            t2 = (maxx - ax) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        # Y\n        if dy == 0.0:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            t1 = (miny - ay) * inv\n            t2 = (maxy - ay) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        # Z\n        if dz == 0.0:\n            if az < minz or az > maxz:\n                return False\n        else:\n            inv = 1.0 / dz\n            t1 = (minz - az) * inv\n            t2 = (maxz - az) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    def _path_free(self, path, obstacles, is_3d):\n        if not path or len(path) < 2:\n            return False\n        for p in path:\n            if not self._in_bounds(p) or self._point_in_obs(p, obstacles, is_3d):\n                return False\n        for i in range(1, len(path)):\n            if self._edge_blocked(path[i - 1], path[i], obstacles, is_3d):\n                return False\n        return True\n\n    # Spatial hashing\n    def _grid_key(self, pos):\n        if self.dim == 3:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        else:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, nodes, anchors, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.ring_max + 1):\n            cand = self._collect_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # anchor fallback\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        # lightweight strided scan fallback\n        if best is None and nodes:\n            stride = max(1, len(nodes) // min(64, len(nodes)))\n            for i in range(0, len(nodes), stride):\n                n = nodes[i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _k_nearest_nodes(self, grid, pos, kcap):\n        key = self._grid_key(pos)\n        items = []\n        ring = 0\n        while len(items) < kcap and ring <= self.ring_max:\n            cand = self._collect_ring(grid, key, ring)\n            for n in cand:\n                items.append((self._dist(n.position, pos), n))\n            ring += 1\n        if not items:\n            return []\n        items.sort(key=lambda x: x[0])\n        res = []\n        seen = set()\n        for d, n in items:\n            if n in seen:\n                continue\n            seen.add(n)\n            res.append(n)\n            if len(res) >= kcap:\n                break\n        return res\n\n    def _exists_close(self, grid, pos, radius):\n        cand = self._collect_ring(grid, self._grid_key(pos), 1)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # Parent selection, rewiring\n    def _angle_penalty(self, parent, new_pos):\n        if parent is None or parent.parent is None:\n            return 0.0\n        a = parent.parent.position\n        b = parent.position\n        c = new_pos\n        v1 = tuple(b[i] - a[i] for i in range(self.dim))\n        v2 = tuple(c[i] - b[i] for i in range(self.dim))\n        n1 = 0.0\n        n2 = 0.0\n        dot = 0.0\n        for i in range(self.dim):\n            n1 += v1[i] * v1[i]\n            n2 += v2[i] * v2[i]\n            dot += v1[i] * v2[i]\n        if n1 <= 1e-12 or n2 <= 1e-12:\n            return 0.0\n        cs = dot / ((n1 ** 0.5) * (n2 ** 0.5))\n        if cs > 1.0:\n            cs = 1.0\n        if cs < -1.0:\n            cs = -1.0\n        return (1.0 - cs)\n\n    def _lazy_choose_parent(self, new_pos, fallback, neighbors, obstacles, is_3d, attractor):\n        # order candidates by g + dist + smoothness surrogate to reduce collision checks\n        beta = self.angle_weight * max(1.0, self.step_max)\n        cand = [fallback] + neighbors\n        scored = []\n        seen = set()\n        for p in cand:\n            if p in seen:\n                continue\n            seen.add(p)\n            d = self._dist(p.position, new_pos)\n            g = p.cost + d\n            smooth = beta * self._angle_penalty(p, new_pos)\n            # small bias toward pointing to attractor\n            to_attr = 0.0\n            if attractor is not None:\n                to_attr = 0.02 * self._dist(new_pos, attractor)\n            scored.append((g + smooth + to_attr, p, g))\n        scored.sort(key=lambda t: t[0])\n        for _, p, g in scored:\n            if not self._edge_blocked(p.position, new_pos, obstacles, is_3d):\n                return p, g\n        return None, float('inf')\n\n    def _propagate_delta(self, node, delta, cap_updates):\n        # bounded subtree cost propagation\n        stack = [node]\n        updates = 0\n        while stack and updates < cap_updates:\n            cur = stack.pop()\n            for ch in list(cur.children):\n                ch.cost += delta\n                updates += 1\n                if updates >= cap_updates:\n                    break\n                stack.append(ch)\n\n    def _rewire_local(self, new_node, neighbors, obstacles, is_3d, cap_updates=48):\n        updates_left = cap_updates\n        for m in neighbors:\n            if m is new_node or m is new_node.parent:\n                continue\n            alt = new_node.cost + self._dist(new_node.position, m.position)\n            if alt + 1e-12 < m.cost:\n                if not self._edge_blocked(new_node.position, m.position, obstacles, is_3d):\n                    delta = alt - m.cost\n                    old_parent = m.parent\n                    m.attach(new_node)\n                    m.cost = alt\n                    if delta != 0.0 and updates_left > 0:\n                        used_before = cap_updates - updates_left\n                        self._propagate_delta(m, delta, updates_left)\n                        used_after = cap_updates - updates_left\n                        updates_left -= max(1, used_after - used_before)\n\n    # Heuristic gate schedule\n    def _interp_gate(self, it):\n        if self.max_iter <= 1:\n            return self.gate_final\n        t = min(1.0, max(0.0, it / float(self.max_iter - 1)))\n        return self.gate_init + (self.gate_final - self.gate_init) * t\n\n    # Path helpers and post-processing\n    def _trace_positions(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        out.reverse()\n        return out\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _vis_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(pruned[-1], path[j], obstacles, is_3d):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _shortcut_curvature_focused(self, path, obstacles, is_3d, trials):\n        if not path or len(path) < 3:\n            return list(path)\n        pts = list(path)\n        n = len(pts)\n        for _ in range(trials):\n            if n < 3:\n                break\n            # bias toward larger bends\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            # prefer skipping around corners\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts\n\n    def _elastic_smooth(self, path, obstacles, is_3d, passes):\n        if not path or len(path) < 3:\n            return list(path)\n        pts = list(path)\n        alpha = 0.32\n        lam_curv = 0.30\n        for _ in range(passes):\n            changed = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                b = pts[i]\n                c = pts[i + 1]\n                # curvature proxy\n                v1 = tuple(b[d] - a[d] for d in range(self.dim))\n                v2 = tuple(c[d] - b[d] for d in range(self.dim))\n                n1 = 0.0\n                n2 = 0.0\n                dot = 0.0\n                for d in range(self.dim):\n                    n1 += v1[d] * v1[d]\n                    n2 += v2[d] * v2[d]\n                    dot += v1[d] * v2[d]\n                curv = 0.0\n                if n1 > 1e-12 and n2 > 1e-12:\n                    cs = dot / ((n1 ** 0.5) * (n2 ** 0.5))\n                    if cs > 1.0:\n                        cs = 1.0\n                    if cs < -1.0:\n                        cs = -1.0\n                    curv = (1.0 - cs)\n                # elastic update\n                newp = tuple(b[d] - alpha * (a[d] - 2.0 * b[d] + c[d]) for d in range(self.dim))\n                newp = self._clamp(newp)\n                if self._point_in_obs(newp, obstacles, is_3d):\n                    continue\n                if self._edge_blocked(a, newp, obstacles, is_3d) or self._edge_blocked(newp, c, obstacles, is_3d):\n                    continue\n                old_len = self._dist(a, b) + self._dist(b, c)\n                new_len = self._dist(a, newp) + self._dist(newp, c)\n                if new_len + lam_curv * curv <= old_len + lam_curv * curv + 1e-9 or new_len <= old_len - 1e-6:\n                    pts[i] = newp\n                    changed = True\n            if not changed:\n                break\n        return pts",
          "objective": -43.64906,
          "time_improvement": 86.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1496.0,
          "node_improvement": 96.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007047319412231445,
                    "num_nodes_avg": 24.1,
                    "path_length_avg": 155.28141234263038,
                    "smoothness_avg": 0.03865255099982554,
                    "success_improvement": 0.0,
                    "time_improvement": 71.98348501765808,
                    "node_improvement": 93.93099974817426,
                    "length_improvement": 14.887797303565245,
                    "smoothness_improvement": 504.99635850519775,
                    "objective_score": 33.052705679962564
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.00686192512512207,
                    "num_nodes_avg": 27.8,
                    "path_length_avg": 236.27561310776304,
                    "smoothness_avg": 0.12059056051198921,
                    "success_improvement": 0.0,
                    "time_improvement": 95.71693654634275,
                    "node_improvement": 98.13209702344957,
                    "length_improvement": 21.124399528186895,
                    "smoothness_improvement": 3002.881979843398,
                    "objective_score": 56.404130580031946
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.004746818542480468,
                    "num_nodes_avg": 23.7,
                    "path_length_avg": 126.69003120079826,
                    "smoothness_avg": 0.08501065961584595,
                    "success_improvement": 0.0,
                    "time_improvement": 90.2286090089029,
                    "node_improvement": 96.98664971392243,
                    "length_improvement": 15.85851360743081,
                    "smoothness_improvement": 981.3293154793831,
                    "objective_score": 41.49033744452626
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "L-IRRT* Dual: Length-focused Informed Bidirectional RRT* with Exact-Join, Ancestor Shortcuts, and Tight Visibility Pruning. It grows two trees with proper RRT*-style neighbor radii based on node counts (not grid cells), selects the true best-cost parent from a sorted candidate set, performs cycle-safe rewiring, applies immediate ancestor line-of-sight shortcuts to collapse detours, and only bridges trees with an exact meeting node to preserve a verified straight join. The best path is finalized by deterministic visibility funneling, randomized chord shortcutting, and elastic moves that only reduce local length.",
          "planning_mechanism": "Alternate expanding start/goal trees. Each expansion: sample (goal/line/uniform; switch to informed ellipse once a solution exists), find nearest via a compact grid, steer with LOS-adaptive step, enforce both node and edge collision checks, reject near-duplicates, pick the lowest cost parent among neighbors within a radius driven by the tree\u2019s node count, add the node, rewire cheaper neighbors, then try to connect to the opposite tree. A direct visible bridge inserts the exact meeting node into the opposite tree; otherwise a short greedy approach is attempted. Upon a successful bridge, assemble start\u2192meet\u2192goal using the exact join. Before returning, run visibility funneling, targeted random shortcutting, an elastic band that only accepts length reductions, and a final visibility pass.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        pts.reverse()\n        return pts\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step=6.0,\n        connect_factor=2.0,\n        goal_bias=0.2,\n        line_bias=0.3,\n        informed_bias=0.6,\n        grid_cell_factor=1.5,\n        dupe_ratio=0.35,\n        neighbor_cap=128,\n        rewire_cap=64,\n        connect_steps=8,\n        shortcut_attempts=140,\n        smooth_passes=4\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step)\n        self.connect_step = float(step * connect_factor)\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dupe_ratio = float(dupe_ratio)\n        self.neighbor_cap = int(max(8, neighbor_cap))\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_steps = int(max(1, connect_steps))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.smooth_passes = int(max(0, smooth_passes))\n        self._rng = 123456789\n        self._eindex = {}\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n        self._eindex = {}\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step * self.dupe_ratio)\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            self._edges_add(edges, n0, n1)\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        Ta, Tb = [], []\n        Ga, Gb = {}, {}\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        Ta.append(start_root)\n        Tb.append(goal_root)\n        nodes.extend([start_root, goal_root])\n        self._grid_add(Ga, start_root)\n        self._grid_add(Gb, goal_root)\n\n        best_len = float('inf')\n        best_path = None\n\n        for it in range(self.max_iter):\n            # Sample once per pair of expansions to keep both trees coherent\n            sample = self._sample_target(best_len)\n\n            res = self._expand_and_maybe_connect(Ta, Ga, Tb, Gb, sample, nodes, edges, best_len)\n            if res is not None:\n                path, L = res\n                if L < best_len:\n                    best_len = L\n                    best_path = path\n                    final = self._finalize_path(best_path)\n                    return PlannerResult(True, final, nodes, edges)\n\n            res = self._expand_and_maybe_connect(Tb, Gb, Ta, Ga, sample, nodes, edges, best_len)\n            if res is not None:\n                path, L = res\n                if L < best_len:\n                    best_len = L\n                    best_path = path\n                    final = self._finalize_path(best_path)\n                    return PlannerResult(True, final, nodes, edges)\n\n        if best_path is not None:\n            final = self._finalize_path(best_path)\n            return PlannerResult(True, final, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _expand_and_maybe_connect(self, Ta, Ga, Tb, Gb, target, nodes, edges, best_len):\n        na = self._nearest(Ga, target)\n        if na is None:\n            return None\n        q_new = self._steer_dynamic(na.position, target)\n        if (not self._in_bounds(q_new)) or self._point_blocked(q_new):\n            return None\n        if self._too_close(Ga, q_new, self.dupe_radius):\n            return None\n\n        parent = self._choose_parent(Ta, Ga, q_new, na, best_len)\n        if parent is None:\n            return None\n        if self._point_blocked(q_new) or (not self._edge_free(parent.position, q_new)):\n            return None\n\n        new_cost = parent.cost + self._dist(parent.position, q_new)\n        # Branch-and-bound against current best\n        if best_len < float('inf'):\n            if new_cost + self._dist(q_new, self._root_of(Tb).position) >= best_len * 1.0001:\n                pass\n\n        nn = Node(q_new, parent, new_cost)\n        parent.add_child(nn)\n        Ta.append(nn)\n        nodes.append(nn)\n        self._grid_add(Ga, nn)\n        self._edges_add(edges, parent, nn)\n\n        # Immediate ancestor shortcut (length-only, LOS-checked)\n        self._ancestor_shortcut(nn, edges)\n\n        # Local rewiring\n        if self.rewire_cap > 0:\n            self._rewire_neighbors(Ta, Ga, nn, edges, best_len)\n\n        # Attempt exact direct connect first\n        meet, ok = self._try_direct_bridge(Tb, Gb, nn.position, nodes, edges)\n        if ok:\n            pa = nn.path_to_root()\n            pb = meet.path_to_root()\n            path = self._assemble_path(Ta, pa, pb)\n            return (self._dedup(path), self._path_len(path))\n\n        # Short greedy connect if direct bridge fails\n        meet, ok = self._greedy_connect(Tb, Gb, nn.position, nodes, edges)\n        if ok:\n            pa = nn.path_to_root()\n            pb = meet.path_to_root()\n            path = self._assemble_path(Ta, pa, pb)\n            return (self._dedup(path), self._path_len(path))\n\n        return None\n\n    def _assemble_path(self, Ta, pa, pb):\n        # pa: rootA -> ... -> meet\n        # pb: rootB -> ... -> meet\n        if Ta and Ta[0].position == self.start:\n            # pa: start->meet, pb: goal->meet\n            return pa + pb[::-1][1:]\n        else:\n            # pa: goal->meet, pb: start->meet\n            q = pb + pa[::-1][1:]\n            # Ensure orientation start->goal\n            if q and q[0] != self.start:\n                q = q[::-1]\n            return q\n\n    # RNG\n    def _seed_rng(self):\n        s = 2166136261\n        for v in self.start + self.goal:\n            s ^= int(v * 10007 + 0.5) & 0xffffffff\n            s = (s * 16777619) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Sampling\n    def _sample_target(self, best_len):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._sample_informed_ellipse(self.start, self.goal, best_len * 1.0)\n            if p is not None:\n                return p\n        r2 = self._rand()\n        if r2 < self.goal_bias:\n            return self.goal\n        if r2 < self.goal_bias + self.line_bias:\n            t = self._rand()\n            if self.is3:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t,\n                     self.start[2] + (self.goal[2] - self.start[2]) * t)\n            else:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t)\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_informed_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(32):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if self._in_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and (not self._point_blocked(p)):\n                return p\n        return None\n\n    # Geometry helpers\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(self._lerp(a, b, r))\n\n    def _steer_dynamic(self, a, b):\n        if self._edge_free(a, b):\n            d = self._dist(a, b)\n            step = self.connect_step if d > self.connect_step else d\n            return self._steer(a, b, step)\n        return self._steer(a, b, self.step)\n\n    def _root_of(self, T):\n        return T[0] if T else None\n\n    # Node grid\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 3):\n            cand = self._grid_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n            if best is not None:\n                return best\n        for lst in grid.values():\n            for n in lst:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n        return best\n\n    def _neighbors_within(self, grid, pos, radius, cap):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        seen = {}\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            i2 = id(n)\n                            if i2 in seen:\n                                continue\n                            seen[i2] = True\n                            p = n.position\n                            d2 = 0.0\n                            for i in range(self.dim):\n                                di = p[i] - pos[i]\n                                d2 += di * di\n                            if d2 <= r2:\n                                out.append(n)\n                                if len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        i2 = id(n)\n                        if i2 in seen:\n                            continue\n                        seen[i2] = True\n                        p = n.position\n                        d2 = 0.0\n                        for i in range(self.dim):\n                            di = p[i] - pos[i]\n                            d2 += di * di\n                        if d2 <= r2:\n                            out.append(n)\n                            if len(out) >= cap:\n                                return out\n        return out\n\n    def _rrtstar_radius(self, n_nodes):\n        # Monotone shrinking radius based on node count (no log to avoid imports).\n        # Encourages short, high-quality connections and rewiring.\n        if n_nodes <= 1:\n            return self.step * 3.0\n        scale = self.step * 6.0\n        r = (scale / (float(n_nodes) ** (1.0 / max(2.0, float(self.dim))))) + 1.25 * self.step\n        if r < 1.05 * self.step:\n            r = 1.05 * self.step\n        return r\n\n    def _too_close(self, grid, pos, radius):\n        nb = self._neighbors_within(grid, pos, radius, 1)\n        return len(nb) > 0\n\n    # Parent selection with length-aware ordering\n    def _choose_parent(self, T, G, newp, fallback_near, best_len):\n        r = self._rrtstar_radius(len(T))\n        neigh = self._neighbors_within(G, newp, r, self.neighbor_cap)\n        # Order by tentative cost-to-come for fewer expensive checks\n        scored = []\n        base_best = fallback_near.cost + self._dist(fallback_near.position, newp)\n        for n in neigh:\n            c = n.cost + self._dist(n.position, newp)\n            scored.append((c, n))\n        scored.sort(key=lambda x: x[0])\n        best_parent = None\n        best_cost = 1e100\n        # Try neighbors first\n        for c, n in scored:\n            if c >= best_cost:\n                break\n            if self._edge_free(n.position, newp):\n                best_parent = n\n                best_cost = c\n                # continue to see if even cheaper exists\n        # Fallback to nearest if no neighbor valid\n        if best_parent is None:\n            if self._edge_free(fallback_near.position, newp):\n                best_parent = fallback_near\n                best_cost = base_best\n            else:\n                return None\n        # Branch-and-bound with best known path\n        if best_len < float('inf'):\n            if best_cost + self._dist(newp, self._root_of(T).position) >= best_len * 1.0001:\n                pass\n        return best_parent\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        if child is new_parent or child.parent is new_parent:\n            return\n        if self._point_blocked(child.position) or self._point_blocked(new_parent.position):\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._edges_remove(edges, old, child)\n        new_parent.add_child(child)\n        self._edges_add(edges, new_parent, child)\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        stack = list(child.children)\n        while stack:\n            n = stack.pop()\n            n.cost = n.parent.cost + self._dist(n.parent.position, n.position)\n            for c in n.children:\n                stack.append(c)\n\n    def _ancestor_shortcut(self, node, edges):\n        # Try to attach to a visible ancestor that reduces cost\n        cur = node.parent.parent if node.parent else None\n        tries = 0\n        while cur is not None and tries < 8:\n            cand_cost = cur.cost + self._dist(cur.position, node.position)\n            if cand_cost + 1e-12 < node.cost:\n                if self._edge_free(cur.position, node.position):\n                    self._reparent(node, cur, edges)\n                    break\n            cur = cur.parent\n            tries += 1\n\n    def _rewire_neighbors(self, T, G, node, edges, best_len):\n        r = self._rrtstar_radius(len(T))\n        neigh = self._neighbors_within(G, node.position, r, self.neighbor_cap)\n        cnt = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            if self._point_blocked(nb.position) or self._point_blocked(node.position):\n                continue\n            if not self._edge_free(node.position, nb.position):\n                continue\n            newc = node.cost + self._dist(node.position, nb.position)\n            # Bound by best path if any\n            if best_len < float('inf'):\n                if newc + self._dist(nb.position, self._root_of(T).position) >= best_len * 1.0001:\n                    continue\n            if newc + 1e-12 < nb.cost:\n                self._reparent(nb, node, edges)\n                cnt += 1\n                if cnt >= self.rewire_cap:\n                    break\n\n    # Bridge attempts\n    def _try_direct_bridge(self, T, G, target_pos, nodes, edges):\n        m = self._nearest(G, target_pos)\n        if m is None:\n            return None, False\n        if self._edge_free(m.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                if not self._too_close(G, target_pos, 0.6 * self.dupe_radius):\n                    new_cost = m.cost + self._dist(m.position, target_pos)\n                    nn = Node(target_pos, m, new_cost)\n                    if self._point_blocked(nn.position) or (not self._edge_free(m.position, nn.position)):\n                        return m, True\n                    m.add_child(nn)\n                    T.append(nn)\n                    nodes.append(nn)\n                    self._grid_add(G, nn)\n                    self._edges_add(edges, m, nn)\n                    return nn, True\n            return m, True\n        return m, False\n\n    def _greedy_connect(self, T, G, target_pos, nodes, edges):\n        cur = self._nearest(G, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < self.connect_steps:\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                    if not self._too_close(G, target_pos, 0.6 * self.dupe_radius):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                            return cur, True\n                        cur.add_child(nn)\n                        T.append(nn)\n                        nodes.append(nn)\n                        self._grid_add(G, nn)\n                        self._edges_add(edges, cur, nn)\n                        return nn, True\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            if self._too_close(G, nxt, 0.6 * self.dupe_radius):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                return cur, False\n            cur.add_child(nn)\n            T.append(nn)\n            nodes.append(nn)\n            self._grid_add(G, nn)\n            self._edges_add(edges, cur, nn)\n            cur = nn\n            steps += 1\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                if not self._too_close(G, target_pos, 0.6 * self.dupe_radius):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                        return cur, True\n                    cur.add_child(nn)\n                    T.append(nn)\n                    nodes.append(nn)\n                    self._grid_add(G, nn)\n                    self._edges_add(edges, cur, nn)\n                    return nn, True\n            return cur, True\n        return cur, False\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(3.5, self.step * 1.6)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Edge bookkeeping\n    def _edges_add(self, edges, parent, child):\n        key = (id(parent), id(child))\n        if key in self._eindex:\n            return\n        edges.append((parent, child))\n        self._eindex[key] = len(edges) - 1\n\n    def _edges_remove(self, edges, parent, child):\n        key = (id(parent), id(child))\n        idx = self._eindex.get(key)\n        if idx is None:\n            return\n        last = len(edges) - 1\n        if idx != last:\n            edges[idx] = edges[last]\n            pk, ck = id(edges[idx][0]), id(edges[idx][1])\n            self._eindex[(pk, ck)] = idx\n        edges.pop()\n        self._eindex.pop(key, None)\n\n    # Path utilities and length-focused smoothing\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_funnel(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            found = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    found = True\n                    break\n                j -= 1\n            if not found:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut_random(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _elastic_length_only(self, pts, passes):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = list(pts)\n        for _ in range(passes):\n            improved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                b = cur[i]\n                c = cur[i + 1]\n                target = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                t = 1.0\n                best = b\n                best_gain = 0.0\n                base_len = self._dist(a, b) + self._dist(b, c)\n                while t > 1e-3:\n                    cand = tuple(b[k] + (target[k] - b[k]) * t for k in range(self.dim))\n                    cand = self._clamp(cand)\n                    if (not self._point_blocked(cand)) and self._edge_free(a, cand) and self._edge_free(cand, c):\n                        new_len = self._dist(a, cand) + self._dist(cand, c)\n                        gain = base_len - new_len\n                        if gain > 1e-6:\n                            best = cand\n                            best_gain = gain\n                            break\n                    t *= 0.5\n                if best != b and best_gain > 0.0:\n                    cur[i] = best\n                    improved = True\n            if not improved:\n                break\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._visibility_funnel(path)\n        p2 = self._shortcut_random(p1, self.shortcut_attempts)\n        p3 = self._elastic_length_only(p2, self.smooth_passes)\n        p4 = self._visibility_funnel(p3)\n        return self._dedup(p4)",
          "objective": -42.26447,
          "time_improvement": 71.0,
          "length_improvement": 22.0,
          "smoothness_improvement": 1530.0,
          "node_improvement": 92.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012109470367431641,
                    "num_nodes_avg": 41.0,
                    "path_length_avg": 144.9927890038839,
                    "smoothness_avg": 0.03738562038885029,
                    "success_improvement": 0.0,
                    "time_improvement": 51.858978125989296,
                    "node_improvement": 89.67514479979855,
                    "length_improvement": 20.527154789201994,
                    "smoothness_improvement": 485.16614325957914,
                    "objective_score": 30.29981702761588
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02904365062713623,
                    "num_nodes_avg": 116.0,
                    "path_length_avg": 224.7502960068727,
                    "smoothness_avg": 0.0866795189248766,
                    "success_improvement": 0.0,
                    "time_improvement": 81.87158905210825,
                    "node_improvement": 92.20587247194786,
                    "length_improvement": 24.971882114323137,
                    "smoothness_improvement": 2130.3264546710066,
                    "objective_score": 50.196238257581385
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009520912170410156,
                    "num_nodes_avg": 47.0,
                    "path_length_avg": 119.70538546749144,
                    "smoothness_avg": 0.1631866982455984,
                    "success_improvement": 0.0,
                    "time_improvement": 80.40107188079743,
                    "node_improvement": 94.0241576605213,
                    "length_improvement": 20.497382730404468,
                    "smoothness_improvement": 1975.7227564949017,
                    "objective_score": 46.297364984956424
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "TIDAL-BiRRT: Time-Optimized Directional Adaptive Lazy BiRRT. It accelerates planning via slab-based exact collision tests with obstacle spatial hashing (cell-indexed AABBs) to cut collision checks, a tight hashed-grid nearest search, goal/line-of-sight biased sampling with direct long steps when visible, and a fast greedy multi-step connect that minimizes iterations. Lightweight visibility prune plus micro-shortcutting returns a short, smooth path with minimal overhead.",
          "planning_mechanism": "Alternate expanding start/goal trees. Each iteration samples (goal/line/uniform), finds a hashed-grid nearest, and, if the straight segment is free, takes a long step (up to the sample), else a capped step. After insertion, the other tree greedily extends toward the new node for a few steps using exact slab checks against only nearby obstacles via a spatial hash; if visible within a step, trees meet and the path is extracted and lightly smoothed.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=7000,\n                 step_size=6.0,\n                 goal_bias=0.30,\n                 line_bias=0.20,\n                 search_r_max=2,\n                 connect_steps=10,\n                 smoothing_iters=8):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.search_r_max = search_r_max\n        self.connect_steps = connect_steps\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n\n        # RNG\n        self._lcg_state = 2463534242\n\n        # Obstacle spatial hash\n        self._obs_grid = {}\n        self._obs_cell = 10.0\n        self._obstacles = []\n        self._is_3d = False\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self._is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        self._obstacles = list(map.obstacles)\n\n        # RNG reset\n        self._lcg_state = 2463534242\n\n        # Build obstacle spatial hash\n        self._obs_cell = max(6.0, self.step_size * 2.0)\n        self._build_obstacle_grid()\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obstacles(start) or self._point_in_obstacles(goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight line\n        if not self._edge_blocked(start, goal):\n            n0 = Node(start)\n            n1 = Node(goal, parent=n0, cost=self._dist(start, goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [start, goal], [n0, n1], [(n0, n1)])\n\n        # Trees and node grids\n        node_cell = max(1.0, self.step_size)\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes_all = [start_root, goal_root]\n        edges_all = []\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root, node_cell)\n        self._grid_add(grid_goal, goal_root, node_cell)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = goal if active_start else start\n\n            # Sampling: goal bias, line-of-sight line bias, else uniform\n            r = self._rand()\n            if r < self.goal_bias:\n                x_rand = root_other\n            elif r < self.goal_bias + self.line_bias:\n                x_rand = self._sample_on_line(start, goal)\n            else:\n                x_rand = self._sample_free()\n\n            nearest = self._nearest_hashed(grid_a, tree_a, x_rand, node_cell)\n            if nearest is None:\n                continue\n\n            # Try long step directly to sample if visible; else capped step\n            d_ns = self._dist(nearest.position, x_rand)\n            direct_allowed = (d_ns <= self.step_size * 1.8) and (not self._edge_blocked(nearest.position, x_rand))\n            new_pos = x_rand if direct_allowed else self._steer(nearest.position, x_rand, self.step_size)\n\n            if not self._in_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if self._edge_blocked(nearest.position, new_pos):\n                continue\n            # light dedup near check\n            if self._near_dup(grid_a, new_pos, node_cell, 0.2 * self.step_size):\n                continue\n\n            # Insert node\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes_all.append(new_node)\n            edges_all.append((nearest, new_node))\n            self._grid_add(grid_a, new_node, node_cell)\n\n            # Greedy bounded connect from other tree toward new_node\n            meet = self._greedy_connect(tree_b, grid_b, new_node.position, node_cell)\n            if meet is not None:\n                # Confirm final visibility (already enforced inside), extract and smooth\n                path = self._extract_path(new_node, meet, active_start)\n                path = self._visibility_prune(path)\n                path = self._shortcut_smooth(path, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges_all)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges_all)\n\n    # ---------------- RNG ----------------\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------- Geometry --------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / max(d, 1e-9)\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # --------- Obstacle grid -------------\n    def _obs_key(self, p):\n        if self._is_3d:\n            return (int(p[0] // self._obs_cell), int(p[1] // self._obs_cell), int(p[2] // self._obs_cell))\n        else:\n            return (int(p[0] // self._obs_cell), int(p[1] // self._obs_cell))\n\n    def _build_obstacle_grid(self):\n        self._obs_grid = {}\n        cell = self._obs_cell\n        if self._is_3d:\n            for idx, o in enumerate(self._obstacles):\n                x, y, z, w, h, d = o\n                x0 = int(x // cell); x1 = int((x + w) // cell)\n                y0 = int(y // cell); y1 = int((y + h) // cell)\n                z0 = int(z // cell); z1 = int((z + d) // cell)\n                for i in range(x0, x1 + 1):\n                    for j in range(y0, y1 + 1):\n                        for k in range(z0, z1 + 1):\n                            self._obs_grid.setdefault((i, j, k), []).append(idx)\n        else:\n            for idx, o in enumerate(self._obstacles):\n                x, y, w, h = o\n                x0 = int(x // cell); x1 = int((x + w) // cell)\n                y0 = int(y // cell); y1 = int((y + h) // cell)\n                for i in range(x0, x1 + 1):\n                    for j in range(y0, y1 + 1):\n                        self._obs_grid.setdefault((i, j), []).append(idx)\n\n    def _point_in_obstacles(self, p):\n        # Query only obstacles in the point's cell\n        key = self._obs_key(p)\n        idxs = self._obs_grid.get(key, [])\n        if self._is_3d:\n            px, py, pz = p\n            for idx in idxs:\n                x, y, z, w, h, d = self._obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = p\n            for idx in idxs:\n                x, y, w, h = self._obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_candidates(self, a, b):\n        # Collect obstacles from all grid cells overlapping the segment AABB\n        cell = self._obs_cell\n        if self._is_3d:\n            minx = min(a[0], b[0]); maxx = max(a[0], b[0])\n            miny = min(a[1], b[1]); maxy = max(a[1], b[1])\n            minz = min(a[2], b[2]); maxz = max(a[2], b[2])\n            x0 = int(minx // cell); x1 = int(maxx // cell)\n            y0 = int(miny // cell); y1 = int(maxy // cell)\n            z0 = int(minz // cell); z1 = int(maxz // cell)\n            seen = set()\n            res = []\n            for i in range(x0, x1 + 1):\n                for j in range(y0, y1 + 1):\n                    for k in range(z0, z1 + 1):\n                        lst = self._obs_grid.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                if idx not in seen:\n                                    seen.add(idx)\n                                    res.append(idx)\n            return res\n        else:\n            minx = min(a[0], b[0]); maxx = max(a[0], b[0])\n            miny = min(a[1], b[1]); maxy = max(a[1], b[1])\n            x0 = int(minx // cell); x1 = int(maxx // cell)\n            y0 = int(miny // cell); y1 = int(maxy // cell)\n            seen = set()\n            res = []\n            for i in range(x0, x1 + 1):\n                for j in range(y0, y1 + 1):\n                    lst = self._obs_grid.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            if idx not in seen:\n                                seen.add(idx)\n                                res.append(idx)\n            return res\n\n    def _edge_blocked(self, a, b):\n        cand = self._segment_candidates(a, b)\n        if not cand:\n            return False\n        if self._is_3d:\n            for idx in cand:\n                x, y, z, w, h, d = self._obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n        else:\n            for idx in cand:\n                x, y, w, h = self._obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x, y), (x + w, y + h)):\n                    return True\n        return False\n\n    def _seg_aabb_intersect(self, p0, p1, bmin, bmax):\n        # Slab method for 2D/3D\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(self.dim):\n            a = p0[i]\n            b = p1[i]\n            d = b - a\n            if abs(d) < 1e-12:\n                if a < bmin[i] or a > bmax[i]:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (bmin[i] - a) * inv\n                t2 = (bmax[i] - a) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return (tmin <= tmax) and (tmax >= 0.0) and (tmin <= 1.0)\n\n    # ------------- Sampling --------------\n    def _sample_free(self):\n        # Try bounded attempts; fallback to unconditional loop\n        for _ in range(64):\n            if self._is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._point_in_obstacles(p):\n                return p\n        while True:\n            if self._is_3d:\n                p = (self.bounds[0] * self._rand(),\n                     self.bounds[1] * self._rand(),\n                     self.bounds[2] * self._rand())\n            else:\n                p = (self.bounds[0] * self._rand(),\n                     self.bounds[1] * self._rand())\n            if not self._point_in_obstacles(p):\n                return p\n\n    def _sample_on_line(self, s, g):\n        t = self._rand()\n        p = tuple(s[i] + (g[i] - s[i]) * t for i in range(self.dim))\n        p = self._clamp(p)\n        if not self._point_in_obstacles(p):\n            return p\n        return self._sample_free()\n\n    # ------------- Node grid -------------\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        res = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        res.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            res.extend(b)\n        return res\n\n    def _nearest_hashed(self, grid, tree, pos, cell):\n        key = self._grid_key(pos, cell)\n        best = None\n        bestd = float('inf')\n        found = False\n        for r in range(0, self.search_r_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n                    found = True\n            if found:\n                return best\n        # fallback random probing\n        if tree:\n            trials = min(32, len(tree))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(tree)))\n                n = tree[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _near_dup(self, grid, pos, cell, radius):\n        key = self._grid_key(pos, cell)\n        cand = self._grid_ring_collect(grid, key, 1)\n        rr = max(radius, 1e-6)\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # ------------- Connect & Path -------------\n    def _greedy_connect(self, tree_b, grid_b, target, cell):\n        cur = self._nearest_hashed(grid_b, tree_b, target, cell)\n        if cur is None:\n            return None\n        # If within one step and visible\n        if self._dist(cur.position, target) <= self.step_size and (not self._edge_blocked(cur.position, target)):\n            return cur\n        steps = 0\n        while steps < self.connect_steps:\n            steps += 1\n            if self._dist(cur.position, target) <= self.step_size:\n                if not self._edge_blocked(cur.position, target):\n                    return cur\n                else:\n                    break\n            nxt_pos = self._steer(cur.position, target, self.step_size)\n            if not self._in_bounds(nxt_pos):\n                break\n            if self._point_in_obstacles(nxt_pos):\n                break\n            if self._edge_blocked(cur.position, nxt_pos):\n                break\n            nxt = Node(nxt_pos, parent=cur, cost=cur.cost + self._dist(cur.position, nxt_pos))\n            cur.add_child(nxt)\n            tree_b.append(nxt)\n            self._grid_add(grid_b, nxt, cell)\n            cur = nxt\n        return None\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    # ------------- Smoothing -------------\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j]):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, iters):\n        if len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 2, n))  # ensure at least one point skipped and allow last index\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j - 1]):\n                pts = pts[:i + 1] + pts[j - 1:]\n        return pts",
          "objective": -40.43025,
          "time_improvement": 70.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1875.0,
          "node_improvement": 81.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008312249183654785,
                    "num_nodes_avg": 62.0,
                    "path_length_avg": 156.69148465051805,
                    "smoothness_avg": 0.038492658323530965,
                    "success_improvement": 0.0,
                    "time_improvement": 69.86334643481058,
                    "node_improvement": 84.38680433140266,
                    "length_improvement": 14.114914327586433,
                    "smoothness_improvement": 502.49369090868373,
                    "objective_score": 31.940420981538455
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03631515502929687,
                    "num_nodes_avg": 250.0,
                    "path_length_avg": 241.12950159214583,
                    "smoothness_avg": 0.12182159461241919,
                    "success_improvement": 0.0,
                    "time_improvement": 78.05451619363491,
                    "node_improvement": 83.20231136195659,
                    "length_improvement": 19.504031840666407,
                    "smoothness_improvement": 3034.5573739254837,
                    "objective_score": 50.29156083211774
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02010810375213623,
                    "num_nodes_avg": 186.0,
                    "path_length_avg": 124.86780284803544,
                    "smoothness_avg": 0.1720857560769434,
                    "success_improvement": 0.0,
                    "time_improvement": 61.24308687730198,
                    "node_improvement": 76.35092180546727,
                    "length_improvement": 17.068750914146232,
                    "smoothness_improvement": 2088.918115249488,
                    "objective_score": 39.058767187925774
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SAGE-IBiRRT*: Simple Adaptive Guided Efficient Informed BiRRT*. A lean bidirectional RRT* that balances trees, uses a single hashed grid for fast nearest and neighbor queries, minimalist informed/corridor sampling, bounded LOS strides, k-free RRT* radius with benefit-capped rewiring via O(1) edge updates, and a two-stage shortcut (greedy visibility pull + light randomized). It maintains an incumbent for informed sampling but returns immediately on a validated bridge after local optimization, reducing search time while preserving high-quality, smooth paths.",
          "planning_mechanism": "Alternate growing the two trees (start/goal). Each iteration: sample a target (goal/corridor/informed/uniform), pick nearest via hashed rings, take a bounded LOS stride, reject out-of-bounds/inside-obstacle/near-duplicate. Select a least-cost parent among radius neighbors (RRT* radius from log(n)/n); validate both node and edge before insertion, then benefit-order rewire nearby nodes with O(1) edge updates. Attempt a short bridge to the opposite tree (direct or up to a few micro-steps). On connection, assemble and apply greedy visibility pulling followed by a few randomized shortcuts, and return. Maintain and use the best-so-far path length to guide informed sampling during search.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = parent\n        if parent is not None:\n            if self not in parent.children:\n                parent.children.append(self)\n\n    def path_from_root(self):\n        out = []\n        cur = self\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        out.reverse()\n        return out\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=8.0,\n                 connect_factor=3.0,\n                 goal_bias=0.12,\n                 corridor_bias=0.35,\n                 informed_bias=0.6,\n                 grid_cell_factor=1.0,\n                 dupe_radius_factor=0.35,\n                 rewire_cap=12,\n                 micro_bridge_steps=2,\n                 shortcut_attempts=160):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_factor = float(connect_factor)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dupe_rf = float(dupe_radius_factor)\n        self.rewire_cap = int(rewire_cap)\n        self.micro_bridge_steps = int(micro_bridge_steps)\n        self.shortcut_attempts = int(shortcut_attempts)\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n        self._seed_rng()\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        self._build_obs_index()\n\n        if self._inside_obstacle(self.start) or self._inside_obstacle(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # setup\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dupe_r = max(0.25, self.step * self.dupe_rf)\n        self.connect_dist = max(self.step, self.connect_factor * self.step)\n        self.axis = self._unit(self._sub(self.goal, self.start))\n        self.corridor_w = max(self.step, 0.2 * self._dist(self.start, self.goal))\n\n        Aroot = Node(self.start, None, 0.0)\n        Broot = Node(self.goal, None, 0.0)\n        Ta, Tb = [Aroot], [Broot]\n        Ga, Gb = {}, {}\n        self._grid_put(Ga, Aroot)\n        self._grid_put(Gb, Broot)\n\n        nodes = [Aroot, Broot]\n        self.edges = []\n        self._edge_idx = {}\n\n        # RRT* constants\n        self.mu_free = self._approx_free_volume()\n        self.zeta = 3.141592653589793 if self.dims == 2 else (4.0 * 3.141592653589793 / 3.0)\n        self.gamma_rrt = 2.4 * ((1.0 + 1.0 / self.dims) ** (1.0 / self.dims)) * (max(self.mu_free, 1e-9) / self.zeta) ** (1.0 / self.dims)\n\n        best_len = float('inf')\n        best_path = None\n\n        for it in range(self.max_iter):\n            grow_a = (len(Ta) <= len(Tb))\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            attractor = self.goal if grow_a else self.start\n\n            target = self._sample_target(attractor, best_len)\n            if target is None:\n                continue\n\n            near = self._nearest(G, T, target)\n            if near is None:\n                continue\n\n            new_pos = self._stride(near.position, target)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._inside_obstacle(new_pos):\n                continue\n            if self._too_close(G, new_pos, self.dupe_r):\n                continue\n\n            parent, new_cost = self._select_parent(G, T, new_pos)\n            if parent is None:\n                # fallback to nearest if edge free\n                if self._edge_free(near.position, new_pos):\n                    parent = near\n                    new_cost = near.cost + self._dist(near.position, new_pos)\n                else:\n                    continue\n\n            # Both checks right before insertion\n            if self._inside_obstacle(new_pos):\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, None, new_cost)\n            new_node.attach(parent)\n            T.append(new_node)\n            nodes.append(new_node)\n            self._add_edge(parent, new_node)\n            self._grid_put(G, new_node)\n\n            # Rewire nearby nodes (benefit-ordered, capped)\n            self._rewire(G, new_node)\n\n            # Try to connect to opposite tree\n            other = self._nearest(Gopp, Topp, new_node.position)\n            connected = False\n            end_node = None\n            if other is not None:\n                if self._dist(new_node.position, other.position) <= self.connect_dist and self._edge_free(new_node.position, other.position):\n                    connected = True\n                    end_node = other\n                else:\n                    # short micro-bridge from opposite tree\n                    p = other\n                    for _ in range(self.micro_bridge_steps):\n                        step_p = self._toward(p.position, new_node.position, self.step)\n                        if not self._in_bounds(step_p):\n                            break\n                        if self._inside_obstacle(step_p):\n                            break\n                        if self._too_close(Gopp, step_p, self.dupe_r):\n                            break\n                        if not self._edge_free(p.position, step_p):\n                            break\n                        q = Node(step_p, None, p.cost + self._dist(p.position, step_p))\n                        q.attach(p)\n                        Topp.append(q)\n                        nodes.append(q)\n                        self._add_edge(p, q)\n                        self._grid_put(Gopp, q)\n                        if self._edge_free(new_node.position, q.position):\n                            connected = True\n                            end_node = q\n                            break\n                        p = q\n\n            if connected and end_node is not None:\n                path = self._assemble(new_node, end_node, grow_a)\n                path = self._smooth(path)\n                return PlannerResult(True, path, nodes, self.edges)\n\n            # Maintain incumbent best for informed sampling\n            if other is not None and self._edge_free(new_node.position, other.position):\n                tmp = self._assemble(new_node, other, grow_a)\n                L = self._path_len(tmp)\n                if L < best_len:\n                    best_len = L\n                    best_path = tmp\n\n        if best_path is not None:\n            best_path = self._smooth(best_path)\n            return PlannerResult(True, best_path, nodes, self.edges)\n        return PlannerResult(False, [], nodes, self.edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0\n        for v in (self.start + self.goal):\n            s = (s * 1664525 + int(977 * v + 0.5) + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        self._rng = s if s != 0 else 123456789\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _add(self, a, b):\n        return tuple(a[i] + b[i] for i in range(self.dims))\n\n    def _sub(self, a, b):\n        return tuple(a[i] - b[i] for i in range(self.dims))\n\n    def _scale(self, a, s):\n        return tuple(a[i] * s for i in range(self.dims))\n\n    def _dot(self, a, b):\n        return sum(a[i] * b[i] for i in range(self.dims))\n\n    def _norm(self, a):\n        return self._dist(a, tuple(0.0 for _ in range(self.dims)))\n\n    def _unit(self, a):\n        n = self._norm(a)\n        if n <= 1e-12:\n            return tuple(0.0 for _ in range(self.dims))\n        inv = 1.0 / n\n        return tuple(a[i] * inv for i in range(self.dims))\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    # Obstacle index\n    def _build_obs_index(self):\n        self.obs_cell = max(3.0, self.step * 1.2)\n        self.og = {}\n        if self.dims == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.og.get(key)\n                            if b is None:\n                                self.og[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.og.get(key)\n                        if b is None:\n                            self.og[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _inside_obstacle(self, p):\n        if self.dims == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.og.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.og.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    # Edge collision\n    def _edge_free(self, a, b):\n        return not self._hit_seg(a, b)\n\n    def _hit_seg(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            seen = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        ids = self.og.get((i, j, k))\n                        if ids:\n                            for idx in ids:\n                                if idx in seen:\n                                    continue\n                                seen.add(idx)\n                                ox, oy, oz, w, h, d = self.obstacles[idx]\n                                if self._seg_box(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            seen = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    ids = self.og.get((i, j))\n                    if ids:\n                        for idx in ids:\n                            if idx in seen:\n                                continue\n                            seen.add(idx)\n                            ox, oy, w, h = self.obstacles[idx]\n                            if self._seg_box(a, b, (ox, oy), (ox + w, oy + h)):\n                                return True\n            return False\n\n    def _seg_box(self, p0, p1, bmin, bmax):\n        # Liang-Barsky / slab method for segment vs AABB\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Spatial hashing for nodes\n    def _key_of(self, pos):\n        return tuple(int(pos[i] // self.cell) for i in range(self.dims))\n\n    def _grid_put(self, grid, node):\n        k = self._key_of(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _ring_fetch(self, grid, key, radius):\n        out = []\n        if self.dims == 3:\n            for dx in range(-radius, radius + 1):\n                for dy in range(-radius, radius + 1):\n                    for dz in range(-radius, radius + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-radius, radius + 1):\n                for dy in range(-radius, radius + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, tree, pos):\n        key = self._key_of(pos)\n        best, bestd = None, 1e100\n        r = 0\n        found_any = False\n        while r <= 6:\n            cand = self._ring_fetch(grid, key, r)\n            if cand:\n                found_any = True\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                break\n            r += 1\n        if not found_any:\n            # fallback full sparse scan\n            step = max(1, len(tree) // 64) if tree else 1\n            for i in range(0, len(tree), step):\n                n = tree[i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors_radius(self, grid, pos, radius, cap=256):\n        key = self._key_of(pos)\n        rc = max(1, int(radius // self.cell) + 1)\n        cand = self._ring_fetch(grid, key, rc)\n        out = []\n        rr = radius * radius\n        for n in cand:\n            d2 = 0.0\n            np = n.position\n            for i in range(self.dims):\n                dd = np[i] - pos[i]\n                d2 += dd * dd\n            if d2 <= rr:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _too_close(self, grid, pos, r):\n        return len(self._neighbors_radius(grid, pos, r, 1)) > 0\n\n    # Parent selection with RRT* radius\n    def _select_parent(self, grid, tree, pos):\n        n = max(1, len(tree))\n        # simple ln approximation via change-of-base on 2\n        ln = self._ln(float(n + 1))\n        r_rrt = (self.gamma_rrt * (ln / float(n))) ** (1.0 / self.dims) if n > 1 else self.step * 2.0\n        r_rrt = min(max(self.step, r_rrt), self.step * 6.0)\n        cand = self._neighbors_radius(grid, pos, r_rrt, 256)\n        if not cand:\n            return (None, None)\n        best_p = None\n        best_c = 1e100\n        # evaluate cost + LOS (edge free)\n        for p in cand:\n            c_try = p.cost + self._dist(p.position, pos)\n            if c_try + 1e-9 < best_c and self._edge_free(p.position, pos):\n                best_p = p\n                best_c = c_try\n        return (best_p, best_c) if best_p is not None else (None, None)\n\n    # Rewiring\n    def _rewire(self, grid, node):\n        n = max(1, len(node.children) + 1)  # local proxy to keep radius scale conservative\n        ln = self._ln(float(n + 1))\n        r_rrt = (self.gamma_rrt * max(ln, 1.0) / float(max(2, n))) ** (1.0 / self.dims)\n        r_rrt = min(max(self.step * 1.5, r_rrt * self.step * 6.0), self.step * 6.0)\n        neigh = self._neighbors_radius(grid, node.position, r_rrt, 256)\n        cand = []\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            alt = node.cost + self._dist(node.position, nb.position)\n            gain = nb.cost - alt\n            if gain > 1e-9:\n                cand.append((gain, nb))\n        cand.sort(key=lambda x: -x[0])\n        changed = 0\n        for gain, nb in cand:\n            if changed >= self.rewire_cap:\n                break\n            if not self._edge_free(node.position, nb.position):\n                continue\n            oldp = nb.parent\n            if oldp is node:\n                continue\n            if oldp is not None:\n                try:\n                    oldp.children.remove(nb)\n                except:\n                    pass\n                self._remove_edge(oldp, nb)\n            nb.attach(node)\n            self._add_edge(node, nb)\n            nb.cost = node.cost + self._dist(node.position, nb.position)\n            # propagate costs\n            stack = [nb]\n            while stack:\n                cur = stack.pop()\n                for ch in cur.children:\n                    ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                    stack.append(ch)\n            changed += 1\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    # Edges utilities (O(1) updates via swap-pop)\n    def _add_edge(self, p, c):\n        self.edges.append((p, c))\n        self._edge_idx[c] = len(self.edges) - 1\n\n    def _remove_edge(self, p, c):\n        idx = self._edge_idx.get(c)\n        if idx is None:\n            # fallback linear search (rare)\n            for i in range(len(self.edges)):\n                if self.edges[i][0] is p and self.edges[i][1] is c:\n                    idx = i\n                    break\n        if idx is None:\n            return\n        last = len(self.edges) - 1\n        if idx != last:\n            self.edges[idx] = self.edges[last]\n            _, moved_child = self.edges[idx]\n            self._edge_idx[moved_child] = idx\n        self.edges.pop()\n        try:\n            del self._edge_idx[c]\n        except:\n            pass\n\n    # Sampling\n    def _sample_target(self, attractor, best_len):\n        # attempt informed, else corridor/goal/uniform\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._sample_informed(best_len)\n            if p is not None and self._in_bounds(p) and not self._inside_obstacle(p):\n                return p\n        r2 = self._rand()\n        if r2 < self.goal_bias:\n            p = attractor\n        elif r2 < self.goal_bias + self.corridor_bias:\n            p = self._sample_corridor()\n        else:\n            p = self._sample_uniform()\n        if self._in_bounds(p) and not self._inside_obstacle(p):\n            return p\n        return None\n\n    def _sample_uniform(self):\n        if self.dims == 3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_corridor(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n        if self.dims == 2:\n            n = (-self.axis[1], self.axis[0])\n            off = self._scale(n, self._rand_range(-self.corridor_w, self.corridor_w))\n            p = self._add(base, off)\n        else:\n            u1, u2 = self._perp_basis(self.axis)\n            off = self._add(self._scale(u1, self._rand_range(-self.corridor_w, self.corridor_w)),\n                            self._scale(u2, self._rand_range(-self.corridor_w, self.corridor_w)))\n            p = self._add(base, off)\n        return self._clamp(p)\n\n    def _sample_informed(self, c_best):\n        cmin = self._dist(self.start, self.goal)\n        if not (c_best < float('inf')) or c_best <= cmin + 1e-9:\n            return None\n        a = 0.5 * c_best\n        l = 0.5 * cmin\n        if a <= l + 1e-12:\n            return None\n        b = (a * a - l * l) ** 0.5\n        center = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dims))\n        if self.dims == 2:\n            for _ in range(32):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                if x * x + y * y <= 1.0:\n                    n = (-self.axis[1], self.axis[0])\n                    p = self._add(center, self._add(self._scale(self.axis, a * x), self._scale(n, b * y)))\n                    if self._in_bounds(p):\n                        return self._clamp(p)\n        else:\n            u1, u2 = self._perp_basis(self.axis)\n            for _ in range(32):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                z = self._rand_range(-1.0, 1.0)\n                if x * x + y * y + z * z <= 1.0:\n                    p = self._add(center,\n                                  self._add(self._scale(self.axis, a * x),\n                                            self._add(self._scale(u1, b * y), self._scale(u2, b * z))))\n                    if self._in_bounds(p):\n                        return self._clamp(p)\n        return None\n\n    def _perp_basis(self, v):\n        if self.dims == 2:\n            return (-v[1], v[0])\n        # 3D: two orthonormal perpendiculars to v\n        if abs(v[0]) < 0.9:\n            tmp = (1.0, 0.0, 0.0)\n        else:\n            tmp = (0.0, 1.0, 0.0)\n        u1 = self._sub(tmp, self._scale(v, self._dot(tmp, v)))\n        n1 = self._norm(u1)\n        if n1 <= 1e-12:\n            u1 = (0.0, 0.0, 1.0)\n            n1 = 1.0\n        u1 = self._scale(u1, 1.0 / n1)\n        u2 = (v[1] * u1[2] - v[2] * u1[1],\n              v[2] * u1[0] - v[0] * u1[2],\n              v[0] * u1[1] - v[1] * u1[0])\n        n2 = self._norm(u2)\n        if n2 <= 1e-12:\n            u2 = (0.0, 0.0, 1.0)\n            n2 = 1.0\n        u2 = self._scale(u2, 1.0 / n2)\n        return u1, u2\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    # Steer\n    def _stride(self, a, target):\n        if self._edge_free(a, target):\n            d = self._dist(a, target)\n            if d <= self.step * 3.0:\n                return self._clamp(target)\n            else:\n                return self._toward(a, target, self.step * 2.0)\n        return self._toward(a, target, self.step)\n\n    def _toward(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        s = step if d > step else d\n        dirv = tuple((b[i] - a[i]) / d for i in range(self.dims))\n        p = tuple(a[i] + dirv[i] * s for i in range(self.dims))\n        return self._clamp(p)\n\n    # Path assembly and smoothing\n    def _assemble(self, u, v, a_side):\n        pu = u.path_from_root()\n        pv = v.path_from_root()\n        if a_side:\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _smooth(self, path):\n        if len(path) <= 2:\n            return list(path)\n        # greedy visibility pulling\n        pts = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(pts[-1], path[j]):\n                    pts.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pts.append(path[i + 1])\n                i += 1\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        # light randomized shortcuts\n        best = self._path_len(pts)\n        n = len(pts)\n        attempts = self.shortcut_attempts\n        stall = 0\n        while attempts > 0 and n >= 3 and stall < 64:\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            a = pts[i]\n            b = pts[j - 1]\n            if self._edge_free(a, b):\n                # improve if shorter\n                old = 0.0\n                for k in range(i + 1, j):\n                    old += self._dist(pts[k - 1], pts[k])\n                newd = self._dist(a, b)\n                if newd + 1e-9 < old:\n                    pts = pts[:i + 1] + pts[j - 1:]\n                    n = len(pts)\n                    best = self._path_len(pts)\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            attempts -= 1\n        return pts\n\n    # Utilities\n    def _ln(self, x):\n        if x <= 0.0:\n            return -1e9\n        k = 0\n        while x > 2.0:\n            x *= 0.5\n            k += 1\n        y = x - 1.0\n        term = y\n        s = term\n        i = 2.0\n        while abs(term) > 1e-6 and i < 48.0:\n            term *= -y * (i - 1.0) / i\n            s += term\n            i += 1.0\n        return s + k * 0.6931471805599453\n\n    def _approx_free_volume(self):\n        if self.dims == 2:\n            area = self.bounds[0] * self.bounds[1]\n            occ = 0.0\n            for ox, oy, w, h in self.obstacles:\n                w = max(0.0, min(w, self.bounds[0] - max(0.0, ox)))\n                h = max(0.0, min(h, self.bounds[1] - max(0.0, oy)))\n                if w > 0 and h > 0:\n                    occ += w * h\n            return max(area - occ, 1.0)\n        else:\n            vol = self.bounds[0] * self.bounds[1] * self.bounds[2]\n            occ = 0.0\n            for ox, oy, oz, w, h, d in self.obstacles:\n                w = max(0.0, min(w, self.bounds[0] - max(0.0, ox)))\n                h = max(0.0, min(h, self.bounds[1] - max(0.0, oy)))\n                d = max(0.0, min(d, self.bounds[2] - max(0.0, oz)))\n                if w > 0 and h > 0 and d > 0:\n                    occ += w * h * d\n            return max(vol - occ, 1.0)",
          "objective": -39.32983,
          "time_improvement": 73.0,
          "length_improvement": 7.0,
          "smoothness_improvement": 2685.0,
          "node_improvement": 92.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009373879432678223,
                    "num_nodes_avg": 41.0,
                    "path_length_avg": 181.58636678228862,
                    "smoothness_avg": 0.053454954582751554,
                    "success_improvement": 0.0,
                    "time_improvement": 62.734279772748366,
                    "node_improvement": 89.67514479979855,
                    "length_improvement": 0.4696349465113734,
                    "smoothness_improvement": 736.6861185118518,
                    "objective_score": 22.78549549229059
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022876167297363283,
                    "num_nodes_avg": 73.0,
                    "path_length_avg": 263.0467863715604,
                    "smoothness_avg": 0.2078331276053119,
                    "success_improvement": 0.0,
                    "time_improvement": 85.72119713863205,
                    "node_improvement": 95.09507491769132,
                    "length_improvement": 12.187411327234097,
                    "smoothness_improvement": 5247.696069435725,
                    "objective_score": 59.267286285108696
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013928437232971191,
                    "num_nodes_avg": 61.0,
                    "path_length_avg": 140.06179758594084,
                    "smoothness_avg": 0.1706252860791988,
                    "success_improvement": 0.0,
                    "time_improvement": 71.32812116571944,
                    "node_improvement": 92.2441195168468,
                    "length_improvement": 6.977623069509789,
                    "smoothness_improvement": 2070.3410446788585,
                    "objective_score": 35.93671541481599
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "FLASH-Connect: Fast Hash-grid Bidirectional RRT with Direct-Visible Steer and Exact Join. It minimizes planning time via visibility-first stepping, exact meeting insertion, informed sampling after first solution, node-count-based neighbor radii, and zero-cost rewiring (parent selection only). Lightweight shortcutting and visibility pruning finalize paths quickly.",
          "planning_mechanism": "Grow two trees toward common samples using a spatial hash for O(1) neighborhood queries. At each expansion, directly jump to the target if the edge is free; otherwise take a bounded step. Choose the lowest-cost feasible parent from nearby nodes (radius scales with the true node count, not grid cells). After inserting the node (with both node and edge collision checks), greedily connect the opposite tree, requiring insertion of the exact meeting node for a kink-free bridge. Once connected, concatenate the two root-to-meet paths and apply fast shortcutting and visibility pruning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        pts.reverse()\n        return pts\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step=7.0,\n        connect_factor=3.0,\n        goal_bias=0.2,\n        line_bias=0.3,\n        informed_bias=0.5,\n        grid_cell_factor=2.0,\n        neighbor_radius_scale=2.2,\n        dupe_ratio=0.5,\n        connect_steps=28,\n        shortcut_attempts=60,\n        smooth_passes=1\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step)\n        self.connect_step = float(step * connect_factor)\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neighbor_radius_scale = float(neighbor_radius_scale)\n        self.dupe_ratio = float(dupe_ratio)\n        self.connect_steps = int(max(1, connect_steps))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.smooth_passes = int(max(0, smooth_passes))\n        self._rng = 123456789\n        self._eindex = {}\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n        self._eindex = {}\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step * self.dupe_ratio)\n\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            self._edges_add(edges, n0, n1)\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize trees and grids\n        Ta, Tb = [], []\n        Ga, Gb = {}, {}\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        Ta.append(root_a)\n        Tb.append(root_b)\n        nodes.extend([root_a, root_b])\n        self._grid_add(Ga, root_a)\n        self._grid_add(Gb, root_b)\n\n        best_len = float('inf')\n\n        for _ in range(self.max_iter):\n            target = self._sample_target(best_len)\n            if target is None:\n                continue\n\n            # Expand A then try to connect B\n            na = self._extend_once(Ta, Ga, target, nodes, edges)\n            if na is not None:\n                mb = self._connect_exact(Tb, Gb, na.position, nodes, edges)\n                if mb is not None:\n                    pa = na.path_to_root()\n                    pb = mb.path_to_root()\n                    if root_a.position == self.start:\n                        path = pa + list(reversed(pb[:-1]))\n                    else:\n                        path = pb + list(reversed(pa[:-1]))\n                    best_len = self._path_len(path)\n                    final = self._finalize_path(path)\n                    return PlannerResult(True, final, nodes, edges)\n\n            # Expand B then try to connect A\n            nb = self._extend_once(Tb, Gb, target, nodes, edges)\n            if nb is not None:\n                ma = self._connect_exact(Ta, Ga, nb.position, nodes, edges)\n                if ma is not None:\n                    pa = ma.path_to_root()\n                    pb = nb.path_to_root()\n                    if root_a.position == self.start:\n                        path = pa + list(reversed(pb[:-1]))\n                    else:\n                        path = pb + list(reversed(pa[:-1]))\n                    best_len = self._path_len(path)\n                    final = self._finalize_path(path)\n                    return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # Expansion with visibility-first steer and k-best parent selection\n    def _extend_once(self, T, G, target, nodes, edges):\n        near = self._nearest(G, target)\n        if near is None:\n            return None\n\n        q_new = self._steer_visible(near.position, target)\n        if q_new == near.position:\n            return None\n        if (not self._in_bounds(q_new)) or self._point_blocked(q_new):\n            return None\n        if self._too_close(G, q_new, self.dupe_radius):\n            return None\n\n        parent = self._select_parent(G, T, q_new, near)\n        if parent is None:\n            return None\n\n        # Both checks before adding node/edge\n        if self._point_blocked(q_new) or (not self._edge_free(parent.position, q_new)):\n            return None\n\n        cost = parent.cost + self._dist(parent.position, q_new)\n        nn = Node(q_new, parent, cost)\n        parent.add_child(nn)\n        T.append(nn)\n        nodes.append(nn)\n        self._grid_add(G, nn)\n        self._edges_add(edges, parent, nn)\n        return nn\n\n    # Greedy exact connection to a target position; inserts the meeting node\n    def _connect_exact(self, T, G, target_pos, nodes, edges):\n        # If a node already exists very close to target_pos, return it\n        existing = self._find_node_at(G, target_pos, eps=1e-9)\n        if existing is not None:\n            return existing\n\n        cur = self._nearest(G, target_pos)\n        if cur is None:\n            return None\n\n        # Try direct connection first\n        if self._edge_free(cur.position, target_pos) and (not self._point_blocked(target_pos)) and self._in_bounds(target_pos):\n            new_cost = cur.cost + self._dist(cur.position, target_pos)\n            meet = Node(target_pos, cur, new_cost)\n            # Both checks before adding node/edge\n            if self._point_blocked(meet.position) or (not self._edge_free(cur.position, meet.position)):\n                return None\n            cur.add_child(meet)\n            T.append(meet)\n            nodes.append(meet)\n            self._grid_add(G, meet)\n            self._edges_add(edges, cur, meet)\n            return meet\n\n        # Stepwise attempt\n        steps = 0\n        last = cur\n        while steps < self.connect_steps:\n            nxt = self._steer(last.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                return None\n            if not self._edge_free(last.position, nxt):\n                return None\n            if self._too_close(G, nxt, 0.75 * self.dupe_radius):\n                return None\n            new_cost = last.cost + self._dist(last.position, nxt)\n            nn = Node(nxt, last, new_cost)\n            # Both checks before adding node/edge\n            if self._point_blocked(nn.position) or (not self._edge_free(last.position, nn.position)):\n                return None\n            last.add_child(nn)\n            T.append(nn)\n            nodes.append(nn)\n            self._grid_add(G, nn)\n            self._edges_add(edges, last, nn)\n            last = nn\n            steps += 1\n\n            # If final small segment is visible, insert exact meeting node\n            if self._edge_free(last.position, target_pos) and (not self._point_blocked(target_pos)) and self._in_bounds(target_pos):\n                new_cost2 = last.cost + self._dist(last.position, target_pos)\n                meet = Node(target_pos, last, new_cost2)\n                # Both checks before adding node/edge\n                if self._point_blocked(meet.position) or (not self._edge_free(last.position, meet.position)):\n                    return None\n                last.add_child(meet)\n                T.append(meet)\n                nodes.append(meet)\n                self._grid_add(G, meet)\n                self._edges_add(edges, last, meet)\n                return meet\n\n        return None\n\n    # RNG\n    def _seed_rng(self):\n        s = 2166136261\n        for v in self.start + self.goal:\n            s ^= int(v * 10007 + 0.5) & 0xffffffff\n            s = (s * 16777619) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Sampling\n    def _sample_target(self, best_len):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._sample_informed_ellipse(self.start, self.goal, best_len * 1.01)\n            if p is not None and self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        r2 = self._rand()\n        if r2 < self.goal_bias:\n            return self.goal\n        if r2 < self.goal_bias + self.line_bias:\n            t = self._rand()\n            if self.is3:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t,\n                     self.start[2] + (self.goal[2] - self.start[2]) * t)\n            else:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t)\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        # Uniform\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_informed_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if self._in_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and (not self._point_blocked(p)):\n                return p\n        return None\n\n    # Geometry helpers\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(self._lerp(a, b, r))\n\n    def _steer_visible(self, a, b):\n        if self._edge_free(a, b):\n            return self._clamp(b)\n        return self._steer(a, b, self.step)\n\n    # Node grid\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        # Small expanding ring for speed\n        for r in range(0, 3):\n            cand = self._grid_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n            if best is not None:\n                return best\n        # fallback\n        for lst in grid.values():\n            for n in lst:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n        return best\n\n    def _neighbors_within(self, grid, pos, radius, cap):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        seen = {}\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            i2 = id(n)\n                            if i2 in seen:\n                                continue\n                            seen[i2] = True\n                            d2 = 0.0\n                            p = n.position\n                            for i in range(self.dim):\n                                di = p[i] - pos[i]\n                                d2 += di * di\n                            if d2 <= r2:\n                                out.append(n)\n                                if len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        i2 = id(n)\n                        if i2 in seen:\n                            continue\n                        seen[i2] = True\n                        d2 = 0.0\n                        p = n.position\n                        for i in range(self.dim):\n                            di = p[i] - pos[i]\n                            d2 += di * di\n                        if d2 <= r2:\n                            out.append(n)\n                            if len(out) >= cap:\n                                return out\n        return out\n\n    def _adaptive_radius(self, n_nodes):\n        t = float(max(1, n_nodes))\n        base = 1.2 * self.step\n        decay = (1.0 / (1.0 + t)) ** (1.0 / max(1, self.dim))\n        r = base + self.neighbor_radius_scale * self.step * decay\n        if r < 1.05 * self.step:\n            r = 1.05 * self.step\n        return r\n\n    def _too_close(self, grid, pos, radius):\n        nb = self._neighbors_within(grid, pos, radius, 1)\n        return len(nb) > 0\n\n    # Parent selection using true node count (fast, cap-limited)\n    def _select_parent(self, grid, tree_nodes, newp, fallback):\n        r = self._adaptive_radius(len(tree_nodes))\n        neigh = self._neighbors_within(grid, newp, r, 48)\n        best = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        for n in neigh:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                best = n\n                best_cost = c\n        return best\n\n    # Node lookup at position (epsilon)\n    def _find_node_at(self, grid, pos, eps=1e-9):\n        key = self._cell_key(pos)\n        lst = self._grid_collect(grid, key, 0)\n        if not lst:\n            lst = []\n        for n in lst:\n            if self._dist(n.position, pos) <= eps:\n                return n\n        # try neighbor ring\n        lst = self._grid_collect(grid, key, 1)\n        for n in lst:\n            if self._dist(n.position, pos) <= eps:\n                return n\n        return None\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(3.5, self.step * 1.6)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Edge bookkeeping\n    def _edges_add(self, edges, parent, child):\n        key = (id(parent), id(child))\n        if key in self._eindex:\n            return\n        edges.append((parent, child))\n        self._eindex[key] = len(edges) - 1\n\n    def _edges_remove(self, edges, parent, child):\n        key = (id(parent), id(child))\n        idx = self._eindex.get(key)\n        if idx is None:\n            return\n        last = len(edges) - 1\n        if idx != last:\n            edges[idx] = edges[last]\n            pk, ck = id(edges[idx][0]), id(edges[idx][1])\n            self._eindex[(pk, ck)] = idx\n        edges.pop()\n        self._eindex.pop(key, None)\n\n    # Path utilities and smoothing\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _elastic_smooth(self, pts, passes):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = list(pts)\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                b = cur[i]\n                c = cur[i + 1]\n                target = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                t = 1.0\n                best = b\n                while t > 1e-3:\n                    cand = tuple(b[k] + (target[k] - b[k]) * t for k in range(self.dim))\n                    cand = self._clamp(cand)\n                    if (not self._point_blocked(cand)) and self._edge_free(a, cand) and self._edge_free(cand, c):\n                        best = cand\n                        break\n                    t *= 0.5\n                if best != b:\n                    cur[i] = best\n                    moved = True\n            if not moved:\n                break\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._shortcut(path, self.shortcut_attempts)\n        p2 = self._visibility_prune(p1)\n        p3 = self._elastic_smooth(p2, self.smooth_passes)\n        out = []\n        last = None\n        for p in p3:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out",
          "objective": -39.25344,
          "time_improvement": 81.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1553.0,
          "node_improvement": 92.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.00945742130279541,
                    "num_nodes_avg": 50.0,
                    "path_length_avg": 167.53693550319753,
                    "smoothness_avg": 0.033726978508844686,
                    "success_improvement": 0.0,
                    "time_improvement": 62.402160293144725,
                    "node_improvement": 87.40871317048602,
                    "length_improvement": 8.170350858066406,
                    "smoothness_improvement": 427.90045296948705,
                    "objective_score": 25.762360867630697
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01689279079437256,
                    "num_nodes_avg": 92.0,
                    "path_length_avg": 258.9566017823895,
                    "smoothness_avg": 0.08894239443432421,
                    "success_improvement": 0.0,
                    "time_improvement": 89.45588977402788,
                    "node_improvement": 93.81845058120003,
                    "length_improvement": 13.552832672535061,
                    "smoothness_improvement": 2188.5518714124423,
                    "objective_score": 45.911225892791606
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.004900145530700684,
                    "num_nodes_avg": 37.0,
                    "path_length_avg": 128.24827679318562,
                    "smoothness_avg": 0.16853365869929307,
                    "success_improvement": 0.0,
                    "time_improvement": 89.91298330339527,
                    "node_improvement": 95.29561347743166,
                    "length_improvement": 14.823601080648544,
                    "smoothness_improvement": 2043.7356987943315,
                    "objective_score": 46.086734133379366
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "GLOW-RRTC*: Guided Lightweight Optimal-Rewire BiRRT-Connect. A simple, general bi-directional planner using ring-grid nearest search, cost-aware parent selection, shrinking local rewiring, and corridor-biased sampling. Each insertion enforces strict node and edge validity, performs short line-of-sight compression, then attempts an adaptive micro-connect to the opposite tree. On bridge, greedy visibility pruning and a few shortcuts yield short, smooth paths quickly while keeping the design compact and robust.",
          "planning_mechanism": "Alternate tree growth. Sample (uniform/goal/corridor), find nearest via ring-grid, steer one step, choose the cheapest feasible parent among local neighbors, validate node and edge, insert, compress to a visible ancestor, and rewire nearby nodes with a decaying radius. Try direct connection to the opposite tree, else extend it a few micro-steps with the same checks. On bridge, stitch, prune by visibility, shortcut, return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        path = []\n        cur = self\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3500,\n                 step_size=8.0,\n                 goal_bias=0.15,\n                 corridor_bias=0.45,\n                 cell_factor=1.0,\n                 min_sep_factor=0.4,\n                 connect_steps=3,\n                 rewire_gamma=2.0,\n                 neighbor_cap=32,\n                 prune_iters=1,\n                 shortcut_attempts=40,\n                 edge_cache_cap=40000):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.cell_factor = float(cell_factor)\n        self.min_sep_factor = float(min_sep_factor)\n        self.connect_steps = int(connect_steps)\n        self.rewire_gamma = float(rewire_gamma)\n        self.neighbor_cap = int(neighbor_cap)\n        self.prune_iters = int(prune_iters)\n        self.shortcut_attempts = int(shortcut_attempts)\n        self.edge_cache_cap = int(edge_cache_cap)\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Build obstacle grid and edge cache\n        self.obs_cell = max(3.0, self.step_size)\n        self._build_obs_grid()\n        self._edge_cache = {}\n\n        # Validate endpoints\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            s = Node(self.start, None, 0.0)\n            g = Node(self.goal, s, self._dist(self.start, self.goal))\n            s.add_child(g)\n            nodes.extend([s, g])\n            edges.append((s, g))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Spatial node grid\n        self.cell = max(1.0, self.cell_factor * self.step_size)\n        self.min_sep = max(0.5, self.min_sep_factor * self.step_size)\n\n        # Trees A/B\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, a_root)\n        self._grid_add(Gb, b_root)\n        nodes.extend([a_root, b_root])\n\n        best_path = None\n        best_cost = float('inf')\n        sg = self._dist(self.start, self.goal)\n        corridor_w = max(self.step_size, 0.2 * sg)\n\n        for it in range(self.max_iter):\n            grow_a = (it % 2 == 0)\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            attractor = self.goal if grow_a else self.start\n            root_y = b_root if grow_a else a_root\n\n            # Sample\n            xr = None\n            r = self._rand()\n            if r < self.goal_bias:\n                xr = attractor\n            elif best_path is not None and self._rand() < self.corridor_bias:\n                xr = self._sample_corridor(self.start, self.goal, corridor_w)\n            else:\n                xr = self._sample_uniform()\n            xr = self._clamp(xr)\n            if not self._in_bounds(xr) or self._point_blocked(xr):\n                continue\n\n            # Nearest and steer\n            n_near = self._nearest(G, T, xr)\n            if n_near is None:\n                continue\n            x_new_pos = self._steer(n_near.position, xr, self.step_size)\n            if not self._in_bounds(x_new_pos) or self._point_blocked(x_new_pos):\n                continue\n            if self._near_duplicate(G, x_new_pos, self.min_sep):\n                continue\n\n            # Cost-aware parent selection among local neighbors\n            radius = self._rewire_radius(len(nodes))\n            cand = self._candidate_parents(G, T, x_new_pos, radius, self.neighbor_cap)\n            best_parent = None\n            best_new_cost = 1e100\n            for p in cand:\n                if not self._edge_free(p.position, x_new_pos):\n                    continue\n                gc = p.cost + self._dist(p.position, x_new_pos)\n                if gc < best_new_cost:\n                    best_new_cost = gc\n                    best_parent = p\n            if best_parent is None:\n                continue\n\n            # Mandatory checks before insertion\n            if self._point_blocked(x_new_pos):\n                continue\n            if not self._edge_free(best_parent.position, x_new_pos):\n                continue\n\n            x_new = Node(x_new_pos, best_parent, best_new_cost)\n            best_parent.add_child(x_new)\n            T.append(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n            self._grid_add(G, x_new)\n\n            # Short line-of-sight compression to ancestor\n            self._compress_one_step(x_new, edges)\n\n            # Local rewiring\n            self._rewire_neighbors(G, x_new, radius, edges)\n\n            # Try to bridge\n            q_opp = self._nearest(Gopp, Topp, x_new.position)\n            bridged = None\n            if q_opp is not None and self._edge_free(x_new.position, q_opp.position):\n                bridged = q_opp\n            else:\n                head = q_opp\n                hops = 0\n                last = head\n                while head is not None and hops < self.connect_steps:\n                    step_pos = self._steer(head.position, x_new.position, self.step_size)\n                    if not self._in_bounds(step_pos) or self._point_blocked(step_pos):\n                        break\n                    if self._near_duplicate(Gopp, step_pos, self.min_sep):\n                        break\n                    par = head\n                    if par.parent is not None and self._edge_free(par.parent.position, step_pos):\n                        par = par.parent\n                    if not self._edge_free(par.position, step_pos):\n                        break\n                    # Node and edge checks passed, insert\n                    q = Node(step_pos, par, par.cost + self._dist(par.position, step_pos))\n                    par.add_child(q)\n                    Topp.append(q)\n                    nodes.append(q)\n                    edges.append((par, q))\n                    self._grid_add(Gopp, q)\n                    self._compress_one_step(q, edges)\n                    self._rewire_neighbors(Gopp, q, self._rewire_radius(len(nodes)), edges)\n                    if self._edge_free(q.position, x_new.position):\n                        bridged = q\n                        break\n                    head = q\n                    last = q\n                    hops += 1\n\n            if bridged is not None:\n                if grow_a:\n                    pa = x_new.path_from_root()\n                    pb = bridged.path_from_root()\n                    if pa and pb and pa[0] == pb[-1]:\n                        pb = pb[:-1]\n                    path = pa + pb[::-1]\n                else:\n                    pa = x_new.path_from_root()\n                    pb = bridged.path_from_root()\n                    if pb and pa and pb[0] == pa[-1]:\n                        pa = pa[:-1]\n                    path = pb + pa[::-1]\n\n                for _ in range(max(1, self.prune_iters)):\n                    path = self._visibility_prune(path)\n                path = self._shortcut(path, self.shortcut_attempts)\n\n                best_path = path\n                best_cost = self._path_len(path)\n                return PlannerResult(True, best_path, nodes, edges)\n\n        if best_path is not None:\n            for _ in range(max(1, self.prune_iters)):\n                best_path = self._visibility_prune(best_path)\n            best_path = self._shortcut(best_path, max(12, self.shortcut_attempts // 2))\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG and geometry\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5 if s > 0.0 else 0.0\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        r = step / max(d, 1e-12)\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Sampling\n    def _sample_uniform(self):\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _sample_corridor(self, s, g, width):\n        t = self._uniform(0.0, 1.0)\n        base = tuple(s[i] + (g[i] - s[i]) * t for i in range(self.dim))\n        if self.dim == 2:\n            dx, dy = g[0] - s[0], g[1] - s[1]\n            n = (dx*dx + dy*dy) ** 0.5\n            if n < 1e-12:\n                return self._sample_uniform()\n            vx, vy = dx / n, dy / n\n            px, py = -vy, vx\n            mag = self._uniform(-width, width)\n            return self._clamp((base[0] + px * mag, base[1] + py * mag))\n        else:\n            ab = (g[0]-s[0], g[1]-s[1], g[2]-s[2])\n            n = (ab[0]**2 + ab[1]**2 + ab[2]**2) ** 0.5\n            if n < 1e-12:\n                return self._sample_uniform()\n            v = (ab[0]/n, ab[1]/n, ab[2]/n)\n            r = (self._uniform(-1.0, 1.0), self._uniform(-1.0, 1.0), self._uniform(-1.0, 1.0))\n            dot = r[0]*v[0] + r[1]*v[1] + r[2]*v[2]\n            u = (r[0]-dot*v[0], r[1]-dot*v[1], r[2]-dot*v[2])\n            un = (u[0]**2 + u[1]**2 + u[2]**2) ** 0.5\n            if un < 1e-12:\n                u = (v[1], -v[0], 0.0)\n                un = (u[0]**2 + u[1]**2 + u[2]**2) ** 0.5\n            u = (u[0]/un, u[1]/un, u[2]/un)\n            mag = self._uniform(-width, width)\n            return self._clamp((base[0] + u[0]*mag, base[1] + u[1]*mag, base[2] + u[2]*mag))\n\n    # Node spatial grid\n    def _gkey(self, pos):\n        if self.dim == 3:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        else:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._gkey(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, tree, pos):\n        key = self._gkey(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        for r in range(0, 3):\n            cand = self._collect_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                found = True\n                break\n        if not found:\n            step = max(1, len(tree) // 64) if tree else 1\n            for i in range(0, len(tree), step):\n                n = tree[i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._gkey(pos)\n        cand = self._collect_ring(grid, key, 1)\n        rr = radius + 1e-9\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    def _candidate_parents(self, grid, tree, pos, radius, cap):\n        key = self._gkey(pos)\n        r_cells = max(1, int(radius // self.cell) + 1)\n        cand = self._collect_ring(grid, key, r_cells)\n        if not cand:\n            cand = tree[:min(len(tree), cap)]\n        if len(cand) > cap:\n            # reservoir-like\n            out = []\n            seen = 0\n            for n in cand:\n                seen += 1\n                if len(out) < cap:\n                    out.append(n)\n                else:\n                    j = int(self._uniform(0, seen))\n                    if j < len(out):\n                        out[j] = n\n            cand = out\n        return cand\n\n    # Obstacle grid and collision checks\n    def _build_obs_grid(self):\n        self.obs_grid = {}\n        if self.dim == 3:\n            for idx, o in enumerate(self.obstacles):\n                ox, oy, oz, w, h, d = o\n                ix0 = int(max(0.0, ox) // self.obs_cell)\n                iy0 = int(max(0.0, oy) // self.obs_cell)\n                iz0 = int(max(0.0, oz) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], ox + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], oy + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], oz + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obs_grid.get(key)\n                            if b is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                ox, oy, w, h = o\n                ix0 = int(max(0.0, ox) // self.obs_cell)\n                iy0 = int(max(0.0, oy) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], ox + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], oy + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obs_grid.get(key)\n                        if b is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_blocked(self, p):\n        if self.dim == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_free(self, a, b):\n        k = self._edge_key(a, b)\n        c = self._edge_cache.get(k)\n        if c is not None:\n            return c\n        hit = self._segment_hits(a, b)\n        ok = not hit\n        if len(self._edge_cache) > self.edge_cache_cap:\n            i = 0\n            # prune roughly a third\n            for kk in list(self._edge_cache.keys()):\n                if (i % 3) == 0:\n                    try:\n                        del self._edge_cache[kk]\n                    except:\n                        pass\n                i += 1\n        self._edge_cache[k] = ok\n        return ok\n\n    def _segment_hits(self, a, b):\n        if self.dim == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obs_grid.get((i, j, k))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                if self._seg_box_hit3d(a, b, self.obstacles[idx]):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obs_grid.get((i, j))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                if self._seg_box_hit2d(a, b, self.obstacles[idx]):\n                    return True\n            return False\n\n    def _seg_box_hit2d(self, a, b, box):\n        x, y, w, h = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        t0, t1 = 0.0, 1.0\n        ax, ay = a\n        bx, by = b\n        dx = bx - ax\n        dy = by - ay\n        if abs(dx) < 1e-12:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            tA = (minx - ax) * inv\n            tB = (maxx - ax) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n        if abs(dy) < 1e-12:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            tA = (miny - ay) * inv\n            tB = (maxy - ay) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n        return t1 >= 0.0 and t0 <= 1.0\n\n    def _seg_box_hit3d(self, a, b, box):\n        x, y, z, w, h, d = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        minz, maxz = z, z + d\n        t0, t1 = 0.0, 1.0\n        ax, ay, az = a\n        bx, by, bz = b\n        dx = bx - ax\n        dy = by - ay\n        dz = bz - az\n        if abs(dx) < 1e-12:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            tA = (minx - ax) * inv\n            tB = (maxx - ax) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n        if abs(dy) < 1e-12:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            tA = (miny - ay) * inv\n            tB = (maxy - ay) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n        if abs(dz) < 1e-12:\n            if az < minz or az > maxz:\n                return False\n        else:\n            inv = 1.0 / dz\n            tA = (minz - az) * inv\n            tB = (maxz - az) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n        return t1 >= 0.0 and t0 <= 1.0\n\n    # RRT* utilities\n    def _rewire_radius(self, n_nodes):\n        base = self.rewire_gamma * self.step_size / ((1.0 + 0.05 * max(1, n_nodes)) ** (1.0 / max(1, self.dim)))\n        return max(self.step_size, base)\n\n    def _compress_one_step(self, node, edges):\n        p = node.parent\n        if p is None or p.parent is None:\n            return\n        gp = p.parent\n        if self._edge_free(gp.position, node.position):\n            self._reparent(node, gp, edges)\n\n    def _rewire_neighbors(self, grid, node, radius, edges):\n        key = self._gkey(node.position)\n        r_cells = max(1, int(radius // self.cell) + 1)\n        neigh = self._collect_ring(grid, key, r_cells)\n        count = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if d > radius:\n                continue\n            new_cost = node.cost + d\n            if new_cost + 1e-9 < nb.cost and self._edge_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n                count += 1\n                if count >= self.neighbor_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        old_parent = child.parent\n        if old_parent is new_parent:\n            return\n        if old_parent is not None:\n            old_parent.remove_child(child)\n            self._edges_remove(edges, old_parent, child)\n        new_parent.add_child(child)\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        edges.append((new_parent, child))\n        self._propagate_costs(child)\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                old = ch.cost\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                if abs(ch.cost - old) > 1e-12:\n                    stack.append(ch)\n\n    # Path utilities\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return path[:]\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], path[j]):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i + 1])\n                i += 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = list(path)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and n >= 3:\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 2, n))\n            a = pts[i]\n            b = pts[j - 1]\n            if self._edge_free(a, b):\n                pts = pts[:i + 1] + pts[j - 1:]\n                n = len(pts)\n            tries += 1\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        return pts\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L",
          "objective": -38.95445,
          "time_improvement": 77.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1518.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007930564880371093,
                    "num_nodes_avg": 51.8,
                    "path_length_avg": 172.28898677930243,
                    "smoothness_avg": 0.04557670744519382,
                    "success_improvement": 0.0,
                    "time_improvement": 68.47215561086668,
                    "node_improvement": 86.95542684462352,
                    "length_improvement": 5.5656762525621,
                    "smoothness_improvement": 613.3744429215927,
                    "objective_score": 26.947924649405227
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.021958351135253906,
                    "num_nodes_avg": 107.1,
                    "path_length_avg": 236.32664856425262,
                    "smoothness_avg": 0.1094935709665247,
                    "success_improvement": 0.0,
                    "time_improvement": 86.2940778957704,
                    "node_improvement": 92.80387018746221,
                    "length_improvement": 21.107362423836506,
                    "smoothness_improvement": 2717.348446000099,
                    "objective_score": 52.13938305303352
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010874390602111816,
                    "num_nodes_avg": 74.8,
                    "path_length_avg": 129.54877071499192,
                    "smoothness_avg": 0.10402004857719598,
                    "success_improvement": 0.0,
                    "time_improvement": 77.61491798934009,
                    "node_improvement": 90.4895104895105,
                    "length_improvement": 13.95987494065061,
                    "smoothness_improvement": 1223.127339940617,
                    "objective_score": 37.776037060895476
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "FLASH-ABiRC: Fast Heuristic Anytime Smooth Hybrid BiRRT-Connect. It alternates growth of two trees with ring-grid nearest lookup, strict mandatory node/edge collision checks, near-duplicate suppression, and on-the-fly line-of-sight compression to reduce bends and depth. After the first feasible bridge, it applies bounded visibility pruning and few shortcuts and returns immediately. If a path exists, informed ellipse/tube sampling with an f-gate refocuses expansions; connection attempts use a direct check plus at most two micro-steps, minimizing collision checks and variance.",
          "planning_mechanism": "Alternate bi-directional expansions: sample (uniform/line; then ellipse/tube after first path), ring-grid nearest, single-step steer, mandatory node/edge checks, optional compression to ancestor if visible, insert. Try direct opposite-tree connect, else extend the other tree a couple of steps with the same checks. On bridge: stitch, prune by visibility, few shortcuts, return. Throughout, use spatial hashes for nodes/obstacles, cached segment-box tests, f-gated pruning when an incumbent cost exists.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        cur = self\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3200,\n                 step_size=7.0,\n                 goal_bias=0.12,\n                 line_bias=0.35,\n                 informed_bias=0.6,\n                 tube_bias=0.35,\n                 cell_factor=1.2,\n                 min_sep_factor=0.55,\n                 ring_max=2,\n                 connect_hops=2,\n                 heur_gate=1.08,\n                 prune_iters=1,\n                 shortcut_trials=28):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.informed_bias = float(informed_bias)\n        self.tube_bias = float(tube_bias)\n        self.cell_factor = float(cell_factor)\n        self.min_sep_factor = float(min_sep_factor)\n        self.ring_max = int(ring_max)\n        self.connect_hops = int(connect_hops)\n        self.heur_gate = float(heur_gate)\n        self.prune_iters = int(prune_iters)\n        self.shortcut_trials = int(shortcut_trials)\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Build obstacle grid and caches\n        self._edge_cache = {}\n        self.obs_cell = max(3.0, self.step_size)\n        self._build_obs_grid()\n\n        # Node checks for start/goal\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            s = Node(self.start, None, 0.0)\n            g = Node(self.goal, s, self._dist(self.start, self.goal))\n            s.add_child(g)\n            nodes.extend([s, g])\n            edges.append((s, g))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Derived params\n        self.cell = max(1.0, self.cell_factor * self.step_size)\n        self.min_sep = max(0.5, self.min_sep_factor * self.step_size)\n        sg = self._dist(self.start, self.goal)\n        self.corridor_w = max(self.step_size, 0.18 * sg)\n\n        # Trees\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, a_root)\n        self._grid_add(Gb, b_root)\n\n        best_path = None\n        c_best = float('inf')\n        informed = False\n\n        for it in range(self.max_iter):\n            grow_a = (it % 2 == 0)\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            root_x = a_root if grow_a else b_root\n            root_y = b_root if grow_a else a_root\n            attractor = self.goal if grow_a else self.start\n\n            # Sample\n            xr = None\n            r = self._rand()\n            if informed and r < self.informed_bias and c_best < float('inf'):\n                xr = self._sample_ellipse(root_x.position, root_y.position, c_best)\n            if xr is None:\n                r2 = self._rand()\n                if r2 < self.goal_bias:\n                    xr = attractor\n                elif r2 < self.goal_bias + self.line_bias:\n                    xr = self._sample_corridor(root_x.position, root_y.position, self.corridor_w)\n                elif informed and self._rand() < self.tube_bias and best_path is not None:\n                    xr = self._sample_tube(best_path)\n                else:\n                    xr = self._sample_uniform()\n            xr = self._clamp(xr)\n            if self._point_blocked(xr):\n                continue\n\n            # Nearest and steer\n            n_near = self._nearest(G, T, xr)\n            if n_near is None:\n                continue\n            x_new_pos = self._steer(n_near.position, xr, self.step_size)\n            if not self._in_bounds(x_new_pos):\n                continue\n            if self._point_blocked(x_new_pos):\n                continue\n            if self._near_duplicate(G, x_new_pos, self.min_sep):\n                continue\n\n            # Heuristic gate\n            if informed and c_best < float('inf'):\n                g_tent = n_near.cost + self._dist(n_near.position, x_new_pos)\n                f = g_tent + self._dist(x_new_pos, root_y.position)\n                if f >= self.heur_gate * c_best:\n                    continue\n\n            # Edge check to nearest; if ok, try one-hop compression to parent\n            if not self._edge_free(n_near.position, x_new_pos):\n                continue\n            parent = n_near\n            if n_near.parent is not None:\n                cand_p = n_near.parent\n                if self._edge_free(cand_p.position, x_new_pos):\n                    parent = cand_p\n\n            # Mandatory checks before insertion (node and edge)\n            if self._point_blocked(x_new_pos):\n                continue\n            if not self._edge_free(parent.position, x_new_pos):\n                continue\n\n            new_cost = parent.cost + self._dist(parent.position, x_new_pos)\n            x_new = Node(x_new_pos, parent, new_cost)\n            parent.add_child(x_new)\n            T.append(x_new)\n            nodes.append(x_new)\n            edges.append((parent, x_new))\n            self._grid_add(G, x_new)\n\n            # Try connect to opposite tree: direct then micro-hops\n            q_opp = self._nearest(Gopp, Topp, x_new.position)\n            bridged = None\n            if q_opp is not None and self._edge_free(x_new.position, q_opp.position):\n                bridged = q_opp\n            else:\n                head = q_opp\n                hops = 0\n                while head is not None and hops < self.connect_hops:\n                    step_pos = self._steer(head.position, x_new.position, self.step_size)\n                    if not self._in_bounds(step_pos) or self._point_blocked(step_pos):\n                        break\n                    if self._near_duplicate(Gopp, step_pos, self.min_sep):\n                        break\n                    # f-gate for opposite step\n                    if informed and c_best < float('inf'):\n                        g_hat = head.cost + self._dist(head.position, step_pos)\n                        f_hat = g_hat + self._dist(step_pos, root_x.position)\n                        if f_hat >= self.heur_gate * c_best:\n                            break\n                    # parent is head, try compression to its parent if visible\n                    par = head\n                    if head.parent is not None and self._edge_free(head.parent.position, step_pos):\n                        par = head.parent\n                    if not self._edge_free(par.position, step_pos):\n                        break\n                    q = Node(step_pos, par, par.cost + self._dist(par.position, step_pos))\n                    par.add_child(q)\n                    Topp.append(q)\n                    nodes.append(q)\n                    edges.append((par, q))\n                    self._grid_add(Gopp, q)\n                    head = q\n                    hops += 1\n                    if self._edge_free(head.position, x_new.position):\n                        bridged = head\n                        break\n\n            if bridged is not None:\n                # Assemble path\n                if grow_a:\n                    pa = x_new.path_from_root()\n                    pb = bridged.path_from_root()\n                    if pa and pb and pa[0] == pb[-1]:\n                        pb = pb[:-1]\n                    path = pa + pb[::-1]\n                else:\n                    pa = x_new.path_from_root()\n                    pb = bridged.path_from_root()\n                    if pb and pa and pb[0] == pa[-1]:\n                        pa = pa[:-1]\n                    path = pb + pa[::-1]\n\n                # Prune and shortcut (bounded)\n                for _ in range(max(1, self.prune_iters)):\n                    path = self._visibility_prune(path)\n                path = self._shortcut(path, self.shortcut_trials)\n\n                L = self._path_len(path)\n                best_path = path\n                c_best = L\n                informed = True\n                return PlannerResult(True, best_path, nodes, edges)\n\n            # Opportunistic incumbent from visible nearest other\n            if q_opp is not None and self._edge_free(x_new.position, q_opp.position):\n                cand = (x_new.path_from_root() + q_opp.path_from_root()[-2::-1]) if (x_new.path_from_root() and q_opp.path_from_root()) else None\n                if cand:\n                    Lc = self._path_len(cand)\n                    if Lc + 1e-9 < c_best:\n                        c_best = Lc\n                        best_path = cand\n                        informed = True\n\n        # No bridge found within budget; return best known (if any)\n        if best_path is not None and len(best_path) >= 2:\n            best_path = self._visibility_prune(best_path)\n            best_path = self._shortcut(best_path, max(12, self.shortcut_trials // 2))\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG and basic geometry\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5 if s > 0.0 else 0.0\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        r = step / max(1e-12, d)\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # Sampling\n    def _sample_uniform(self):\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _sample_corridor(self, a, b, width):\n        t = self._uniform(0.0, 1.0)\n        base = tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n        if self.dim == 2:\n            dx, dy = b[0] - a[0], b[1] - a[1]\n            n = (dx*dx + dy*dy) ** 0.5\n            if n < 1e-12:\n                return self._sample_uniform()\n            vx, vy = dx / n, dy / n\n            px, py = -vy, vx\n            mag = self._uniform(-width, width)\n            return self._clamp((base[0] + px * mag, base[1] + py * mag))\n        else:\n            ab = (b[0]-a[0], b[1]-a[1], b[2]-a[2])\n            n = (ab[0]**2 + ab[1]**2 + ab[2]**2) ** 0.5\n            if n < 1e-12:\n                return self._sample_uniform()\n            v = (ab[0]/n, ab[1]/n, ab[2]/n)\n            r = (self._uniform(-1.0, 1.0), self._uniform(-1.0, 1.0), self._uniform(-1.0, 1.0))\n            dot = r[0]*v[0] + r[1]*v[1] + r[2]*v[2]\n            u = (r[0]-dot*v[0], r[1]-dot*v[1], r[2]-dot*v[2])\n            un = (u[0]**2 + u[1]**2 + u[2]**2) ** 0.5\n            if un < 1e-12:\n                u = (v[1], -v[0], 0.0)\n                un = (u[0]**2 + u[1]**2 + u[2]**2) ** 0.5\n            u = (u[0]/un, u[1]/un, u[2]/un)\n            mag = self._uniform(-width, width)\n            return self._clamp((base[0] + u[0]*mag, base[1] + u[1]*mag, base[2] + u[2]*mag))\n\n    def _sample_ellipse(self, a, b, c_best):\n        if c_best == float('inf'):\n            return None\n        for _ in range(24):\n            p = self._sample_uniform()\n            if self._dist(p, a) + self._dist(p, b) <= c_best + 1e-9 and not self._point_blocked(p):\n                return p\n        return None\n\n    def _sample_tube(self, path):\n        if not path or len(path) < 2:\n            return self._sample_uniform()\n        i = int(self._uniform(0, len(path) - 1))\n        if i >= len(path) - 1:\n            i = len(path) - 2\n        a = path[i]\n        b = path[i + 1]\n        t = self._uniform(0.0, 1.0)\n        base = tuple(a[d] + t * (b[d] - a[d]) for d in range(self.dim))\n        rad = 0.7 * self.step_size\n        if self.dim == 2:\n            return self._clamp((base[0] + self._uniform(-rad, rad),\n                                base[1] + self._uniform(-rad, rad)))\n        else:\n            return self._clamp((base[0] + self._uniform(-rad, rad),\n                                base[1] + self._uniform(-rad, rad),\n                                base[2] + self._uniform(-rad, rad)))\n\n    # Node spatial grid\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        return out\n\n    def _nearest(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        for r in range(0, self.ring_max + 1):\n            cand = self._collect_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                found = True\n                break\n        if not found:\n            step = max(1, len(tree) // 64) if tree else 1\n            for i in range(0, len(tree), step):\n                n = tree[i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _near_duplicate(self, grid, pos, radius):\n        cand = self._collect_ring(grid, self._grid_key(pos), 1)\n        rr = radius + 1e-9\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # Obstacles grid and collision checks\n    def _build_obs_grid(self):\n        self.obs_grid = {}\n        if self.dim == 3:\n            for idx, o in enumerate(self.obstacles):\n                ox, oy, oz, w, h, d = o\n                ix0 = int(max(0.0, ox) // self.obs_cell)\n                iy0 = int(max(0.0, oy) // self.obs_cell)\n                iz0 = int(max(0.0, oz) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], ox + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], oy + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], oz + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obs_grid.get(key)\n                            if b is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                ox, oy, w, h = o\n                ix0 = int(max(0.0, ox) // self.obs_cell)\n                iy0 = int(max(0.0, oy) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], ox + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], oy + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obs_grid.get(key)\n                        if b is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_blocked(self, p):\n        if self.dim == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_free(self, a, b):\n        k = self._edge_key(a, b)\n        c = self._edge_cache.get(k)\n        if c is not None:\n            return c\n        hit = self._segment_hits(a, b)\n        self._edge_cache[k] = not hit\n        return not hit\n\n    def _segment_hits(self, a, b):\n        if self.dim == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obs_grid.get((i, j, k))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                if self._seg_box_hit3d(a, b, self.obstacles[idx]):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obs_grid.get((i, j))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                if self._seg_box_hit2d(a, b, self.obstacles[idx]):\n                    return True\n            return False\n\n    def _seg_box_hit2d(self, a, b, box):\n        x, y, w, h = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        t0, t1 = 0.0, 1.0\n        ax, ay = a\n        bx, by = b\n        dx = bx - ax\n        dy = by - ay\n\n        if abs(dx) < 1e-12:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            tA = (minx - ax) * inv\n            tB = (maxx - ax) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n\n        if abs(dy) < 1e-12:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            tA = (miny - ay) * inv\n            tB = (maxy - ay) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n\n        return t1 >= 0.0 and t0 <= 1.0\n\n    def _seg_box_hit3d(self, a, b, box):\n        x, y, z, w, h, d = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        minz, maxz = z, z + d\n        t0, t1 = 0.0, 1.0\n        ax, ay, az = a\n        bx, by, bz = b\n        dx = bx - ax\n        dy = by - ay\n        dz = bz - az\n\n        if abs(dx) < 1e-12:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            tA = (minx - ax) * inv\n            tB = (maxx - ax) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n\n        if abs(dy) < 1e-12:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            tA = (miny - ay) * inv\n            tB = (maxy - ay) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n\n        if abs(dz) < 1e-12:\n            if az < minz or az > maxz:\n                return False\n        else:\n            inv = 1.0 / dz\n            tA = (minz - az) * inv\n            tB = (maxz - az) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n\n        return t1 >= 0.0 and t0 <= 1.0\n\n    # Path utils\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return path[:]\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], path[j]):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i + 1])\n                i += 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = list(path)\n        n = len(pts)\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 2, n))\n            a = pts[i]\n            b = pts[j - 1]\n            if self._edge_free(a, b):\n                pts = pts[:i + 1] + pts[j - 1:]\n                n = len(pts)\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        return pts\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L",
          "objective": -38.87335,
          "time_improvement": 75.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1876.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.006264138221740723,
                    "num_nodes_avg": 56.7,
                    "path_length_avg": 171.88502102126137,
                    "smoothness_avg": 0.04966818877179101,
                    "success_improvement": 0.0,
                    "time_improvement": 75.09701035598583,
                    "node_improvement": 85.72148073533116,
                    "length_improvement": 5.78709628579148,
                    "smoothness_improvement": 677.4150104767455,
                    "objective_score": 29.388435930654364
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02297062873840332,
                    "num_nodes_avg": 122.2,
                    "path_length_avg": 242.80866792108137,
                    "smoothness_avg": 0.11993325646889634,
                    "success_improvement": 0.0,
                    "time_improvement": 85.662236374922,
                    "node_improvement": 91.78928979372438,
                    "length_improvement": 18.943477787944797,
                    "smoothness_improvement": 2985.9690733776524,
                    "objective_score": 51.99460295213174
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017574667930603027,
                    "num_nodes_avg": 116.3,
                    "path_length_avg": 134.8321489290259,
                    "smoothness_avg": 0.1622613841577103,
                    "success_improvement": 0.0,
                    "time_improvement": 63.82230532897514,
                    "node_improvement": 85.2129688493325,
                    "length_improvement": 10.450906698324257,
                    "smoothness_improvement": 1963.9528295965463,
                    "objective_score": 35.23699976566982
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Simple Balanced BiRRT-Connect-S (SB-Connect-S): a lean, robust bidirectional RRT-Connect variant with lightweight hash-grid nearest search, duplicate suppression, capped greedy connect, and deterministic shortcut-plus-relax smoothing. It avoids rewiring/compression to reduce overhead and improve generalization, while enforcing strict node/edge collision checks and bounds at every insertion.",
          "planning_mechanism": "Alternate expanding start and goal trees. Each iteration: sample (with small goal bias), steer one step from the nearest node if both node and edge are free, then greedily connect the opposite tree toward the new node with a capped number of steps. On first line-of-sight bridge, concatenate the two trees and post-process using chord shortcuts followed by bounded Laplacian relaxation; return the smoothed path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=7.0,\n        goal_bias=0.2,\n        collision_step=1.0,\n        grid_cell=4.0,\n        dupe_radius_ratio=0.5,\n        connect_limit=24,\n        shortcut_passes=2,\n        relax_iters=16,\n        relax_alpha=0.3\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.connect_limit = connect_limit\n        self.shortcut_passes = shortcut_passes\n        self.relax_iters = relax_iters\n        self.relax_alpha = relax_alpha\n\n        self.bounds = None\n        self.dim = 2\n        self.edge_res = 1.0\n\n        self._rng_s = 2463534242  # xorshift seed\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.edge_res = max(0.5, min(self.collision_step, self.step_size * 0.5))\n        self.grid_cell = max(1.0, self.grid_cell)\n\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early LOS\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_res):\n            n0 = Node(start)\n            n1 = Node(goal, parent=n0, cost=self._dist(start, goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [start, goal], [n0, n1], [(n0, n1)])\n\n        # Initialize trees and neighbor grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        dupe_radius = max(1e-6, self.dupe_radius_ratio * self.step_size)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            grow_tree = tree_a if active_start else tree_b\n            other_tree = tree_b if active_start else tree_a\n            grow_grid = grid_a if active_start else grid_b\n            other_grid = grid_b if active_start else grid_a\n            attractor = goal if active_start else start\n\n            # Sample\n            x_rand = attractor if (self._rand() < self.goal_bias) else self._sample_free(obstacles, is_3d)\n\n            # Extend one step from nearest with both checks\n            nearest = self._nearest_grid(grow_grid, grow_tree, x_rand)\n            if nearest is None:\n                continue\n            x_new = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(x_new):\n                continue\n            if self._is_in_obstacle(x_new, obstacles, is_3d):\n                continue\n            if self._exists_close(grow_grid, x_new, dupe_radius):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, x_new, obstacles, is_3d, self.edge_res):\n                continue\n\n            new_node = Node(x_new, parent=nearest, cost=nearest.cost + self._dist(nearest.position, x_new))\n            nearest.add_child(new_node)\n            grow_tree.append(new_node)\n            nodes.append(new_node)\n            self._grid_add(grow_grid, new_node)\n            edges.append((nearest, new_node))\n\n            # Greedy capped connect from the opposite tree\n            bridger = self._connect_toward(other_tree, other_grid, new_node.position, obstacles, is_3d, edges, nodes)\n            if bridger is not None:\n                # Verify LOS between last node of opposite tree and new_node\n                if not self._is_edge_in_obstacle(bridger.position, new_node.position, obstacles, is_3d, self.edge_res):\n                    if active_start:\n                        path_a = self._collect_root_to(new_node)\n                        path_b = self._collect_to_root(bridger)\n                    else:\n                        path_a = self._collect_root_to(bridger)\n                        path_b = self._collect_to_root(new_node)\n                    raw_path = path_a + path_b\n                    smooth = self._smooth_path(raw_path, obstacles, is_3d)\n                    return PlannerResult(True, smooth, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG utilities\n    def _rand(self):\n        # xorshift32\n        x = self._rng_s & 0xFFFFFFFF\n        x ^= (x << 13) & 0xFFFFFFFF\n        x ^= (x >> 17) & 0xFFFFFFFF\n        x ^= (x << 5) & 0xFFFFFFFF\n        self._rng_s = x & 0xFFFFFFFF\n        return (self._rng_s % 1000003) / 1000003.0\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry and bounds\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / (d if d > 1e-12 else 1.0)\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision checks\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for ox, oy, oz, w, h, d in obstacles:\n                if ox <= px <= ox + w and oy <= py <= oy + h and oz <= pz <= oz + d:\n                    return True\n        else:\n            px, py = pos\n            for ox, oy, w, h in obstacles:\n                if ox <= px <= ox + w and oy <= py <= oy + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = max(1, int(d / max(1e-9, resolution)))\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # Hash grid for neighbors\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, 3):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # Connect routine\n    def _connect_toward(self, tree, grid, target, obstacles, is_3d, edges, nodes):\n        last = None\n        steps = 0\n        while steps < self.connect_limit:\n            nearest = self._nearest_grid(grid, tree, target)\n            if nearest is None:\n                break\n            step = self._steer(nearest.position, target, self.step_size)\n            if not self._in_bounds(step):\n                break\n            if self._is_in_obstacle(step, obstacles, is_3d):\n                break\n            if self._is_edge_in_obstacle(nearest.position, step, obstacles, is_3d, self.edge_res):\n                break\n\n            node = Node(step, parent=nearest, cost=nearest.cost + self._dist(nearest.position, step))\n            nearest.add_child(node)\n            tree.append(node)\n            nodes.append(node)\n            self._grid_add(grid, node)\n            edges.append((nearest, node))\n            last = node\n            steps += 1\n\n            # If we can directly see the target from here, stop\n            if not self._is_edge_in_obstacle(node.position, target, obstacles, is_3d, self.edge_res):\n                return node\n        return last\n\n    # Paths\n    def _collect_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts\n\n    def _collect_root_to(self, node):\n        pts = self._collect_to_root(node)\n        pts.reverse()\n        return pts\n\n    # Smoothing\n    def _smooth_path(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return list(path)\n\n        pts = list(path)\n\n        # Deterministic chord shortcutting (multiple passes)\n        for _ in range(self.shortcut_passes):\n            i = 0\n            while i + 2 < len(pts):\n                j = len(pts) - 1\n                merged = False\n                while j >= i + 2:\n                    if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d, self.edge_res):\n                        pts = pts[:i + 1] + pts[j:]\n                        merged = True\n                        break\n                    j -= 1\n                if not merged:\n                    i += 1\n\n        # Bounded Laplacian relaxation (keep endpoints)\n        for _ in range(self.relax_iters):\n            changed = False\n            for k in range(1, len(pts) - 1):\n                prevp = pts[k - 1]\n                nextp = pts[k + 1]\n                mid = tuple((prevp[d] + nextp[d]) * 0.5 for d in range(self.dim))\n                cand = tuple(pts[k][d] * (1.0 - self.relax_alpha) + mid[d] * self.relax_alpha for d in range(self.dim))\n                cand = self._clamp(cand)\n                if self._is_in_obstacle(cand, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(prevp, cand, obstacles, is_3d, self.edge_res):\n                    continue\n                if self._is_edge_in_obstacle(cand, nextp, obstacles, is_3d, self.edge_res):\n                    continue\n                if cand != pts[k]:\n                    pts[k] = cand\n                    changed = True\n            if not changed:\n                break\n\n        return pts",
          "objective": -37.58195,
          "time_improvement": 61.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1824.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01876068115234375,
                    "num_nodes_avg": 52.9,
                    "path_length_avg": 157.00483474933822,
                    "smoothness_avg": 0.041133669291120264,
                    "success_improvement": 0.0,
                    "time_improvement": 31.98180949063289,
                    "node_improvement": 86.67841853437423,
                    "length_improvement": 13.943162173073038,
                    "smoothness_improvement": 543.831247598565,
                    "objective_score": 20.679596389026514
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02154686450958252,
                    "num_nodes_avg": 118.9,
                    "path_length_avg": 237.81157593905044,
                    "smoothness_avg": 0.12476449035220605,
                    "success_improvement": 0.0,
                    "time_improvement": 86.97908997520419,
                    "node_improvement": 92.01101928374655,
                    "length_improvement": 20.611650924864367,
                    "smoothness_improvement": 3110.2802009923225,
                    "objective_score": 54.012118552441486
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01912965774536133,
                    "num_nodes_avg": 120.4,
                    "path_length_avg": 125.41225389807512,
                    "smoothness_avg": 0.1508052150070723,
                    "success_improvement": 0.0,
                    "time_improvement": 63.12897066561279,
                    "node_improvement": 84.69167196439923,
                    "length_improvement": 16.70715245068287,
                    "smoothness_improvement": 1818.231203606877,
                    "objective_score": 38.05413868812794
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "AURORA-IBiTT*: Adaptive Ultra-Refined Optimized Rewire-Aware Informed Bi-Tree. It grows two trees guided by low-dispersion Halton, goal/ellipse/corridor sampling, an adaptive neighbor radius r=\u03b3(log n/n)^(1/d), curvature-regularized parent choice with lightweight rewiring, and a short beam connect across trees. Collision checks are slab-accurate with quantized edge-caching to boost reuse. After bridging, it applies visibility pruning, stochastic shortcuts, and convex elastic smoothing for a short, smooth path. Duplicate suppression adapts with tree size, and an admissible f-gate focuses expansions once an incumbent exists.",
          "planning_mechanism": "Each iteration alternates the active tree. A sample is drawn via goal bias; else ellipse if an incumbent exists, otherwise corridor/Halton/uniform. The nearest node is found with a hashed grid; a long then short steer is attempted, enforcing bounds, node-free, and edge-free checks. If gated, neighbors within r=\u03b3(log n/n)^(1/d) are collected; the parent is chosen minimizing cost + \u03b2\u00b7angle_penalty, then attached and lightly rewired. A beam of k nearest nodes in the opposite tree attempts short-step connections toward the new node. On a successful bridge, start-to-goal is assembled and post-processed (visibility prune, shortcuts, elastic smoothing), then returned.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = set()\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.add(self)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=5.0,\n        goal_bias=0.18,\n        ellipse_bias=0.55,\n        neighbor_gamma=2.8,\n        neighbor_k_max=28,\n        beam_k=3,\n        connect_steps=3,\n        grid_cell_factor=1.35,\n        heur_gate_init=1.25,\n        heur_gate_final=1.06,\n        beta_angle=0.05,\n        smoothing_trials=100,\n        elastic_passes=3\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.ellipse_bias = ellipse_bias\n        self.neighbor_gamma = neighbor_gamma\n        self.neighbor_k_max = neighbor_k_max\n        self.beam_k = beam_k\n        self.connect_steps = connect_steps\n        self.grid_cell_factor = grid_cell_factor\n        self.heur_gate_init = heur_gate_init\n        self.heur_gate_final = heur_gate_final\n        self.beta_angle = beta_angle\n        self.smoothing_trials = smoothing_trials\n        self.elastic_passes = elastic_passes\n\n        self.dim = 2\n        self.bounds = None\n        self.cell = 1.0\n        self._edge_cache = {}\n        self._seed = 1234567\n        self._halton_idx = 1\n        self._qstep = 0.5\n\n    # Main entry\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obs(start, obstacles, is_3d) or self._point_in_obs(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        self.cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self._edge_cache = {}\n        self._seed = 1234567\n        self._halton_idx = 1\n        self._qstep = max(1e-3, self.step_size * 0.25)\n\n        # Direct path check\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.add(g)\n            nodes = [s, g]\n            edges = [(s, g)]\n            return PlannerResult(True, [start, goal], nodes, edges)\n\n        # Initialize trees and grids\n        a_root = Node(start, None, 0.0)\n        b_root = Node(goal, None, 0.0)\n        tree_a = [a_root]\n        tree_b = [b_root]\n        all_nodes = [a_root, b_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_add(grid_a, a_root)\n        self._grid_add(grid_b, b_root)\n\n        best_path = None\n        c_best = float('inf')\n        informed = False\n\n        for it in range(self.max_iter):\n            from_start = (it % 2 == 0)\n            if from_start:\n                tree_x, tree_y = tree_a, tree_b\n                grid_x, grid_y = grid_a, grid_b\n                root_x, root_y = a_root, b_root\n                attractor = goal\n            else:\n                tree_x, tree_y = tree_b, tree_a\n                grid_x, grid_y = grid_b, grid_a\n                root_x, root_y = b_root, a_root\n                attractor = start\n\n            # Sampling\n            r = self._rand()\n            if r < self.goal_bias:\n                x_rand = attractor\n            else:\n                if informed and self._rand() < self.ellipse_bias:\n                    x_rand = self._ellipse_accept_sample(root_x.position, root_y.position, c_best, 14)\n                else:\n                    if self._rand() < 0.6:\n                        width = self._corridor_width(root_x.position, root_y.position, c_best)\n                        x_rand = self._corridor_sample(root_x.position, root_y.position, width)\n                    else:\n                        if self._rand() < 0.7:\n                            x_rand = self._halton_sample()\n                        else:\n                            x_rand = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n            # Nearest in active tree\n            n_near = self._nearest_hashed(grid_x, tree_x, x_rand)\n            if n_near is None:\n                continue\n\n            # Steer long then short\n            target = self._steer(n_near.position, x_rand, 2.0 * self.step_size)\n            x_new_pos = None\n            if self._in_bounds(target) and not self._point_in_obs(target, obstacles, is_3d):\n                if not self._edge_blocked(n_near.position, target, obstacles, is_3d):\n                    x_new_pos = target\n            if x_new_pos is None:\n                target = self._steer(n_near.position, x_rand, self.step_size)\n                if not self._in_bounds(target):\n                    continue\n                if self._point_in_obs(target, obstacles, is_3d):\n                    continue\n                if self._edge_blocked(n_near.position, target, obstacles, is_3d):\n                    continue\n                x_new_pos = target\n\n            # Adaptive duplicate suppression\n            if self._near_duplicate(grid_x, x_new_pos, self._adaptive_min_sep(len(tree_x))):\n                continue\n\n            # Heuristic gate\n            if informed:\n                g_tent = n_near.cost + self._dist(n_near.position, x_new_pos)\n                f_tent = g_tent + self._dist(x_new_pos, root_y.position)\n                if f_tent >= self._interp_gate(it) * c_best:\n                    continue\n\n            # Neighbor radius and parent choice\n            radius = self._neighbor_radius(len(tree_x))\n            neigh = self._neighbors_in_radius(grid_x, x_new_pos, radius, self.neighbor_k_max)\n            parent, new_cost = self._choose_parent(x_new_pos, n_near, neigh, obstacles, is_3d)\n            if parent is None:\n                continue\n\n            # Insert new node (node free and edge free already ensured)\n            x_new = Node(x_new_pos, None, new_cost)\n            x_new.attach(parent)\n            tree_x.append(x_new)\n            all_nodes.append(x_new)\n            self._grid_add(grid_x, x_new)\n\n            # Lightweight rewiring\n            self._rewire(x_new, neigh, obstacles, is_3d)\n\n            # Beam connect from other tree\n            bridge = None\n            beam = self._k_nearest(grid_y, x_new.position, min(self.beam_k, len(tree_y)))\n            for cand in beam:\n                if not self._edge_blocked(x_new.position, cand.position, obstacles, is_3d):\n                    bridge = cand\n                    break\n\n            steps_done = 0\n            cur = None if bridge is not None else (beam[0] if beam else None)\n            while bridge is None and cur is not None and steps_done < self.connect_steps:\n                step_try = self._steer(cur.position, x_new.position, 2.0 * self.step_size)\n                step_pos = None\n                if self._in_bounds(step_try) and not self._point_in_obs(step_try, obstacles, is_3d):\n                    if not self._edge_blocked(cur.position, step_try, obstacles, is_3d):\n                        step_pos = step_try\n                if step_pos is None:\n                    step_try = self._steer(cur.position, x_new.position, self.step_size)\n                    if not self._in_bounds(step_try) or self._point_in_obs(step_try, obstacles, is_3d):\n                        break\n                    if self._edge_blocked(cur.position, step_try, obstacles, is_3d):\n                        break\n                    step_pos = step_try\n\n                if self._near_duplicate(grid_y, step_pos, self._adaptive_min_sep(len(tree_y))):\n                    break\n\n                # gated growth on the other side\n                if informed:\n                    g2 = cur.cost + self._dist(cur.position, step_pos)\n                    f2 = g2 + self._dist(step_pos, root_x.position)\n                    if f2 >= self._interp_gate(it) * c_best:\n                        break\n\n                # Parent choice within other tree\n                r_b = self._neighbor_radius(len(tree_y))\n                neigh_b = self._neighbors_in_radius(grid_y, step_pos, r_b, self.neighbor_k_max)\n                p_b, c_b = self._choose_parent(step_pos, cur, neigh_b, obstacles, is_3d)\n                if p_b is None:\n                    break\n\n                nxt = Node(step_pos, None, c_b)\n                nxt.attach(p_b)\n                tree_y.append(nxt)\n                all_nodes.append(nxt)\n                self._grid_add(grid_y, nxt)\n                self._rewire(nxt, neigh_b, obstacles, is_3d)\n\n                cur = nxt\n                steps_done += 1\n\n                if not self._edge_blocked(cur.position, x_new.position, obstacles, is_3d):\n                    bridge = cur\n                    break\n\n            # Assemble on success\n            if bridge is not None:\n                if from_start:\n                    pa = self._path_to_root(x_new)\n                    pb = self._path_to_root(bridge)\n                    path = pa + list(reversed(pb))\n                else:\n                    pa = self._path_to_root(x_new)\n                    pb = self._path_to_root(bridge)\n                    path = pb + list(reversed(pa))\n\n                # Post-processing\n                path = self._vis_prune(path, obstacles, is_3d)\n                path = self._shortcut(path, obstacles, is_3d, self.smoothing_trials)\n                path = self._elastic_smooth(path, obstacles, is_3d, self.elastic_passes)\n\n                L = self._path_length(path)\n                if L < c_best:\n                    c_best = L\n                    best_path = path\n                    informed = True\n                    # Early return after high-quality bridge\n                    edges = []\n                    for n in all_nodes:\n                        if n.parent is not None:\n                            edges.append((n.parent, n))\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n        edges = []\n        for n in all_nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        return PlannerResult(best_path is not None, best_path if best_path else [], all_nodes, edges)\n\n    # RNG and sampling\n    def _rand(self):\n        self._seed = (1664525 * self._seed + 1013904223) % (1 << 31)\n        return self._seed / float(1 << 31)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _halton(self, index, base):\n        f = 1.0\n        r = 0.0\n        i = index\n        while i > 0:\n            f = f / base\n            r = r + f * (i % base)\n            i = i // base\n        return r\n\n    def _halton_sample(self):\n        bases = [2, 3, 5]\n        idx = self._halton_idx\n        self._halton_idx += 1\n        coords = []\n        for d in range(self.dim):\n            u = self._halton(idx, bases[d])\n            coords.append(u * self.bounds[d])\n        return tuple(coords)\n\n    def _ellipse_accept_sample(self, a, b, c_best, tries):\n        if c_best == float('inf'):\n            return self._halton_sample()\n        for _ in range(tries):\n            p = self._halton_sample()\n            if self._dist(p, a) + self._dist(p, b) <= c_best + 1e-9:\n                return p\n        return self._halton_sample()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5 if s > 0.0 else 0.0\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        out = []\n        for i in range(self.dim):\n            v = p[i]\n            if v < 0.0:\n                v = 0.0\n            if v > self.bounds[i]:\n                v = self.bounds[i]\n            out.append(v)\n        return tuple(out)\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Obstacles and collisions\n    def _point_in_obs(self, p, obstacles, is_3d):\n        if is_3d:\n            x, y, z = p\n            for o in obstacles:\n                ox, oy, oz, w, h, d = o\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n        else:\n            x, y = p\n            for o in obstacles:\n                ox, oy, w, h = o\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n        return False\n\n    def _qround(self, p):\n        q = self._qstep\n        if self.dim == 3:\n            return (int(p[0] / q + 0.5), int(p[1] / q + 0.5), int(p[2] / q + 0.5))\n        else:\n            return (int(p[0] / q + 0.5), int(p[1] / q + 0.5))\n\n    def _edge_key(self, a, b):\n        qa = self._qround(a)\n        qb = self._qround(b)\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        cached = self._edge_cache.get(k)\n        if cached is not None:\n            return cached\n\n        if is_3d:\n            ax, ay, az = a\n            bx, by, bz = b\n            minx = ax if ax < bx else bx\n            maxx = ax if ax > bx else bx\n            miny = ay if ay < by else by\n            maxy = ay if ay > by else by\n            minz = az if az < bz else bz\n            maxz = az if az > bz else bz\n            blocked = False\n            for box in obstacles:\n                ox, oy, oz, w, h, d = box\n                bx0, bx1 = ox, ox + w\n                by0, by1 = oy, oy + h\n                bz0, bz1 = oz, oz + d\n                if maxx < bx0 or bx1 < minx or maxy < by0 or by1 < miny or maxz < bz0 or bz1 < minz:\n                    continue\n                if self._seg_box_intersect_3d(a, b, box):\n                    blocked = True\n                    break\n        else:\n            ax, ay = a\n            bx, by = b\n            minx = ax if ax < bx else bx\n            maxx = ax if ax > bx else bx\n            miny = ay if ay < by else by\n            maxy = ay if ay > by else by\n            blocked = False\n            for box in obstacles:\n                ox, oy, w, h = box\n                bx0, bx1 = ox, ox + w\n                by0, by1 = oy, oy + h\n                if maxx < bx0 or bx1 < minx or maxy < by0 or by1 < miny:\n                    continue\n                if self._seg_box_intersect_2d(a, b, box):\n                    blocked = True\n                    break\n\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _seg_box_intersect_2d(self, a, b, box):\n        x, y, w, h = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        ax, ay = a\n        bx, by = b\n        dx = bx - ax\n        dy = by - ay\n        tmin, tmax = 0.0, 1.0\n\n        if dx == 0.0:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            t1 = (minx - ax) * inv\n            t2 = (maxx - ax) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        if dy == 0.0:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            t1 = (miny - ay) * inv\n            t2 = (maxy - ay) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    def _seg_box_intersect_3d(self, a, b, box):\n        x, y, z, w, h, d = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        minz, maxz = z, z + d\n        ax, ay, az = a\n        bx, by, bz = b\n        dx = bx - ax\n        dy = by - ay\n        dz = bz - az\n        tmin, tmax = 0.0, 1.0\n\n        # X\n        if dx == 0.0:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            t1 = (minx - ax) * inv\n            t2 = (maxx - ax) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        # Y\n        if dy == 0.0:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            t1 = (miny - ay) * inv\n            t2 = (maxy - ay) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        # Z\n        if dz == 0.0:\n            if az < minz or az > maxz:\n                return False\n        else:\n            inv = 1.0 / dz\n            t1 = (minz - az) * inv\n            t2 = (maxz - az) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    # Spatial hashing\n    def _grid_key(self, pos):\n        if self.dim == 3:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        else:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, nodes, pos):\n        k = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        found = False\n        for r in range(0, 3):\n            cand = self._collect_ring(grid, k, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                found = True\n                break\n        if not found:\n            # bounded fallback scan\n            limit = min(96, len(nodes))\n            if limit == 0:\n                return None\n            step = max(1, len(nodes) // limit)\n            for i in range(0, len(nodes), step):\n                n = nodes[i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius, kmax):\n        ring = int(radius // self.cell) + 1\n        cand = self._collect_ring(grid, self._grid_key(pos), ring)\n        items = []\n        rr = radius + 1e-9\n        for n in cand:\n            d = self._dist(n.position, pos)\n            if d <= rr:\n                items.append((d, n))\n        items.sort(key=lambda x: x[0])\n        res = [n for (_, n) in items[:kmax]]\n        return res\n\n    def _k_nearest(self, grid, pos, kcap):\n        ring = 1\n        items = []\n        key = self._grid_key(pos)\n        while len(items) < kcap and ring <= 3:\n            cand = self._collect_ring(grid, key, ring)\n            for n in cand:\n                items.append((self._dist(n.position, pos), n))\n            ring += 1\n        if not items:\n            return []\n        items.sort(key=lambda x: x[0])\n        return [n for (_, n) in items[:kcap]]\n\n    # Neighbor radius with ln approximation\n    def _neighbor_radius(self, ncount):\n        n = max(1, ncount)\n        ln = self._math_log(n + 1.0)\n        base = (ln / n) ** (1.0 / float(self.dim))\n        diag = 0.0\n        for i in range(self.dim):\n            diag += self.bounds[i] * self.bounds[i]\n        diag = diag ** 0.5\n        return max(self.step_size * 1.2, self.neighbor_gamma * base * (0.15 * diag))\n\n    def _math_log(self, x):\n        if x <= 0.0:\n            return -1e9\n        k = 0\n        y = x\n        while y >= 2.0:\n            y *= 0.5\n            k += 1\n        while y < 1.0:\n            y *= 2.0\n            k -= 1\n        t = y - 1.0\n        t2 = t * t\n        t3 = t2 * t\n        t4 = t3 * t\n        t5 = t4 * t\n        ln_y = t - 0.5 * t2 + (1.0 / 3.0) * t3 - 0.25 * t4 + 0.2 * t5\n        ln2 = 0.6931471805599453\n        return ln_y + k * ln2\n\n    def _adaptive_min_sep(self, ncount):\n        base = self.step_size * 0.5\n        minv = self.step_size * 0.2\n        scale = 1.0 / (1.0 + 0.002 * ncount)\n        return max(minv, base * scale)\n\n    # Parent selection with smoothness regularization\n    def _choose_parent(self, new_pos, fallback, neighbors, obstacles, is_3d):\n        beta = self.beta_angle * max(1.0, self.step_size)\n        best_p = None\n        best_eff = float('inf')\n        best_cost = float('inf')\n\n        def angle_penalty(p):\n            if p is None or p.parent is None:\n                return 0.0\n            a = p.parent.position\n            b = p.position\n            c = new_pos\n            v1 = tuple(b[i] - a[i] for i in range(self.dim))\n            v2 = tuple(c[i] - b[i] for i in range(self.dim))\n            n1 = 0.0\n            n2 = 0.0\n            dot = 0.0\n            for i in range(self.dim):\n                n1 += v1[i] * v1[i]\n                n2 += v2[i] * v2[i]\n                dot += v1[i] * v2[i]\n            if n1 <= 1e-12 or n2 <= 1e-12:\n                return 0.0\n            cosang = dot / ((n1 ** 0.5) * (n2 ** 0.5))\n            if cosang > 1.0:\n                cosang = 1.0\n            if cosang < -1.0:\n                cosang = -1.0\n            return (1.0 - cosang)\n\n        cand = [fallback] + neighbors\n        seen = set()\n        for p in cand:\n            if p in seen:\n                continue\n            seen.add(p)\n            if self._edge_blocked(p.position, new_pos, obstacles, is_3d):\n                continue\n            g = p.cost + self._dist(p.position, new_pos)\n            eff = g + beta * angle_penalty(p)\n            if eff < best_eff - 1e-12 or (abs(eff - best_eff) <= 1e-12 and g < best_cost - 1e-12):\n                best_eff = eff\n                best_cost = g\n                best_p = p\n\n        if best_p is None:\n            return None, float('inf')\n        return best_p, best_cost\n\n    def _rewire(self, new_node, neighbors, obstacles, is_3d):\n        for m in neighbors:\n            if m is new_node or m is new_node.parent:\n                continue\n            alt = new_node.cost + self._dist(new_node.position, m.position)\n            if alt + 1e-12 < m.cost:\n                if not self._edge_blocked(new_node.position, m.position, obstacles, is_3d):\n                    delta = alt - m.cost\n                    m.attach(new_node)\n                    m.cost = alt\n                    if delta != 0.0:\n                        stack = [m]\n                        while stack:\n                            cur = stack.pop()\n                            for ch in cur.children:\n                                ch.cost += delta\n                                stack.append(ch)\n\n    # Sampling helpers\n    def _corridor_width(self, a, b, c_best):\n        ab = self._dist(a, b)\n        base = max(self.step_size * 1.5, 0.2 * ab)\n        if c_best < float('inf'):\n            return max(self.step_size, 0.12 * c_best)\n        return base\n\n    def _corridor_sample(self, a, b, width):\n        t = self._uniform(0.0, 1.0)\n        base = tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n        ab = tuple(b[i] - a[i] for i in range(self.dim))\n        nrm = 0.0\n        for i in range(self.dim):\n            nrm += ab[i] * ab[i]\n        nrm = nrm ** 0.5 if nrm > 0.0 else 0.0\n        if nrm <= 1e-12:\n            return self._halton_sample()\n        v = tuple(ab[i] / nrm for i in range(self.dim))\n        if self.dim == 2:\n            perp = (-v[1], v[0])\n            mag = self._uniform(-width, width)\n            p = (base[0] + perp[0] * mag, base[1] + perp[1] * mag)\n            return self._clamp(p)\n        else:\n            r = (self._uniform(-1.0, 1.0), self._uniform(-1.0, 1.0), self._uniform(-1.0, 1.0))\n            dot = r[0] * v[0] + r[1] * v[1] + r[2] * v[2]\n            u = (r[0] - dot * v[0], r[1] - dot * v[1], r[2] - dot * v[2])\n            un = (u[0] * u[0] + u[1] * u[1] + u[2] * u[2]) ** 0.5\n            if un <= 1e-12:\n                u = (v[1], -v[0], 0.0)\n                un = (u[0] * u[0] + u[1] * u[1] + u[2] * u[2]) ** 0.5\n            u = (u[0] / un, u[1] / un, u[2] / un)\n            mag = self._uniform(-width, width)\n            p = (base[0] + u[0] * mag, base[1] + u[1] * mag, base[2] + u[2] * mag)\n            return self._clamp(p)\n\n    def _interp_gate(self, it):\n        t = min(1.0, max(0.0, it / float(max(1, self.max_iter - 1))))\n        return self.heur_gate_init + (self.heur_gate_final - self.heur_gate_init) * t\n\n    # Path extraction and post-processing\n    def _path_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        out.reverse()\n        return out\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _vis_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        pruned = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(pruned[-1], path[j], obstacles, is_3d):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _shortcut(self, path, obstacles, is_3d, trials):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(trials):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts\n\n    def _elastic_smooth(self, path, obstacles, is_3d, passes):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        alpha = 0.35\n        for _ in range(passes):\n            changed = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                b = pts[i]\n                c = pts[i + 1]\n                # Second-difference descent step\n                newp = tuple(b[d] - alpha * (a[d] - 2.0 * b[d] + c[d]) for d in range(self.dim))\n                newp = self._clamp(newp)\n                if self._point_in_obs(newp, obstacles, is_3d):\n                    continue\n                if not self._edge_blocked(a, newp, obstacles, is_3d) and not self._edge_blocked(newp, c, obstacles, is_3d):\n                    old_len = self._dist(a, b) + self._dist(b, c)\n                    new_len = self._dist(a, newp) + self._dist(newp, c)\n                    if new_len + 1e-9 < old_len:\n                        pts[i] = newp\n                        changed = True\n            if not changed:\n                break\n        return pts\n\n    def _near_duplicate(self, grid, pos, radius):\n        cand = self._collect_ring(grid, self._grid_key(pos), 1)\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                return True\n        return False",
          "objective": -37.53646,
          "time_improvement": 65.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1454.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0071801900863647464,
                    "num_nodes_avg": 47.0,
                    "path_length_avg": 160.51590277895028,
                    "smoothness_avg": 0.04963783641985328,
                    "success_improvement": 0.0,
                    "time_improvement": 71.45525960103957,
                    "node_improvement": 88.16419038025687,
                    "length_improvement": 12.018690149609398,
                    "smoothness_improvement": 676.9399302577328,
                    "objective_score": 32.03249162136617
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.034240341186523436,
                    "num_nodes_avg": 173.0,
                    "path_length_avg": 236.55090848704262,
                    "smoothness_avg": 0.11759912881669805,
                    "success_improvement": 0.0,
                    "time_improvement": 78.62792856193626,
                    "node_improvement": 88.37599946247397,
                    "length_improvement": 21.032498006645234,
                    "smoothness_improvement": 2925.910287682397,
                    "objective_score": 50.83742881098
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026254725456237794,
                    "num_nodes_avg": 120.0,
                    "path_length_avg": 120.05972194186322,
                    "smoothness_avg": 0.06754656129700941,
                    "success_improvement": 0.0,
                    "time_improvement": 45.95428801397764,
                    "node_improvement": 84.74253019707565,
                    "length_improvement": 20.262049315816473,
                    "smoothness_improvement": 759.18727392943,
                    "objective_score": 29.739452363330326
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "CINDER-IBRRT*: Curvature-Informed, Near-duplicate-Discarding, Elastic-refined Rapidly-exploring Bidirectional RRT*. It balances trees, mixes corridor/ellipse/goal sampling, uses grid-accelerated k-nearest parenting with curvature penalty, bounded rewiring, and limited-step seam connection. A fast visibility prune + shortcut + elastic band refines the first found feasible path. Tuned parameters reduce wasted expansions, suppress zig-zags, and improve success rate and smoothness without heavy post-processing.",
          "planning_mechanism": "Alternate expansion of the smaller tree. Sample via: informed ellipse if an incumbent exists, else goal/corridor/uniform. Find hashed-nearest; steer one step; reject near-duplicates. Choose parent from a small neighbor set minimizing cost + curvature term; verify node and edge; insert and bounded-rewire neighbors. Attempt to connect the opposite tree by direct line-of-sight or a few safe steps with full node/edge checks. On bridge, extract, visibility-prune, shortcut, apply a light elastic band, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = set()\n\n    def reattach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.add(self)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=2800,\n        step_size=5.5,\n        goal_bias=0.18,\n        corridor_bias=0.38,\n        informed_bias=0.60,\n        grid_cell_factor=1.3,\n        dup_radius_factor=0.42,\n        k_near=14,\n        rewire_k=8,\n        connect_steps=12,\n        curvature_weight=0.12,\n        smoothing_trials=64,\n        band_passes=2\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dup_factor = float(dup_radius_factor)\n        self.k_near = int(max(1, k_near))\n        self.rewire_k = int(max(0, rewire_k))\n        self.connect_steps = int(max(1, connect_steps))\n        self.curv_w = float(curvature_weight)\n        self.smoothing_trials = int(max(0, smoothing_trials))\n        self.band_passes = int(max(0, band_passes))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], nodes, edges)\n        if self._point_in_obs(start, obstacles) or self._point_in_obs(goal, obstacles):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Spatial and caches\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_radius = max(0.5, self.step * self.dup_factor)\n        self._edge_cache = {}\n        self._seed_from_scene(start, goal, obstacles)\n\n        # Early direct\n        if not self._edge_blocked(start, goal, obstacles):\n            n0 = Node(start, None, 0.0)\n            n1 = Node(goal, n0, self._dist(start, goal))\n            n0.children.add(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [start, goal], nodes, edges)\n\n        # Initialize trees and grids\n        ra = Node(start, None, 0.0)\n        rb = Node(goal, None, 0.0)\n        Ta, Tb = [ra], [rb]\n        Ga, Gb = {}, {}\n        self._gadd(Ga, ra)\n        self._gadd(Gb, rb)\n        nodes.extend([ra, rb])\n\n        best_path = None\n        c_best = float('inf')\n\n        for it in range(self.max_iter):\n            # Expand smaller tree to balance\n            if len(Ta) <= len(Tb):\n                Tx, Gx, Ty, Gy, attract = Ta, Ga, Tb, Gb, goal\n                root_other = rb\n            else:\n                Tx, Gx, Ty, Gy, attract = Tb, Gb, Ta, Ga, start\n                root_other = ra\n\n            s = self._sample(start, goal, attract, c_best)\n            if s is None:\n                continue\n\n            near = self._nearest(Gx, s)\n            if near is None:\n                continue\n\n            newp = self._steer(near.position, s, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obs(newp, obstacles):\n                continue\n            if self._is_duplicate(Gx, newp, self.dup_radius):\n                continue\n\n            parent, new_cost = self._choose_parent(Gx, near, newp, obstacles)\n            if parent is None:\n                continue\n\n            # Strict checks before adding node/edge\n            if self._point_in_obs(newp, obstacles):\n                continue\n            if self._edge_blocked(parent.position, newp, obstacles):\n                continue\n\n            nn = Node(newp, parent, new_cost)\n            nn.reattach(parent)\n            Tx.append(nn)\n            nodes.append(nn)\n            self._gadd(Gx, nn)\n            edges.append((parent, nn))\n\n            # bounded local rewiring\n            if self.rewire_k > 0:\n                self._rewire_bound(Gx, nn, obstacles, edges)\n\n            # Attempt to connect opposite tree\n            meet, bridged = self._connect_limited(Ty, Gy, nn.position, obstacles, edges)\n            if bridged:\n                # Assemble path\n                if Tx is Ta:\n                    pa = self._path_to_root(nn)\n                    pb = self._path_to_root(meet)\n                    path = pa + pb[-2::-1]\n                else:\n                    pa = self._path_to_root(meet)\n                    pb = self._path_to_root(nn)\n                    path = pa + pb[-2::-1]\n\n                path = self._dedup(path)\n                path = self._vis_prune(path, obstacles)\n                path = self._shortcut(path, obstacles, self.smoothing_trials)\n                path = self._elastic_band(path, obstacles, self.band_passes)\n\n                L = self._path_len(path)\n                if L < c_best:\n                    c_best = L\n                    best_path = path\n                    # return first good path\n                    # Rebuild edges for coherence\n                    edges = []\n                    for n in nodes:\n                        if n.parent is not None:\n                            edges.append((n.parent, n))\n                    return PlannerResult(True, best_path, nodes, edges)\n\n        # No connection\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        return PlannerResult(best_path is not None, best_path if best_path else [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self, s, g, obs):\n        x = 2166136261\n        for v in s + g:\n            x ^= int(v * 2654435761) & 0xffffffff\n            x = (x * 16777619) & 0xffffffff\n        x ^= (len(obs) * 2246822519) & 0xffffffff\n        self._rng = (x if x != 0 else 123456789) & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _randr(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        r = step / max(d, 1e-12)\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Obstacles\n    def _point_in_obs(self, p, obstacles):\n        if self.is3:\n            x, y, z = p\n            for o in obstacles:\n                ox, oy, oz, w, h, d = o\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n        else:\n            x, y = p\n            for o in obstacles:\n                ox, oy, w, h = o\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked(self, a, b, obstacles):\n        k = self._edge_key(a, b)\n        cached = self._edge_cache.get(k)\n        if cached is not None:\n            return cached\n        blocked = self._segment_hits_any(a, b, obstacles)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _segment_hits_any(self, a, b, obstacles):\n        if self.is3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            for box in obstacles:\n                ox, oy, oz, w, h, d = box\n                bx0, bx1 = ox, ox + w\n                by0, by1 = oy, oy + h\n                bz0, bz1 = oz, oz + d\n                if maxx < bx0 or bx1 < minx or maxy < by0 or by1 < miny or maxz < bz0 or bz1 < minz:\n                    continue\n                if self._seg_box_intersect_3d(a, b, (bx0, by0, bz0), (bx1, by1, bz1)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            for box in obstacles:\n                ox, oy, w, h = box\n                bx0, bx1 = ox, ox + w\n                by0, by1 = oy, oy + h\n                if maxx < bx0 or bx1 < minx or maxy < by0 or by1 < miny:\n                    continue\n                if self._seg_box_intersect_2d(a, b, (bx0, by0), (bx1, by1)):\n                    return True\n            return False\n\n    def _seg_box_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t0 = (mn - p) * inv\n                t1 = (mx - p) * inv\n                if t0 > t1:\n                    t0, t1 = t1, t0\n                if t0 > tmin:\n                    tmin = t0\n                if t1 < tmax:\n                    tmax = t1\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_box_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t0 = (mn - p) * inv\n                t1 = (mx - p) * inv\n                if t0 > t1:\n                    t0, t1 = t1, t0\n                if t0 > tmin:\n                    tmin = t0\n                if t1 < tmax:\n                    tmax = t1\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Grid\n    def _gkey(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _gadd(self, grid, node):\n        k = self._gkey(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _gcollect(self, grid, key, ring):\n        out = []\n        if self.is3:\n            for dx in range(-ring, ring + 1):\n                for dy in range(-ring, ring + 1):\n                    for dz in range(-ring, ring + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-ring, ring + 1):\n                for dy in range(-ring, ring + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        k = self._gkey(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 3):\n            cand = self._gcollect(grid, k, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            if best is not None:\n                return best\n        # fallback: scan a few buckets\n        vals = list(grid.values())\n        if not vals:\n            return None\n        trials = min(24, len(vals))\n        for i in range(trials):\n            b = vals[int(self._rand() * len(vals)) % max(1, len(vals))]\n            if not b:\n                continue\n            n = b[int(self._rand() * len(b)) % max(1, len(b))]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _neighbors_k(self, grid, pos, kmax, radius_hint):\n        rc = int(radius_hint // self.cell) + 1\n        cand = self._gcollect(grid, self._gkey(pos), rc)\n        # select k closest without full sort\n        sel = []\n        for n in cand:\n            d = self._dist(n.position, pos)\n            if len(sel) < kmax:\n                sel.append((d, n))\n            else:\n                # replace worst if better\n                wi = 0\n                wd = sel[0][0]\n                for i in range(1, len(sel)):\n                    if sel[i][0] > wd:\n                        wi = i\n                        wd = sel[i][0]\n                if d < wd:\n                    sel[wi] = (d, n)\n        return [n for _, n in sorted(sel, key=lambda x: x[0])]\n\n    def _is_duplicate(self, grid, pos, radius):\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        for n in self._gcollect(grid, self._gkey(pos), rc):\n            if self._dist(n.position, pos) <= r2 ** 0.5:\n                return True\n        return False\n\n    # Sampling\n    def _sample(self, start, goal, attractor, c_best):\n        r = self._rand()\n        if c_best < float('inf') and r < self.informed_bias:\n            p = self._ellipse_sample(start, goal, c_best * 1.02)\n            if p is not None:\n                return p\n        r2 = self._rand()\n        if r2 < self.goal_bias:\n            return attractor if (self._in_bounds(attractor)) else None\n        elif r2 < self.goal_bias + self.corridor_bias:\n            p = self._corridor_sample(start, goal)\n            if p is not None:\n                return p\n        # uniform\n        if self.is3:\n            return (self._randr(0.0, self.bounds[0]),\n                    self._randr(0.0, self.bounds[1]),\n                    self._randr(0.0, self.bounds[2]))\n        else:\n            return (self._randr(0.0, self.bounds[0]),\n                    self._randr(0.0, self.bounds[1]))\n\n    def _corridor_sample(self, a, b):\n        t = self._rand()\n        base = tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n        ab = self._dist(a, b)\n        width = max(self.step, 0.12 * ab)\n        if self.is3:\n            p = (base[0] + self._randr(-width, width),\n                 base[1] + self._randr(-width, width),\n                 base[2] + self._randr(-width, width))\n        else:\n            p = (base[0] + self._randr(-width, width),\n                 base[1] + self._randr(-width, width))\n        p = self._clamp(p)\n        return p if self._in_bounds(p) else None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(28):\n            if self.is3:\n                p = (c[0] + self._randr(-ext[0], ext[0]),\n                     c[1] + self._randr(-ext[1], ext[1]),\n                     c[2] + self._randr(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._randr(-ext[0], ext[0]),\n                     c[1] + self._randr(-ext[1], ext[1]))\n            p = self._clamp(p)\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum + 1e-9:\n                return p\n        return None\n\n    # Parenting and rewiring\n    def _curv_penalty(self, parent, new_pos):\n        if parent is None or parent.parent is None:\n            return 0.0\n        a = parent.parent.position\n        b = parent.position\n        c = new_pos\n        v1 = tuple(b[i] - a[i] for i in range(self.dim))\n        v2 = tuple(c[i] - b[i] for i in range(self.dim))\n        n1 = 0.0\n        n2 = 0.0\n        dot = 0.0\n        for i in range(self.dim):\n            n1 += v1[i] * v1[i]\n            n2 += v2[i] * v2[i]\n            dot += v1[i] * v2[i]\n        if n1 <= 1e-12 or n2 <= 1e-12:\n            return 0.0\n        cosang = dot / ((n1 ** 0.5) * (n2 ** 0.5))\n        if cosang > 1.0:\n            cosang = 1.0\n        if cosang < -1.0:\n            cosang = -1.0\n        return (1.0 - cosang)\n\n    def _choose_parent(self, grid, fallback, newp, obstacles):\n        # radius hint encourages locality\n        radius = self.step * 2.5\n        neigh = self._neighbors_k(grid, newp, self.k_near, radius)\n        if fallback not in neigh:\n            neigh.append(fallback)\n        best = None\n        best_cost = 1e100\n        best_tie = 1e100\n        for p in neigh:\n            if self._edge_blocked(p.position, newp, obstacles):\n                continue\n            g = p.cost + self._dist(p.position, newp)\n            tie = self.curv_w * self._curv_penalty(p, newp)\n            if (g + tie) < (best_cost + best_tie) - 1e-12 or (abs((g + tie) - (best_cost + best_tie)) <= 1e-12 and g < best_cost):\n                best = p\n                best_cost = g\n                best_tie = tie\n        if best is None:\n            return None, None\n        return best, best_cost\n\n    def _rewire_bound(self, grid, pivot, obstacles, edges):\n        neigh = self._neighbors_k(grid, pivot.position, self.rewire_k * 2, self.step * 2.5)\n        # rank by distance to pivot\n        items = []\n        for n in neigh:\n            if n is pivot or n.parent is None:\n                continue\n            d = self._dist(n.position, pivot.position)\n            items.append((d, n))\n        items.sort(key=lambda x: x[0])\n        cnt = 0\n        for _, nb in items:\n            if cnt >= self.rewire_k:\n                break\n            alt = pivot.cost + self._dist(pivot.position, nb.position)\n            if alt + 1e-12 < nb.cost:\n                if not self._edge_blocked(pivot.position, nb.position, obstacles):\n                    oldp = nb.parent\n                    nb.reattach(pivot)\n                    nb.cost = alt\n                    self._propagate_costs(nb)\n                    # maintain edges list: remove old and add new\n                    if oldp is not None:\n                        self._remove_edge(edges, (oldp, nb))\n                    edges.append((pivot, nb))\n                    cnt += 1\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _remove_edge(self, edges, e):\n        for i in range(len(edges)):\n            if edges[i][0] is e[0] and edges[i][1] is e[1]:\n                edges.pop(i)\n                return\n\n    # Connect opposite tree\n    def _connect_limited(self, tree, grid, target_pos, obstacles, edges):\n        near = self._nearest(grid, target_pos)\n        if near is None:\n            return None, False\n\n        # direct seam insertion if possible\n        if (not self._point_in_obs(target_pos, obstacles)) and (not self._edge_blocked(near.position, target_pos, obstacles)):\n            if not self._is_duplicate(grid, target_pos, self.dup_radius * 0.7):\n                meet = Node(target_pos, near, near.cost + self._dist(near.position, target_pos))\n                meet.reattach(near)\n                tree.append(meet)\n                edges.append((near, meet))\n                self._gadd(grid, meet)\n                return meet, True\n            return near, True\n\n        # bounded stepping toward target\n        cur = near\n        steps = 0\n        while steps < self.connect_steps:\n            nxtp = self._steer(cur.position, target_pos, self.step)\n            if (not self._in_bounds(nxtp)) or self._point_in_obs(nxtp, obstacles):\n                break\n            if self._is_duplicate(grid, nxtp, self.dup_radius * 0.8):\n                break\n            if self._edge_blocked(cur.position, nxtp, obstacles):\n                break\n            # Strict node & edge checks already satisfied; add\n            nn = Node(nxtp, cur, cur.cost + self._dist(cur.position, nxtp))\n            nn.reattach(cur)\n            tree.append(nn)\n            edges.append((cur, nn))\n            self._gadd(grid, nn)\n            cur = nn\n            steps += 1\n            if (not self._point_in_obs(target_pos, obstacles)) and (not self._edge_blocked(cur.position, target_pos, obstacles)):\n                if not self._is_duplicate(grid, target_pos, self.dup_radius * 0.7):\n                    meet = Node(target_pos, cur, cur.cost + self._dist(cur.position, target_pos))\n                    meet.reattach(cur)\n                    tree.append(meet)\n                    edges.append((cur, meet))\n                    self._gadd(grid, meet)\n                    return meet, True\n                return cur, True\n\n        if (not self._point_in_obs(target_pos, obstacles)) and (not self._edge_blocked(cur.position, target_pos, obstacles)):\n            if not self._is_duplicate(grid, target_pos, self.dup_radius * 0.7):\n                meet = Node(target_pos, cur, cur.cost + self._dist(cur.position, target_pos))\n                meet.reattach(cur)\n                tree.append(meet)\n                edges.append((cur, meet))\n                self._gadd(grid, meet)\n                return meet, True\n            return cur, True\n\n        return cur, False\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _path_len(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _vis_prune(self, path, obstacles):\n        if not path or len(path) < 3:\n            return path\n        pruned = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._segment_hits_any(pruned[-1], path[j], obstacles):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _shortcut(self, path, obstacles, trials):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        t = 0\n        while t < trials and n > 2:\n            i = int(self._randr(0, max(1, n - 2)))\n            j = int(self._randr(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                t += 1\n                continue\n            a, b = pts[i], pts[j]\n            if not self._segment_hits_any(a, b, obstacles):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n            t += 1\n        return pts\n\n    def _elastic_band(self, path, obstacles, passes):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(passes):\n            changed = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                b = pts[i]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[d] + c[d]) for d in range(self.dim))\n                newp = tuple(0.5 * b[d] + 0.5 * mid[d] for d in range(self.dim))\n                newp = self._clamp(newp)\n                if self._point_in_obs(newp, obstacles):\n                    continue\n                if (not self._segment_hits_any(a, newp, obstacles)) and (not self._segment_hits_any(newp, c, obstacles)):\n                    old_len = self._dist(a, b) + self._dist(b, c)\n                    new_len = self._dist(a, newp) + self._dist(newp, c)\n                    if new_len <= old_len * 1.001:\n                        pts[i] = newp\n                        changed = True\n            if not changed:\n                break\n        return pts",
          "objective": -36.50824,
          "time_improvement": 62.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1555.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010398459434509278,
                    "num_nodes_avg": 44.0,
                    "path_length_avg": 164.85491031068415,
                    "smoothness_avg": 0.030734131405092617,
                    "success_improvement": 0.0,
                    "time_improvement": 58.6610769997782,
                    "node_improvement": 88.9196675900277,
                    "length_improvement": 9.640411365491827,
                    "smoothness_improvement": 381.0558967242601,
                    "objective_score": 25.287849402849854
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05961427688598633,
                    "num_nodes_avg": 173.0,
                    "path_length_avg": 240.43844712076992,
                    "smoothness_avg": 0.12001221059710285,
                    "success_improvement": 0.0,
                    "time_improvement": 62.79007334082074,
                    "node_improvement": 88.37599946247397,
                    "length_improvement": 19.734725714111764,
                    "smoothness_improvement": 2988.0006199647655,
                    "objective_score": 45.61786053053711
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01708211898803711,
                    "num_nodes_avg": 74.0,
                    "path_length_avg": 118.74540609054498,
                    "smoothness_avg": 0.10986166164127453,
                    "success_improvement": 0.0,
                    "time_improvement": 64.8362240741286,
                    "node_improvement": 90.59122695486332,
                    "length_improvement": 21.134955323266684,
                    "smoothness_improvement": 1297.4322269326722,
                    "objective_score": 38.619001550861945
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "FLASH-IBRRT*: Fast, Low-Overhead, Adaptive, Informed BiRRT* with capped rewiring and greedy bridging. It uses obstacle-bin accelerated collision checks, compact spatial hashing for nearest/neighbor queries, LOS-adaptive stepping, small-radius k-best parenting, and a short greedy connect. Successful bridges are finalized with shortcutting, visibility pruning, and elastic smoothing for short, smooth paths with low planning time.",
          "planning_mechanism": "Alternate bidirectional growth with biased sampling (goal/line/uniform; switch to informed-ellipse once a path length is known). For each side: pick nearest via hashed rings, steer with LOS-accelerated step, enforce node and edge collision checks, suppress near-duplicates, choose a lower-cost parent from nearby nodes, add the node, and lightly rewire neighbors if cheaper (cycle-safe). Attempt a direct or few-step greedy bridge to the opposite tree\u2019s nearest. On success, stitch start-to-goal, then shortcut, prune by visibility, and elastically smooth before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        pts.reverse()\n        return pts\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3500,\n        step=5.0,\n        connect_factor=2.2,\n        goal_bias=0.22,\n        line_bias=0.25,\n        informed_bias=0.55,\n        grid_cell_factor=1.4,\n        dupe_ratio=0.35,\n        neighbor_cap=80,\n        rewire_cap=10,\n        connect_trials=10,\n        shortcut_attempts=100,\n        smooth_passes=8\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step)\n        self.connect_step = float(step * connect_factor)\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dupe_ratio = float(dupe_ratio)\n        self.neighbor_cap = int(max(1, neighbor_cap))\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_trials = int(max(1, connect_trials))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.smooth_passes = int(max(0, smooth_passes))\n        self._rng = 88172645463393265\n        self._eindex = {}\n        self._ecache = {}\n        self._ecache_cap = 50000\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n        self._eindex = {}\n        self._ecache = {}\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n\n        # Prepare grids\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dupe_radius = max(0.4, self.step * self.dupe_ratio)\n\n        # Build obstacle bins for fast collision\n        self._build_obs_bins()\n\n        # Validate start/goal\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight-line solution\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            self._edges_add(edges, n0, n1)\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Trees and spatial hashes\n        Ta, Tb = [], []\n        Ga, Gb = {}, {}\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        Ta.append(root_a)\n        Tb.append(root_b)\n        nodes.extend([root_a, root_b])\n        self._grid_add(Ga, root_a)\n        self._grid_add(Gb, root_b)\n\n        best_len = float('inf')\n\n        for _ in range(self.max_iter):\n            target = self._sample_target(best_len)\n            # Expand start side\n            res = self._expand_and_connect(Ta, Ga, Tb, Gb, target, nodes, edges, a_is_start=True)\n            if res is not None:\n                path, L = res\n                best_len = L\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n            # Expand goal side\n            res = self._expand_and_connect(Tb, Gb, Ta, Ga, target, nodes, edges, a_is_start=False)\n            if res is not None:\n                path, L = res\n                best_len = L\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # Core expansion + bridge\n    def _expand_and_connect(self, Ta, Ga, Tb, Gb, target, nodes, edges, a_is_start):\n        na = self._nearest(Ga, target)\n        if na is None:\n            return None\n        q_new = self._steer_los(na.position, target)\n        if (not self._in_bounds(q_new)) or self._point_blocked(q_new):\n            return None\n        if self._too_close(Ga, q_new, 0.8 * self.dupe_radius):\n            return None\n\n        parent = self._choose_parent(Ga, q_new, na, len(Ta))\n        if parent is None:\n            return None\n\n        # Both checks before adding node/edge\n        if self._point_blocked(q_new) or (not self._edge_free(parent.position, q_new)):\n            return None\n\n        cost = parent.cost + self._dist(parent.position, q_new)\n        nn = Node(q_new, parent, cost)\n        parent.add_child(nn)\n        Ta.append(nn)\n        nodes.append(nn)\n        self._grid_add(Ga, nn)\n        self._edges_add(edges, parent, nn)\n\n        # Light rewiring\n        if self.rewire_cap > 0:\n            self._rewire_local(Ga, nn, edges, self.rewire_cap)\n\n        # Try to connect to opposite tree\n        meet = self._bridge(Tb, Gb, nn.position, nodes, edges)\n        if meet is not None:\n            pa = nn.path_to_root()\n            pb = meet.path_to_root()\n            if a_is_start:\n                # start-side expansion\n                path = pa + pb[-2::-1]\n            else:\n                path = pb + pa[-2::-1]\n            L = self._path_len(path)\n            return (self._dedup(path), L)\n        return None\n\n    # RNG\n    def _seed_rng(self):\n        s = 1469598103934665603\n        for v in self.start + self.goal:\n            s ^= int(v * 1315423911 + 0.5) & 0xffffffffffffffff\n            s = (s * 1099511628211) & 0xffffffffffffffff\n        s ^= (len(self.obstacles) * 11400714819323198485) & 0xffffffffffffffff\n        if s == 0:\n            s = 88172645463393265\n        self._rng = s & 0xffffffffffffffff\n\n    def _rand(self):\n        # xorshift64*\n        x = self._rng\n        x ^= (x >> 12) & 0xffffffffffffffff\n        x ^= (x << 25) & 0xffffffffffffffff\n        x ^= (x >> 27) & 0xffffffffffffffff\n        self._rng = x & 0xffffffffffffffff\n        return ((x * 2685821657736338717) & 0xffffffffffffffff) / float(1 << 64)\n\n    def _rr(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Sampling\n    def _sample_target(self, best_len):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._sample_informed(self.start, self.goal, best_len * 1.01)\n            if p is not None:\n                return p\n        r2 = self._rand()\n        if r2 < self.goal_bias:\n            return self.goal\n        if r2 < self.goal_bias + self.line_bias:\n            t = self._rand()\n            if self.is3:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t,\n                     self.start[2] + (self.goal[2] - self.start[2]) * t)\n            else:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t)\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        # Uniform\n        if self.is3:\n            return (self._rr(0.0, self.bounds[0]),\n                    self._rr(0.0, self.bounds[1]),\n                    self._rr(0.0, self.bounds[2]))\n        else:\n            return (self._rr(0.0, self.bounds[0]),\n                    self._rr(0.0, self.bounds[1]))\n\n    def _sample_informed(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rr(-ext[0], ext[0]),\n                     c[1] + self._rr(-ext[1], ext[1]),\n                     c[2] + self._rr(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rr(-ext[0], ext[0]),\n                     c[1] + self._rr(-ext[1], ext[1]))\n            if self._in_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and (not self._point_blocked(p)):\n                return p\n        return None\n\n    # Geometry and helpers\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(self._lerp(a, b, r))\n\n    def _steer_los(self, a, b):\n        # If LOS, take a longer stride; else normal step\n        if self._edge_free(a, b):\n            d = self._dist(a, b)\n            s = self.connect_step if d > self.connect_step else d\n            return self._steer(a, b, s)\n        return self._steer(a, b, self.step)\n\n    # Node grid and NN\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 3):\n            cand = self._grid_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n            if best is not None:\n                return best\n        # fallback: randomized subset to avoid O(N)\n        all_nodes = []\n        for lst in grid.values():\n            for n in lst:\n                all_nodes.append(n)\n        if not all_nodes:\n            return None\n        tries = min(64, len(all_nodes))\n        for _ in range(tries):\n            idx = int(self._rr(0, len(all_nodes)))\n            n = all_nodes[idx]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                best = n\n                bestd = d\n        return best\n\n    def _neighbors_within(self, grid, pos, radius, cap):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        seen = {}\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            i2 = id(n)\n                            if i2 in seen:\n                                continue\n                            seen[i2] = True\n                            d2 = 0.0\n                            p = n.position\n                            for i in range(self.dim):\n                                di = p[i] - pos[i]\n                                d2 += di * di\n                            if d2 <= r2:\n                                out.append(n)\n                                if len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        i2 = id(n)\n                        if i2 in seen:\n                            continue\n                        seen[i2] = True\n                        d2 = 0.0\n                        p = n.position\n                        for i in range(self.dim):\n                            di = p[i] - pos[i]\n                            d2 += di * di\n                        if d2 <= r2:\n                            out.append(n)\n                            if len(out) >= cap:\n                                return out\n        return out\n\n    def _adaptive_radius(self, n_nodes):\n        t = float(max(1, n_nodes))\n        base = 1.25 * self.step\n        extra = 2.5 * self.step / ((1.0 + t) ** (1.0 / 3.0))\n        r = base + extra\n        if r < 1.05 * self.step:\n            r = 1.05 * self.step\n        return r\n\n    def _too_close(self, grid, pos, radius):\n        nb = self._neighbors_within(grid, pos, radius, 1)\n        return len(nb) > 0\n\n    def _choose_parent(self, grid, newp, fallback, n_tree_nodes):\n        r = self._adaptive_radius(n_tree_nodes)\n        neigh = self._neighbors_within(grid, newp, r, self.neighbor_cap)\n        best = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        for n in neigh:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                best = n\n                best_cost = c\n        return best\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _rewire_local(self, grid, node, edges, cap):\n        r = self._adaptive_radius(1) + self._adaptive_radius(1) + self.step\n        neigh = self._neighbors_within(grid, node.position, r, self.neighbor_cap)\n        cnt = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            if self._point_blocked(nb.position):\n                continue\n            if not self._edge_free(node.position, nb.position):\n                continue\n            newc = node.cost + self._dist(node.position, nb.position)\n            if newc + 1e-12 < nb.cost:\n                self._reparent(nb, node, edges)\n                cnt += 1\n                if cnt >= cap:\n                    break\n\n    def _reparent(self, child, new_parent, edges):\n        if child is new_parent or child.parent is new_parent:\n            return\n        if self._point_blocked(child.position) or self._point_blocked(new_parent.position):\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._edges_remove(edges, old, child)\n        new_parent.add_child(child)\n        self._edges_add(edges, new_parent, child)\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        stack = list(child.children)\n        while stack:\n            n = stack.pop()\n            n.cost = n.parent.cost + self._dist(n.parent.position, n.position)\n            for c in n.children:\n                stack.append(c)\n\n    # Bridge attempts\n    def _bridge(self, T, G, target_pos, nodes, edges):\n        near = self._nearest(G, target_pos)\n        if near is None:\n            return None\n        # Direct visibility first\n        if self._edge_free(near.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                if not self._too_close(G, target_pos, 0.6 * self.dupe_radius):\n                    newc = near.cost + self._dist(near.position, target_pos)\n                    nn = Node(target_pos, near, newc)\n                    if (not self._point_blocked(nn.position)) and self._edge_free(near.position, nn.position):\n                        near.add_child(nn)\n                        T.append(nn)\n                        nodes.append(nn)\n                        self._grid_add(G, nn)\n                        self._edges_add(edges, near, nn)\n                        return nn\n                return near\n            return near\n        # Greedy stepping towards target_pos\n        cur = near\n        steps = 0\n        while steps < self.connect_trials:\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                break\n            if not self._edge_free(cur.position, nxt):\n                break\n            if self._too_close(G, nxt, 0.6 * self.dupe_radius):\n                break\n            newc = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, newc)\n            if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                break\n            cur.add_child(nn)\n            T.append(nn)\n            nodes.append(nn)\n            self._grid_add(G, nn)\n            self._edges_add(edges, cur, nn)\n            cur = nn\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                    if not self._too_close(G, target_pos, 0.6 * self.dupe_radius):\n                        newc2 = cur.cost + self._dist(cur.position, target_pos)\n                        nn2 = Node(target_pos, cur, newc2)\n                        if (not self._point_blocked(nn2.position)) and self._edge_free(cur.position, nn2.position):\n                            cur.add_child(nn2)\n                            T.append(nn2)\n                            nodes.append(nn2)\n                            self._grid_add(G, nn2)\n                            self._edges_add(edges, cur, nn2)\n                            return nn2\n                return cur\n            steps += 1\n        # Final check\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                if not self._too_close(G, target_pos, 0.6 * self.dupe_radius):\n                    newc = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, newc)\n                    if (not self._point_blocked(nn.position)) and self._edge_free(cur.position, nn.position):\n                        cur.add_child(nn)\n                        T.append(nn)\n                        nodes.append(nn)\n                        self._grid_add(G, nn)\n                        self._edges_add(edges, cur, nn)\n                        return nn\n            return cur\n        return None\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(3.0, self.step * 1.5)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy1, iy0 - 1, -1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        if key in self._ecache:\n            return self._ecache[key]\n        hit = self._segment_hits_any(a, b)\n        res = not hit\n        if len(self._ecache) > self._ecache_cap:\n            self._ecache.clear()\n        self._ecache[key] = res\n        return res\n\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Edge bookkeeping\n    def _edges_add(self, edges, parent, child):\n        key = (id(parent), id(child))\n        if key in self._eindex:\n            return\n        edges.append((parent, child))\n        self._eindex[key] = len(edges) - 1\n\n    def _edges_remove(self, edges, parent, child):\n        key = (id(parent), id(child))\n        idx = self._eindex.get(key)\n        if idx is None:\n            return\n        last = len(edges) - 1\n        if idx != last:\n            edges[idx] = edges[last]\n            pk, ck = id(edges[idx][0]), id(edges[idx][1])\n            self._eindex[(pk, ck)] = idx\n        edges.pop()\n        self._eindex.pop(key, None)\n\n    # Path utilities and smoothing\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rr(0, max(1, len(cur) - 2)))\n            j = int(self._rr(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _elastic(self, pts, passes):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = list(pts)\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                b = cur[i]\n                c = cur[i + 1]\n                target = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                t = 1.0\n                best = b\n                while t > 1e-3:\n                    cand = tuple(b[k] + (target[k] - b[k]) * t for k in range(self.dim))\n                    cand = self._clamp(cand)\n                    if (not self._point_blocked(cand)) and self._edge_free(a, cand) and self._edge_free(cand, c):\n                        best = cand\n                        break\n                    t *= 0.5\n                if best != b:\n                    cur[i] = best\n                    moved = True\n            if not moved:\n                break\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._shortcut(path, self.shortcut_attempts)\n        p2 = self._visibility_prune(p1)\n        p3 = self._elastic(p2, self.smooth_passes)\n        return self._dedup(p3)",
          "objective": -36.2946,
          "time_improvement": 70.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1565.0,
          "node_improvement": 91.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010896635055541993,
                    "num_nodes_avg": 37.0,
                    "path_length_avg": 158.8373930707889,
                    "smoothness_avg": 0.04065007760526215,
                    "success_improvement": 0.0,
                    "time_improvement": 60.49347072740427,
                    "node_improvement": 90.68244774615965,
                    "length_improvement": 12.938707918341045,
                    "smoothness_improvement": 536.2619875787317,
                    "objective_score": 28.592575907119567
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04400351047515869,
                    "num_nodes_avg": 121.0,
                    "path_length_avg": 258.28080909958425,
                    "smoothness_avg": 0.12915590334471116,
                    "success_improvement": 0.0,
                    "time_improvement": 73.40839311365298,
                    "node_improvement": 91.869918699187,
                    "length_improvement": 13.778431721669307,
                    "smoothness_improvement": 3223.2744202964086,
                    "objective_score": 46.40594906857952
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.012626433372497558,
                    "num_nodes_avg": 67.0,
                    "path_length_avg": 134.24774687852602,
                    "smoothness_avg": 0.08149139702456171,
                    "success_improvement": 0.0,
                    "time_improvement": 75.66346447683141,
                    "node_improvement": 91.48124602670057,
                    "length_improvement": 10.83903871403107,
                    "smoothness_improvement": 936.5645550831911,
                    "objective_score": 33.88528534688402
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "FLASH-Beam BiRRT-Lazy: a fast bi-directional planner that alternates tree growth with beam-guided sampling, single-parent insertion, on-the-fly grandparent compression, and immediate early exit upon the first bridge. It uses a lightweight spatial hash for nearest search, duplicate suppression, corridor/informed sampling, and a one-step micro-bridge to raise success in narrow passages. A bounded finalize stage (visibility prune, few shortcuts, gentle corner rounding) yields short and smooth paths without lengthy global rewiring.",
          "planning_mechanism": "Mechanism: Build start/goal trees on a spatial grid. Each iteration samples a target (goal/corridor/informed/uniform), steers one step from the nearest node, and inserts only if both node and edge are collision-free; if possible, reparent to the grandparent via LOS compression before insertion. After each insertion, attempt an immediate LOS bridge to the nearest node of the opposite tree, else add a single micro-step in the opposite tree toward the new node and recheck. Return as soon as any bridge is found, then run a short finalize routine (visibility prune, capped random shortcuts, angle-aware corner cuts) to polish the path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        pts = []\n        cur = self\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=8.0,\n                 goal_bias=0.2,\n                 corridor_bias=0.4,\n                 informed_bias=0.6,\n                 corridor_width_factor=0.25,\n                 dupe_radius_factor=0.6,\n                 cell_size_factor=1.4,\n                 connect_radius_factor=4.0,\n                 attempts_per_iter=2,\n                 post_shortcuts=48,\n                 corner_cut_fraction=0.3):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.corridor_width_factor = float(corridor_width_factor)\n        self.dupe_radius_factor = float(dupe_radius_factor)\n        self.cell_size_factor = float(cell_size_factor)\n        self.connect_radius_factor = float(connect_radius_factor)\n        self.attempts_per_iter = int(max(1, attempts_per_iter))\n        self.post_shortcuts = int(max(0, post_shortcuts))\n        self.corner_cut_fraction = float(corner_cut_fraction)\n        self._rng = 1337\n        self._edge_cache = {}\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Build obstacle buckets\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self._build_obs_grid()\n\n        # Start/goal feasibility\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            s = Node(self.start, None, 0.0)\n            g = Node(self.goal, s, self._dist(self.start, self.goal))\n            s.add_child(g)\n            edges = [(s, g)]\n            return PlannerResult(True, [self.start, self.goal], [s, g], edges)\n\n        # Derived params\n        self.cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_factor)\n        self.connect_radius = max(self.step_size, self.connect_radius_factor * self.step_size)\n        self.corridor_w = max(self.step_size, self.corridor_width_factor * self._dist(self.start, self.goal))\n\n        # Trees and grids\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, a_root)\n        self._grid_add(Gb, b_root)\n        nodes = [a_root, b_root]\n        edges = []\n\n        c_best = float('inf')\n        best_path = None\n\n        for it in range(self.max_iter):\n            grow_a = (it % 2 == 0)\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            root_x = a_root if grow_a else b_root\n            root_y = b_root if grow_a else a_root\n            attractor = self.goal if grow_a else self.start\n\n            target = self._choose_target(root_x.position, root_y.position, c_best, attractor)\n\n            inserted = None\n            tries = 0\n            while tries < self.attempts_per_iter:\n                near = self._nearest(G, T, target)\n                if near is None:\n                    break\n                new_pos = self._steer(near.position, target, self.step_size)\n                if not self._in_bounds(new_pos):\n                    target = self._jitter(target, near.position)\n                    tries += 1\n                    continue\n                if self._exists_close(G, new_pos, self.dupe_radius):\n                    target = self._jitter(target, near.position)\n                    tries += 1\n                    continue\n                if self._point_blocked(new_pos):\n                    target = self._jitter(target, near.position)\n                    tries += 1\n                    continue\n                if not self._edge_free(near.position, new_pos):\n                    target = self._jitter(target, near.position)\n                    tries += 1\n                    continue\n\n                parent = near\n                ppar = parent.parent\n                if ppar is not None and self._edge_free(ppar.position, new_pos):\n                    parent = ppar\n                new_cost = parent.cost + self._dist(parent.position, new_pos)\n\n                new_node = Node(new_pos, parent, new_cost)\n                parent.add_child(new_node)\n                T.append(new_node)\n                nodes.append(new_node)\n                self._grid_add(G, new_node)\n                edges.append((parent, new_node))\n                inserted = new_node\n                break\n\n            if inserted is None:\n                continue\n\n            # Try to bridge directly to nearest in opposite tree\n            other = self._nearest(Gopp, Topp, inserted.position)\n            if other is not None and self._edge_free(inserted.position, other.position):\n                path = self._compose_path(inserted, other, grow_a)\n                final = self._finalize(path)\n                return PlannerResult(True, final, nodes, edges)\n\n            # Micro-bridge: add one step in the opposite tree toward inserted\n            if other is not None:\n                nxt_pos = self._steer(other.position, inserted.position, self.step_size)\n                if (self._in_bounds(nxt_pos) and\n                    not self._exists_close(Gopp, nxt_pos, self.dupe_radius) and\n                    not self._point_blocked(nxt_pos) and\n                    self._edge_free(other.position, nxt_pos)):\n                    nxt = Node(nxt_pos, other, other.cost + self._dist(other.position, nxt_pos))\n                    other.add_child(nxt)\n                    Topp.append(nxt)\n                    nodes.append(nxt)\n                    self._grid_add(Gopp, nxt)\n                    edges.append((other, nxt))\n                    if self._edge_free(inserted.position, nxt.position):\n                        path = self._compose_path(inserted, nxt, grow_a)\n                        final = self._finalize(path)\n                        return PlannerResult(True, final, nodes, edges)\n\n        # If loop ends without immediate bridge, try best known (unused here); else fail\n        if best_path:\n            final = self._finalize(best_path)\n            return PlannerResult(True, final, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= step:\n            return tuple(b)\n        r = step / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n\n    # Sampling\n    def _choose_target(self, a, b, c_best, attractor):\n        r = self._rand()\n        if c_best < float('inf') and r < self.informed_bias:\n            p = self._sample_informed(a, b, c_best)\n            if p is not None:\n                return p\n        r = self._rand()\n        if r < self.goal_bias:\n            return attractor\n        elif r < self.goal_bias + self.corridor_bias:\n            return self._sample_corridor(a, b, self.corridor_w)\n        else:\n            return self._sample_free()\n\n    def _sample_free(self):\n        for _ in range(32):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._point_blocked(p):\n                return p\n        if self.dim == 3:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5, self.bounds[2] * 0.5)\n        else:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5)\n\n    def _sample_corridor(self, a, b, width):\n        t = self._rand()\n        base = tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n        if self.dim == 2:\n            abx = b[0] - a[0]\n            aby = b[1] - a[1]\n            n = (abx * abx + aby * aby) ** 0.5\n            if n <= 1e-12:\n                return self._sample_free()\n            vx = -aby / n\n            vy = abx / n\n            m = self._uniform(-width, width)\n            p = (base[0] + vx * m, base[1] + vy * m)\n            if not self._in_bounds(p) or self._point_blocked(p):\n                return self._sample_free()\n            return p\n        else:\n            ab = (b[0] - a[0], b[1] - a[1], b[2] - a[2])\n            n = (ab[0]*ab[0] + ab[1]*ab[1] + ab[2]*ab[2]) ** 0.5\n            if n <= 1e-12:\n                return self._sample_free()\n            v = (ab[0]/n, ab[1]/n, ab[2]/n)\n            r = (self._uniform(-1.0, 1.0), self._uniform(-1.0, 1.0), self._uniform(-1.0, 1.0))\n            dot = r[0]*v[0] + r[1]*v[1] + r[2]*v[2]\n            u = (r[0]-dot*v[0], r[1]-dot*v[1], r[2]-dot*v[2])\n            un = (u[0]*u[0] + u[1]*u[1] + u[2]*u[2]) ** 0.5\n            if un <= 1e-12:\n                u = (v[1], -v[0], 0.0)\n                un = (u[0]*u[0] + u[1]*u[1] + u[2]*u[2]) ** 0.5\n            u = (u[0]/un, u[1]/un, u[2]/un)\n            m = self._uniform(-width, width)\n            p = (base[0] + u[0]*m, base[1] + u[1]*m, base[2] + u[2]*m)\n            if not self._in_bounds(p) or self._point_blocked(p):\n                return self._sample_free()\n            return p\n\n    def _sample_informed(self, a, b, c_best):\n        if c_best == float('inf'):\n            return None\n        for _ in range(32):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._dist(p, a) + self._dist(p, b) <= c_best + 1e-9 and not self._point_blocked(p):\n                return p\n        return None\n\n    def _jitter(self, target, center):\n        if self.dim == 3:\n            return (min(max(center[0] + self._uniform(-self.step_size, self.step_size), 0.0), self.bounds[0]),\n                    min(max(center[1] + self._uniform(-self.step_size, self.step_size), 0.0), self.bounds[1]),\n                    min(max(center[2] + self._uniform(-self.step_size, self.step_size), 0.0), self.bounds[2]))\n        else:\n            return (min(max(center[0] + self._uniform(-self.step_size, self.step_size), 0.0), self.bounds[0]),\n                    min(max(center[1] + self._uniform(-self.step_size, self.step_size), 0.0), self.bounds[1]))\n\n    # Node spatial hashing\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 3):\n            cand = self._ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        if tree:\n            step = max(1, len(tree) // 32)\n            for i in range(0, len(tree), step):\n                n = tree[i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        ring = int(max(1, radius // self.cell_size) + 1)\n        cand = self._ring_collect(grid, self._grid_key(pos), ring)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # Obstacles and collision\n    def _build_obs_grid(self):\n        self.obs_grid = {}\n        if self.dim == 3:\n            for idx, o in enumerate(self.obstacles):\n                ox, oy, oz, w, h, d = o\n                ix0 = int(max(0.0, ox) // self.obs_cell)\n                iy0 = int(max(0.0, oy) // self.obs_cell)\n                iz0 = int(max(0.0, oz) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], ox + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], oy + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], oz + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obs_grid.get(key)\n                            if lst is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                ox, oy, w, h = o\n                ix0 = int(max(0.0, ox) // self.obs_cell)\n                iy0 = int(max(0.0, oy) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], ox + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], oy + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obs_grid.get(key)\n                        if lst is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_blocked(self, p):\n        if self.dim == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        key = (a, b)\n        ans = self._edge_cache.get(key)\n        if ans is not None:\n            return ans\n        blocked = self._segment_hits(a, b)\n        self._edge_cache[key] = (not blocked)\n        return not blocked\n\n    def _segment_hits(self, a, b):\n        if self.dim == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obs_grid.get((i, j, k))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                if self._seg_box_hit_3d(a, b, self.obstacles[idx]):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obs_grid.get((i, j))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                if self._seg_box_hit_2d(a, b, self.obstacles[idx]):\n                    return True\n            return False\n\n    def _seg_box_hit_2d(self, a, b, box):\n        x, y, w, h = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        ax, ay = a\n        bx, by = b\n        dx = bx - ax\n        dy = by - ay\n        t0, t1 = 0.0, 1.0\n\n        if abs(dx) < 1e-12:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            tmin = (minx - ax) * inv\n            tmax = (maxx - ax) * inv\n            if tmin > tmax:\n                tmin, tmax = tmax, tmin\n            if tmin > t0:\n                t0 = tmin\n            if tmax < t1:\n                t1 = tmax\n            if t0 > t1:\n                return False\n\n        if abs(dy) < 1e-12:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            tmin = (miny - ay) * inv\n            tmax = (maxy - ay) * inv\n            if tmin > tmax:\n                tmin, tmax = tmax, tmin\n            if tmin > t0:\n                t0 = tmin\n            if tmax < t1:\n                t1 = tmax\n            if t0 > t1:\n                return False\n\n        return t1 >= 0.0 and t0 <= 1.0\n\n    def _seg_box_hit_3d(self, a, b, box):\n        x, y, z, w, h, d = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        minz, maxz = z, z + d\n        ax, ay, az = a\n        bx, by, bz = b\n        dx = bx - ax\n        dy = by - ay\n        dz = bz - az\n        t0, t1 = 0.0, 1.0\n\n        if abs(dx) < 1e-12:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            tmin = (minx - ax) * inv\n            tmax = (maxx - ax) * inv\n            if tmin > tmax:\n                tmin, tmax = tmax, tmin\n            if tmin > t0:\n                t0 = tmin\n            if tmax < t1:\n                t1 = tmax\n            if t0 > t1:\n                return False\n\n        if abs(dy) < 1e-12:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            tmin = (miny - ay) * inv\n            tmax = (maxy - ay) * inv\n            if tmin > tmax:\n                tmin, tmax = tmax, tmin\n            if tmin > t0:\n                t0 = tmin\n            if tmax < t1:\n                t1 = tmax\n            if t0 > t1:\n                return False\n\n        if abs(dz) < 1e-12:\n            if az < minz or az > maxz:\n                return False\n        else:\n            inv = 1.0 / dz\n            tmin = (minz - az) * inv\n            tmax = (maxz - az) * inv\n            if tmin > tmax:\n                tmin, tmax = tmax, tmin\n            if tmin > t0:\n                t0 = tmin\n            if tmax < t1:\n                t1 = tmax\n            if t0 > t1:\n                return False\n\n        return t1 >= 0.0 and t0 <= 1.0\n\n    # Path utilities and smoothing\n    def _compose_path(self, a_end, b_end, grew_a):\n        pa = a_end.path_from_root()\n        pb = b_end.path_from_root()\n        if grew_a:\n            return pa + pb[::-1]\n        else:\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], path[j]):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i + 1])\n                i += 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return list(path)\n        pts = list(path)\n        bestL = self._path_len(pts)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and n >= 3:\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 2, n))\n            a = pts[i]\n            b = pts[j - 1]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j - 1:]\n                newL = self._path_len(new_pts)\n                if newL + 1e-9 <= bestL:\n                    pts = new_pts\n                    n = len(pts)\n                    bestL = newL\n            tries += 1\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        return pts\n\n    def _corner_cut(self, path):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        i = 1\n        while i < len(pts) - 1:\n            p0 = pts[i - 1]\n            p1 = pts[i]\n            p2 = pts[i + 1]\n            l01 = self._dist(p0, p1)\n            l12 = self._dist(p1, p2)\n            if l01 <= 1e-6 or l12 <= 1e-6:\n                i += 1\n                continue\n            v1 = tuple((p1[j] - p0[j]) / l01 for j in range(self.dim))\n            v2 = tuple((p2[j] - p1[j]) / l12 for j in range(self.dim))\n            dot = 0.0\n            for j in range(self.dim):\n                dot += v1[j] * v2[j]\n            if dot > 0.997:\n                i += 1\n                continue\n            cut = self.corner_cut_fraction * min(l01, l12, self.step_size)\n            a = tuple(p1[j] - v1[j] * cut for j in range(self.dim))\n            b = tuple(p1[j] + v2[j] * cut for j in range(self.dim))\n            if (self._in_bounds(a) and self._in_bounds(b) and\n                not self._point_blocked(a) and not self._point_blocked(b) and\n                self._edge_free(p0, a) and self._edge_free(a, b) and self._edge_free(b, p2)):\n                pts = pts[:i] + [a, b] + pts[i + 1:]\n                i += 2\n            else:\n                i += 1\n        return pts\n\n    def _finalize(self, path):\n        if not path:\n            return []\n        p = self._visibility_prune(path)\n        p = self._shortcut(p, self.post_shortcuts)\n        p = self._corner_cut(p)\n        p = self._visibility_prune(p)\n        return p",
          "objective": -36.28535,
          "time_improvement": 64.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1594.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007711052894592285,
                    "num_nodes_avg": 46.0,
                    "path_length_avg": 164.8442723313133,
                    "smoothness_avg": 0.05273670917747908,
                    "success_improvement": 0.0,
                    "time_improvement": 69.34482229143484,
                    "node_improvement": 88.41601611684715,
                    "length_improvement": 9.646242210554556,
                    "smoothness_improvement": 725.4440182244762,
                    "objective_score": 30.218412104885566
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.030881428718566896,
                    "num_nodes_avg": 128.6,
                    "path_length_avg": 239.11146879242807,
                    "smoothness_avg": 0.10866454352893289,
                    "success_improvement": 0.0,
                    "time_improvement": 80.72448819690932,
                    "node_improvement": 91.35926896459048,
                    "length_improvement": 20.177709275065677,
                    "smoothness_improvement": 2696.0169729065346,
                    "objective_score": 49.80405688864487
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02857198715209961,
                    "num_nodes_avg": 115.2,
                    "path_length_avg": 126.27223843137217,
                    "smoothness_avg": 0.11472901332971522,
                    "success_improvement": 0.0,
                    "time_improvement": 41.184173071448896,
                    "node_improvement": 85.35282898919262,
                    "length_improvement": 16.135991671729823,
                    "smoothness_improvement": 1359.3445811391077,
                    "objective_score": 28.833569830168102
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "HASTE-BiRRT: Hashed, Anytime, Saturation\u2011Throttled, Efficient BiRRT-Connect. It accelerates bidirectional RRT with cached collision tests, hashed nearest search with leader fallbacks, per-cell growth throttling, and duplicate-suppressed commit-only connections. A light visibility prune plus brief shortcutting refines the path while keeping postprocessing costs low.",
          "planning_mechanism": "Alternate expanding start/goal trees with goal-biased sampling; find nearest via grid rings, else leader-guided buckets; steer one step and validate with cached edge checks; suppress inserts in saturated/duplicate cells; attempt a single, commit-only direct bridge to the opposite tree, skipping known-blocked cell pairs; upon success, extract start-to-goal path, visibility-prune, then run a few shortcuts; terminate on success or iteration cap.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=7.0,\n                 goal_bias=0.25,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=40,\n                 max_per_cell=6,\n                 search_r_max=2,\n                 leader_stride=25):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n        self.max_per_cell = max_per_cell\n        self.search_r_max = search_r_max\n        self.leader_stride = leader_stride\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        # Caches\n        self._edge_blocked_cache = set()   # quantized blocked segments (safe to reuse only for blocked)\n        self._edge_exact_cache = {}        # exact endpoint pairs -> bool\n        self._connect_blocked_cells = set()  # (cellA, cellB) pairs known to fail direct connect\n\n    # ------------- Public API -------------\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Parameters derived\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size * 2.5)\n        self.edge_res = max(0.5, self.collision_step)\n\n        # Reset caches\n        self._edge_blocked_cache = set()\n        self._edge_exact_cache = {}\n        self._connect_blocked_cells = set()\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            path = [start, goal]\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Initialize trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Grids and counts\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n        self._grid_add(grid_start, counts_start, start_root)\n        self._grid_add(grid_goal, counts_goal, goal_root)\n\n        # Leaders\n        leaders_start = [start_root]\n        leaders_goal = [goal_root]\n        inserted_since_leader_start = 0\n        inserted_since_leader_goal = 0\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            grid_a = grid_start if active_start else grid_goal\n            counts_a = counts_start if active_start else counts_goal\n            leaders_a = leaders_start if active_start else leaders_goal\n\n            tree_b = goal_tree if active_start else start_tree\n            grid_b = grid_goal if active_start else grid_start\n            counts_b = counts_goal if active_start else counts_start\n            leaders_b = leaders_goal if active_start else leaders_start\n\n            root_other = goal if active_start else start\n\n            # Sample with goal/opposite-root bias\n            if self._rand() < self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest lookup\n            nearest = self._nearest_hashed(grid_a, leaders_a, tree_a, x_rand)\n            if nearest is None:\n                continue\n\n            # Steer\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Per-cell throttling and duplicate suppression\n            key_new = self._grid_key(new_pos)\n            if self._cell_count(counts_a, key_new) >= self.max_per_cell:\n                continue\n            if self._near_duplicate(grid_a, new_pos, dup_radius=0.7 * self.step_size):\n                continue\n\n            # Insert node and edge\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, counts_a, new_node)\n\n            # Leader sampling\n            if active_start:\n                inserted_since_leader_start += 1\n                if inserted_since_leader_start >= self.leader_stride:\n                    leaders_start.append(new_node)\n                    inserted_since_leader_start = 0\n            else:\n                inserted_since_leader_goal += 1\n                if inserted_since_leader_goal >= self.leader_stride:\n                    leaders_goal.append(new_node)\n                    inserted_since_leader_goal = 0\n\n            # Try commit-only direct connection to the other tree (with cell-pair de-dup)\n            other_near = self._nearest_hashed(grid_b, leaders_b, tree_b, new_node.position)\n            if other_near is not None:\n                pair_key = (self._grid_key(new_node.position), self._grid_key(other_near.position))\n                if pair_key not in self._connect_blocked_cells:\n                    if not self._edge_blocked(new_node.position, other_near.position, obstacles, is_3d):\n                        path = self._extract_path(new_node, other_near, a_is_start_tree=active_start)\n                        path = self._visibility_prune(path, obstacles, is_3d)\n                        path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                        return PlannerResult(True, path, start_tree + goal_tree, edges)\n                    else:\n                        # cache blocked cell pair to avoid repeating futile checks\n                        self._connect_blocked_cells.add(pair_key)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ------------- Random -------------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------- Geometry -------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ------------- Collision & caches -------------\n    def _quant(self, p, q=1.5):\n        # Quantize for blocked-segment cache; coarse to avoid false frees; safe for blocked reuse only\n        if self.dim == 3:\n            return (int(p[0] // q), int(p[1] // q), int(p[2] // q))\n        else:\n            return (int(p[0] // q), int(p[1] // q))\n\n    def _seg_key_exact(self, a, b):\n        # Canonicalize order for undirected segment\n        if a <= b:\n            return (a, b)\n        else:\n            return (b, a)\n\n    def _seg_key_quant_blocked(self, a, b):\n        qa = self._quant(a)\n        qb = self._quant(b)\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        # Exact cache check\n        k_exact = self._seg_key_exact(a, b)\n        cached = self._edge_exact_cache.get(k_exact)\n        if cached is not None:\n            return cached\n        # Blocked quantized cache\n        kq = self._seg_key_quant_blocked(a, b)\n        if kq in self._edge_blocked_cache:\n            self._edge_exact_cache[k_exact] = True\n            return True\n        # Compute\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res)\n        # Update caches\n        self._edge_exact_cache[k_exact] = blocked\n        if blocked:\n            self._edge_blocked_cache.add(kq)\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ------------- Sampling -------------\n    def _sample_free(self, obstacles, is_3d):\n        # Rejection sampling within bounds until a free point is found\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ------------- Grid / NN -------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n\n    def _cell_count(self, counts, key):\n        return counts.get(key, 0)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, leaders, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Local rings\n        for r in range(0, self.search_r_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Leader fallback\n        if leaders:\n            lead_best = None\n            lead_bestd = float('inf')\n            for n in leaders:\n                d = self._dist(n.position, pos)\n                if d < lead_bestd:\n                    lead_bestd = d\n                    lead_best = n\n            if lead_best is not None:\n                # Search around leader cell for neighbors\n                lk = self._grid_key(lead_best.position)\n                for r in range(0, min(2, self.search_r_max) + 1):\n                    cand = self._grid_ring_collect(grid, lk, r)\n                    for n in cand:\n                        d = self._dist(n.position, pos)\n                        if d < bestd:\n                            bestd = d\n                            best = n\n                if best is not None:\n                    return best\n        # Sparse random subset fallback (avoid full scan)\n        if tree:\n            trials = min(64, len(tree))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(tree)))\n                n = tree[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            if best is not None:\n                return best\n        return None\n\n    def _near_duplicate(self, grid, pos, dup_radius):\n        key = self._grid_key(pos)\n        r = 1\n        cand = self._grid_ring_collect(grid, key, r)\n        rr = dup_radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # ------------- Path -------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            # start-tree path to meet, then meet->goal via reversed goal-tree path\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -35.78786,
          "time_improvement": 66.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1772.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016536712646484375,
                    "num_nodes_avg": 67.3,
                    "path_length_avg": 176.25078259592178,
                    "smoothness_avg": 0.05067539409595988,
                    "success_improvement": 0.0,
                    "time_improvement": 35.1470831615236,
                    "node_improvement": 83.05212792747419,
                    "length_improvement": 3.3941531868009323,
                    "smoothness_improvement": 693.1799609813568,
                    "objective_score": 16.046516665444422
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023010659217834472,
                    "num_nodes_avg": 105.2,
                    "path_length_avg": 247.25890321415372,
                    "smoothness_avg": 0.1191098532602342,
                    "success_improvement": 0.0,
                    "time_improvement": 85.63605318102866,
                    "node_improvement": 92.93153262111133,
                    "length_improvement": 17.45786115419664,
                    "smoothness_improvement": 2964.7823157454163,
                    "objective_score": 50.989444225553655
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.011754655838012695,
                    "num_nodes_avg": 94.4,
                    "path_length_avg": 127.41557160345823,
                    "smoothness_avg": 0.13822063405561777,
                    "success_improvement": 0.0,
                    "time_improvement": 76.0361625858193,
                    "node_improvement": 87.99745708836618,
                    "length_improvement": 15.376644218505373,
                    "smoothness_improvement": 1658.156262801516,
                    "objective_score": 40.327616620856595
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Bounded BiRRT-Connect with Grid-Accelerated Nearest and Lightweight Shortcutting: a time-capped, bidirectional RRT-Connect that uses a coarse spatial grid for fast nearest-neighbor queries, commits only validated steps, attempts a single greedy bridge per iteration, and applies a brief shortcut smoother to the first found path for quality without heavy rewiring or anytime overhead.",
          "planning_mechanism": "Mechanism: Alternate growing start/goal trees with one extend loop toward a biased sample; each successful extension triggers a greedy extend from the opposite tree toward the new node. Both node and edge collisions are strictly checked before every insertion and the final bridge. Nearest queries use a bucket grid with limited ring expansion and linear fallback. On success, a bounded-time shortcut pass improves path length/smoothness; the planner enforces a hard time limit and returns the best (first) feasible path promptly.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=6.0,\n        goal_sample_rate=0.15,\n        bridge_bias_rate=0.30,\n        cell_size_factor=2.0,\n        time_limit_sec=12.0,\n        edge_resolution=1.0,\n        smooth_attempts=80,\n        smooth_time_frac=0.2\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.bridge_bias_rate = bridge_bias_rate\n        self.cell_size_factor = cell_size_factor\n        self.time_limit_sec = time_limit_sec\n        self.edge_resolution = edge_resolution\n        self.smooth_attempts = smooth_attempts\n        self.smooth_time_frac = smooth_time_frac\n\n    def plan(self, map):\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Validate start/goal feasibility\n        if self._is_in_obstacle(start_position, obstacles, is_3d) or self._is_in_obstacle(goal_position, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Initialize trees and spatial grids\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root = Node(goal_position, parent=None, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        grid_start = {}\n        grid_goal = {}\n        self._grid_insert(grid_start, start_root.position, start_root, cell_size, dim)\n        self._grid_insert(grid_goal, goal_root.position, goal_root, cell_size, dim)\n\n        start_time = time.time()\n\n        # Early straight-line check\n        if not self._is_edge_in_obstacle(start_position, goal_position, obstacles, is_3d, self.edge_resolution):\n            edges.append((start_root, goal_root))\n            direct_path = [start_position, goal_position]\n            return PlannerResult(True, direct_path, start_tree + goal_tree, edges)\n\n        # Main loop\n        for it in range(self.max_iter):\n            if time.time() - start_time >= self.time_limit_sec:\n                return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n            # Alternate tree growth\n            if it % 2 == 0:\n                grow_tree, grow_grid = start_tree, grid_start\n                other_tree, other_grid = goal_tree, grid_goal\n                a_is_start_side = True\n                other_root_pos = goal_root.position\n            else:\n                grow_tree, grow_grid = goal_tree, grid_goal\n                other_tree, other_grid = start_tree, grid_start\n                a_is_start_side = False\n                other_root_pos = start_root.position\n\n            sample = self._sample(bounds, obstacles, is_3d, other_root_pos)\n\n            # Extend grow_tree toward sample\n            a_near = self._nearest_from_grid(grow_tree, grow_grid, sample, cell_size, dim)\n            a_last = self._extend(grow_tree, grow_grid, a_near, sample, nodes, edges, obstacles, is_3d, bounds, cell_size, dim)\n            if a_last is None:\n                continue\n\n            # Greedy connect: extend other_tree toward the new node\n            b_near = self._nearest_from_grid(other_tree, other_grid, a_last.position, cell_size, dim)\n            b_last = self._extend(other_tree, other_grid, b_near, a_last.position, nodes, edges, obstacles, is_3d, bounds, cell_size, dim)\n            if b_last is None:\n                continue\n\n            # Attempt final short bridge\n            if self._distance(b_last.position, a_last.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(b_last.position, a_last.position, obstacles, is_3d, self.edge_resolution):\n                    edges.append((b_last, a_last))\n                    # Extract and smooth path\n                    final_path = self._assemble_path(a_last, b_last, a_is_start_side)\n                    remaining = max(0.0, self.time_limit_sec - (time.time() - start_time))\n                    budget = min(remaining, self.time_limit_sec * self.smooth_time_frac)\n                    final_path = self._shortcut_path(final_path, obstacles, is_3d, bounds, budget, self.smooth_attempts)\n                    return PlannerResult(True, final_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---- Utilities ----\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _within_bounds(self, p, bounds):\n        for i in range(len(bounds)):\n            if p[i] < 0.0 or p[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step_size):\n        d = self._distance(from_pos, to_pos)\n        if d <= step_size:\n            return to_pos\n        r = step_size / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    def _sample(self, bounds, obstacles, is_3d, other_root_pos):\n        # Bias toward the opposite root\n        if random.random() < self.bridge_bias_rate:\n            return other_root_pos\n        # Mild goal bias to encourage meeting/goal attraction\n        if random.random() < self.goal_sample_rate:\n            return other_root_pos\n        # Uniform rejection sampling in free space\n        dim = len(bounds)\n        for _ in range(30):\n            pt = tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n        # Fallback: last sample even if occupied (extend will reject)\n        return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n\n    def _extend(self, tree, grid, nearest_node, target_pos, nodes, edges, obstacles, is_3d, bounds, cell_size, dim):\n        current = nearest_node\n        last_new = None\n        while True:\n            step_pos = self._steer(current.position, target_pos, self.step_size)\n            if not self._within_bounds(step_pos, bounds):\n                break\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                break\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d, self.edge_resolution):\n                break\n            # Both node and edge are valid \u2192 commit\n            new_node = Node(step_pos)\n            new_node.cost = current.cost + self._distance(current.position, step_pos)\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node.position, new_node, cell_size, dim)\n            last_new = new_node\n            current = new_node\n            # Stop if reached target (within one step)\n            if self._distance(current.position, target_pos) <= self.step_size:\n                break\n        return last_new\n\n    def _assemble_path(self, a_node, b_node, a_is_start_side):\n        if a_is_start_side:\n            pa = a_node.path_from_root()   # start -> ... -> a\n            pb = b_node.path_from_root()   # goal  -> ... -> b\n            return pa + pb[::-1]           # start ... a, b ... goal\n        else:\n            pa = a_node.path_from_root()   # goal  -> ... -> a\n            pb = b_node.path_from_root()   # start -> ... -> b\n            return pb + pa[::-1]           # start ... b, a ... goal\n\n    # ---- Spatial grid for approximate nearest ----\n    def _cell_index(self, pos, cell_size, dim):\n        if dim == 2:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size))\n        else:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size), int(pos[2] // cell_size))\n\n    def _grid_insert(self, grid, pos, node, cell_size, dim):\n        idx = self._cell_index(pos, cell_size, dim)\n        if idx in grid:\n            grid[idx].append(node)\n        else:\n            grid[idx] = [node]\n\n    def _nearest_from_grid(self, tree, grid, point, cell_size, dim, max_rings=3):\n        # For small trees, just do linear scan\n        if len(tree) < 32:\n            return min(tree, key=lambda n: self._distance(n.position, point))\n\n        center = self._cell_index(point, cell_size, dim)\n        best = None\n        # Expand rings until some candidates found, then pick nearest among them\n        for r in range(0, max_rings + 1):\n            candidates = []\n            if dim == 2:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        idx = (center[0] + dx, center[1] + dy)\n                        if idx in grid:\n                            candidates.extend(grid[idx])\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            idx = (center[0] + dx, center[1] + dy, center[2] + dz)\n                            if idx in grid:\n                                candidates.extend(grid[idx])\n            if candidates:\n                best = min(candidates, key=lambda n: self._distance(n.position, point))\n                break\n\n        if best is None:\n            # Fallback to linear scan if grid empty nearby\n            best = min(tree, key=lambda n: self._distance(n.position, point))\n        return best\n\n    # ---- Collision utilities ----\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist / max(1e-6, resolution)))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    # ---- Path shortcutting ----\n    def _shortcut_path(self, path, obstacles, is_3d, bounds, time_budget, attempts):\n        if len(path) < 3:\n            return path\n        start_t = time.time()\n        pts = list(path)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and (time.time() - start_t) <= time_budget:\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            # Keep within bounds and collision-free\n            if not self._segment_within_bounds(a, b, bounds):\n                tries += 1\n                continue\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_resolution):\n                # Apply shortcut\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n            tries += 1\n        return pts\n\n    def _segment_within_bounds(self, a, b, bounds):\n        # The interpolated segment is within bounds if endpoints are; checks along the way via edge collision\n        for d in range(len(bounds)):\n            if a[d] < 0.0 or a[d] > bounds[d]:\n                return False\n            if b[d] < 0.0 or b[d] > bounds[d]:\n                return False\n        return True",
          "objective": -35.38986,
          "time_improvement": 79.0,
          "length_improvement": 6.0,
          "smoothness_improvement": 1571.0,
          "node_improvement": 81.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009288859367370606,
                    "num_nodes_avg": 87.5,
                    "path_length_avg": 179.7819366813108,
                    "smoothness_avg": 0.041891929272141075,
                    "success_improvement": 0.0,
                    "time_improvement": 63.57137981686718,
                    "node_improvement": 77.96524804835055,
                    "length_improvement": 1.4586716778820132,
                    "smoothness_improvement": 555.6996628894441,
                    "objective_score": 22.725115266236582
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009074711799621582,
                    "num_nodes_avg": 124.9,
                    "path_length_avg": 251.58839597257443,
                    "smoothness_avg": 0.10077141463831178,
                    "success_improvement": 0.0,
                    "time_improvement": 94.3352914641303,
                    "node_improvement": 91.6078747564335,
                    "length_improvement": 16.01255185389636,
                    "smoothness_improvement": 2492.9210813599107,
                    "objective_score": 50.372723958376454
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01003124713897705,
                    "num_nodes_avg": 215.4,
                    "path_length_avg": 148.33090891427284,
                    "smoothness_avg": 0.13860849885025553,
                    "success_improvement": 0.0,
                    "time_improvement": 79.54962026854608,
                    "node_improvement": 72.6128417037508,
                    "length_improvement": 1.4856730579993105,
                    "smoothness_improvement": 1663.0898743601072,
                    "objective_score": 33.07173928716395
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "LINX-Opt*: Length-Intensive Informed Bi-RRT* with Cost-Optimal Bridge and Monotone Shortcutting. It grows two cost-aware RRT* trees with a decaying, node-count-driven neighbor radius, k-best parent selection, local rewiring, and a bridge that minimizes total cost-to-go across trees. An informed-ellipsoid sampler and admissible gating prune expansions that cannot beat the current best length. The solution is post-processed by deterministic visibility pruning, randomized shortcutting, and length-monotone vertex sliding, guaranteeing non-increasing path length.",
          "planning_mechanism": "Alternate expanding start/goal trees. Each step: sample (goal/line/uniform; switch to informed ellipse after first solution), pick nearest via spatial hash, steer, enforce collision checks, select the lowest-cost parent among neighbors within an adaptive radius, insert node, and rewire cheaper neighbors. Then search the opposite tree for a direct, edge-free connection that minimizes cost_a + dist + cost_b; on success, assemble the path and apply length-only smoothing before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        pts.reverse()\n        return pts\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step=5.0,\n        goal_bias=0.12,\n        line_bias=0.20,\n        informed_bias=0.50,\n        grid_cell_factor=1.25,\n        k_near=56,\n        rewire_cap=24,\n        connect_rad_scale=4.0,\n        dupe_ratio=0.25,\n        gate_ratio=0.6,\n        shortcut_attempts=120,\n        slide_passes=8\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step)\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.k_near = int(max(8, k_near))\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_rad_scale = float(connect_rad_scale)\n        self.dupe_ratio = float(dupe_ratio)\n        self.gate_ratio = float(gate_ratio)\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.slide_passes = int(max(0, slide_passes))\n        self._rng = 1234567\n        self._eindex = {}\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n        self._eindex = {}\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dupe_radius = max(0.25, self.step * self.dupe_ratio)\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            self._edges_add(edges, n0, n1)\n            path = [self.start, self.goal]\n            path = self._finalize_path_length_opt(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize trees and grids\n        Ta, Tb = [], []\n        Ga, Gb = {}, {}\n        ra = Node(self.start, None, 0.0)\n        rb = Node(self.goal, None, 0.0)\n        Ta.append(ra)\n        Tb.append(rb)\n        nodes.extend([ra, rb])\n        self._grid_add(Ga, ra)\n        self._grid_add(Gb, rb)\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            sample = self._sample_target(best_len)\n            if sample is None:\n                continue\n\n            # Expand A then B\n            res = self._expand_and_maybe_bridge(Ta, Ga, Tb, Gb, sample, nodes, edges, best_len)\n            if res is not None:\n                path, L = res\n                if L + 1e-9 < best_len:\n                    best_len = L\n                    best_path = path\n                    final = self._finalize_path_length_opt(best_path)\n                    return PlannerResult(True, final, nodes, edges)\n\n            res = self._expand_and_maybe_bridge(Tb, Gb, Ta, Ga, sample, nodes, edges, best_len)\n            if res is not None:\n                path, L = res\n                if L + 1e-9 < best_len:\n                    best_len = L\n                    best_path = path\n                    final = self._finalize_path_length_opt(best_path)\n                    return PlannerResult(True, final, nodes, edges)\n\n        # If no bridge found, try to return best (if any)\n        if best_path is not None:\n            final = self._finalize_path_length_opt(best_path)\n            return PlannerResult(True, final, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # One expansion on Ta toward target and cost-optimal bridge to Tb\n    def _expand_and_maybe_bridge(self, Ta, Ga, Tb, Gb, target, nodes, edges, best_len):\n        near = self._nearest(Ga, target)\n        if near is None:\n            return None\n\n        q_new = self._steer_adaptive(near.position, target)\n        if (not self._in_bounds(q_new)) or self._point_blocked(q_new):\n            return None\n\n        if self._too_close(Ga, q_new, self.dupe_radius):\n            return None\n\n        # Admissible gating toward better-than-best paths\n        if best_len < float('inf') and self._rand() < self.gate_ratio:\n            root_goal = self.goal if Ta[0].position == self.start else self.start\n            if near.cost + self._dist(near.position, q_new) + self._dist(q_new, root_goal) >= best_len * 0.999:\n                return None\n\n        # Parent selection (k-near within adaptive radius), both checks enforced before add\n        parent = self._select_parent(Ga, q_new, near, len(Ta))\n        if parent is None:\n            return None\n        if self._point_blocked(q_new) or (not self._edge_free(parent.position, q_new)):\n            return None\n\n        cost = parent.cost + self._dist(parent.position, q_new)\n        nn = Node(q_new, parent, cost)\n        parent.add_child(nn)\n        Ta.append(nn)\n        nodes.append(nn)\n        self._grid_add(Ga, nn)\n        self._edges_add(edges, parent, nn)\n\n        # Local rewiring\n        if self.rewire_cap > 0:\n            self._rewire_neighbors(Ga, nn, edges, len(Ta))\n\n        # Cost-optimal direct bridge to opposite tree\n        meet, ok = self._best_direct_bridge(Tb, Gb, nn)\n        if ok and meet is not None:\n            # Insert a clone at meet to keep parenthood coherent\n            if not self._edge_free(nn.position, meet.position):\n                return None\n            if self._point_blocked(meet.position):\n                return None\n            if not self._too_close(Ga, meet.position, 0.75 * self.dupe_radius):\n                cn = Node(meet.position, nn, nn.cost + self._dist(nn.position, meet.position))\n                if (not self._point_blocked(cn.position)) and self._edge_free(nn.position, cn.position):\n                    nn.add_child(cn)\n                    Ta.append(cn)\n                    nodes.append(cn)\n                    self._grid_add(Ga, cn)\n                    self._edges_add(edges, nn, cn)\n                    nn = cn  # meeting node on A\n\n            pa = nn.path_to_root()\n            pb = meet.path_to_root()\n            if Ta[0].position == self.start:\n                path = pa + pb[-2::-1]\n            else:\n                path = pb + pa[-2::-1]\n            path = self._dedup(path)\n            L = self._path_len(path)\n            return (path, L)\n        return None\n\n    # RNG\n    def _seed_rng(self):\n        s = 2166136261\n        for v in self.start + self.goal:\n            s ^= int(v * 10007 + 0.5) & 0xffffffff\n            s = (s * 16777619) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Sampling\n    def _sample_target(self, best_len):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._sample_informed(self.start, self.goal, best_len * 1.01)\n            if p is not None:\n                return p\n        r2 = self._rand()\n        if r2 < self.goal_bias:\n            return self.goal\n        if r2 < self.goal_bias + self.line_bias:\n            t = self._rand()\n            if self.is3:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t,\n                     self.start[2] + (self.goal[2] - self.start[2]) * t)\n            else:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t)\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        # Uniform\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_informed(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (self._in_bounds(p)\n                and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum\n                and (not self._point_blocked(p))):\n                return p\n        return None\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _steer(self, a, b, step_len):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= step_len:\n            return self._clamp(b)\n        r = step_len / d\n        return self._clamp(self._lerp(a, b, r))\n\n    def _steer_adaptive(self, a, b):\n        # Fast long step if fully visible, else nominal step\n        if self._edge_free(a, b):\n            d = self._dist(a, b)\n            max_step = self.step * 2.5\n            step_len = max_step if d > max_step else d\n            return self._steer(a, b, step_len)\n        return self._steer(a, b, self.step)\n\n    # Node grid\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 3):\n            cand = self._grid_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n            if best is not None:\n                return best\n        # fallback scan\n        for lst in grid.values():\n            for n in lst:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n        return best\n\n    def _neighbors_within(self, grid, pos, radius, cap):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        seen = {}\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            i2 = id(n)\n                            if i2 in seen:\n                                continue\n                            seen[i2] = True\n                            p = n.position\n                            d2 = 0.0\n                            for i in range(self.dim):\n                                di = p[i] - pos[i]\n                                d2 += di * di\n                            if d2 <= r2:\n                                out.append(n)\n                                if len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        i2 = id(n)\n                        if i2 in seen:\n                            continue\n                        seen[i2] = True\n                        p = n.position\n                        d2 = 0.0\n                        for i in range(self.dim):\n                            di = p[i] - pos[i]\n                            d2 += di * di\n                        if d2 <= r2:\n                            out.append(n)\n                            if len(out) >= cap:\n                                return out\n        return out\n\n    def _k_nearest(self, grid, pos, k):\n        key = self._cell_key(pos)\n        out = []\n        bestd = []\n        seen = {}\n        # expand rings until gather >= k or up to 4 rings then full scan\n        for r in range(0, 5):\n            cand = self._grid_collect(grid, key, r)\n            for n in cand:\n                i2 = id(n)\n                if i2 in seen:\n                    continue\n                seen[i2] = True\n                d = self._dist(n.position, pos)\n                out.append((d, n))\n            if len(out) >= k:\n                break\n        if len(out) < k:\n            for lst in grid.values():\n                for n in lst:\n                    i2 = id(n)\n                    if i2 in seen:\n                        continue\n                    seen[i2] = True\n                    d = self._dist(n.position, pos)\n                    out.append((d, n))\n        out.sort(key=lambda t: t[0])\n        return [n for _, n in out[:k]]\n\n    def _adaptive_radius(self, n_nodes):\n        # Decays ~ n^{-1/d}, bounded below by 1.1*step\n        n = float(max(1, n_nodes))\n        r0 = 8.0 * self.step\n        r = r0 * pow(n, -1.0 / float(self.dim))\n        if r < 1.1 * self.step:\n            r = 1.1 * self.step\n        return r\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors_within(grid, pos, radius, 1)) > 0\n\n    # Parent selection with RRT*-style radius and k-near fallback\n    def _select_parent(self, grid, newp, fallback, n_nodes):\n        r = self._adaptive_radius(n_nodes)\n        neigh = self._neighbors_within(grid, newp, r, self.k_near)\n        if not neigh:\n            neigh = self._k_nearest(grid, newp, max(8, self.k_near // 2))\n        best = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        for n in neigh:\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                best = n\n                best_cost = c\n        return best\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _rewire_neighbors(self, grid, node, edges, n_nodes):\n        r = self._adaptive_radius(n_nodes)\n        neigh = self._neighbors_within(grid, node.position, r, self.k_near * 2)\n        cnt = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            if self._point_blocked(nb.position) or self._point_blocked(node.position):\n                continue\n            if not self._edge_free(node.position, nb.position):\n                continue\n            newc = node.cost + self._dist(node.position, nb.position)\n            if newc + 1e-12 < nb.cost:\n                self._reparent(nb, node, edges)\n                cnt += 1\n                if cnt >= self.rewire_cap:\n                    break\n\n    def _reparent(self, child, new_parent, edges):\n        if child is new_parent or child.parent is new_parent:\n            return\n        if self._point_blocked(child.position) or self._point_blocked(new_parent.position):\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._edges_remove(edges, old, child)\n        new_parent.add_child(child)\n        self._edges_add(edges, new_parent, child)\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        stack = list(child.children)\n        while stack:\n            n = stack.pop()\n            n.cost = n.parent.cost + self._dist(n.parent.position, n.position)\n            for c in n.children:\n                stack.append(c)\n\n    # Cost-optimal direct bridge: pick b in other tree minimizing cost_a(nn)+|nn-b|+cost_b(b)\n    def _best_direct_bridge(self, T_other, G_other, nn):\n        if not T_other:\n            return None, False\n        # Broad neighbor set based on connection radius\n        conn_r = self.connect_rad_scale * self.step\n        cand = self._neighbors_within(G_other, nn.position, conn_r, self.k_near * 2)\n        if not cand:\n            cand = self._k_nearest(G_other, nn.position, max(8, self.k_near // 2))\n        best = None\n        best_sum = 1e100\n        for b in cand:\n            if self._edge_free(nn.position, b.position):\n                s = nn.cost + self._dist(nn.position, b.position) + b.cost\n                if s < best_sum:\n                    best_sum = s\n                    best = b\n        return best, (best is not None)\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(3.5, self.step * 1.6)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Edge bookkeeping\n    def _edges_add(self, edges, parent, child):\n        key = (id(parent), id(child))\n        if key in self._eindex:\n            return\n        edges.append((parent, child))\n        self._eindex[key] = len(edges) - 1\n\n    def _edges_remove(self, edges, parent, child):\n        key = (id(parent), id(child))\n        idx = self._eindex.get(key)\n        if idx is None:\n            return\n        last = len(edges) - 1\n        if idx != last:\n            edges[idx] = edges[last]\n            pk, ck = id(edges[idx][0]), id(edges[idx][1])\n            self._eindex[(pk, ck)] = idx\n        edges.pop()\n        self._eindex.pop(key, None)\n\n    # Path utilities and length-focused smoothing\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                # always non-increasing by triangle inequality\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _vertex_slide(self, pts, passes):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = list(pts)\n        for _ in range(passes):\n            improved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                b = cur[i]\n                c = cur[i + 1]\n                base = self._dist(a, b) + self._dist(b, c)\n                # target along chord midpoint direction\n                target = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                t = 1.0\n                best = b\n                best_cost = base\n                while t > 1e-3:\n                    cand = tuple(b[k] + (target[k] - b[k]) * t for k in range(self.dim))\n                    cand = self._clamp(cand)\n                    if (not self._point_blocked(cand)) and self._edge_free(a, cand) and self._edge_free(cand, c):\n                        cost = self._dist(a, cand) + self._dist(cand, c)\n                        if cost + 1e-9 < best_cost:\n                            best_cost = cost\n                            best = cand\n                            break\n                    t *= 0.5\n                if best != b:\n                    cur[i] = best\n                    improved = True\n            if not improved:\n                break\n        return cur\n\n    def _finalize_path_length_opt(self, path):\n        if not path or len(path) < 2:\n            return path\n        p = self._dedup(path)\n        p = self._visibility_prune(p)\n        preL = self._path_len(p)\n        p = self._shortcut(p, self.shortcut_attempts)\n        p = self._visibility_prune(p)\n        p = self._vertex_slide(p, self.slide_passes)\n        # Ensure non-increasing length\n        if self._path_len(p) <= preL + 1e-9:\n            return self._dedup(p)\n        return self._dedup(self._visibility_prune(path))",
          "objective": -35.27699,
          "time_improvement": 58.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1281.0,
          "node_improvement": 92.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025435256958007812,
                    "num_nodes_avg": 53.0,
                    "path_length_avg": 144.69673143688058,
                    "smoothness_avg": 0.03314433575334971,
                    "success_improvement": 0.0,
                    "time_improvement": 7.782657816326337,
                    "node_improvement": 86.65323596071518,
                    "length_improvement": 20.689428633008873,
                    "smoothness_improvement": 418.7808286169965,
                    "objective_score": 16.842358667788204
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03843412399291992,
                    "num_nodes_avg": 110.0,
                    "path_length_avg": 230.44795748855236,
                    "smoothness_avg": 0.08709211817757703,
                    "success_improvement": 0.0,
                    "time_improvement": 76.77400950049635,
                    "node_improvement": 92.6090169992609,
                    "length_improvement": 23.069838713645836,
                    "smoothness_improvement": 2140.9429306262177,
                    "objective_score": 47.578820731467495
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.005914950370788574,
                    "num_nodes_avg": 36.0,
                    "path_length_avg": 129.46421361331863,
                    "smoothness_avg": 0.10881121536240616,
                    "success_improvement": 0.0,
                    "time_improvement": 88.59936170652746,
                    "node_improvement": 95.4227590591227,
                    "length_improvement": 14.016033741405511,
                    "smoothness_improvement": 1284.0706278013454,
                    "objective_score": 41.40978189580827
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "FOCUS-IBRRT*: Focused Optimal k-nearest Informed BiRRT* with volume-calibrated neighbor radius, exact prolate hyperspheroid sampling aligned to the start\u2013goal axis, direct line-of-sight strides, k-nearest least-cost parent selection, bounded benefit-ordered rewiring, and aggressive visibility-based shortcutting. It reduces path length by concentrating samples inside the informed lens once an incumbent exists, optimizing parent choice over a theoretically grounded neighbor set, and post-connection path compression.",
          "planning_mechanism": "Alternate growing the two trees. Each iteration: sample a target (goal/corridor/informed/uniform), find the nearest in a hashed grid, take a direct line-of-sight stride if possible else a bounded step, then choose the least-cost parent among a k-nearest (or radius) set derived from free-space volume and log(n)/n. Insert only after node and edge collision checks, then rewire nearby nodes if a shorter collision-free connection exists. Try to connect to the opposite tree. Maintain the best path length to focus informed sampling. On success, assemble and apply visibility pruning and multi-pass shortcuts to minimize length before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = parent\n        if parent is not None:\n            if self not in parent.children:\n                parent.children.append(self)\n\n    def path_from_root(self):\n        out = []\n        cur = self\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        out.reverse()\n        return out\nclass Planner:\n    def __init__(\n        self,\n        max_iter=7000,\n        step_size=6.0,\n        goal_bias=0.18,\n        corridor_bias=0.25,\n        informed_bias=0.55,\n        connect_factor=2.25,\n        k_factor=10.0,\n        k_cap=120,\n        rewire_cap=16,\n        dupe_radius_factor=0.25,\n        grid_cell_factor=1.1,\n        shortcut_passes=3,\n        shortcut_attempts=220\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.connect_factor = float(connect_factor)\n        self.k_factor = float(k_factor)\n        self.k_cap = int(k_cap)\n        self.rewire_cap = int(rewire_cap)\n        self.dupe_rf = float(dupe_radius_factor)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.shortcut_passes = int(shortcut_passes)\n        self.shortcut_attempts = int(shortcut_attempts)\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n        self._seed_rng()\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._build_obs_index()\n\n        if self._inside_obstacle(self.start) or self._inside_obstacle(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight line\n        if self._los(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Derived constants\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dupe_r = max(0.25, self.step * self.dupe_rf)\n        self.connect_dist = max(self.step, self.connect_factor * self.step)\n        self.axis = self._unit(self._sub(self.goal, self.start))\n        self.corridor_w = max(self.step, 0.15 * self._dist(self.start, self.goal))\n\n        # Trees and spatial hash\n        Aroot = Node(self.start, None, 0.0)\n        Broot = Node(self.goal, None, 0.0)\n        nodes = [Aroot, Broot]\n        edges = []\n        Ta, Tb = [Aroot], [Broot]\n        Ga, Gb = {}, {}\n        self._grid_put(Ga, Aroot)\n        self._grid_put(Gb, Broot)\n\n        # Free-space volume for RRT* radius\n        self.mu_free = self._free_volume()\n        self.zeta = 3.141592653589793 if self.dims == 2 else (4.0 * 3.141592653589793 / 3.0)\n        self.gamma_rrt = 2.6 * ((1.0 + 1.0 / self.dims) ** (1.0 / self.dims)) * (max(self.mu_free, 1e-9) / self.zeta) ** (1.0 / self.dims)\n\n        best_len = float('inf')\n        best_path = None\n\n        for it in range(self.max_iter):\n            grow_a = (len(Ta) <= len(Tb))  # grow smaller tree to balance\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            attractor = self.goal if grow_a else self.start\n\n            target = self._sample_target(attractor, best_len)\n            if target is None:\n                continue\n\n            near = self._nearest(G, T, target)\n            if near is None:\n                continue\n\n            new_pos = self._stride(near.position, target)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._inside_obstacle(new_pos):\n                continue\n            if self._too_close(G, new_pos, self.dupe_r):\n                continue\n\n            parent, new_cost = self._select_parent(G, T, new_pos)\n            if parent is None:\n                continue\n            # Both checks before add\n            if self._inside_obstacle(new_pos):\n                continue\n            if not self._los(parent.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, None, new_cost)\n            new_node.attach(parent)\n            T.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_put(G, new_node)\n\n            # Local bounded rewiring (benefit-ordered)\n            self._rewire(G, new_node, edges)\n\n            # Try to connect to the opposite tree\n            other = self._nearest(Gopp, Topp, new_node.position)\n            connected = False\n            end_node = None\n            if other is not None:\n                dno = self._dist(new_node.position, other.position)\n                if dno <= self.connect_dist and self._los(new_node.position, other.position):\n                    connected = True\n                    end_node = other\n                else:\n                    # Single micro-bridge step from opposite tree toward the new node\n                    step_p = self._toward(other.position, new_node.position, self.step)\n                    if self._in_bounds(step_p) and (not self._inside_obstacle(step_p)) and (not self._too_close(Gopp, step_p, self.dupe_r)) and self._los(other.position, step_p):\n                        q = Node(step_p, None, other.cost + self._dist(other.position, step_p))\n                        q.attach(other)\n                        Topp.append(q)\n                        nodes.append(q)\n                        edges.append((other, q))\n                        self._grid_put(Gopp, q)\n                        # Short connection check\n                        if self._los(new_node.position, q.position):\n                            connected = True\n                            end_node = q\n\n            if connected and end_node is not None:\n                path = self._assemble(new_node, end_node, grow_a)\n                path = self._compress(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Maintain incumbent best for informed sampling\n            if other is not None and self._los(new_node.position, other.position):\n                tmp = self._assemble(new_node, other, grow_a)\n                L = self._path_len(tmp)\n                if L < best_len:\n                    best_len = L\n                    best_path = tmp\n\n        if best_path is not None:\n            best_path = self._compress(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0\n        for v in (self.start + self.goal):\n            s = (s * 1664525 + int(997 * v + 0.5) + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        self._rng = s if s != 0 else 123456789\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _add(self, a, b):\n        return tuple(a[i] + b[i] for i in range(self.dims))\n\n    def _sub(self, a, b):\n        return tuple(a[i] - b[i] for i in range(self.dims))\n\n    def _scale(self, a, s):\n        return tuple(a[i] * s for i in range(self.dims))\n\n    def _dot(self, a, b):\n        return sum(a[i] * b[i] for i in range(self.dims))\n\n    def _norm(self, a):\n        return self._dist(a, tuple(0.0 for _ in range(self.dims)))\n\n    def _unit(self, a):\n        n = self._norm(a)\n        if n <= 1e-12:\n            return tuple(0.0 for _ in range(self.dims))\n        inv = 1.0 / n\n        return tuple(a[i] * inv for i in range(self.dims))\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    # Log approximation (for n>=1)\n    def _ln(self, x):\n        if x <= 0.0:\n            return -1e9\n        k = 0\n        while x > 2.0:\n            x *= 0.5\n            k += 1\n        # x in (0,2]\n        y = x - 1.0\n        term = y\n        s = term\n        i = 2.0\n        while abs(term) > 1e-6:\n            term *= -y * (i - 1.0) / i\n            s += term\n            i += 1.0\n            if i > 32.0:\n                break\n        # ln(x) = s + k*ln(2)\n        return s + k * 0.6931471805599453\n\n    # Obstacle index\n    def _build_obs_index(self):\n        self.obs_cell = max(3.0, self.step * 1.3)\n        self.og = {}\n        if self.dims == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.og.get(key)\n                            if b is None:\n                                self.og[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.og.get(key)\n                        if b is None:\n                            self.og[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _inside_obstacle(self, p):\n        if self.dims == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.og.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.og.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    # Segment vs obstacle intersection\n    def _los(self, a, b):\n        return not self._hit_seg(a, b)\n\n    def _hit_seg(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            seen = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        ids = self.og.get((i, j, k))\n                        if ids:\n                            for idx in ids:\n                                if idx in seen:\n                                    continue\n                                seen.add(idx)\n                                ox, oy, oz, w, h, d = self.obstacles[idx]\n                                if self._seg_box(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            seen = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    ids = self.og.get((i, j))\n                    if ids:\n                        for idx in ids:\n                            if idx in seen:\n                                continue\n                            seen.add(idx)\n                            ox, oy, w, h = self.obstacles[idx]\n                            if self._seg_box(a, b, (ox, oy), (ox + w, oy + h)):\n                                return True\n            return False\n\n    def _seg_box(self, p0, p1, bmin, bmax):\n        # Liang-Barsky slab\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Spatial hashing for nodes\n    def _key_of(self, pos):\n        return tuple(int(pos[i] // self.cell) for i in range(self.dims))\n\n    def _grid_put(self, grid, node):\n        k = self._key_of(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _ring_fetch(self, grid, key, radius):\n        out = []\n        if self.dims == 3:\n            for dx in range(-radius, radius + 1):\n                for dy in range(-radius, radius + 1):\n                    for dz in range(-radius, radius + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-radius, radius + 1):\n                for dy in range(-radius, radius + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, tree, pos):\n        key = self._key_of(pos)\n        best, bestd = None, 1e100\n        found = False\n        for r in range(0, 6):\n            cand = self._ring_fetch(grid, key, r)\n            if cand:\n                found = True\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                break\n        if not found:\n            # Random subsample fallback\n            if not tree:\n                return None\n            step = max(1, len(tree) // 32)\n            for i in range(0, len(tree), step):\n                n = tree[i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors_radius(self, grid, pos, radius, cap):\n        key = self._key_of(pos)\n        r = max(1, int(radius // self.cell) + 1)\n        cand = self._ring_fetch(grid, key, r)\n        out = []\n        rr = radius * radius\n        for n in cand:\n            d2 = 0.0\n            np = n.position\n            for i in range(self.dims):\n                dd = np[i] - pos[i]\n                d2 += dd * dd\n            if d2 <= rr:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _neighbors_k(self, grid, tree, pos, k):\n        # Gather from local rings and expand until we have >=k\n        key = self._key_of(pos)\n        picked = []\n        for r in range(0, 6):\n            cand = self._ring_fetch(grid, key, r)\n            if cand:\n                picked.extend(cand)\n            if len(picked) >= k:\n                break\n        if len(picked) < k:\n            # augment with sparse subsample\n            step = max(1, max(len(tree) // (k + 1), 1))\n            for i in range(0, len(tree), step):\n                picked.append(tree[i])\n                if len(picked) >= k:\n                    break\n        # sort by distance\n        picked = list({id(n): n for n in picked}.values())\n        picked.sort(key=lambda n: self._dist(n.position, pos))\n        return picked[:k]\n\n    def _too_close(self, grid, pos, r):\n        neigh = self._neighbors_radius(grid, pos, r, 1)\n        return len(neigh) > 0\n\n    # Parent selection\n    def _select_parent(self, grid, tree, pos):\n        n = max(1, len(tree))\n        ln = self._ln(float(n + 1))\n        # RRT* radius\n        r_rrt = (self.gamma_rrt * (ln / float(n))) ** (1.0 / self.dims) if n > 1 else self.step * 2.0\n        r_rrt = min(max(self.step, r_rrt), self.step * 6.0)\n        k = int(min(self.k_cap, max(2, int(self.k_factor * max(1.0, ln)))))\n        cand = self._neighbors_radius(grid, pos, r_rrt, self.k_cap)\n        if len(cand) < 2:\n            cand = self._neighbors_k(grid, tree, pos, k)\n        best_p = None\n        best_c = 1e100\n        for p in cand:\n            newc = p.cost + self._dist(p.position, pos)\n            if newc + 1e-9 < best_c and self._los(p.position, pos):\n                best_p = p\n                best_c = newc\n        return (best_p, best_c) if best_p is not None else (None, None)\n\n    # Rewiring\n    def _rewire(self, grid, node, edges):\n        # Use the same RRT* radius, prioritize by potential improvement\n        nset = self._neighbors_radius(grid, node.position, max(self.step * 4.0, self.step * 1.5), self.k_cap)\n        cand = []\n        for nb in nset:\n            if nb is node or nb is node.parent:\n                continue\n            # avoid cycles\n            if self._is_ancestor(nb, node):\n                continue\n            alt = node.cost + self._dist(node.position, nb.position)\n            gain = nb.cost - alt\n            if gain > 1e-9:\n                cand.append((gain, nb))\n        cand.sort(key=lambda x: -x[0])\n        changed = 0\n        for gain, nb in cand:\n            if changed >= self.rewire_cap:\n                break\n            if not self._los(node.position, nb.position):\n                continue\n            # Both checks (node already exists and valid)\n            oldp = nb.parent\n            if oldp is node:\n                continue\n            # Reparent\n            if oldp is not None:\n                try:\n                    oldp.children.remove(nb)\n                except:\n                    pass\n                self._remove_edge(edges, oldp, nb)\n            nb.attach(node)\n            edges.append((node, nb))\n            old_cost = nb.cost\n            nb.cost = node.cost + self._dist(node.position, nb.position)\n            # propagate to subtree\n            stack = [nb]\n            while stack:\n                cur = stack.pop()\n                for ch in cur.children:\n                    ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                    stack.append(ch)\n            changed += 1\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is p and e[1] is c:\n                edges.pop(i)\n                return\n\n    # Sampling\n    def _sample_target(self, attractor, best_len):\n        for _ in range(24):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._sample_informed(best_len)\n                if p is not None and not self._inside_obstacle(p):\n                    return p\n            r2 = self._rand()\n            if r2 < self.goal_bias:\n                p = attractor\n            elif r2 < self.goal_bias + self.corridor_bias:\n                p = self._sample_corridor()\n            else:\n                p = self._sample_uniform()\n            if self._in_bounds(p) and (not self._inside_obstacle(p)):\n                return p\n        return None\n\n    def _sample_uniform(self):\n        if self.dims == 3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_corridor(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n        if self.dims == 2:\n            # lateral offset perpendicular to axis\n            n = (-self.axis[1], self.axis[0])\n            off = self._scale(n, self._rand_range(-self.corridor_w, self.corridor_w))\n            p = self._add(base, off)\n        else:\n            # random combination of two orthonormal perpendiculars\n            u1, u2 = self._perp_basis(self.axis)\n            off = self._add(self._scale(u1, self._rand_range(-self.corridor_w, self.corridor_w)),\n                            self._scale(u2, self._rand_range(-self.corridor_w, self.corridor_w)))\n            p = self._add(base, off)\n        return self._clamp(p)\n\n    def _sample_informed(self, c_best):\n        cmin = self._dist(self.start, self.goal)\n        if not (c_best < float('inf')) or c_best <= cmin + 1e-9:\n            return None\n        a = 0.5 * c_best\n        l = 0.5 * cmin\n        if a <= l + 1e-12:\n            return None\n        b = (a * a - l * l) ** 0.5\n        center = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dims))\n        # sample uniformly in unit ball via rejection\n        if self.dims == 2:\n            for _ in range(32):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                if x * x + y * y <= 1.0:\n                    # scale to ellipse aligned with axis\n                    major = a * x\n                    minor = b * y\n                    n = (-self.axis[1], self.axis[0])\n                    p = self._add(center, self._add(self._scale(self.axis, major), self._scale(n, minor)))\n                    if self._in_bounds(p):\n                        return self._clamp(p)\n        else:\n            u1, u2 = self._perp_basis(self.axis)\n            for _ in range(32):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                z = self._rand_range(-1.0, 1.0)\n                if x * x + y * y + z * z <= 1.0:\n                    major = a * x\n                    minor1 = b * y\n                    minor2 = b * z\n                    p = self._add(center,\n                                  self._add(self._scale(self.axis, major),\n                                            self._add(self._scale(u1, minor1), self._scale(u2, minor2))))\n                    if self._in_bounds(p):\n                        return self._clamp(p)\n        return None\n\n    def _perp_basis(self, v):\n        # returns two orthonormal vectors perpendicular to v (3D)\n        if abs(v[0]) < 0.9:\n            tmp = (1.0, 0.0, 0.0)\n        else:\n            tmp = (0.0, 1.0, 0.0)\n        u1 = self._sub(tmp, self._scale(v, self._dot(tmp, v)))\n        n1 = self._norm(u1)\n        if n1 <= 1e-12:\n            u1 = (0.0, 0.0, 1.0)\n            n1 = 1.0\n        u1 = self._scale(u1, 1.0 / n1)\n        # cross v x u1\n        u2 = (v[1] * u1[2] - v[2] * u1[1],\n              v[2] * u1[0] - v[0] * u1[2],\n              v[0] * u1[1] - v[1] * u1[0])\n        n2 = self._norm(u2)\n        if n2 <= 1e-12:\n            u2 = (0.0, 0.0, 1.0)\n            n2 = 1.0\n        u2 = self._scale(u2, 1.0 / n2)\n        return u1, u2\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    # Stepping/steer\n    def _stride(self, a, target):\n        # If line-of-sight, go straight to target (bounded by connect range to avoid duplicates)\n        if self._los(a, target):\n            d = self._dist(a, target)\n            if d <= self.step * 4.0:\n                return self._clamp(target)\n            else:\n                return self._toward(a, target, self.step * 2.0)\n        # Otherwise bounded step\n        return self._toward(a, target, self.step)\n\n    def _toward(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        s = step if d > step else d\n        dirv = tuple((b[i] - a[i]) / d for i in range(self.dims))\n        p = tuple(a[i] + dirv[i] * s for i in range(self.dims))\n        return self._clamp(p)\n\n    # Path assembly\n    def _assemble(self, u, v, a_side):\n        pu = u.path_from_root()\n        pv = v.path_from_root()\n        if a_side:\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    # Path utilities\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _compress(self, path):\n        if len(path) <= 2:\n            return path[:]\n        # 1) Greedy visibility pruning (string pulling)\n        pts = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            extended = False\n            while j > i + 1:\n                if self._los(pts[-1], path[j]):\n                    pts.append(path[j])\n                    i = j\n                    extended = True\n                    break\n                j -= 1\n            if not extended:\n                pts.append(path[i + 1])\n                i += 1\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        # 2) Deterministic shortcut passes then randomized attempts\n        pts = self._shortcut_pass(pts)\n        for _ in range(max(0, self.shortcut_passes - 1)):\n            pts = self._shortcut_random(pts, self.shortcut_attempts)\n        return pts\n\n    def _shortcut_pass(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = list(path)\n        improved = True\n        while improved:\n            improved = False\n            i = 0\n            while i + 2 < len(pts):\n                j = i + 2\n                if self._los(pts[i], pts[j]):\n                    # if using this chord shortens length between i..j\n                    seg_old = 0.0\n                    for k in range(i + 1, j + 1):\n                        seg_old += self._dist(pts[k - 1], pts[k])\n                    seg_new = self._dist(pts[i], pts[j])\n                    if seg_new + 1e-9 < seg_old:\n                        pts = pts[:i + 1] + pts[j:]\n                        improved = True\n                        # stay at same i to try extend further\n                        continue\n                i += 1\n        return pts\n\n    def _shortcut_random(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = list(path)\n        best = self._path_len(pts)\n        n = len(pts)\n        stall = 0\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            a = pts[i]\n            b = pts[j - 1]\n            if self._los(a, b):\n                # check improvement\n                seg_old = 0.0\n                for k in range(i + 1, j):\n                    seg_old += self._dist(pts[k - 1], pts[k])\n                seg_new = self._dist(a, b)\n                if seg_new + 1e-9 < seg_old:\n                    pts = pts[:i + 1] + pts[j - 1:]\n                    n = len(pts)\n                    best = self._path_len(pts)\n                    stall = 0\n                    continue\n            stall += 1\n            if stall > 64:\n                break\n        return pts\n\n    # Volume\n    def _free_volume(self):\n        if self.dims == 2:\n            area = self.bounds[0] * self.bounds[1]\n            occ = 0.0\n            for ox, oy, w, h in self.obstacles:\n                w = max(0.0, min(w, self.bounds[0] - max(0.0, ox)))\n                h = max(0.0, min(h, self.bounds[1] - max(0.0, oy)))\n                if w > 0 and h > 0:\n                    occ += w * h\n            return max(area - occ, 1.0)\n        else:\n            vol = self.bounds[0] * self.bounds[1] * self.bounds[2]\n            occ = 0.0\n            for ox, oy, oz, w, h, d in self.obstacles:\n                w = max(0.0, min(w, self.bounds[0] - max(0.0, ox)))\n                h = max(0.0, min(h, self.bounds[1] - max(0.0, oy)))\n                d = max(0.0, min(d, self.bounds[2] - max(0.0, oz)))\n                if w > 0 and h > 0 and d > 0:\n                    occ += w * h * d\n            return max(vol - occ, 1.0)",
          "objective": -35.21019,
          "time_improvement": 63.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1597.0,
          "node_improvement": 91.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015950322151184082,
                    "num_nodes_avg": 50.0,
                    "path_length_avg": 166.92643526049486,
                    "smoothness_avg": 0.055910285668953376,
                    "success_improvement": 0.0,
                    "time_improvement": 42.170966930511455,
                    "node_improvement": 87.40871317048602,
                    "length_improvement": 8.504975715087154,
                    "smoothness_improvement": 775.1173818477029,
                    "objective_score": 21.62986241744424
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03612496852874756,
                    "num_nodes_avg": 87.0,
                    "path_length_avg": 242.7480790589756,
                    "smoothness_avg": 0.12274371886855026,
                    "success_improvement": 0.0,
                    "time_improvement": 78.16944712989631,
                    "node_improvement": 94.1544043539609,
                    "length_improvement": 18.963704094069396,
                    "smoothness_improvement": 3058.2842952149917,
                    "objective_score": 50.12047807148549
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.015928983688354492,
                    "num_nodes_avg": 69.0,
                    "path_length_avg": 129.74285308846646,
                    "smoothness_avg": 0.08321157406704471,
                    "success_improvement": 0.0,
                    "time_improvement": 69.29803801729228,
                    "node_improvement": 91.2269548633185,
                    "length_improvement": 13.830974669398307,
                    "smoothness_improvement": 958.4450800933132,
                    "objective_score": 33.88022160729324
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "AeroFuse-Connect IRRT*: A dual-informed, bidirectional RRT* with progressive connect, LRU edge-collision caching, grid-accelerated obstacle queries, adaptive step/rewire radii, k-nearest bridging, and two-phase cached shortcutting. It balances fast first-solution discovery with local rewiring and limited connect loops to improve robustness, path length, and smoothness while keeping collision checks low via spatial hashing and cache aging.",
          "planning_mechanism": "Mechanism: Alternate tree growth with a small beam of guided samples (goal-biased, then ellipse-informed after an incumbent). For each sample: steer a bounded step, validate node and edge, pick the cheapest visible parent among nearby nodes plus short ancestor lookback, insert, and locally rewire with cache-backed LOS. Attempt direct bridges to k nearest nodes of the opposite tree; if blocked, run a short progressive connect loop that inserts micro-steps toward the target. When a bridge is found, extract the path and apply randomized plus greedy cached shortcutting. Obstacle slab tests are restricted to candidates from an obstacle grid; an LRU-ish edge cache with quantization reduces repeated checks.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        child.parent = self\n        self.children.append(child)\n\n    def path_to_root(self):\n        pts = []\n        cur = self\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        base_step=8.0,\n        connect_steps=3,\n        beam_width=2,\n        goal_bias=0.22,\n        lookback_depth=5,\n        grid_cell_factor=1.4,\n        per_cell_cap=12,\n        dup_separation_factor=0.6,\n        rewire_radius_factor=2.2,\n        k_bridge=4,\n        edge_cache_capacity=50000,\n        edge_cache_quant_factor=0.5,\n        smooth_rand_attempts=90,\n        smooth_greedy_pass=1\n    ):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.connect_steps = connect_steps\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.lookback_depth = lookback_depth\n        self.grid_cell_factor = grid_cell_factor\n        self.per_cell_cap = per_cell_cap\n        self.dup_separation_factor = dup_separation_factor\n        self.rewire_radius_factor = rewire_radius_factor\n        self.k_bridge = k_bridge\n        self.edge_cache_capacity = edge_cache_capacity\n        self.edge_cache_quant_factor = edge_cache_quant_factor\n        self.smooth_rand_attempts = smooth_rand_attempts\n        self.smooth_greedy_pass = smooth_greedy_pass\n\n        # PRNG state\n        self._rnd = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        # Early identical start/goal\n        if self._dist(self.start, self.goal) <= 1e-12:\n            return PlannerResult(True, [self.start, self.goal], [], [])\n\n        # Edge cache\n        self._tick = 0\n        self._last_pruned = 0\n        self._ecache = {}\n        self._eq = max(0.25, self.base_step * self.edge_cache_quant_factor)\n\n        # Spatial hashing\n        self.cell_size = max(1.0, self.base_step * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.base_step * self.dup_separation_factor)\n\n        # Scene-based seed\n        self._seed_from_scene()\n\n        # Obstacle grid\n        self._build_obstacle_grid()\n\n        # Validate endpoints\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            path = [self.start, self.goal]\n            path = self._shortcut(path)  # cheap cleanup\n            return PlannerResult(True, path, [], [])\n\n        nodes = []\n        edges = []\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        incumbent_len = None\n\n        for it in range(self.max_iter):\n            # Alternate which tree grows first\n            if (it % 2) == 0:\n                sides = [(tree_a, grid_a, tree_b, grid_b, self.goal),\n                         (tree_b, grid_b, tree_a, grid_a, self.start)]\n            else:\n                sides = [(tree_b, grid_b, tree_a, grid_a, self.start),\n                         (tree_a, grid_a, tree_b, grid_b, self.goal)]\n\n            for active_tree, active_grid, other_tree, other_grid, attractor in sides:\n                # Adaptive step and radii\n                step = self.base_step if incumbent_len is None else max(3.0, self.base_step * 0.65)\n                rewire_r = max(step * self.rewire_radius_factor, self.cell_size * 1.2)\n                dup_sep = max(0.5, step * self.dup_separation_factor)\n\n                progressed = False\n                for _b in range(self.beam_width):\n                    q_rand = self._guided_sample(attractor, incumbent_len)\n                    if q_rand is None:\n                        continue\n\n                    nearest = self._nearest_in_grid(active_grid, q_rand, max_ring=6)\n                    if nearest is None:\n                        continue\n\n                    q_new = self._steer(nearest.position, q_rand, step)\n                    if not self._within_bounds(q_new):\n                        continue\n                    # Node collision\n                    if self._point_in_obstacles(q_new):\n                        continue\n                    # Edge collision\n                    if not self._edge_free(nearest.position, q_new):\n                        continue\n                    # Duplicate suppression\n                    if self._has_nearby(active_grid, q_new, dup_sep):\n                        continue\n\n                    # Parent selection: neighbors + short ancestor lookback\n                    parent = self._best_parent(nearest, q_new, active_grid, rewire_r, self.lookback_depth)\n                    new_cost = parent.cost + self._dist(parent.position, q_new)\n\n                    # Per-cell admission with simple gating\n                    if not self._cell_admit(active_grid, q_new, new_cost):\n                        continue\n\n                    # Insert node (after both checks already done)\n                    n_new = Node(q_new, parent, new_cost)\n                    parent.add_child(n_new)\n                    active_tree.append(n_new)\n                    nodes.append(n_new)\n                    edges.append((parent, n_new))\n                    self._grid_insert(active_grid, n_new)\n                    progressed = True\n\n                    # Local rewiring around the new node\n                    neighs = self._neighbors_in_grid(active_grid, q_new, rewire_r)\n                    self._rewire_from(n_new, neighs, edges)\n\n                    # Try bridging to k nearest nodes in the other tree\n                    join_node = None\n                    best_path = None\n                    best_len = 1e100\n\n                    others = self._nearest_k_in_grid(other_grid, q_new, k=self.k_bridge, max_ring=6)\n                    for on in others:\n                        if self._edge_free(n_new.position, on.position):\n                            path = n_new.path_to_root() + on.path_to_root()[::-1]\n                            if len(path) >= 2 and self._dist(path[-1], path[-2]) <= 1e-12:\n                                path.pop()\n                            sm = self._shortcut(path)\n                            L = self._path_len(sm)\n                            if L < best_len:\n                                best_len = L\n                                best_path = sm\n                                join_node = n_new\n                                break  # direct bridge found\n\n                        # Progressive connect if direct bridge blocked\n                        if join_node is None and self.connect_steps > 0:\n                            meet = self._progress_connect(n_new, on.position, active_tree, active_grid, step, dup_sep, rewire_r, nodes, edges)\n                            if meet is not None:\n                                path = meet.path_to_root() + on.path_to_root()[::-1]\n                                if len(path) >= 2 and self._dist(path[-1], path[-2]) <= 1e-12:\n                                    path.pop()\n                                sm = self._shortcut(path)\n                                L = self._path_len(sm)\n                                if L < best_len:\n                                    best_len = L\n                                    best_path = sm\n                                    join_node = meet\n                                    break\n\n                    if best_path is not None:\n                        incumbent_len = best_len\n                        return PlannerResult(True, best_path, nodes, edges)\n\n                if not progressed:\n                    continue\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # ---------- PRNG ----------\n    def _seed_from_scene(self):\n        s = 146959810  # FNV-ish\n        for v in self.start + self.goal:\n            s ^= (int(v * 997 + 0.5) & 0xffffffff)\n            s = (s * 16777619) & 0x7fffffff\n        s ^= (len(self.obstacles) * 374761393) & 0x7fffffff\n        if s == 0:\n            s = 123456789\n        self._rnd = s\n\n    def _rand(self):\n        # LCG\n        self._rnd = (1103515245 * self._rnd + 12345) & 0x7fffffff\n        return self._rnd / 2147483647.0\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= step:\n            return tuple(b)\n        r = step / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, attractor, incumbent_len):\n        # Pre-solution: mild goal bias; Post-solution: ellipse corridor\n        for _ in range(24):\n            if incumbent_len is not None and self._dist(self.start, self.goal) > 1e-9:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                if self._rand() < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            if self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum_dist\n        ext = [half] * self.dims\n        for _ in range(18):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._within_bounds(p) or self._point_in_obstacles(p):\n                continue\n            if self._dist(p, f1) + self._dist(p, f2) <= max_sum_dist:\n                return p\n        return None\n\n    # ---------- Node grid ----------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (\n                int(pos[0] // self.cell_size),\n                int(pos[1] // self.cell_size),\n                int(pos[2] // self.cell_size),\n            )\n        else:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _nearest_in_grid(self, grid, pos, max_ring=6):\n        cell = self._cell_of(pos)\n        best = None\n        best_d = 1e100\n        if self.is_3d:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if not bucket:\n                                continue\n                            for n in bucket:\n                                d = self._dist(n.position, pos)\n                                if d < best_d:\n                                    best_d = d\n                                    best = n\n                                    found = True\n                if found:\n                    return best\n        else:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if not bucket:\n                            continue\n                        for n in bucket:\n                            d = self._dist(n.position, pos)\n                            if d < best_d:\n                                best_d = d\n                                best = n\n                                found = True\n                if found:\n                    return best\n        # Fallback: scan all buckets\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._dist(n.position, pos)\n                if d < best_d:\n                    best_d = d\n                    best = n\n        return best\n\n    def _nearest_k_in_grid(self, grid, pos, k=3, max_ring=6):\n        cell = self._cell_of(pos)\n        cand = []\n        seen = set()\n        if self.is_3d:\n            for ring in range(0, max_ring + 1):\n                any_found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            key = (cell[0] + dx, cell[1] + dy, cell[2] + dz)\n                            if key in seen:\n                                continue\n                            seen.add(key)\n                            bucket = grid.get(key)\n                            if bucket:\n                                any_found = True\n                                for n in bucket:\n                                    cand.append((self._dist(n.position, pos), n))\n                if any_found and len(cand) >= k:\n                    break\n        else:\n            for ring in range(0, max_ring + 1):\n                any_found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        key = (cell[0] + dx, cell[1] + dy)\n                        if key in seen:\n                            continue\n                        seen.add(key)\n                        bucket = grid.get(key)\n                        if bucket:\n                            any_found = True\n                            for n in bucket:\n                                cand.append((self._dist(n.position, pos), n))\n                if any_found and len(cand) >= k:\n                    break\n        if not cand:\n            for bucket in grid.values():\n                for n in bucket:\n                    cand.append((self._dist(n.position, pos), n))\n        cand.sort(key=lambda x: x[0])\n        return [n for _, n in cand[:k]]\n\n    def _neighbors_in_grid(self, grid, pos, radius):\n        out = []\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if not bucket:\n                            continue\n                        for n in bucket:\n                            if self._dist(n.position, pos) <= radius:\n                                out.append(n)\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if not bucket:\n                        continue\n                    for n in bucket:\n                        if self._dist(n.position, pos) <= radius:\n                            out.append(n)\n        return out\n\n    def _has_nearby(self, grid, pos, radius):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if not bucket:\n                            continue\n                        for n in bucket:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if not bucket:\n                        continue\n                    for n in bucket:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    def _cell_admit(self, grid, pos, cand_cost):\n        key = self._cell_of(pos)\n        bucket = grid.get(key)\n        if not bucket or len(bucket) < self.per_cell_cap:\n            return True\n        # Simple cost gate vs best in cell\n        best_cost = 1e100\n        for n in bucket:\n            if n.cost < best_cost:\n                best_cost = n.cost\n        return cand_cost + 1e-9 < best_cost\n\n    # ---------- Obstacle grid and collision ----------\n    def _build_obstacle_grid(self):\n        self._obs_cell = max(4.0, self.base_step * 1.5)\n        self._obs_grid = {}\n        self._obs_is_3d = self.is_3d\n        if self._obs_is_3d:\n            for idx, ob in enumerate(self.obstacles):\n                x, y, z, w, h, d = ob\n                cx0 = int(max(0.0, x) // self._obs_cell)\n                cy0 = int(max(0.0, y) // self._obs_cell)\n                cz0 = int(max(0.0, z) // self._obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self._obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self._obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self._obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            key = (cx, cy, cz)\n                            if key in self._obs_grid:\n                                self._obs_grid[key].append(idx)\n                            else:\n                                self._obs_grid[key] = [idx]\n        else:\n            for idx, ob in enumerate(self.obstacles):\n                x, y, w, h = ob\n                cx0 = int(max(0.0, x) // self._obs_cell)\n                cy0 = int(max(0.0, y) // self._obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self._obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self._obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        key = (cx, cy)\n                        if key in self._obs_grid:\n                            self._obs_grid[key].append(idx)\n                        else:\n                            self._obs_grid[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self._obs_is_3d:\n            cx = int(p[0] // self._obs_cell)\n            cy = int(p[1] // self._obs_cell)\n            cz = int(p[2] // self._obs_cell)\n            bucket = self._obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self._obs_cell)\n            cy = int(p[1] // self._obs_cell)\n            bucket = self._obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self._eq) for i in range(self.dims))\n        qb = tuple(int(b[i] / self._eq) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self._ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self._ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self._ecache[key] = (free, self._tick)\n        if len(self._ecache) - self._last_pruned > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self._ecache:\n            return\n        # Age-based prune: drop entries older than (tick - window), else drop every 3rd\n        window = 2500\n        cutoff = self._tick - window\n        to_del = []\n        for k, v in self._ecache.items():\n            if v[1] < cutoff:\n                to_del.append(k)\n        if not to_del:\n            i = 0\n            for k in list(self._ecache.keys()):\n                if (i % 3) == 0:\n                    to_del.append(k)\n                i += 1\n        for k in to_del:\n            if k in self._ecache:\n                del self._ecache[k]\n        self._last_pruned = len(self._ecache)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self._obs_is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self._obs_cell)\n            cy0 = int(max(0.0, miny) // self._obs_cell)\n            cz0 = int(max(0.0, minz) // self._obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self._obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self._obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self._obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bucket = self._obs_grid.get((cx, cy, cz))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self._obs_cell)\n            cy0 = int(max(0.0, miny) // self._obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self._obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self._obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bucket = self._obs_grid.get((cx, cy))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # ---------- Parent selection and rewiring ----------\n    def _best_parent(self, nearest, q_new, grid, neighbor_radius, lookback):\n        best = nearest\n        best_cost = nearest.cost + self._dist(nearest.position, q_new)\n        # Nearby nodes\n        neighs = self._neighbors_in_grid(grid, q_new, neighbor_radius)\n        for nb in neighs:\n            if self._edge_free(nb.position, q_new):\n                c = nb.cost + self._dist(nb.position, q_new)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best = nb\n        # Short ancestor lookback\n        cur = nearest\n        depth = 0\n        while cur is not None and depth < lookback:\n            if self._edge_free(cur.position, q_new):\n                c = cur.cost + self._dist(cur.position, q_new)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best = cur\n            cur = cur.parent\n            depth += 1\n        return best\n\n    def _rewire_from(self, pivot, neighbors, edges):\n        for nb in neighbors:\n            if nb is pivot or nb.parent is None:\n                continue\n            new_cost = pivot.cost + self._dist(pivot.position, nb.position)\n            if new_cost + 1e-12 < nb.cost and self._edge_free(pivot.position, nb.position):\n                old_parent = nb.parent\n                # Update edges coherence\n                try:\n                    edges.remove((old_parent, nb))\n                except ValueError:\n                    pass\n                if nb in old_parent.children:\n                    old_parent.children.remove(nb)\n                pivot.add_child(nb)\n                delta = new_cost - nb.cost\n                nb.cost = new_cost\n                edges.append((pivot, nb))\n                if abs(delta) > 0.0:\n                    self._propagate_cost(nb, delta)\n\n    def _propagate_cost(self, node, delta):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    # ---------- Progressive connect ----------\n    def _progress_connect(self, from_node, target_pos, active_tree, active_grid, step, dup_sep, rewire_r, nodes, edges):\n        current = from_node\n        for _ in range(self.connect_steps):\n            nxt = self._steer(current.position, target_pos, step)\n            if not self._within_bounds(nxt):\n                return None\n            if self._point_in_obstacles(nxt):\n                return None\n            if not self._edge_free(current.position, nxt):\n                return None\n            if self._has_nearby(active_grid, nxt, dup_sep):\n                return None\n            # Choose parent with quick lookback only (for speed)\n            parent = self._best_parent(current, nxt, active_grid, 0.0, min(2, self.lookback_depth))\n            new_cost = parent.cost + self._dist(parent.position, nxt)\n            if not self._cell_admit(active_grid, nxt, new_cost):\n                return None\n            nn = Node(nxt, parent, new_cost)\n            parent.add_child(nn)\n            active_tree.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_insert(active_grid, nn)\n            # Limited local rewire\n            if rewire_r > 0.0:\n                neighs = self._neighbors_in_grid(active_grid, nxt, rewire_r)\n                self._rewire_from(nn, neighs, edges)\n            current = nn\n            # Early success if LOS to target is free\n            if self._edge_free(current.position, target_pos):\n                return current\n        return None\n\n    # ---------- Smoothing ----------\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        # Random pair contractions using cached LOS\n        for _ in range(self.smooth_rand_attempts):\n            if len(pts) < 3:\n                break\n            i = int(self._rand_range(0, len(pts) - 2))\n            j = int(self._rand_range(i + 2, len(pts)))\n            if self._edge_free(pts[i], pts[j]):\n                del pts[i + 1:j]\n        # Greedy forward pass\n        for _pass in range(self.smooth_greedy_pass):\n            i = 0\n            while i < len(pts) - 2:\n                j = len(pts) - 1\n                improved = False\n                while j > i + 1:\n                    if self._edge_free(pts[i], pts[j]):\n                        del pts[i + 1:j]\n                        improved = True\n                        break\n                    j -= 1\n                if not improved:\n                    i += 1\n        return pts",
          "objective": -34.88191,
          "time_improvement": 58.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1698.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021793293952941894,
                    "num_nodes_avg": 70.0,
                    "path_length_avg": 169.2890388576565,
                    "smoothness_avg": 0.05355523016360862,
                    "success_improvement": 0.0,
                    "time_improvement": 20.98685501444851,
                    "node_improvement": 82.37219843868043,
                    "length_improvement": 7.209995245633105,
                    "smoothness_improvement": 738.2556491041739,
                    "objective_score": 14.313331897235285
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.021245622634887697,
                    "num_nodes_avg": 98.0,
                    "path_length_avg": 242.53571379984956,
                    "smoothness_avg": 0.12285372075383123,
                    "success_improvement": 0.0,
                    "time_improvement": 87.16113239461782,
                    "node_improvement": 93.41530605388698,
                    "length_improvement": 19.034597730160733,
                    "smoothness_improvement": 3061.1147229544267,
                    "objective_score": 52.874671971253925
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017209863662719725,
                    "num_nodes_avg": 115.0,
                    "path_length_avg": 123.12829693538227,
                    "smoothness_avg": 0.10966311568419326,
                    "success_improvement": 0.0,
                    "time_improvement": 66.82923466820458,
                    "node_improvement": 85.37825810553083,
                    "length_improvement": 18.224047914960124,
                    "smoothness_improvement": 1294.9067370137366,
                    "objective_score": 37.45773283450613
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "SwiftStar-Connect BiRRT*: A bidirectional, connect-style RRT with light RRT* rewiring, ellipse-informed sampling, LRU edge-collision caching, and grid-accelerated near/nearest queries. It prioritizes cheap parents and limited-cost rewiring to shorten paths early, attempts minimal-cost bridges across trees, and finalizes with fast LOS compression and cache-reusing shortcutting for smooth, short solutions with low planning time.",
          "planning_mechanism": "Mechanism: Alternate tree growth with adaptive sampling (goal/line and ellipse after an incumbent). Each extension performs bounded connect steps; at every accepted step, select the best visible parent among near neighbors, insert only if node and edge are collision-free, and rewire cheaper neighbors through the new node. After each insertion, attempt a k-near, minimal total-cost bridge to the opposite tree using cached edge checks. Upon success, extract the path, apply LOS compression and randomized shortcutting (using the same cache), and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 connect_steps=3,\n                 goal_bias=0.22,\n                 line_bias=0.28,\n                 rewire_radius_factor=2.5,\n                 connect_radius_factor=3.0,\n                 k_bridge=8,\n                 min_separation_factor=0.6,\n                 grid_cell_factor=1.4,\n                 edge_cache_capacity=45000,\n                 edge_cache_quant_factor=0.65,\n                 shortcut_iters=140,\n                 no_improve_stall=14):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.connect_steps = max(1, int(connect_steps))\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.rewire_radius_factor = rewire_radius_factor\n        self.connect_radius_factor = connect_radius_factor\n        self.k_bridge = k_bridge\n        self.min_sep_factor = min_separation_factor\n        self.grid_cell_factor = grid_cell_factor\n        self.edge_cache_capacity = edge_cache_capacity\n        self.edge_cache_quant_factor = edge_cache_quant_factor\n        self.shortcut_iters = shortcut_iters\n        self.no_improve_stall = no_improve_stall\n\n        # PRNG\n        self._rng = 123456789\n\n    # -------------- Public API --------------\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obs_raw = list(map.obstacles) if map.obstacles else []\n\n        # Basic checks\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_from_scene()\n        self._build_obstacle_index()\n\n        if self._pt_collides(self.start) or self._pt_collides(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        self._init_edge_cache()\n        if self._edge_ok(self.start, self.goal):\n            s = Node(self.start, None, 0.0)\n            g = Node(self.goal, s, self._dist(self.start, self.goal))\n            s.children.append(g)\n            nodes = [s, g]\n            edges = [(s, g)]\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Parameters\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step_size * self.min_sep_factor)\n        self.rewire_radius = max(self.step_size, self.rewire_radius_factor * self.step_size)\n        self.connect_radius = max(self.step_size, self.connect_radius_factor * self.step_size)\n\n        # Trees\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n\n        tree_s = [start_root]\n        tree_g = [goal_root]\n        edges = []\n        all_nodes = [start_root, goal_root]\n\n        grid_s = {}\n        grid_g = {}\n        self._grid_add(grid_s, start_root)\n        self._grid_add(grid_g, goal_root)\n\n        best_len = float('inf')\n        best_path = None\n        fails_s = 0\n        fails_g = 0\n\n        for it in range(self.max_iter):\n            # Choose active tree (alternate, but flip if the last choice stalled)\n            active_is_start = (it % 2 == 0)\n            if active_is_start and fails_s > 3 and fails_g < fails_s:\n                active_is_start = False\n            if (not active_is_start) and fails_g > 3 and fails_s < fails_g:\n                active_is_start = True\n\n            A_tree = tree_s if active_is_start else tree_g\n            B_tree = tree_g if active_is_start else tree_s\n            A_grid = grid_s if active_is_start else grid_g\n            B_grid = grid_g if active_is_start else grid_s\n            root_other = self.goal if active_is_start else self.start\n            root_self = self.start if active_is_start else self.goal\n\n            # Sample\n            target = self._sample(root_other, best_len)\n            if target is None:\n                if active_is_start:\n                    fails_s += 1\n                else:\n                    fails_g += 1\n                continue\n\n            # Nearest and bounded connect\n            nnear = self._nearest(A_grid, A_tree, target)\n            if nnear is None:\n                if active_is_start:\n                    fails_s += 1\n                else:\n                    fails_g += 1\n                continue\n\n            last = nnear\n            progressed = False\n            for step_id in range(self.connect_steps):\n                new_pos = self._steer(last.position, target)\n                if not self._in_bounds(new_pos):\n                    break\n                # Node collision\n                if self._pt_collides(new_pos):\n                    break\n\n                # Candidate parent: choose best visible among near neighbors (RRT* light)\n                neigh = self._near(A_grid, new_pos, self.rewire_radius)\n                if last not in neigh:\n                    neigh.append(last)\n                best_parent = None\n                best_cost = float('inf')\n                for cand in neigh:\n                    if not self._edge_ok(cand.position, new_pos):\n                        continue\n                    trial = cand.cost + self._dist(cand.position, new_pos)\n                    if trial < best_cost:\n                        best_cost = trial\n                        best_parent = cand\n                if best_parent is None:\n                    # cannot link this step\n                    break\n\n                # Duplicate suppression: keep alternatives that can improve cost locally\n                if self._has_close_better(A_grid, new_pos, best_cost, self.min_sep):\n                    break\n\n                # Edge collision check (parent->new) already passed via _edge_ok\n                new_node = Node(new_pos, best_parent, best_cost)\n                best_parent.children.append(new_node)\n                A_tree.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                self._grid_add(A_grid, new_node)\n                progressed = True\n\n                # Local rewiring: improve nearby neighbors if cheaper through new_node\n                self._rewire(A_grid, A_tree, new_node, neigh, edges)\n\n                last = new_node\n\n                # Try bridging to the other tree (k-near, minimal total cost)\n                bridge = self._best_bridge(B_grid, B_tree, new_node, self.connect_radius)\n                if bridge is not None and self._edge_ok(new_node.position, bridge.position):\n                    # Build path\n                    if active_is_start:\n                        meet_a = new_node\n                        meet_b = bridge\n                    else:\n                        meet_a = bridge\n                        meet_b = new_node\n                    raw_path = self._path_to_root(meet_a) + self._path_to_root(meet_b)[::-1]\n                    # Deduplicate meet point if repeated\n                    if len(raw_path) >= 2 and self._dist(raw_path[-1], raw_path[-2]) <= 1e-12:\n                        raw_path.pop()\n                    # Smooth\n                    path = self._compress_path(raw_path)\n                    path = self._shortcut(path)\n                    plen = self._path_len(path)\n                    if plen < best_len:\n                        best_len = plen\n                        best_path = path\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n                # Stop connect if reached target\n                if self._dist(new_pos, target) <= 1e-9:\n                    break\n\n            if not progressed:\n                if active_is_start:\n                    fails_s += 1\n                else:\n                    fails_g += 1\n            else:\n                if active_is_start:\n                    fails_s = 0\n                else:\n                    fails_g = 0\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, all_nodes, edges)\n        return PlannerResult(False, [], all_nodes, edges)\n\n    # -------------- PRNG --------------\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0x7fffffff\n        s ^= len(self.obs_raw) * 1103515245\n        self._rng = (s ^ 0x9E3779B9) & 0x7fffffff\n        if self._rng == 0:\n            self._rng = 123456789\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xFFFFFFFF\n        return (self._rng / 4294967295.0)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # -------------- Geometry --------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5 if s > 0.0 else 0.0\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(min(max(a[i], 0.0), self.bounds[i]) for i in range(self.dim))\n        if d <= self.step_size:\n            return tuple(min(max(b[i], 0.0), self.bounds[i]) for i in range(self.dim))\n        r = self.step_size / d\n        return tuple(min(max(a[i] + (b[i] - a[i]) * r, 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _path_to_root(self, node):\n        seq = []\n        cur = node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        return seq[::-1]\n\n    def _path_len(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    # -------------- Sampling --------------\n    def _sample(self, attractor, incumbent_len):\n        # Informed ellipse after incumbent, else blend goal/line/uniform\n        for _ in range(20):\n            if incumbent_len < float('inf') and self._dist(self.start, self.goal) > 1e-9:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.02)\n                if p is not None and self._in_bounds(p) and not self._pt_collides(p):\n                    return p\n            else:\n                r = self._rand()\n                if r < self.goal_bias:\n                    p = attractor\n                else:\n                    if self._rand() < self.line_bias:\n                        t = self._rand()\n                        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n                        jit = 0.5 * self.step_size\n                        p = tuple(min(max(base[i] + self._rand_range(-jit, jit), 0.0), self.bounds[i]) for i in range(self.dim))\n                    else:\n                        p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._in_bounds(p) and not self._pt_collides(p):\n                    return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum_dist\n        if half <= 0.0:\n            return None\n        tries = 20\n        while tries > 0:\n            tries -= 1\n            p = tuple(c[i] + self._rand_range(-half, half) for i in range(self.dim))\n            if not self._in_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum_dist and not self._pt_collides(p):\n                return p\n        return None\n\n    # -------------- Node grid --------------\n    def _cell(self, pos, cell=None):\n        cs = self.cell_size if cell is None else cell\n        return tuple(int(pos[i] // cs) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._cell(node.position)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _gather(self, grid, center, radius):\n        rng = int(radius // self.cell_size) + 1\n        key = self._cell(center)\n        out = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        return out\n\n    def _nearest(self, grid, nodes, pos, max_ring=4):\n        # ring-expansion search, fallback linear scan\n        best = None\n        bestd = float('inf')\n        c = self._cell(pos)\n        for ring in range(0, max_ring + 1):\n            found = False\n            if self.dim == 2:\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        b = grid.get((c[0] + dx, c[1] + dy))\n                        if not b:\n                            continue\n                        for n in b:\n                            d = self._dist(n.position, pos)\n                            if d < bestd:\n                                bestd = d\n                                best = n\n                                found = True\n            else:\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            b = grid.get((c[0] + dx, c[1] + dy, c[2] + dz))\n                            if not b:\n                                continue\n                            for n in b:\n                                d = self._dist(n.position, pos)\n                                if d < bestd:\n                                    bestd = d\n                                    best = n\n                                    found = True\n            if found:\n                return best\n        # fallback\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius):\n        cand = self._gather(grid, pos, radius)\n        out = []\n        r = radius\n        for n in cand:\n            if self._dist(n.position, pos) <= r:\n                out.append(n)\n        return out\n\n    def _has_close_better(self, grid, pos, cost, radius):\n        cand = self._gather(grid, pos, radius)\n        for n in cand:\n            if self._dist(n.position, pos) <= radius and n.cost <= cost + 1e-12:\n                return True\n        return False\n\n    # -------------- Rewiring --------------\n    def _rewire(self, grid, tree, new_node, neigh, edges):\n        # Recompute costs of neighbors via new_node if cheaper and edge-free\n        for nb in neigh:\n            if nb is new_node:\n                continue\n            # Ensure edge-free and obey triangle inequality\n            if not self._edge_ok(new_node.position, nb.position):\n                continue\n            alt = new_node.cost + self._dist(new_node.position, nb.position)\n            if alt + 1e-12 < nb.cost:\n                old_parent = nb.parent\n                nb.attach(new_node)\n                nb.cost = alt\n                # Update edges list (avoid duplicates)\n                if old_parent is not None:\n                    try:\n                        idx = None\n                        for i in range(len(edges) - 1, -1, -1):\n                            if edges[i][0] is old_parent and edges[i][1] is nb:\n                                idx = i\n                                break\n                        if idx is not None:\n                            edges.pop(idx)\n                    except:\n                        pass\n                edges.append((new_node, nb))\n                # Propagate cost changes to descendants (lazy: single-pass BFS)\n                stack = list(nb.children)\n                while stack:\n                    ch = stack.pop()\n                    p = ch.parent\n                    if p is None:\n                        continue\n                    newc = p.cost + self._dist(p.position, ch.position)\n                    if newc + 1e-12 < ch.cost:\n                        ch.cost = newc\n                        stack.extend(ch.children)\n\n    # -------------- Bridging --------------\n    def _best_bridge(self, grid_b, tree_b, new_node, radius):\n        near = self._near(grid_b, new_node.position, radius)\n        if not near:\n            nn = self._nearest(grid_b, tree_b, new_node.position)\n            if nn is not None:\n                near = [nn]\n        # choose up to k closest\n        if len(near) > self.k_bridge:\n            tmp = [(self._dist(n.position, new_node.position), n) for n in near]\n            tmp.sort(key=lambda t: t[0])\n            near = [t[1] for t in tmp[:self.k_bridge]]\n        best = None\n        best_total = float('inf')\n        for nb in near:\n            if not self._edge_ok(new_node.position, nb.position):\n                continue\n            total = new_node.cost + self._dist(new_node.position, nb.position) + nb.cost\n            if total < best_total:\n                best_total = total\n                best = nb\n        return best\n\n    # -------------- Obstacles and collision --------------\n    def _build_obstacle_index(self):\n        # Spatial index for obstacles\n        self.obs_cell = max(4.0, 1.8 * self.step_size)\n        self._obs_grid = {}\n        if self.is3:\n            for idx, o in enumerate(self.obs_raw):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            if k in self._obs_grid:\n                                self._obs_grid[k].append(idx)\n                            else:\n                                self._obs_grid[k] = [idx]\n        else:\n            for idx, o in enumerate(self.obs_raw):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        if k in self._obs_grid:\n                            self._obs_grid[k].append(idx)\n                        else:\n                            self._obs_grid[k] = [idx]\n\n    def _pt_collides(self, p):\n        if self.is3:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self._obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obs_raw[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self._obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obs_raw[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_ok(self, a, b):\n        # Edge collision with LRU cache\n        key = self._edge_key(a, b)\n        hit = self._edge_cache.get(key)\n        if hit is not None:\n            self._edge_tick += 1\n            self._edge_cache[key] = (hit[0], self._edge_tick)\n            return hit[0]\n        free = not self._segment_hits(a, b)\n        self._edge_tick += 1\n        self._edge_cache[key] = (free, self._edge_tick)\n        if len(self._edge_cache) > self.edge_cache_capacity:\n            self._prune_edge_cache()\n        return free\n\n    def _segment_hits(self, a, b):\n        # Collect candidate obstacles overlapping the segment AABB\n        if self.is3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = []\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self._obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            cand.extend(bkt)\n            if not cand:\n                return False\n            # Unique indices (small)\n            seen = {}\n            for idx in cand:\n                seen[idx] = 1\n            for idx in seen.keys():\n                x, y, z, w, h, d = self.obs_raw[idx]\n                if self._seg_aabb_intersect(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = []\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self._obs_grid.get((cx, cy))\n                    if bkt:\n                        cand.extend(bkt)\n            if not cand:\n                return False\n            seen = {}\n            for idx in cand:\n                seen[idx] = 1\n            for idx in seen.keys():\n                x, y, w, h = self.obs_raw[idx]\n                if self._seg_aabb_intersect(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect(self, p0, p1, bmin, bmax):\n        # Slab method for 2D/3D\n        tmin = 0.0\n        tmax = 1.0\n        n = self.dim\n        for i in range(n):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # -------------- Edge cache (LRU-ish) --------------\n    def _init_edge_cache(self):\n        self._edge_cache = {}\n        self._edge_tick = 0\n        self._edge_quant = max(0.25, self.step_size * self.edge_cache_quant_factor)\n\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self._edge_quant) for i in range(self.dim))\n        qb = tuple(int(b[i] / self._edge_quant) for i in range(self.dim))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _prune_edge_cache(self):\n        if not self._edge_cache:\n            return\n        # Remove oldest ~35%\n        cutoff = self._edge_tick - 3000\n        keys = []\n        for k, v in self._edge_cache.items():\n            if v[1] < cutoff:\n                keys.append(k)\n        if not keys:\n            # fallback: drop every 3rd entry\n            cnt = 0\n            for k in list(self._edge_cache.keys()):\n                if (cnt % 3) == 0:\n                    keys.append(k)\n                cnt += 1\n        for k in keys:\n            if k in self._edge_cache:\n                del self._edge_cache[k]\n\n    # -------------- Path smoothing --------------\n    def _compress_path(self, path):\n        if not path or len(path) < 3:\n            return path[:]\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            # Greedy farthest visible\n            while j > i + 1:\n                if self._edge_ok(path[i], path[j]):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcut(self, path):\n        if not path or len(path) < 3:\n            return path[:]\n        pts = list(path)\n        n = len(pts)\n        attempts = 0\n        noimp = 0\n        while attempts < self.shortcut_iters and n >= 3:\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 1, n - 1))\n            if j <= i + 1:\n                attempts += 1\n                continue\n            if self._edge_ok(pts[i], pts[j]):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n                noimp = 0\n            else:\n                noimp += 1\n            attempts += 1\n            if noimp >= self.no_improve_stall:\n                break\n        return pts",
          "objective": -34.66909,
          "time_improvement": 60.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1491.0,
          "node_improvement": 83.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010434675216674804,
                    "num_nodes_avg": 57.0,
                    "path_length_avg": 165.61516807722336,
                    "smoothness_avg": 0.04286445670685625,
                    "success_improvement": 0.0,
                    "time_improvement": 58.51710168884272,
                    "node_improvement": 85.64593301435407,
                    "length_improvement": 9.223702036596448,
                    "smoothness_improvement": 570.9218291198628,
                    "objective_score": 25.94396087421
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.061072278022766116,
                    "num_nodes_avg": 247.0,
                    "path_length_avg": 231.2357958382865,
                    "smoothness_avg": 0.11753231792206476,
                    "success_improvement": 0.0,
                    "time_improvement": 61.880020947292024,
                    "node_improvement": 83.40388362561312,
                    "length_improvement": 22.806835595835025,
                    "smoothness_improvement": 2924.1911952415403,
                    "objective_score": 46.86906361789632
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.020351886749267578,
                    "num_nodes_avg": 155.0,
                    "path_length_avg": 128.29218025571564,
                    "smoothness_avg": 0.08468563755750409,
                    "success_improvement": 0.0,
                    "time_improvement": 58.10536234871463,
                    "node_improvement": 80.29243483788939,
                    "length_improvement": 14.794442491294339,
                    "smoothness_improvement": 977.1950588879074,
                    "objective_score": 31.194249493830526
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "QUICKSTAR-IBiRRT: Quantized-Cache Informed Best-First BiRRT with selective R*-parenting and elastic-corner smoothing. It grows two best-first guided RRT trees that use an informed heuristic after the first solution, quantized endpoint edge-caching with slab-intersection for fast collision tests, a lightweight R*-style parent selection for shorter/smoother edges, duplicate suppression via hashed grids, and a three-stage smoother (visibility prune, elastic shortcuts, corner rounding) for low-jerk, short paths.",
          "planning_mechanism": "Alternate expanding start/goal trees; sample by goal bias then informed ellipse/corridor after an incumbent, else uniform. For each sample: find a near node by grid-hash rings; try a long steer then fallback; if valid, choose a parent among nearby nodes by cost plus curvature tie-break and insert. Greedily attempt to connect the opposite tree; on success extract the path and smooth (visibility prune, random shortcuts, corner rounding). Collision checks (node and edge) are done before every insertion and bridge; edge tests use a quantized cache and slab method.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = set()\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None and self in self.parent.children:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.add(self)\n\n    def path_to_root(self):\n        out = []\n        cur = self\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        out.reverse()\n        return out\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3200,\n        step_size=5.5,\n        goal_bias=0.16,\n        neighbor_gamma=2.3,\n        neighbor_k_max=18,\n        connect_steps=3,\n        grid_cell_factor=1.6,\n        min_sep_factor=0.5,\n        heur_gate_init=1.35,\n        heur_gate_final=1.10,\n        shortcut_trials=90,\n        round_passes=2\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.neighbor_gamma = neighbor_gamma\n        self.neighbor_k_max = neighbor_k_max\n        self.connect_steps = connect_steps\n        self.grid_cell_factor = grid_cell_factor\n        self.min_sep_factor = min_sep_factor\n        self.heur_gate_init = heur_gate_init\n        self.heur_gate_final = heur_gate_final\n        self.shortcut_trials = shortcut_trials\n        self.round_passes = round_passes\n\n        self.dim = 2\n        self.bounds = None\n        self.cell = 1.0\n        self.min_sep = 1.0\n        self._edge_cache = {}\n        self._cache_quant = 0.5\n        self._seed = 987654321\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Initialize spatial/grid/caching parameters\n        self.cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step_size * self.min_sep_factor)\n        self._cache_quant = max(0.25, self.step_size * 0.2)\n        self._edge_cache = {}\n        self._seed = 987654321\n\n        # Basic validations\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._pt_in_obs(start, obstacles, is_3d) or self._pt_in_obs(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.add(g)\n            nodes = [s, g]\n            edges = [(s, g)]\n            return PlannerResult(True, [start, goal], nodes, edges)\n\n        # Initialize bidirectional trees\n        a_root = Node(start, None, 0.0)\n        b_root = Node(goal, None, 0.0)\n        tree_a = [a_root]\n        tree_b = [b_root]\n        all_nodes = [a_root, b_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_add(grid_a, a_root)\n        self._grid_add(grid_b, b_root)\n\n        best_path = None\n        c_best = float('inf')\n        informed = False\n\n        for it in range(self.max_iter):\n            from_start = (it % 2 == 0)\n            if from_start:\n                tree_x, tree_y = tree_a, tree_b\n                grid_x, grid_y = grid_a, grid_b\n                root_x, root_y = a_root, b_root\n                attractor = goal\n            else:\n                tree_x, tree_y = tree_b, tree_a\n                grid_x, grid_y = grid_b, grid_a\n                root_x, root_y = b_root, a_root\n                attractor = start\n\n            # Sample: goal bias, then informed set (ellipse/corridor), else uniform\n            r = self._rand()\n            if r < self.goal_bias:\n                x_rand = attractor\n            else:\n                if informed and self._rand() < 0.6:\n                    x_rand = self._ellipse_or_corridor_sample(root_x.position, root_y.position, c_best)\n                else:\n                    x_rand = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n            # Find approximate nearest\n            n_near = self._nearest_hashed(grid_x, tree_x, x_rand)\n            if n_near is None:\n                continue\n\n            # Try long steer then fallback\n            x_new_pos = None\n            for mult in (2.4, 1.6, 1.0):\n                target = self._steer(n_near.position, x_rand, mult * self.step_size)\n                if not self._in_bounds(target):\n                    continue\n                if self._pt_in_obs(target, obstacles, is_3d):\n                    continue\n                if self._edge_blocked(n_near.position, target, obstacles, is_3d):\n                    continue\n                x_new_pos = target\n                break\n            if x_new_pos is None:\n                continue\n\n            # Duplicate suppression\n            if self._near_duplicate(grid_x, x_new_pos, self.min_sep):\n                continue\n\n            # Heuristic f-gate once we have an incumbent\n            if informed:\n                g_tent = n_near.cost + self._dist(n_near.position, x_new_pos)\n                f_tent = g_tent + self._dist(x_new_pos, root_y.position)\n                if f_tent >= self._gate_factor(it) * c_best:\n                    continue\n\n            # R*-style parent selection: neighbors within adaptive radius; curvature tie-break\n            radius = self._neighbor_radius(len(tree_x))\n            neigh = self._neighbors_in_radius(grid_x, x_new_pos, radius, self.neighbor_k_max)\n            parent, new_cost = self._select_parent(x_new_pos, n_near, neigh, obstacles, is_3d)\n            if parent is None:\n                continue\n            # Safety: ensure chosen edge is valid\n            if self._edge_blocked(parent.position, x_new_pos, obstacles, is_3d):\n                continue\n\n            # Insert node (node+edge checks already done)\n            x_new = Node(x_new_pos, None, new_cost)\n            x_new.attach(parent)\n            tree_x.append(x_new)\n            all_nodes.append(x_new)\n            self._grid_add(grid_x, x_new)\n\n            # Lightweight localized rewiring (strict improvement, capped)\n            self._rewire_local(x_new, neigh, obstacles, is_3d, max_changes=5)\n\n            # Try to connect opposite tree\n            y_near = self._nearest_hashed(grid_y, tree_y, x_new.position)\n            bridged = None\n\n            # Direct check\n            if y_near is not None and not self._edge_blocked(x_new.position, y_near.position, obstacles, is_3d):\n                bridged = y_near\n            else:\n                # Stepwise greedy connect\n                cur = y_near\n                steps = 0\n                while cur is not None and steps < self.connect_steps:\n                    step_pos = None\n                    for mult in (2.0, 1.0):\n                        cand = self._steer(cur.position, x_new.position, mult * self.step_size)\n                        if not self._in_bounds(cand):\n                            continue\n                        if self._pt_in_obs(cand, obstacles, is_3d):\n                            continue\n                        if self._edge_blocked(cur.position, cand, obstacles, is_3d):\n                            continue\n                        step_pos = cand\n                        break\n                    if step_pos is None:\n                        break\n                    if self._near_duplicate(grid_y, step_pos, self.min_sep):\n                        break\n\n                    if informed:\n                        g2 = cur.cost + self._dist(cur.position, step_pos)\n                        f2 = g2 + self._dist(step_pos, root_x.position)\n                        if f2 >= self._gate_factor(it) * c_best:\n                            break\n\n                    # Choose parent in other tree for the step\n                    r_b = self._neighbor_radius(len(tree_y))\n                    neigh_b = self._neighbors_in_radius(grid_y, step_pos, r_b, self.neighbor_k_max)\n                    p_b, c_b = self._select_parent(step_pos, cur, neigh_b, obstacles, is_3d)\n                    if p_b is None:\n                        break\n                    if self._edge_blocked(p_b.position, step_pos, obstacles, is_3d):\n                        break\n\n                    nxt = Node(step_pos, None, c_b)\n                    nxt.attach(p_b)\n                    tree_y.append(nxt)\n                    all_nodes.append(nxt)\n                    self._grid_add(grid_y, nxt)\n                    self._rewire_local(nxt, neigh_b, obstacles, is_3d, max_changes=4)\n\n                    cur = nxt\n                    steps += 1\n\n                    if not self._edge_blocked(cur.position, x_new.position, obstacles, is_3d):\n                        bridged = cur\n                        break\n\n            if bridged is not None:\n                # Assemble path\n                if from_start:\n                    pa = x_new.path_to_root()\n                    pb = bridged.path_to_root()\n                    raw = pa + list(reversed(pb))\n                else:\n                    pa = x_new.path_to_root()\n                    pb = bridged.path_to_root()\n                    raw = pb + list(reversed(pa))\n\n                # Post-processing\n                path = self._vis_prune(raw, obstacles, is_3d)\n                path = self._shortcut(path, obstacles, is_3d, self.shortcut_trials)\n                path = self._round_corners(path, obstacles, is_3d, self.round_passes)\n                path = self._drop_collinear(path)\n\n                L = self._path_length(path)\n                if L < c_best:\n                    c_best = L\n                    best_path = path\n                    informed = True\n                    # Return the first high-quality bridge\n                    edges = []\n                    for n in all_nodes:\n                        if n.parent is not None:\n                            edges.append((n.parent, n))\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n        # No bridge found within iterations\n        edges = []\n        for n in all_nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        return PlannerResult(best_path is not None, best_path if best_path else [], all_nodes, edges)\n\n    # RNG utilities (no imports)\n    def _rand(self):\n        self._seed = (1664525 * self._seed + 1013904223) % (1 << 31)\n        return self._seed / float(1 << 31)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry and helpers\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        d2 = self._dist2(a, b)\n        return d2 ** 0.5 if d2 > 0.0 else 0.0\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _clamp(self, p):\n        out = []\n        for i in range(self.dim):\n            v = p[i]\n            if v < 0.0:\n                v = 0.0\n            if v > self.bounds[i]:\n                v = self.bounds[i]\n            out.append(v)\n        return tuple(out)\n\n    # Obstacles and collision\n    def _pt_in_obs(self, p, obstacles, is_3d):\n        if is_3d:\n            x, y, z = p\n            for o in obstacles:\n                ox, oy, oz, w, h, d = o\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n        else:\n            x, y = p\n            for o in obstacles:\n                ox, oy, w, h = o\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n        return False\n\n    def _qkey(self, a, b):\n        # Quantize endpoints for higher cache hit; order-invariant key\n        qa = tuple(int(a[i] / self._cache_quant + 0.5) for i in range(self.dim))\n        qb = tuple(int(b[i] / self._cache_quant + 0.5) for i in range(self.dim))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._qkey(a, b)\n        cached = self._edge_cache.get(k)\n        if cached is not None:\n            return cached\n\n        if is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            blocked = False\n            for box in obstacles:\n                ox, oy, oz, w, h, d = box\n                bx0, bx1 = ox, ox + w\n                by0, by1 = oy, oy + h\n                bz0, bz1 = oz, oz + d\n                if maxx < bx0 or bx1 < minx or maxy < by0 or by1 < miny or maxz < bz0 or bz1 < minz:\n                    continue\n                if self._seg_box_hit_3d(a, b, box):\n                    blocked = True\n                    break\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            blocked = False\n            for box in obstacles:\n                ox, oy, w, h = box\n                bx0, bx1 = ox, ox + w\n                by0, by1 = oy, oy + h\n                if maxx < bx0 or bx1 < minx or maxy < by0 or by1 < miny:\n                    continue\n                if self._seg_box_hit_2d(a, b, box):\n                    blocked = True\n                    break\n\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _seg_box_hit_2d(self, a, b, box):\n        # Liang-Barsky in 2D\n        x, y, w, h = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        ax, ay = a\n        bx, by = b\n        dx = bx - ax\n        dy = by - ay\n        tmin, tmax = 0.0, 1.0\n\n        if dx == 0.0:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            t1 = (minx - ax) * inv\n            t2 = (maxx - ax) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        if dy == 0.0:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            t1 = (miny - ay) * inv\n            t2 = (maxy - ay) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    def _seg_box_hit_3d(self, a, b, box):\n        # 3D slab method\n        x, y, z, w, h, d = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        minz, maxz = z, z + d\n        ax, ay, az = a\n        bx, by, bz = b\n        dx = bx - ax\n        dy = by - ay\n        dz = bz - az\n        tmin, tmax = 0.0, 1.0\n\n        # X\n        if dx == 0.0:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            t1 = (minx - ax) * inv\n            t2 = (maxx - ax) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        # Y\n        if dy == 0.0:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            t1 = (miny - ay) * inv\n            t2 = (maxy - ay) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        # Z\n        if dz == 0.0:\n            if az < minz or az > maxz:\n                return False\n        else:\n            inv = 1.0 / dz\n            t1 = (minz - az) * inv\n            t2 = (maxz - az) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    # Spatial hashing\n    def _grid_key(self, pos):\n        if self.dim == 3:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        else:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, nodes, pos):\n        k = self._grid_key(pos)\n        best = None\n        bestd2 = float('inf')\n        found = False\n        for r in range(0, 3):\n            cand = self._collect_ring(grid, k, r)\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd2:\n                        bestd2 = d2\n                        best = n\n                found = True\n                break\n        if not found:\n            # bounded fallback scan\n            limit = min(96, len(nodes))\n            if limit == 0:\n                return None\n            step = max(1, len(nodes) // limit)\n            for i in range(0, len(nodes), step):\n                n = nodes[i]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius, kmax):\n        ring = int(radius // self.cell) + 1\n        cand = self._collect_ring(grid, self._grid_key(pos), ring)\n        items = []\n        rr2 = (radius + 1e-9) * (radius + 1e-9)\n        for n in cand:\n            d2 = self._dist2(n.position, pos)\n            if d2 <= rr2:\n                items.append((d2, n))\n        items.sort(key=lambda x: x[0])\n        res = [n for (_, n) in items[:kmax]]\n        return res\n\n    def _neighbor_radius(self, ncount):\n        n = float(max(1, ncount))\n        # r_n = gamma * (log(n)/n)^(1/d), scaled by step size and a mild factor\n        # approximate ln via series around 1 after scaling into [1,2)\n        ln_n = self._ln_approx(n + 1.0)\n        base = (ln_n / n) ** (1.0 / float(self.dim))\n        return max(self.step_size * 1.1, self.neighbor_gamma * base * (self.step_size * 5.0))\n\n    def _ln_approx(self, x):\n        if x <= 0.0:\n            return -1e9\n        k = 0\n        y = x\n        while y >= 2.0:\n            y *= 0.5\n            k += 1\n        while y < 1.0:\n            y *= 2.0\n            k -= 1\n        t = y - 1.0\n        t2 = t * t\n        t3 = t2 * t\n        t4 = t3 * t\n        t5 = t4 * t\n        ln_y = t - 0.5 * t2 + (1.0/3.0) * t3 - 0.25 * t4 + 0.2 * t5\n        ln2 = 0.6931471805599453\n        return ln_y + k * ln2\n\n    def _near_duplicate(self, grid, pos, radius):\n        cand = self._collect_ring(grid, self._grid_key(pos), 1)\n        r2 = radius * radius\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                return True\n        return False\n\n    # Parent selection with curvature-aware tie-break\n    def _select_parent(self, new_pos, fallback, neighbors, obstacles, is_3d):\n        best_p = None\n        best_cost = float('inf')\n        best_tie = float('inf')\n        lam = 0.08  # curvature weight\n\n        def angle_penalty(p):\n            if p is None or p.parent is None:\n                return 0.0\n            a = p.parent.position\n            b = p.position\n            c = new_pos\n            v1 = tuple(b[i] - a[i] for i in range(self.dim))\n            v2 = tuple(c[i] - b[i] for i in range(self.dim))\n            n1 = 0.0\n            n2 = 0.0\n            dot = 0.0\n            for i in range(self.dim):\n                n1 += v1[i] * v1[i]\n                n2 += v2[i] * v2[i]\n                dot += v1[i] * v2[i]\n            if n1 <= 1e-12 or n2 <= 1e-12:\n                return 0.0\n            cosang = dot / ((n1 ** 0.5) * (n2 ** 0.5))\n            if cosang > 1.0:\n                cosang = 1.0\n            if cosang < -1.0:\n                cosang = -1.0\n            return (1.0 - cosang)  # smaller is smoother\n\n        cand = [fallback] + neighbors\n        seen = set()\n        for p in cand:\n            if p in seen:\n                continue\n            seen.add(p)\n            if self._edge_blocked(p.position, new_pos, obstacles, is_3d):\n                continue\n            cost = p.cost + self._dist(p.position, new_pos)\n            tie = angle_penalty(p)\n            score_cost = cost + lam * self.step_size * tie\n            if (score_cost < best_cost - 1e-12) or (abs(score_cost - best_cost) <= 1e-12 and tie < best_tie - 1e-12):\n                best_cost = score_cost\n                best_tie = tie\n                best_p = p\n\n        if best_p is None:\n            return None, float('inf')\n        # return true accumulated cost without penalty\n        return best_p, best_p.cost + self._dist(best_p.position, new_pos)\n\n    def _rewire_local(self, new_node, neighbors, obstacles, is_3d, max_changes=5):\n        changes = 0\n        for m in neighbors:\n            if changes >= max_changes:\n                break\n            if m is new_node or m is new_node.parent:\n                continue\n            alt = new_node.cost + self._dist(new_node.position, m.position)\n            if alt + 1e-12 < m.cost:\n                if not self._edge_blocked(new_node.position, m.position, obstacles, is_3d):\n                    delta = alt - m.cost\n                    m.attach(new_node)\n                    m.cost = alt\n                    self._propagate_cost(m, delta)\n                    changes += 1\n\n    def _propagate_cost(self, node, delta):\n        if delta == 0.0:\n            return\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    # Informed sampling\n    def _ellipse_or_corridor_sample(self, a, b, c_best):\n        ab = self._dist(a, b)\n        if c_best < float('inf'):\n            # ellipse with foci a,b and major axis c_best\n            for _ in range(12):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._dist(p, a) + self._dist(p, b) <= c_best + 1e-9:\n                    return p\n        # corridor around segment ab\n        width = max(self.step_size, 0.2 * (ab if ab > 0.0 else max(self.bounds)))\n        t = self._uniform(0.0, 1.0)\n        base = tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n        abv = tuple(b[i] - a[i] for i in range(self.dim))\n        nrm = 0.0\n        for i in range(self.dim):\n            nrm += abv[i] * abv[i]\n        nrm = nrm ** 0.5 if nrm > 0.0 else 0.0\n        if nrm <= 1e-9:\n            return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n        v = tuple(abv[i] / nrm for i in range(self.dim))\n        if self.dim == 2:\n            perp = (-v[1], v[0])\n            mag = self._uniform(-width, width)\n            p = (base[0] + perp[0] * mag, base[1] + perp[1] * mag)\n            return self._clamp(p)\n        else:\n            # random orthogonal direction to v\n            r = (self._uniform(-1.0, 1.0), self._uniform(-1.0, 1.0), self._uniform(-1.0, 1.0))\n            dot = r[0]*v[0] + r[1]*v[1] + r[2]*v[2]\n            u = (r[0] - dot*v[0], r[1] - dot*v[1], r[2] - dot*v[2])\n            un = (u[0]*u[0] + u[1]*u[1] + u[2]*u[2]) ** 0.5\n            if un <= 1e-9:\n                u = (v[1], -v[0], 0.0)\n                un = (u[0]*u[0] + u[1]*u[1] + u[2]*u[2]) ** 0.5\n            u = (u[0]/un, u[1]/un, u[2]/un)\n            mag = self._uniform(-width, width)\n            p = (base[0] + u[0]*mag, base[1] + u[1]*mag, base[2] + u[2]*mag)\n            return self._clamp(p)\n\n    # Heuristic gate interpolation\n    def _gate_factor(self, it):\n        t = 0.0\n        if self.max_iter > 1:\n            t = min(1.0, max(0.0, it / float(self.max_iter - 1)))\n        return self.heur_gate_init + (self.heur_gate_final - self.heur_gate_init) * t\n\n    # Path utilities and smoothing\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _vis_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        pruned = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(pruned[-1], path[j], obstacles, is_3d):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _shortcut(self, path, obstacles, is_3d, trials):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(trials):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 2, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts\n\n    def _round_corners(self, path, obstacles, is_3d, passes):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        alpha = 0.35\n        for _ in range(passes):\n            changed = False\n            i = 1\n            while i < len(pts) - 1:\n                a = pts[i - 1]\n                b = pts[i]\n                c = pts[i + 1]\n                ab = tuple(b[d] - a[d] for d in range(self.dim))\n                bc = tuple(c[d] - b[d] for d in range(self.dim))\n                abn = self._dist(a, b)\n                bcn = self._dist(b, c)\n                if abn <= 1e-9 or bcn <= 1e-9:\n                    i += 1\n                    continue\n                p1 = tuple(b[d] - ab[d] * (alpha) for d in range(self.dim))\n                p2 = tuple(b[d] + bc[d] * (alpha) for d in range(self.dim))\n                if self._pt_in_obs(p1, obstacles, is_3d) or self._pt_in_obs(p2, obstacles, is_3d):\n                    i += 1\n                    continue\n                if self._edge_blocked(a, p1, obstacles, is_3d):\n                    i += 1\n                    continue\n                if self._edge_blocked(p1, p2, obstacles, is_3d):\n                    i += 1\n                    continue\n                if self._edge_blocked(p2, c, obstacles, is_3d):\n                    i += 1\n                    continue\n                old_len = self._dist(a, b) + self._dist(b, c)\n                new_len = self._dist(a, p1) + self._dist(p1, p2) + self._dist(p2, c)\n                if new_len + 1e-9 < old_len:\n                    pts = pts[:i] + [p1, p2] + pts[i + 1:]\n                    changed = True\n                    i += 2\n                else:\n                    i += 1\n            if not changed:\n                break\n        return pts\n\n    def _drop_collinear(self, path):\n        if len(path) < 3:\n            return path\n        out = [path[0]]\n        for i in range(1, len(path) - 1):\n            a = out[-1]\n            b = path[i]\n            c = path[i + 1]\n            v1 = tuple(b[d] - a[d] for d in range(self.dim))\n            v2 = tuple(c[d] - b[d] for d in range(self.dim))\n            cross = 0.0\n            if self.dim == 2:\n                cross = abs(v1[0] * v2[1] - v1[1] * v2[0])\n            else:\n                cx = v1[1]*v2[2] - v1[2]*v2[1]\n                cy = v1[2]*v2[0] - v1[0]*v2[2]\n                cz = v1[0]*v2[1] - v1[1]*v2[0]\n                cross = (cx*cx + cy*cy + cz*cz) ** 0.5\n            n1 = 0.0\n            n2 = 0.0\n            for d in range(self.dim):\n                n1 += v1[d] * v1[d]\n                n2 += v2[d] * v2[d]\n            if cross <= 1e-6 * (n1 ** 0.5 + n2 ** 0.5):\n                continue\n            out.append(b)\n        out.append(path[-1])\n        return out",
          "objective": -33.99181,
          "time_improvement": 65.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1040.0,
          "node_improvement": 86.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012869930267333985,
                    "num_nodes_avg": 69.0,
                    "path_length_avg": 162.8984312218409,
                    "smoothness_avg": 0.022167112741891128,
                    "success_improvement": 0.0,
                    "time_improvement": 48.83578094521355,
                    "node_improvement": 82.62402417527072,
                    "length_improvement": 10.712788556481911,
                    "smoothness_improvement": 246.96345106636906,
                    "objective_score": 22.313224672785054
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.024409103393554687,
                    "num_nodes_avg": 135.0,
                    "path_length_avg": 234.8496345441535,
                    "smoothness_avg": 0.03698976045179835,
                    "success_improvement": 0.0,
                    "time_improvement": 84.76437198378565,
                    "node_improvement": 90.92924813545656,
                    "length_improvement": 21.600432217236936,
                    "smoothness_improvement": 851.7731790723212,
                    "objective_score": 42.648436820839464
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.019227242469787596,
                    "num_nodes_avg": 134.0,
                    "path_length_avg": 128.54055732296086,
                    "smoothness_avg": 0.16682411487458576,
                    "success_improvement": 0.0,
                    "time_improvement": 60.42045800327847,
                    "node_improvement": 82.96249205340115,
                    "length_improvement": 14.629482269675032,
                    "smoothness_improvement": 2021.9904275294534,
                    "objective_score": 37.01377890043583
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "FLASH-Lite BiRRT: a fast bidirectional planner with obstacle-grid-accelerated collision checks, coarse edge memoization, tight goal/informed sampling, and shallow LOS compression. It limits per-step work via small beams and bounded neighbor searches, while a coarse node grid speeds nearest queries and duplicate suppression. A provisional path triggers ellipse-informed sampling and early return after light shortcutting.",
          "planning_mechanism": "Alternate growing start/goal trees. For each side, draw a small beam of samples (goal/informed/uniform), pick the best g+h candidate using hashed-nearest and bounded parent search, enforce node and edge checks via obstacle-grid slab tests with memoization, insert, apply one-hop LOS compression, then attempt a direct or short greedy connect to the opposite tree. On bridging, extract and lightly smooth the path and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=8.0,\n                 collision_step=1.0,\n                 beam_k=2,\n                 goal_bias=0.3,\n                 informed_bias=0.6,\n                 grid_cell_factor=1.2,\n                 dupe_radius_ratio=0.6,\n                 min_sep_ratio=0.3,\n                 connect_steps=3,\n                 heuristic_weight=0.7,\n                 smoothing_iters=25,\n                 edge_cache_max=40000,\n                 obs_cell_factor=2.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_step = collision_step\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.informed_bias = informed_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.min_sep_ratio = min_sep_ratio\n        self.connect_steps = connect_steps\n        self.heuristic_weight = heuristic_weight\n        self.smoothing_iters = smoothing_iters\n        self.edge_cache_max = edge_cache_max\n        self.obs_cell_factor = obs_cell_factor\n\n        # runtime\n        self.dim = 2\n        self.bounds = None\n        self.start = None\n        self.goal = None\n        self.obstacles = None\n        self.is_3d = False\n\n        # structures\n        self.node_cell = 1.0\n        self.dupe_radius = 1.0\n        self.min_sep = 1.0\n        self.edge_res = 1.0\n        self.cache_bin = 1.0\n        self.edge_cache = None\n        self.edge_cache_order = None\n\n        # obstacle grid\n        self.obs_cell = 4.0\n        self.obs_grid = None  # dict cell->list of obstacle indices\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = map.start\n        self.goal = map.goal\n        self.obstacles = map.obstacles\n\n        # configure discretizations\n        self.node_cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.min_sep = max(0.25, self.step_size * self.min_sep_ratio)\n        self.edge_res = max(0.5, min(self.collision_step, self.step_size * 0.5))\n        self.cache_bin = max(self.edge_res, 1.0)\n        self.edge_cache = {}\n        self.edge_cache_order = []\n        # obstacle spatial grid\n        base_cell = self.step_size * self.obs_cell_factor\n        self.obs_cell = max(2.0, base_cell)\n        self._build_obstacle_grid()\n\n        # validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_collision(self.start) or self._point_in_collision(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # early straight path\n        if not self._edge_blocked_memo(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # init trees\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n\n        dsg = self._dist(self.start, self.goal)\n        c_best = float('inf')\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            Ta = tree_a if active_start else tree_b\n            Tb = tree_b if active_start else tree_a\n            Ga = grid_a if active_start else grid_b\n            Gb = grid_b if active_start else grid_a\n            other_root = self.goal if active_start else self.start\n\n            best = None  # (parent, new_pos, score)\n\n            for _ in range(self.beam_k):\n                # Sampling: goal / informed / uniform\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = other_root\n                elif c_best < float('inf') and self._rand() < self.informed_bias:\n                    x_rand = self._sample_informed(c_best)\n                else:\n                    x_rand = self._sample_free()\n\n                near = self._nearest_hashed(Ga, Ta, x_rand)\n                if near is None:\n                    continue\n\n                new_pos = self._steer(near.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._point_in_collision(new_pos):\n                    continue\n                if self._dist(near.position, new_pos) < self.min_sep:\n                    continue\n                if self._exists_close(Ga, new_pos, self.dupe_radius):\n                    continue\n\n                # bounded parent search (nearest + neighbors within 1 ring)\n                parent = None\n                parent_cost = float('inf')\n                candidates = self._neighbors(Ga, new_pos, 1)\n                if not candidates:\n                    candidates = [near]\n                for p in candidates:\n                    if not self._edge_blocked_memo(p.position, new_pos):\n                        g = p.cost + self._dist(p.position, new_pos)\n                        if g < parent_cost:\n                            parent_cost = g\n                            parent = p\n                if parent is None:\n                    continue\n\n                # score by g + w*h (favor bridging)\n                other_near = self._nearest_hashed(Gb, Tb, new_pos)\n                h = self._dist(new_pos, other_near.position) if other_near is not None else self._dist(new_pos, other_root)\n                score = parent_cost + self.heuristic_weight * h\n                # prefer if direct bridge\n                if other_near is not None and not self._edge_blocked_memo(new_pos, other_near.position):\n                    score *= 0.25\n                if (best is None) or (score < best[2]):\n                    best = (parent, new_pos, score)\n\n            if best is None:\n                continue\n\n            parent, new_pos, _ = best\n\n            # enforce checks before insertion\n            if self._point_in_collision(new_pos):\n                continue\n            if self._edge_blocked_memo(parent.position, new_pos):\n                continue\n\n            # insert\n            new_cost = parent.cost + self._dist(parent.position, new_pos)\n            q_new = Node(new_pos, parent, new_cost)\n            parent.add_child(q_new)\n            Ta.append(q_new)\n            nodes.append(q_new)\n            edges.append((parent, q_new))\n            self._grid_add(Ga, q_new)\n\n            # shallow LOS compression to grandparent\n            gp = parent.parent\n            if gp is not None and not self._edge_blocked_memo(gp.position, q_new.position):\n                # reattach\n                try:\n                    parent.children.remove(q_new)\n                except:\n                    pass\n                self._edges_remove(edges, parent, q_new)\n                gp.add_child(q_new)\n                q_new.cost = gp.cost + self._dist(gp.position, q_new.position)\n                edges.append((gp, q_new))\n\n            # try direct bridge\n            other_near = self._nearest_hashed(Gb, Tb, q_new.position)\n            if other_near is not None and not self._edge_blocked_memo(q_new.position, other_near.position):\n                path = self._extract_path(q_new, other_near)\n                c_best = self._path_length(path)\n                path = self._smooth_path(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # short greedy connect from opposite tree\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                step_pos = self._steer(p.position, q_new.position, self.step_size)\n                if not self._in_bounds(step_pos):\n                    break\n                if self._point_in_collision(step_pos):\n                    break\n                if self._edge_blocked_memo(p.position, step_pos):\n                    break\n                # add micro step (checks passed)\n                q = Node(step_pos, p, p.cost + self._dist(p.position, step_pos))\n                p.add_child(q)\n                Tb.append(q)\n                nodes.append(q)\n                edges.append((p, q))\n                self._grid_add(Gb, q)\n                p = q\n                steps += 1\n                if not self._edge_blocked_memo(q_new.position, p.position):\n                    path = self._extract_path(q_new, p)\n                    c_best = self._path_length(path)\n                    path = self._smooth_path(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        if not hasattr(self, \"_rng\"):\n            self._rng = 2463534242\n        self._rng = (1664525 * self._rng + 1013904223) % (1 << 32)\n        return self._rng / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        if self.dim == 3:\n            return (min(max(p[0], 0.0), self.bounds[0]),\n                    min(max(p[1], 0.0), self.bounds[1]),\n                    min(max(p[2], 0.0), self.bounds[2]))\n        else:\n            return (min(max(p[0], 0.0), self.bounds[0]),\n                    min(max(p[1], 0.0), self.bounds[1]))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # node grid for nearest/dupe\n    def _grid_key(self, pos):\n        if self.dim == 3:\n            return (int(pos[0] // self.node_cell),\n                    int(pos[1] // self.node_cell),\n                    int(pos[2] // self.node_cell))\n        else:\n            return (int(pos[0] // self.node_cell),\n                    int(pos[1] // self.node_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        res = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            res.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        res.extend(b)\n        return res\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # search expanding rings; evaluate within first non-empty ring\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                return best\n        # fallback linear\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _neighbors(self, grid, pos, rings):\n        key = self._grid_key(pos)\n        cand = self._grid_ring_collect(grid, key, rings)\n        return cand\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        rc = int(radius / self.node_cell) + 1\n        cand = self._grid_ring_collect(grid, key, rc)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # obstacle grid\n    def _obs_key(self, pos):\n        if self.dim == 3:\n            return (int(pos[0] // self.obs_cell),\n                    int(pos[1] // self.obs_cell),\n                    int(pos[2] // self.obs_cell))\n        else:\n            return (int(pos[0] // self.obs_cell),\n                    int(pos[1] // self.obs_cell))\n\n    def _build_obstacle_grid(self):\n        self.obs_grid = {}\n        for idx, obs in enumerate(self.obstacles):\n            if self.is_3d:\n                x, y, z, w, h, d = obs\n                i0 = int(x // self.obs_cell)\n                i1 = int((x + w) // self.obs_cell)\n                j0 = int(y // self.obs_cell)\n                j1 = int((y + h) // self.obs_cell)\n                k0 = int(z // self.obs_cell)\n                k1 = int((z + d) // self.obs_cell)\n                for i in range(i0, i1 + 1):\n                    for j in range(j0, j1 + 1):\n                        for k in range(k0, k1 + 1):\n                            key = (i, j, k)\n                            bucket = self.obs_grid.get(key)\n                            if bucket is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                bucket.append(idx)\n            else:\n                x, y, w, h = obs\n                i0 = int(x // self.obs_cell)\n                i1 = int((x + w) // self.obs_cell)\n                j0 = int(y // self.obs_cell)\n                j1 = int((y + h) // self.obs_cell)\n                for i in range(i0, i1 + 1):\n                    for j in range(j0, j1 + 1):\n                        key = (i, j)\n                        bucket = self.obs_grid.get(key)\n                        if bucket is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _collect_obs_aabb(self, a_min, a_max):\n        # gather obstacle indices whose grid cells overlap the aabb\n        res = []\n        seen = {}\n        if self.is_3d:\n            i0 = int(a_min[0] // self.obs_cell)\n            i1 = int(a_max[0] // self.obs_cell)\n            j0 = int(a_min[1] // self.obs_cell)\n            j1 = int(a_max[1] // self.obs_cell)\n            k0 = int(a_min[2] // self.obs_cell)\n            k1 = int(a_max[2] // self.obs_cell)\n            for i in range(i0, i1 + 1):\n                for j in range(j0, j1 + 1):\n                    for k in range(k0, k1 + 1):\n                        bucket = self.obs_grid.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                if idx not in seen:\n                                    seen[idx] = 1\n                                    res.append(idx)\n        else:\n            i0 = int(a_min[0] // self.obs_cell)\n            i1 = int(a_max[0] // self.obs_cell)\n            j0 = int(a_min[1] // self.obs_cell)\n            j1 = int(a_max[1] // self.obs_cell)\n            for i in range(i0, i1 + 1):\n                for j in range(j0, j1 + 1):\n                    bucket = self.obs_grid.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            if idx not in seen:\n                                seen[idx] = 1\n                                res.append(idx)\n        return res\n\n    # collision\n    def _point_in_collision(self, p):\n        # gather candidate obstacles from cell\n        key = self._obs_key(p)\n        cand = self.obs_grid.get(key, [])\n        if self.is_3d:\n            px, py, pz = p\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = p\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_blocked_memo(self, a, b):\n        key = self._edge_key_q(a, b)\n        st = self.edge_cache.get(key)\n        if st is not None:\n            return st == 1\n        blocked = self._segment_blocked(a, b)\n        self.edge_cache[key] = 1 if blocked else 2\n        self.edge_cache_order.append(key)\n        if len(self.edge_cache_order) > self.edge_cache_max:\n            # gentle pruning: drop oldest quarter\n            trim = max(1, self.edge_cache_max // 4)\n            for _ in range(trim):\n                k = self.edge_cache_order.pop(0)\n                try:\n                    del self.edge_cache[k]\n                except:\n                    pass\n        return blocked\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _segment_blocked(self, a, b):\n        # collect candidate obstacles from segment AABB\n        if self.is_3d:\n            a_min = (min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2]))\n            a_max = (max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2]))\n            cand = self._collect_obs_aabb(a_min, a_max)\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            a_min = (min(a[0], b[0]), min(a[1], b[1]))\n            a_max = (max(a[0], b[0]), max(a[1], b[1]))\n            cand = self._collect_obs_aabb(a_min, a_max)\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_2d(self, a, b, bmin, bmax):\n        # slab method\n        t0 = 0.0\n        t1 = 1.0\n        dx = b[0] - a[0]\n        dy = b[1] - a[1]\n        # X\n        if abs(dx) < 1e-12:\n            if a[0] < bmin[0] or a[0] > bmax[0]:\n                return False\n        else:\n            inv = 1.0 / dx\n            tmin = (bmin[0] - a[0]) * inv\n            tmax = (bmax[0] - a[0]) * inv\n            if tmin > tmax:\n                tmin, tmax = tmax, tmin\n            t0 = max(t0, tmin)\n            t1 = min(t1, tmax)\n            if t0 > t1:\n                return False\n        # Y\n        if abs(dy) < 1e-12:\n            if a[1] < bmin[1] or a[1] > bmax[1]:\n                return False\n        else:\n            inv = 1.0 / dy\n            tmin = (bmin[1] - a[1]) * inv\n            tmax = (bmax[1] - a[1]) * inv\n            if tmin > tmax:\n                tmin, tmax = tmax, tmin\n            t0 = max(t0, tmin)\n            t1 = min(t1, tmax)\n            if t0 > t1:\n                return False\n        return True\n\n    def _seg_aabb_3d(self, a, b, bmin, bmax):\n        t0 = 0.0\n        t1 = 1.0\n        for i in range(3):\n            d = b[i] - a[i]\n            if abs(d) < 1e-12:\n                if a[i] < bmin[i] or a[i] > bmax[i]:\n                    return False\n            else:\n                inv = 1.0 / d\n                tmin = (bmin[i] - a[i]) * inv\n                tmax = (bmax[i] - a[i]) * inv\n                if tmin > tmax:\n                    tmin, tmax = tmax, tmin\n                if tmin > t0:\n                    t0 = tmin\n                if tmax < t1:\n                    t1 = tmax\n                if t0 > t1:\n                    return False\n        return True\n\n    # sampling\n    def _sample_free(self):\n        while True:\n            if self.is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._point_in_collision(p):\n                return p\n\n    def _sample_informed(self, c_best):\n        # simple ellipse/hyper-ellipsoid rejection: sum of distances <= c_best\n        tries = 0\n        while tries < 40:\n            tries += 1\n            if self.is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= c_best and not self._point_in_collision(p):\n                return p\n        return self._sample_free()\n\n    # paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node):\n        path_a = self._path_to_root(a_node)\n        path_b = []\n        cur = b_node\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _path_length(self, path):\n        if len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _smooth_path(self, path):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        # random shortcuts\n        iters = self.smoothing_iters\n        for _ in range(iters):\n            if len(pts) < 3:\n                break\n            i = int(self._uniform(0, len(pts) - 2))\n            j = int(self._uniform(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked_memo(a, b):\n                pts = pts[:i + 1] + pts[j:]\n        # forward visibility collapse\n        collapsed = [pts[0]]\n        last = pts[0]\n        k = 1\n        while k < len(pts) - 1:\n            nxt = pts[k + 1]\n            if self._segment_blocked(last, nxt):\n                collapsed.append(pts[k])\n                last = pts[k]\n            k += 1\n        collapsed.append(pts[-1])\n        return collapsed\n\n    # edges bookkeeping\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)",
          "objective": -33.763,
          "time_improvement": 67.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1397.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015280461311340332,
                    "num_nodes_avg": 61.0,
                    "path_length_avg": 185.13604801409235,
                    "smoothness_avg": 0.050288639635450806,
                    "success_improvement": 0.0,
                    "time_improvement": 44.59959528623428,
                    "node_improvement": 84.63863006799295,
                    "length_improvement": -1.4760015849388635,
                    "smoothness_improvement": 687.1264138236365,
                    "objective_score": 15.929909704025151
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.020370221138000487,
                    "num_nodes_avg": 87.7,
                    "path_length_avg": 238.43136748544165,
                    "smoothness_avg": 0.09288723874146164,
                    "success_improvement": 0.0,
                    "time_improvement": 87.6901431990191,
                    "node_improvement": 94.10737082577437,
                    "length_improvement": 20.404746666968464,
                    "smoothness_improvement": 2290.0555567915944,
                    "objective_score": 50.00016874384478
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016862821578979493,
                    "num_nodes_avg": 88.3,
                    "path_length_avg": 127.88732909814462,
                    "smoothness_avg": 0.10332586481221465,
                    "success_improvement": 0.0,
                    "time_improvement": 67.49813314094155,
                    "node_improvement": 88.7730451366815,
                    "length_improvement": 15.063325353212544,
                    "smoothness_improvement": 1214.2973736893703,
                    "objective_score": 35.35892202265684
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "ARC-BiRRT: Adaptive Reuse-Cached, Ring-Hashed, Cost-Gated BiRRT-Connect. It accelerates bidirectional planning with exact edge-collision memoization, ring-hash nearest search, local LOS parent selection, per-cell cost-gated admission, and single-shot tree bridging; upon success it applies cache-reused visibility pruning and bounded shortcut smoothing for shorter, smoother paths.",
          "planning_mechanism": "Alternate expanding start/goal trees with small-beam guided sampling (goal/corridor bias); find a near node via ring-hash, steer one step, enforce node+edge checks and near-duplicate rejection; pick a best-cost parent among nearby ring neighbors that see the new point; admit only if per-cell capacity or cost improves; after insertion, attempt a direct LOS bridge to the opposite tree; on success, extract and cache-prune/shortcut the path and stop early.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=7.5,\n        beam_width=2,\n        goal_bias=0.3,\n        grid_cell_factor=1.6,\n        ring_max=3,\n        max_per_cell=6,\n        min_sep_factor=0.5,\n        los_neighbor_rings=1,\n        smoothing_iters=50,\n        corridor_bias=0.5\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.ring_max = ring_max\n        self.max_per_cell = max_per_cell\n        self.min_sep_factor = min_sep_factor\n        self.los_neighbor_rings = los_neighbor_rings\n        self.smoothing_iters = smoothing_iters\n        self.corridor_bias = corridor_bias\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        # RNG state\n        self._lcg_state = 2463534242\n\n        # Caches\n        self._edge_cache = {}  # exact endpoints (ordered) -> bool blocked\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Derived params\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.3, self.step_size * self.min_sep_factor)\n        self.edge_res = max(0.5, min(1.0, self.step_size * 0.5))\n\n        # Reset caches\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            path = [start, goal]\n            path = self._visibility_prune(path, obstacles, is_3d)\n            path = self._shortcut_smooth(path, obstacles, is_3d, iters=min(10, self.smoothing_iters))\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Initialize trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n        bestcost_start = {}\n        bestcost_goal = {}\n\n        self._grid_add(grid_start, counts_start, bestcost_start, start_root)\n        self._grid_add(grid_goal, counts_goal, bestcost_goal, goal_root)\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n\n            tree_a = start_tree if active_start else goal_tree\n            grid_a = grid_start if active_start else grid_goal\n            counts_a = counts_start if active_start else counts_goal\n            bestcost_a = bestcost_start if active_start else bestcost_goal\n\n            tree_b = goal_tree if active_start else start_tree\n            grid_b = grid_goal if active_start else grid_start\n            counts_b = counts_goal if active_start else counts_start\n            bestcost_b = bestcost_goal if active_start else bestcost_start\n\n            attractor = goal if active_start else start\n\n            for _ in range(self.beam_width):\n                x_rand = self._guided_sample(obstacles, is_3d, attractor)\n\n                nearest = self._nearest_hashed(grid_a, tree_a, x_rand)\n                if nearest is None:\n                    continue\n\n                new_pos = self._steer(nearest.position, x_rand)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._edge_blocked(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                if self._near_duplicate(grid_a, new_pos, self.min_sep):\n                    continue\n\n                # Choose a parent among local neighbors with LOS (limited rings) for better path cost\n                parent = self._choose_parent_local(grid_a, new_pos, nearest, obstacles, is_3d)\n                if self._edge_blocked(parent.position, new_pos, obstacles, is_3d):\n                    continue  # safety\n\n                new_cost = parent.cost + self._dist(parent.position, new_pos)\n\n                # Per-cell cost-gated admission\n                key_new = self._grid_key(new_pos)\n                ccount = counts_a.get(key_new, 0)\n                bestc = bestcost_a.get(key_new, float('inf'))\n                if ccount >= self.max_per_cell and not (new_cost + 1e-9 < bestc):\n                    continue\n\n                # Insert node\n                new_node = Node(new_pos, parent=parent, cost=new_cost)\n                parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((parent, new_node))\n                self._grid_add(grid_a, counts_a, bestcost_a, new_node)\n\n                # Try single-shot direct bridge to the other tree\n                other_near = self._nearest_hashed(grid_b, tree_b, new_node.position)\n                if other_near is not None:\n                    if not self._edge_blocked(new_node.position, other_near.position, obstacles, is_3d):\n                        path = self._extract_path(new_node, other_near, a_is_start_tree=active_start)\n                        path = self._visibility_prune(path, obstacles, is_3d)\n                        path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos):\n        d = self._dist(from_pos, to_pos)\n        if d <= 1e-9:\n            return self._clamp(from_pos)\n        if d <= self.step_size:\n            return self._clamp(to_pos)\n        r = self.step_size / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision and caching\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        if k in self._edge_cache:\n            return self._edge_cache[k]\n        blocked = self._segment_hits(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_hits(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _guided_sample(self, obstacles, is_3d, attractor):\n        # Goal-biased with optional corridor pull (activated only after success; here kept generic)\n        if self._rand() < self.goal_bias:\n            p = attractor\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # Mild blend toward attractor\n        alpha = 0.2\n        if self.dim == 3:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]),\n                   self._uniform(0.0, self.bounds[2]))\n            p = tuple(alpha * attractor[i] + (1.0 - alpha) * rnd[i] for i in range(3))\n        else:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]))\n            p = tuple(alpha * attractor[i] + (1.0 - alpha) * rnd[i] for i in range(2))\n        if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    # Grid / NN\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, bestcost, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n        bc = bestcost.get(k)\n        if bc is None or node.cost < bc:\n            bestcost[k] = node.cost\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.ring_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback to limited random subset to avoid O(N)\n        if not tree:\n            return None\n        trials = min(64, len(tree))\n        for _ in range(trials):\n            idx = int(self._uniform(0, len(tree)))\n            n = tree[idx]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r = 1\n        cand = self._grid_ring_collect(grid, key, r)\n        rr = radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # Parent selection among local neighbors with LOS\n    def _choose_parent_local(self, grid, new_pos, fallback_nearest, obstacles, is_3d):\n        key = self._grid_key(new_pos)\n        best_parent = fallback_nearest\n        best_cost = fallback_nearest.cost + self._dist(fallback_nearest.position, new_pos)\n        max_r = max(1, self.los_neighbor_rings)\n        for r in range(0, max_r + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            for n in cand:\n                if n is fallback_nearest or n is best_parent:\n                    pass\n                # Check LOS\n                if not self._edge_blocked(n.position, new_pos, obstacles, is_3d):\n                    c = n.cost + self._dist(n.position, new_pos)\n                    if c + 1e-9 < best_cost:\n                        best_cost = c\n                        best_parent = n\n        return best_parent\n\n    # Path\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -33.74569,
          "time_improvement": 58.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1051.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010497808456420898,
                    "num_nodes_avg": 34.0,
                    "path_length_avg": 154.57051194099205,
                    "smoothness_avg": 0.03958955729868922,
                    "success_improvement": 0.0,
                    "time_improvement": 58.830179046785545,
                    "node_improvement": 91.4379249559305,
                    "length_improvement": 15.277453078640955,
                    "smoothness_improvement": 519.6625418241595,
                    "objective_score": 29.41383827034103
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.049208974838256835,
                    "num_nodes_avg": 116.0,
                    "path_length_avg": 236.11546529476226,
                    "smoothness_avg": 0.06943512420354042,
                    "success_improvement": 0.0,
                    "time_improvement": 69.28227518814471,
                    "node_improvement": 92.20587247194786,
                    "length_improvement": 21.177861477765767,
                    "smoothness_improvement": 1686.6157578555544,
                    "objective_score": 41.92447823238064
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026494455337524415,
                    "num_nodes_avg": 117.0,
                    "path_length_avg": 122.03531483713664,
                    "smoothness_avg": 0.08227711903121854,
                    "success_improvement": 0.0,
                    "time_improvement": 45.98660915000911,
                    "node_improvement": 85.12396694214877,
                    "length_improvement": 18.94995458240024,
                    "smoothness_improvement": 946.5588810119002,
                    "objective_score": 29.898749899502377
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "FALCON-Guided IBiRRT*: Fast Adaptive Corridor-Informed BiRRT* with quantized-hash neighbors and slab-accurate, cached edge checks. It alternates start/goal tree growth, uses goal/corridor/ellipse sampling after an incumbent, tries long steering with safe fallback, and applies an O((log n/n)^(1/d)) neighbor radius with curvature tie-break for parent choice and light rewiring. A short burst connect grows the opposite tree toward the new node. On a bridge, it visibility-prunes, shortcuts, and rubber-bands the path for length and smoothness. Duplicate suppression and heuristic f-gating keep expansions focused and few.",
          "planning_mechanism": "Each iteration: pick active tree; sample by goal bias, then ellipse/corridor/uniform; find a hash-grid nearest; attempt a long steer, else fallback; verify bounds, node, and edge; apply a relaxed f-gate once a path exists; gather neighbors within r=\u03b3(log n/n)^(1/d) and select the best-cost parent with an angle tie-break; attach, then rewire only if strictly cheaper; attempt direct or stepwise connect from the other tree. On success, extract start-to-goal, visibility-prune, shortcut, rubber-band, and return edges from recorded parents/children.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = set()\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.add(self)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3500,\n        step_size=5.0,\n        goal_bias=0.15,\n        corridor_bias=0.5,\n        neighbor_gamma=2.5,\n        neighbor_k_max=20,\n        connect_steps=4,\n        grid_cell_factor=1.5,\n        min_sep_factor=0.45,\n        heur_gate_init=1.20,\n        heur_gate_final=1.05,\n        smoothing_trials=80,\n        rubber_passes=2\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.neighbor_gamma = neighbor_gamma\n        self.neighbor_k_max = neighbor_k_max\n        self.connect_steps = connect_steps\n        self.grid_cell_factor = grid_cell_factor\n        self.min_sep_factor = min_sep_factor\n        self.heur_gate_init = heur_gate_init\n        self.heur_gate_final = heur_gate_final\n        self.smoothing_trials = smoothing_trials\n        self.rubber_passes = rubber_passes\n\n        self.dim = 2\n        self.bounds = None\n        self.cell = 1.0\n        self.min_sep = 1.0\n        self._edge_cache = {}\n        self._seed = 123456789\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Initialize parameters\n        self.cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step_size * self.min_sep_factor)\n        self._edge_cache = {}\n        self._seed = 123456789\n\n        # Basic validations\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obs(start, obstacles, is_3d) or self._point_in_obs(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.add(g)\n            nodes = [s, g]\n            edges = [(s, g)]\n            return PlannerResult(True, [start, goal], nodes, edges)\n\n        # Initialize bidirectional trees\n        a_root = Node(start, None, 0.0)\n        b_root = Node(goal, None, 0.0)\n        tree_a = [a_root]\n        tree_b = [b_root]\n        all_nodes = [a_root, b_root]\n\n        grid_a = {}\n        grid_b = {}\n        self._grid_add(grid_a, a_root)\n        self._grid_add(grid_b, b_root)\n\n        best_path = None\n        c_best = float('inf')\n        informed = False\n\n        # Main loop\n        for it in range(self.max_iter):\n            from_start = (it % 2 == 0)\n            if from_start:\n                tree_x, tree_y = tree_a, tree_b\n                grid_x, grid_y = grid_a, grid_b\n                root_x, root_y = a_root, b_root\n                attractor = goal\n            else:\n                tree_x, tree_y = tree_b, tree_a\n                grid_x, grid_y = grid_b, grid_a\n                root_x, root_y = b_root, a_root\n                attractor = start\n\n            # Sample\n            r = self._rand()\n            if r < self.goal_bias:\n                x_rand = attractor\n            else:\n                if informed and self._rand() < 0.55:\n                    x_rand = self._ellipse_sample(root_x.position, root_y.position, c_best)\n                elif self._rand() < self.corridor_bias:\n                    width = self._corridor_width(root_x.position, root_y.position, c_best)\n                    x_rand = self._corridor_sample(root_x.position, root_y.position, width)\n                else:\n                    x_rand = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n            # Nearest in active tree\n            n_near = self._nearest_hashed(grid_x, tree_x, x_rand)\n            if n_near is None:\n                continue\n\n            # Try a longer steer first, then fallback\n            target_long = self._steer(n_near.position, x_rand, 2.0 * self.step_size)\n            x_new_pos = None\n            if self._in_bounds(target_long) and not self._point_in_obs(target_long, obstacles, is_3d):\n                if not self._edge_blocked(n_near.position, target_long, obstacles, is_3d):\n                    x_new_pos = target_long\n            if x_new_pos is None:\n                target_short = self._steer(n_near.position, x_rand, self.step_size)\n                if not self._in_bounds(target_short):\n                    continue\n                if self._point_in_obs(target_short, obstacles, is_3d):\n                    continue\n                if self._edge_blocked(n_near.position, target_short, obstacles, is_3d):\n                    continue\n                x_new_pos = target_short\n\n            if self._near_duplicate(grid_x, x_new_pos, self.min_sep):\n                continue\n\n            # Heuristic f-gate (after incumbent found)\n            if informed:\n                g_tent = n_near.cost + self._dist(n_near.position, x_new_pos)\n                f_tent = g_tent + self._dist(x_new_pos, root_y.position)\n                gate = self._interp_gate(it)\n                if f_tent >= gate * c_best:\n                    continue\n\n            # Select parent among neighbors within O((log n / n)^(1/d)) radius\n            radius = self._neighbor_radius(len(tree_x))\n            neigh = self._neighbors_in_radius(grid_x, x_new_pos, radius, self.neighbor_k_max)\n            parent, new_cost = self._choose_parent(x_new_pos, n_near, neigh, obstacles, is_3d)\n            if parent is None:\n                continue\n            # Safety: node + edge checks already passed; verify chosen parent edge\n            if self._edge_blocked(parent.position, x_new_pos, obstacles, is_3d):\n                continue\n\n            # Insert new node\n            x_new = Node(x_new_pos, None, new_cost)\n            x_new.attach(parent)\n            tree_x.append(x_new)\n            all_nodes.append(x_new)\n            self._grid_add(grid_x, x_new)\n\n            # Light local rewiring\n            self._rewire(x_new, neigh, obstacles, is_3d)\n\n            # Try to connect to the other tree\n            other_near = self._nearest_hashed(grid_y, tree_y, x_new.position)\n            bridged = None\n\n            if other_near is not None and not self._edge_blocked(x_new.position, other_near.position, obstacles, is_3d):\n                bridged = other_near\n            else:\n                cur = other_near\n                steps = 0\n                while cur is not None and steps < self.connect_steps:\n                    # steer toward x_new (long then short)\n                    step_long = self._steer(cur.position, x_new.position, 2.0 * self.step_size)\n                    step_pos = None\n                    if self._in_bounds(step_long) and not self._point_in_obs(step_long, obstacles, is_3d):\n                        if not self._edge_blocked(cur.position, step_long, obstacles, is_3d):\n                            step_pos = step_long\n                    if step_pos is None:\n                        step_short = self._steer(cur.position, x_new.position, self.step_size)\n                        if not self._in_bounds(step_short):\n                            break\n                        if self._point_in_obs(step_short, obstacles, is_3d):\n                            break\n                        if self._edge_blocked(cur.position, step_short, obstacles, is_3d):\n                            break\n                        step_pos = step_short\n\n                    if self._near_duplicate(grid_y, step_pos, self.min_sep):\n                        break\n\n                    if informed:\n                        g2 = cur.cost + self._dist(cur.position, step_pos)\n                        f2 = g2 + self._dist(step_pos, root_x.position)\n                        if f2 >= self._interp_gate(it) * c_best:\n                            break\n\n                    # parent choice in other tree\n                    r_b = self._neighbor_radius(len(tree_y))\n                    neigh_b = self._neighbors_in_radius(grid_y, step_pos, r_b, self.neighbor_k_max)\n                    p_b, c_b = self._choose_parent(step_pos, cur, neigh_b, obstacles, is_3d)\n                    if p_b is None:\n                        break\n                    if self._edge_blocked(p_b.position, step_pos, obstacles, is_3d):\n                        break\n\n                    nxt = Node(step_pos, None, c_b)\n                    nxt.attach(p_b)\n                    tree_y.append(nxt)\n                    all_nodes.append(nxt)\n                    self._grid_add(grid_y, nxt)\n                    self._rewire(nxt, neigh_b, obstacles, is_3d)\n\n                    cur = nxt\n                    steps += 1\n\n                    # final bridge check\n                    if not self._edge_blocked(cur.position, x_new.position, obstacles, is_3d):\n                        bridged = cur\n                        break\n\n            if bridged is not None:\n                # Assemble path\n                if from_start:\n                    pa = self._path_to_root(x_new)\n                    pb = self._path_to_root(bridged)\n                    path = pa + list(reversed(pb))\n                else:\n                    pa = self._path_to_root(x_new)\n                    pb = self._path_to_root(bridged)\n                    path = pb + list(reversed(pa))\n\n                # Post-processing: visibility prune, shortcut, rubber-band\n                path = self._vis_prune(path, obstacles, is_3d)\n                path = self._shortcut(path, obstacles, is_3d, self.smoothing_trials)\n                path = self._rubber_band(path, obstacles, is_3d, self.rubber_passes)\n\n                L = self._path_length(path)\n                if L < c_best:\n                    c_best = L\n                    best_path = path\n                    informed = True\n                    # Return on first high-quality bridge\n                    edges = []\n                    for n in all_nodes:\n                        if n.parent is not None:\n                            edges.append((n.parent, n))\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n        # No bridge or ran out of iterations\n        edges = []\n        for n in all_nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        return PlannerResult(best_path is not None, best_path if best_path else [], all_nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._seed = (1103515245 * self._seed + 12345) % (1 << 31)\n        return self._seed / float(1 << 31)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry and helpers\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5 if s > 0.0 else 0.0\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _clamp(self, p):\n        out = []\n        for i in range(self.dim):\n            v = p[i]\n            if v < 0.0:\n                v = 0.0\n            if v > self.bounds[i]:\n                v = self.bounds[i]\n            out.append(v)\n        return tuple(out)\n\n    # Obstacles and collision\n    def _point_in_obs(self, p, obstacles, is_3d):\n        if is_3d:\n            x, y, z = p\n            for o in obstacles:\n                ox, oy, oz, w, h, d = o\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n        else:\n            x, y = p\n            for o in obstacles:\n                ox, oy, w, h = o\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        # exact endpoint key with order invariance\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        cached = self._edge_cache.get(k)\n        if cached is not None:\n            return cached\n\n        if is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            blocked = False\n            for box in obstacles:\n                ox, oy, oz, w, h, d = box\n                bx0, bx1 = ox, ox + w\n                by0, by1 = oy, oy + h\n                bz0, bz1 = oz, oz + d\n                if maxx < bx0 or bx1 < minx or maxy < by0 or by1 < miny or maxz < bz0 or bz1 < minz:\n                    continue\n                if self._seg_box_intersect_3d(a, b, box):\n                    blocked = True\n                    break\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            blocked = False\n            for box in obstacles:\n                ox, oy, w, h = box\n                bx0, bx1 = ox, ox + w\n                by0, by1 = oy, oy + h\n                if maxx < bx0 or bx1 < minx or maxy < by0 or by1 < miny:\n                    continue\n                if self._seg_box_intersect_2d(a, b, box):\n                    blocked = True\n                    break\n\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _seg_box_intersect_2d(self, a, b, box):\n        # Slab method (Liang-Barsky)\n        x, y, w, h = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        ax, ay = a\n        bx, by = b\n        dx = bx - ax\n        dy = by - ay\n        tmin, tmax = 0.0, 1.0\n\n        if dx == 0.0:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            t1 = (minx - ax) * inv\n            t2 = (maxx - ax) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        if dy == 0.0:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            t1 = (miny - ay) * inv\n            t2 = (maxy - ay) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    def _seg_box_intersect_3d(self, a, b, box):\n        # Slab method in 3D\n        x, y, z, w, h, d = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        minz, maxz = z, z + d\n        ax, ay, az = a\n        bx, by, bz = b\n        dx = bx - ax\n        dy = by - ay\n        dz = bz - az\n        tmin, tmax = 0.0, 1.0\n\n        # X\n        if dx == 0.0:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            t1 = (minx - ax) * inv\n            t2 = (maxx - ax) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        # Y\n        if dy == 0.0:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            t1 = (miny - ay) * inv\n            t2 = (maxy - ay) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        # Z\n        if dz == 0.0:\n            if az < minz or az > maxz:\n                return False\n        else:\n            inv = 1.0 / dz\n            t1 = (minz - az) * inv\n            t2 = (maxz - az) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    # Spatial hashing\n    def _grid_key(self, pos):\n        if self.dim == 3:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        else:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, nodes, pos):\n        k = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        found_any = False\n        for r in range(0, 3):\n            cand = self._collect_ring(grid, k, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                found_any = True\n                break\n        if not found_any:\n            # bounded fallback scan\n            limit = min(96, len(nodes))\n            if limit == 0:\n                return None\n            step = max(1, len(nodes) // limit)\n            for i in range(0, len(nodes), step):\n                n = nodes[i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius, kmax):\n        ring = int(radius // self.cell) + 1\n        cand = self._collect_ring(grid, self._grid_key(pos), ring)\n        items = []\n        rr = radius + 1e-9\n        for n in cand:\n            d = self._dist(n.position, pos)\n            if d <= rr:\n                items.append((d, n))\n        items.sort(key=lambda x: x[0])\n        res = [n for (_, n) in items[:kmax]]\n        return res\n\n    def _neighbor_radius(self, ncount):\n        n = max(1, ncount)\n        import_math_log = self._math_log(n + 1.0)\n        # r_n = gamma * (log n / n)^(1/d) scaled by step_size\n        base = (import_math_log / n) ** (1.0 / float(self.dim))\n        return max(self.step_size * 1.2, self.neighbor_gamma * base * (self.step_size * 6.0))\n\n    def _math_log(self, x):\n        # simple ln approximation via change-of-base using log2\n        # ln(x) = log2(x) * ln(2) ; log2 via iterative bit trick fallback to series\n        # To keep it simple and robust, use Newton method on exp approximation:\n        # but since imports are disallowed, approximate with log series around 1 using change x to m*2^k ~\n        # We'll use a simple binary search to find k so that y=x/2^k in [1,2), then use ln(y) ~ t - t^2/2 + t^3/3 - ... with t=y-1\n        if x <= 0.0:\n            return -1e9\n        # find k\n        k = 0\n        y = x\n        while y >= 2.0:\n            y *= 0.5\n            k += 1\n        while y < 1.0:\n            y *= 2.0\n            k -= 1\n        t = y - 1.0\n        # 5-term series for ln(1+t)\n        t2 = t * t\n        t3 = t2 * t\n        t4 = t3 * t\n        t5 = t4 * t\n        ln_y = t - 0.5 * t2 + (1.0/3.0) * t3 - 0.25 * t4 + 0.2 * t5\n        ln2 = 0.6931471805599453\n        return ln_y + k * ln2\n\n    def _near_duplicate(self, grid, pos, radius):\n        cand = self._collect_ring(grid, self._grid_key(pos), 1)\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                return True\n        return False\n\n    # Parent selection with curvature tie-break\n    def _choose_parent(self, new_pos, fallback, neighbors, obstacles, is_3d):\n        best_p = None\n        best_cost = float('inf')\n        best_tie = float('inf')\n\n        def angle_penalty(p):\n            if p is None or p.parent is None:\n                return 0.0\n            a = p.parent.position\n            b = p.position\n            c = new_pos\n            v1 = tuple(b[i] - a[i] for i in range(self.dim))\n            v2 = tuple(c[i] - b[i] for i in range(self.dim))\n            n1 = 0.0\n            n2 = 0.0\n            dot = 0.0\n            for i in range(self.dim):\n                n1 += v1[i] * v1[i]\n                n2 += v2[i] * v2[i]\n                dot += v1[i] * v2[i]\n            if n1 <= 1e-12 or n2 <= 1e-12:\n                return 0.0\n            cosang = dot / ((n1 ** 0.5) * (n2 ** 0.5))\n            if cosang > 1.0:\n                cosang = 1.0\n            if cosang < -1.0:\n                cosang = -1.0\n            return (1.0 - cosang)  # smaller is smoother\n\n        cand = [fallback] + neighbors\n        seen = set()\n        for p in cand:\n            if p in seen:\n                continue\n            seen.add(p)\n            if self._edge_blocked(p.position, new_pos, obstacles, is_3d):\n                continue\n            cost = p.cost + self._dist(p.position, new_pos)\n            tie = angle_penalty(p)\n            # prioritize lower cost, then smoother turn\n            if (cost < best_cost - 1e-12) or (abs(cost - best_cost) <= 1e-12 and tie < best_tie - 1e-12):\n                best_cost = cost\n                best_tie = tie\n                best_p = p\n\n        if best_p is None:\n            return None, float('inf')\n        return best_p, best_cost\n\n    def _rewire(self, new_node, neighbors, obstacles, is_3d):\n        for m in neighbors:\n            if m is new_node or m is new_node.parent:\n                continue\n            alt = new_node.cost + self._dist(new_node.position, m.position)\n            if alt + 1e-12 < m.cost:\n                if not self._edge_blocked(new_node.position, m.position, obstacles, is_3d):\n                    delta = alt - m.cost\n                    m.attach(new_node)\n                    m.cost = alt\n                    self._propagate_cost(m, delta)\n\n    def _propagate_cost(self, node, delta):\n        if delta == 0.0:\n            return\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    # Sampling helpers\n    def _ellipse_sample(self, a, b, c_best):\n        tries = 12\n        for _ in range(tries):\n            p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n            if self._dist(p, a) + self._dist(p, b) <= c_best + 1e-9:\n                return p\n        return self._corridor_sample(a, b, self._corridor_width(a, b, c_best))\n\n    def _corridor_width(self, a, b, c_best):\n        ab = self._dist(a, b)\n        base = max(self.step_size * 1.5, 0.2 * ab)\n        if c_best < float('inf'):\n            return max(self.step_size, 0.15 * c_best)\n        return base\n\n    def _corridor_sample(self, a, b, width):\n        t = self._uniform(0.0, 1.0)\n        base = tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n        ab = tuple(b[i] - a[i] for i in range(self.dim))\n        nrm = 0.0\n        for i in range(self.dim):\n            nrm += ab[i] * ab[i]\n        nrm = nrm ** 0.5 if nrm > 0.0 else 0.0\n        if nrm <= 1e-9:\n            return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n        v = tuple(ab[i] / nrm for i in range(self.dim))\n        if self.dim == 2:\n            perp = (-v[1], v[0])\n            mag = self._uniform(-width, width)\n            p = (base[0] + perp[0] * mag, base[1] + perp[1] * mag)\n            return self._clamp(p)\n        else:\n            # random orthogonal direction to v\n            r = (self._uniform(-1.0, 1.0), self._uniform(-1.0, 1.0), self._uniform(-1.0, 1.0))\n            dot = r[0]*v[0] + r[1]*v[1] + r[2]*v[2]\n            u = (r[0] - dot*v[0], r[1] - dot*v[1], r[2] - dot*v[2])\n            un = (u[0]*u[0] + u[1]*u[1] + u[2]*u[2]) ** 0.5\n            if un <= 1e-9:\n                u = (v[1], -v[0], 0.0)\n                un = (u[0]*u[0] + u[1]*u[1] + u[2]*u[2]) ** 0.5\n            u = (u[0]/un, u[1]/un, u[2]/un)\n            mag = self._uniform(-width, width)\n            p = (base[0] + u[0]*mag, base[1] + u[1]*mag, base[2] + u[2]*mag)\n            return self._clamp(p)\n\n    # Heuristic gate interpolation\n    def _interp_gate(self, it):\n        t = min(1.0, max(0.0, it / float(max(1, self.max_iter - 1))))\n        return self.heur_gate_init + (self.heur_gate_final - self.heur_gate_init) * t\n\n    # Path utilities\n    def _path_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        out.reverse()\n        return out\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _vis_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        pruned = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(pruned[-1], path[j], obstacles, is_3d):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _shortcut(self, path, obstacles, is_3d, trials):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(trials):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts\n\n    def _rubber_band(self, path, obstacles, is_3d, passes):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(passes):\n            changed = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                b = pts[i]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[d] + c[d]) for d in range(self.dim))\n                newp = tuple(0.5 * b[d] + 0.5 * mid[d] for d in range(self.dim))\n                if self._point_in_obs(newp, obstacles, is_3d):\n                    continue\n                if not self._edge_blocked(a, newp, obstacles, is_3d) and not self._edge_blocked(newp, c, obstacles, is_3d):\n                    old_len = self._dist(a, b) + self._dist(b, c)\n                    new_len = self._dist(a, newp) + self._dist(newp, c)\n                    if new_len + 1e-9 < old_len:\n                        pts[i] = newp\n                        changed = True\n            if not changed:\n                break\n        return pts",
          "objective": -33.60536,
          "time_improvement": 55.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1455.0,
          "node_improvement": 84.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025463962554931642,
                    "num_nodes_avg": 110.0,
                    "path_length_avg": 170.2514297674242,
                    "smoothness_avg": 0.0419187075776401,
                    "success_improvement": 0.0,
                    "time_improvement": -1.2316097368635643,
                    "node_improvement": 72.29916897506925,
                    "length_improvement": 6.682493537929557,
                    "smoothness_improvement": 556.1188015205249,
                    "objective_score": 6.42060720930129
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03313391208648682,
                    "num_nodes_avg": 166.0,
                    "path_length_avg": 236.7833017722465,
                    "smoothness_avg": 0.12341445881430893,
                    "success_improvement": 0.0,
                    "time_improvement": 79.31853738613928,
                    "node_improvement": 88.84633474433919,
                    "length_improvement": 20.954918438974353,
                    "smoothness_improvement": 3075.5429171338174,
                    "objective_score": 51.74622686489548
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.006153082847595215,
                    "num_nodes_avg": 69.0,
                    "path_length_avg": 118.5008222690273,
                    "smoothness_avg": 0.06557706324259252,
                    "success_improvement": 0.0,
                    "time_improvement": 87.33379467396959,
                    "node_improvement": 91.2269548633185,
                    "length_improvement": 21.297396251688706,
                    "smoothness_improvement": 734.1354040504717,
                    "objective_score": 42.64925317345646
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Adaptive Goal-Biased Grid BiRRT (AG-GBiRRT): a simplified, robust bidirectional RRT with commit-only connection, grid-accelerated nearest search, and light post-connection shortcut smoothing. It alternates growing two trees, uses uniform-with-goal-bias sampling, single-step steering with strict node/edge collision checks, and an early straight-line test. Upon any successful bridge between trees, it extracts the path and performs a few inexpensive shortcuts for smoothness, returning quickly without extra rewiring or bloat.",
          "planning_mechanism": "Mechanism: alternate start/goal tree expansion; sample (goal-biased), find nearest via grid, steer one step, validate node and edge, add node and edge, attempt a direct, collision-free bridge to the opposite tree (commit-only); on success, extract [start\u2192\u2026\u2192meetA, meetB\u2192\u2026\u2192goal] and run brief shortcut smoothing; terminate on success or iteration budget.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size * 2.0)\n        self.edge_res = max(0.5, self.collision_step)\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_res):\n            path = [start, goal]\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Trees and grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = goal if active_start else start\n\n            # Sample with goal/opposite-root bias\n            if self._rand() < self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest and steer\n            nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                continue\n\n            # Insert node (both node and edge validated)\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, new_node)\n\n            # Try commit-only direct connection to the other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None:\n                if not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                    path = self._extract_path(new_node, other_near)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- Random ----------\n    def _rand(self):\n        try:\n            return self._lcg_next()\n        except:\n            return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Sampling ----------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ---------- Grid nearest ----------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    # ---------- Path ----------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # path_a ends at meet_a; we then go straight to meet_b and up to other root\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            # pick two indices i < j with at least one point between\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -32.96764,
          "time_improvement": 69.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1142.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01299290657043457,
                    "num_nodes_avg": 78.8,
                    "path_length_avg": 167.86786188508313,
                    "smoothness_avg": 0.03825680999831742,
                    "success_improvement": 0.0,
                    "time_improvement": 49.04501835909778,
                    "node_improvement": 80.15613195668597,
                    "length_improvement": 7.988964864290817,
                    "smoothness_improvement": 498.8021524662562,
                    "objective_score": 22.000895188635106
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02625594139099121,
                    "num_nodes_avg": 208.9,
                    "path_length_avg": 244.3021244779086,
                    "smoothness_avg": 0.07331771296729457,
                    "success_improvement": 0.0,
                    "time_improvement": 83.61025026480232,
                    "node_improvement": 85.96385137405093,
                    "length_improvement": 18.444919002512343,
                    "smoothness_improvement": 1786.5175632625994,
                    "objective_score": 45.082614297261095
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01305999755859375,
                    "num_nodes_avg": 163.0,
                    "path_length_avg": 140.27860161008172,
                    "smoothness_avg": 0.09759083301298958,
                    "success_improvement": 0.0,
                    "time_improvement": 73.37500455677744,
                    "node_improvement": 79.27527018436109,
                    "length_improvement": 6.833632159773637,
                    "smoothness_improvement": 1141.348192519241,
                    "objective_score": 31.819421625493614
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SBCR: Simple Bi-Connect Rewire \u2014 a streamlined bi-directional planner that pairs bucketed approximate nearest search with adaptive stepping, bounded k-near parent selection, and micro-rewiring. It incrementally connects the opposite tree with strict collision checks and finishes with deterministic visibility and shortcut smoothing. The design minimizes heavy ring scans and complex heuristics to generalize across spaces.",
          "planning_mechanism": "Mechanism: alternate expanding start/goal trees; sample goal-biased or uniform; find approx-nearest via 1\u20132 ring grid buckets (linear fallback); steer adaptively and validate node+edge; choose lowest-cost parent among up to k nearby candidates and locally rewire a few; attempt small direct bridges and an incremental connect toward the new node; on meeting, extract path, apply visibility compression and shortcutting, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        for c in self.children:\n            if c is child:\n                child.parent = self\n                return\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        i = -1\n        for k in range(len(self.children)):\n            if self.children[k] is child:\n                i = k\n                break\n        if i >= 0:\n            self.children.pop(i)\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=6.0,\n                 goal_bias=0.25,\n                 grid_cell=None,\n                 k_near=6,\n                 rewire_radius_ratio=2.0,\n                 dupe_radius_ratio=0.5,\n                 connect_steps=10,\n                 smoothing_iters=30):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell = grid_cell\n        self.k_near = int(k_near)\n        self.rewire_radius_ratio = float(rewire_radius_ratio)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.connect_steps = int(connect_steps)\n        self.smoothing_iters = int(smoothing_iters)\n\n        self.dim = 2\n        self.bounds = None\n        self.start = None\n        self.goal = None\n        self._lcg_state = 1103515245\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        obstacles = list(map.obstacles)\n        is_3d = (self.dim == 3)\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size)\n\n        # Validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obstacles(self.start, obstacles, is_3d) or self._point_in_obstacles(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if not self._segment_blocked(self.start, self.goal, obstacles, is_3d):\n            s = Node(self.start, None, 0.0)\n            g = Node(self.goal, s, self._dist(self.start, self.goal))\n            s.add_child(g)\n            return PlannerResult(True, [self.start, self.goal], [s, g], [(s, g)])\n\n        # Initialize trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        dupe_radius = max(0.1, self.dupe_radius_ratio * self.step_size)\n        min_sep = 0.25 * self.step_size\n        rewire_radius = max(self.step_size, self.rewire_radius_ratio * self.step_size)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            other_root_pos = self.goal if active_start else self.start\n\n            # Sample: goal biased or uniform\n            if self._rand() < self.goal_bias:\n                x_rand = other_root_pos\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Approx-nearest via small bucket rings, then fallback\n            nearest = self._nearest_bucket(grid_a, tree_a, x_rand, rmax=2)\n\n            # Adaptive steer\n            dnt = self._dist(nearest.position, x_rand)\n            step = min(self.step_size, max(0.5, 0.8 * dnt))\n            new_pos = self._steer(nearest.position, x_rand, step)\n\n            # Basic validity checks\n            if not self._in_bounds(new_pos):\n                continue\n            if self._dist(nearest.position, new_pos) < min_sep:\n                continue\n            if self._exists_near(grid_a, new_pos, dupe_radius):\n                continue\n            # Node and edge collision checks (both)\n            if self._point_in_obstacles(new_pos, obstacles, is_3d):\n                continue\n            if self._segment_blocked(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Choose lowest-cost parent among nearby candidates\n            near_cands = self._collect_near_nodes(grid_a, new_pos, rewire_radius, tree_a, self.k_near)\n            if nearest not in near_cands:\n                near_cands.append(nearest)\n            best_parent = nearest\n            best_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            # sort by distance\n            dlist = []\n            for n in near_cands:\n                d = self._dist(n.position, new_pos)\n                dlist.append((d, n))\n            dlist.sort(key=lambda x: x[0])\n            for _, n in dlist[:self.k_near]:\n                if self._segment_blocked(n.position, new_pos, obstacles, is_3d):\n                    continue\n                c = n.cost + self._dist(n.position, new_pos)\n                if c < best_cost:\n                    best_cost = c\n                    best_parent = n\n\n            # Insert new node\n            new_node = Node(new_pos, best_parent, best_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            self._add_edge(edges, best_parent, new_node)\n            self._grid_add(grid_a, new_node)\n\n            # Micro-rewiring: improve a few neighbors if possible\n            rewires = 0\n            for _, nbr in dlist[:self.k_near]:\n                if rewires >= 4:\n                    break\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                alt = new_node.cost + self._dist(new_node.position, nbr.position)\n                if alt + 1e-9 < nbr.cost and not self._segment_blocked(new_node.position, nbr.position, obstacles, is_3d):\n                    old = nbr.parent\n                    if old is not None:\n                        old.remove_child(nbr)\n                        self._remove_edge(edges, old, nbr)\n                    new_node.add_child(nbr)\n                    self._add_edge(edges, new_node, nbr)\n                    delta = alt - nbr.cost\n                    nbr.cost = alt\n                    self._propagate_cost(nbr, delta)\n                    rewires += 1\n\n            # Try a couple of direct bridges to the other tree\n            other_near = self._nearest_bucket(grid_b, tree_b, new_node.position, rmax=2)\n            if other_near is not None:\n                cand_b = self._collect_near_nodes(grid_b, new_node.position, rewire_radius, tree_b, self.k_near)\n                if other_near not in cand_b:\n                    cand_b.append(other_near)\n                bd = [(self._dist(n.position, new_node.position), n) for n in cand_b]\n                bd.sort(key=lambda x: x[0])\n                tries = 0\n                for _, nb in bd:\n                    if tries >= 2:\n                        break\n                    if not self._segment_blocked(new_node.position, nb.position, obstacles, is_3d):\n                        path = self._finalize_path(self._merge_paths(new_node, nb, active_start), obstacles, is_3d)\n                        return PlannerResult(True, path, start_tree + goal_tree, edges)\n                    tries += 1\n\n            # Incremental connect from the other tree toward new_node\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                nxt_pos = self._steer(p.position, new_node.position, self.step_size)\n                if not self._in_bounds(nxt_pos):\n                    break\n                if self._dist(p.position, nxt_pos) < min_sep:\n                    break\n                if self._exists_near(grid_b, nxt_pos, dupe_radius):\n                    break\n                if self._point_in_obstacles(nxt_pos, obstacles, is_3d):\n                    break\n                if self._segment_blocked(p.position, nxt_pos, obstacles, is_3d):\n                    break\n                q = Node(nxt_pos, p, p.cost + self._dist(p.position, nxt_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                self._add_edge(edges, p, q)\n                self._grid_add(grid_b, q)\n                p = q\n                steps += 1\n\n                # Check if we can connect new_node and q directly\n                if not self._segment_blocked(new_node.position, p.position, obstacles, is_3d):\n                    path = self._finalize_path(self._merge_paths(new_node, p, active_start), obstacles, is_3d)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # RNG\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        r = step / max(1e-12, d)\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Grid\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_bucket(self, grid, tree, pos, rmax=2):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        found = False\n        for r in range(0, rmax + 1):\n            cand = self._collect_ring(grid, key, r)\n            if not cand:\n                continue\n            found = True\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        if found:\n            return best\n        # fallback: linear\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _collect_near_nodes(self, grid, pos, radius, tree, kmax):\n        key = self._grid_key(pos)\n        r_cells = int(max(1, radius / max(1e-9, self.grid_cell))) + 1\n        cand = self._collect_ring(grid, key, r_cells)\n        if not cand:\n            cand = list(tree)\n        # Select up to kmax nearest by distance\n        dl = []\n        for n in cand:\n            dl.append((self._dist(n.position, pos), n))\n        dl.sort(key=lambda x: x[0])\n        out = []\n        i = 0\n        while i < len(dl) and len(out) < kmax:\n            out.append(dl[i][1])\n            i += 1\n        return out\n\n    def _exists_near(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(max(1, radius / max(1e-9, self.grid_cell))) + 1\n        cand = self._collect_ring(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                return True\n        return False\n\n    # Collision\n    def _point_in_obstacles(self, p, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = p\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = p\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_blocked(self, a, b, obstacles, is_3d):\n        if is_3d:\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                aabb = (x, y, z, x + w, y + h, z + d)\n                if self._seg_box_intersect_3d(a, b, aabb):\n                    return True\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                aabb = (x, y, x + w, y + h)\n                if self._seg_box_intersect_2d(a, b, aabb):\n                    return True\n        return False\n\n    def _seg_box_intersect_2d(self, p0, p1, aabb):\n        minx, miny, maxx, maxy = aabb\n        tmin = 0.0\n        tmax = 1.0\n        dx = p1[0] - p0[0]\n        dy = p1[1] - p0[1]\n        eps = 1e-12\n\n        if abs(dx) < eps:\n            if p0[0] < minx or p0[0] > maxx:\n                return False\n        else:\n            tx1 = (minx - p0[0]) / dx\n            tx2 = (maxx - p0[0]) / dx\n            if tx1 > tx2:\n                tx1, tx2 = tx2, tx1\n            if tx1 > tmin:\n                tmin = tx1\n            if tx2 < tmax:\n                tmax = tx2\n            if tmin > tmax:\n                return False\n\n        if abs(dy) < eps:\n            if p0[1] < miny or p0[1] > maxy:\n                return False\n        else:\n            ty1 = (miny - p0[1]) / dy\n            ty2 = (maxy - p0[1]) / dy\n            if ty1 > ty2:\n                ty1, ty2 = ty2, ty1\n            if ty1 > tmin:\n                tmin = ty1\n            if ty2 < tmax:\n                tmax = ty2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    def _seg_box_intersect_3d(self, p0, p1, aabb):\n        minx, miny, minz, maxx, maxy, maxz = aabb\n        tmin = 0.0\n        tmax = 1.0\n        dx = p1[0] - p0[0]\n        dy = p1[1] - p0[1]\n        dz = p1[2] - p0[2]\n        eps = 1e-12\n\n        if abs(dx) < eps:\n            if p0[0] < minx or p0[0] > maxx:\n                return False\n        else:\n            tx1 = (minx - p0[0]) / dx\n            tx2 = (maxx - p0[0]) / dx\n            if tx1 > tx2:\n                tx1, tx2 = tx2, tx1\n            if tx1 > tmin:\n                tmin = tx1\n            if tx2 < tmax:\n                tmax = tx2\n            if tmin > tmax:\n                return False\n\n        if abs(dy) < eps:\n            if p0[1] < miny or p0[1] > maxy:\n                return False\n        else:\n            ty1 = (miny - p0[1]) / dy\n            ty2 = (maxy - p0[1]) / dy\n            if ty1 > ty2:\n                ty1, ty2 = ty2, ty1\n            if ty1 > tmin:\n                tmin = ty1\n            if ty2 < tmax:\n                tmax = ty2\n            if tmin > tmax:\n                return False\n\n        if abs(dz) < eps:\n            if p0[2] < minz or p0[2] > maxz:\n                return False\n        else:\n            tz1 = (minz - p0[2]) / dz\n            tz2 = (maxz - p0[2]) / dz\n            if tz1 > tz2:\n                tz1, tz2 = tz2, tz1\n            if tz1 > tmin:\n                tmin = tz1\n            if tz2 < tmax:\n                tmax = tz2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    # Edges and costs\n    def _add_edge(self, edges, parent, child):\n        for e in edges:\n            if e[0] is parent and e[1] is child:\n                return\n        edges.append((parent, child))\n\n    def _remove_edge(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_cost(self, node, delta):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur is not node:\n                cur.cost += delta\n            for ch in cur.children:\n                stack.append(ch)\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._point_in_obstacles(p, obstacles, is_3d):\n                return p\n\n    # Paths and smoothing\n    def _trace_to_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        path.reverse()\n        return path\n\n    def _merge_paths(self, a_node, b_node, a_is_start_tree):\n        # a_node in active tree, b_node in opposite tree\n        # Build start->goal ordering\n        if a_is_start_tree:\n            pa = self._trace_to_root(a_node)  # start -> a\n            pb = self._trace_to_root(b_node)  # goal -> b, reversed to b->goal\n            pb.reverse()\n            # Avoid duplicate meeting point if equal\n            if len(pa) > 0 and len(pb) > 0 and pa[-1] == pb[0]:\n                pb = pb[1:]\n            return pa + pb\n        else:\n            # a in goal tree, b in start tree\n            pb = self._trace_to_root(b_node)  # start -> b\n            pa = self._trace_to_root(a_node)  # goal -> a, reversed to a->goal\n            pa.reverse()\n            if len(pb) > 0 and len(pa) > 0 and pb[-1] == pa[0]:\n                pa = pa[1:]\n            return pb + pa\n\n    def _visibility_compress(self, pts, obstacles, is_3d):\n        if len(pts) <= 2:\n            return pts\n        out = [pts[0]]\n        anchor = pts[0]\n        for i in range(1, len(pts) - 1):\n            nxt = pts[i + 1]\n            if self._segment_blocked(anchor, nxt, obstacles, is_3d):\n                out.append(pts[i])\n                anchor = pts[i]\n        out.append(pts[-1])\n        return out\n\n    def _shortcut(self, pts, obstacles, is_3d, iters):\n        if len(pts) <= 2:\n            return pts\n        out = list(pts)\n        n = len(out)\n        # deterministic sweep passes + limited random jumps\n        for _ in range(max(1, iters // 3)):\n            i = 0\n            while i + 2 < n:\n                if not self._segment_blocked(out[i], out[i + 2], obstacles, is_3d):\n                    out.pop(i + 1)\n                    n -= 1\n                else:\n                    i += 1\n        # random shortcuts\n        attempts = max(1, iters) * 2\n        while attempts > 0 and n > 2:\n            attempts -= 1\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 2, n))\n            if not self._segment_blocked(out[i], out[j - 1], obstacles, is_3d):\n                out = out[:i + 1] + out[j - 1:]\n                n = len(out)\n        return out\n\n    def _finalize_path(self, path, obstacles, is_3d):\n        path = self._visibility_compress(path, obstacles, is_3d)\n        path = self._shortcut(path, obstacles, is_3d, self.smoothing_iters)\n        path = self._visibility_compress(path, obstacles, is_3d)\n        return path",
          "objective": -32.79253,
          "time_improvement": 55.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1521.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01910665035247803,
                    "num_nodes_avg": 59.8,
                    "path_length_avg": 173.35565811169963,
                    "smoothness_avg": 0.045431660067628374,
                    "success_improvement": 0.0,
                    "time_improvement": 24.041791701183453,
                    "node_improvement": 84.94082095190129,
                    "length_improvement": 4.981016792786297,
                    "smoothness_improvement": 611.1041364872717,
                    "objective_score": 13.256668268463173
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.039565300941467284,
                    "num_nodes_avg": 142.5,
                    "path_length_avg": 238.26189840651946,
                    "smoothness_avg": 0.10674399801223185,
                    "success_improvement": 0.0,
                    "time_improvement": 75.30420524774607,
                    "node_improvement": 90.42531747631526,
                    "length_improvement": 20.46132032340967,
                    "smoothness_improvement": 2646.599953448795,
                    "objective_score": 48.101053535613595
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016315269470214843,
                    "num_nodes_avg": 94.4,
                    "path_length_avg": 124.04664467622756,
                    "smoothness_avg": 0.11048733375039402,
                    "success_improvement": 0.0,
                    "time_improvement": 66.41479431078653,
                    "node_improvement": 87.99745708836618,
                    "length_improvement": 17.614125072510827,
                    "smoothness_improvement": 1305.390729978361,
                    "objective_score": 37.019866986634256
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Algorithm description: SWIFT-BiRRT-LOS \u2014 Simple, Weighted-bias, Informed, Fast Triaged Bi-directional RRT with hashed-near lookup, near-duplicate suppression, on-the-fly line-of-sight grandparent compression, light bounded connect-extend, and capped shortcut smoothing for faster, shorter, and smoother paths.",
          "planning_mechanism": "Planning mechanism: Alternate growing two trees with balanced goal/corridor/informed-biased samples. For each sample, find a hashed-nearest node, steer once, check node and edge collisions, insert if not near-duplicate and the cell is not saturated, then immediately try LOS compression to the grandparent to shorten chains. Attempt to connect to the opposite tree using a costless direct check first, then a few bounded, collision-checked extend steps. On success, merge trees and return a visibility-pruned, lightly-shortcutted path; otherwise stop on budget or stall.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=10.0,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 rings_near=2,\n                 goal_bias=0.2,\n                 corridor_bias=0.4,\n                 informed_bias=0.5,\n                 dupe_radius_ratio=0.6,\n                 cell_cap=10,\n                 connect_radius_factor=4.0,\n                 connect_steps=3,\n                 smoothing_attempts=24,\n                 stall_limit=700,\n                 edge_cache_limit=30000):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.collision_step = float(collision_step)\n        self.grid_cell = grid_cell\n        self.rings_near = int(max(1, rings_near))\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.cell_cap = int(max(2, cell_cap))\n        self.connect_radius_factor = float(max(1.0, connect_radius_factor))\n        self.connect_steps = int(max(0, connect_steps))\n        self.smoothing_attempts = int(max(0, smoothing_attempts))\n        self.stall_limit = int(max(100, stall_limit))\n        self.edge_cache_limit = int(max(2000, edge_cache_limit))\n\n        self.bounds = None\n        self.dim = 2\n        self.start = None\n        self.goal = None\n        self.edge_cache = None\n        self.edge_stamp = 0\n        self.edge_res = 1.0\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.8 * self.step_size)\n        self.edge_res = max(0.5, min(self.collision_step, 0.5 * self.step_size))\n\n        self.edge_cache = {}\n        self.edge_stamp = 0\n\n        # Early direct connection\n        if not self._edge_blocked_memo(self.start, self.goal, obstacles, is_3d):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            edges = [(n0, n1)]\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], edges)\n\n        # Initialize trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n\n        dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        connect_radius = max(self.step_size, self.connect_radius_factor * self.step_size)\n        dsg = self._dist(self.start, self.goal)\n        corridor_base = max(self.step_size, 0.2 * dsg)\n\n        best_path = None\n        best_len = float('inf')\n        last_improve = 0\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            other_root = self.goal if active_start else self.start\n\n            # Sampling strategy\n            if best_path is not None and self._rand() < self.informed_bias:\n                x_rand = self._sample_informed(best_len, obstacles, is_3d)\n            else:\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = other_root\n                elif r < self.goal_bias + self.corridor_bias:\n                    width = max(self.step_size, corridor_base + (0.1 * (best_len - dsg) if best_path is not None else 0.0))\n                    x_rand = self._sample_corridor(width, obstacles, is_3d)\n                else:\n                    x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest and steer\n            nearest = self._nearest(grid1, tree1, x_rand)\n            if nearest is None:\n                continue\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._exists_close(grid1, new_pos, dupe_radius):\n                continue\n            if not self._cell_accept(grid1, new_pos):\n                continue\n            if self._edge_blocked_memo(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Insert node\n            new_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            self._grid_add(grid1, new_node)\n            edges.append((nearest, new_node))\n\n            # LOS grandparent compression\n            gp = nearest.parent\n            if gp is not None and not self._edge_blocked_memo(gp.position, new_pos, obstacles, is_3d):\n                # reparent new_node to grandparent\n                try:\n                    nearest.children.remove(new_node)\n                except:\n                    pass\n                self._remove_edge(edges, nearest, new_node)\n                gp.add_child(new_node)\n                new_node.cost = gp.cost + self._dist(gp.position, new_pos)\n                edges.append((gp, new_node))\n\n            # Try connect to opposite tree (direct first, then bounded extend)\n            qnear = self._nearest(grid2, tree2, new_node.position)\n            if qnear is not None and self._dist(qnear.position, new_node.position) <= connect_radius:\n                if not self._edge_blocked_memo(new_node.position, qnear.position, obstacles, is_3d):\n                    a_end = new_node\n                    b_end = qnear\n                else:\n                    a_end, b_end = self._bounded_connect_extend(new_node, tree2, grid2, dupe_radius, obstacles, is_3d, edges, nodes)\n                if a_end is not None and b_end is not None:\n                    path = self._merge_paths(a_end, b_end) if active_start else self._merge_paths(b_end, a_end)\n                    plen = self._path_length(path)\n                    if plen < best_len:\n                        best_path = path\n                        best_len = plen\n                        last_improve = it\n                    final = self._finalize_path(best_path, obstacles, is_3d)\n                    return PlannerResult(True, final, nodes, edges)\n\n            if best_path is not None and (it - last_improve) >= self.stall_limit:\n                final = self._finalize_path(best_path, obstacles, is_3d)\n                return PlannerResult(True, final, nodes, edges)\n\n        if best_path is not None:\n            final = self._finalize_path(best_path, obstacles, is_3d)\n            return PlannerResult(True, final, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG (deterministic)\n    def _rand(self):\n        if not hasattr(self, \"_rng\"):\n            self._rng = 987654321\n        self._rng = (1103515245 * self._rng + 12345) % (1 << 31)\n        return (self._rng & 0x7fffffff) / float(1 << 31)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp_tuple(b)\n        if d <= 1e-12:\n            return self._clamp_tuple(a)\n        r = step / d\n        return self._clamp_tuple(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_exact(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked_memo(self, a, b, obstacles, is_3d):\n        key = self._edge_key_exact(a, b)\n        st = self.edge_cache.get(key)\n        if st is not None:\n            return st[0] == 1\n        blocked = self._edge_blocked(a, b, obstacles, is_3d)\n        self.edge_stamp += 1\n        self.edge_cache[key] = (1 if blocked else 2, self.edge_stamp)\n        if len(self.edge_cache) > self.edge_cache_limit:\n            cutoff = self.edge_stamp - (self.edge_cache_limit // 2)\n            self.edge_cache = {k: v for k, v in self.edge_cache.items() if v[1] >= cutoff}\n        return blocked\n\n    # Spatial hashing\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.rings_near + 1):\n            cand = self._ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback random subset\n        if tree:\n            k = min(16, len(tree))\n            for _ in range(k):\n                idx = int(self._uniform(0, len(tree)))\n                n = tree[idx % len(tree)]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius // self.grid_cell) + 1\n        cand = self._ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    def _cell_accept(self, grid, pos):\n        key = self._grid_key(pos)\n        lst = grid.get(key)\n        if lst is None:\n            return True\n        return len(lst) < self.cell_cap\n\n    # Connect helpers\n    def _bounded_connect_extend(self, new_node, other_tree, other_grid, dupe_radius, obstacles, is_3d, edges, nodes):\n        q = self._nearest(other_grid, other_tree, new_node.position)\n        if q is None:\n            return (None, None)\n        cur = q\n        for _ in range(self.connect_steps):\n            nxt_pos = self._steer(cur.position, new_node.position, self.step_size)\n            if not self._in_bounds(nxt_pos):\n                break\n            if self._is_in_obstacle(nxt_pos, obstacles, is_3d):\n                break\n            if self._exists_close(other_grid, nxt_pos, dupe_radius):\n                break\n            if self._edge_blocked_memo(cur.position, nxt_pos, obstacles, is_3d):\n                break\n            nxt = Node(nxt_pos, cur, cur.cost + self._dist(cur.position, nxt_pos))\n            cur.add_child(nxt)\n            other_tree.append(nxt)\n            nodes.append(nxt)\n            self._grid_add(other_grid, nxt)\n            edges.append((cur, nxt))\n            # LOS compression toward grandparent\n            gp = cur.parent\n            if gp is not None and not self._edge_blocked_memo(gp.position, nxt_pos, obstacles, is_3d):\n                try:\n                    cur.children.remove(nxt)\n                except:\n                    pass\n                self._remove_edge(edges, cur, nxt)\n                gp.add_child(nxt)\n                nxt.cost = gp.cost + self._dist(gp.position, nxt_pos)\n                edges.append((gp, nxt))\n            cur = nxt\n            if not self._edge_blocked_memo(cur.position, new_node.position, obstacles, is_3d):\n                return (new_node, cur)\n        return (None, None)\n\n    # Path utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_paths(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        pb.reverse()\n        return pa + pb\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _remove_edge(self, edges, a, b):\n        for i in range(len(edges)):\n            if edges[i][0] is a and edges[i][1] is b:\n                edges.pop(i)\n                return\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked_memo(pruned[-1], path[j], obstacles, is_3d):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _smooth_path(self, path, obstacles, is_3d, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return list(path)\n        pts = list(path)\n        best_len = self._path_length(pts)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and n >= 3:\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked_memo(a, b, obstacles, is_3d):\n                new_pts = pts[:i + 1] + pts[j:]\n                new_len = self._path_length(new_pts)\n                if new_len + 1e-9 < best_len:\n                    pts = new_pts\n                    best_len = new_len\n                    n = len(pts)\n            tries += 1\n        return pts\n\n    def _finalize_path(self, path, obstacles, is_3d):\n        if not path:\n            return []\n        pruned = self._visibility_prune(path, obstacles, is_3d)\n        return self._smooth_path(pruned, obstacles, is_3d, self.smoothing_attempts)\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        for _ in range(64):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        if self.dim == 3:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5, self.bounds[2] * 0.5)\n        else:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5)\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        tries = 0\n        while tries < 24:\n            if self.dim == 3:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                else:\n                    tries += 1\n                    continue\n            else:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                else:\n                    tries += 1\n                    continue\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n            tries += 1\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d):\n        for _ in range(48):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if (self._dist(self.start, p) + self._dist(p, self.goal) <= best_len + 1e-9 and\n                not self._is_in_obstacle(p, obstacles, is_3d)):\n                return p\n        return self._sample_corridor(max(self.step_size, 0.2 * self._dist(self.start, self.goal)), obstacles, is_3d)",
          "objective": -32.12619,
          "time_improvement": 59.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 1812.0,
          "node_improvement": 91.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01643836498260498,
                    "num_nodes_avg": 47.5,
                    "path_length_avg": 172.57597716951437,
                    "smoothness_avg": 0.055340882959087935,
                    "success_improvement": 0.0,
                    "time_improvement": 35.532778493067305,
                    "node_improvement": 88.03827751196172,
                    "length_improvement": 5.408372272033185,
                    "smoothness_improvement": 766.2049929605337,
                    "objective_score": 17.73588187594277
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.024622559547424316,
                    "num_nodes_avg": 81.2,
                    "path_length_avg": 250.16418359040821,
                    "smoothness_avg": 0.12448872572717391,
                    "success_improvement": 0.0,
                    "time_improvement": 84.62985642705796,
                    "node_improvement": 94.5441107303635,
                    "length_improvement": 16.487994940743906,
                    "smoothness_improvement": 3103.1845785650153,
                    "objective_score": 50.7976767853888
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.020916748046875,
                    "num_nodes_avg": 75.5,
                    "path_length_avg": 143.54340806097915,
                    "smoothness_avg": 0.13110948178151688,
                    "success_improvement": 0.0,
                    "time_improvement": 57.35770095388541,
                    "node_improvement": 90.40050858232676,
                    "length_improvement": 4.665303168464438,
                    "smoothness_improvement": 1567.7029307656137,
                    "objective_score": 27.845006841072355
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SWIFT-Connect-S: A simplified, fast, and robust bidirectional RRT-Connect with bounded collision memoization, hash-grid nearest search, informed sampling after a provisional path, limited greedy bridging, and shallow multi-ancestor line-of-sight compression. It minimizes redundant checks and data churn for stable, low-latency planning while maintaining high path quality and smoothness.",
          "planning_mechanism": "Alternate expansion of two trees toward sampled targets (goal-biased/uniform; ellipse-informed once a path exists). For each step, pick the nearest by grid, steer once, and add only if both node and edge are free (cached). After insertion, compress up to a few ancestors via LOS to shorten trees, then attempt a short capped greedy connect from the opposite tree; if connected, extract and quickly shortcut-smooth with early stop and return. Bounded caches and light structures keep iterations fast and consistent.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=8.0,\n                 goal_bias=0.15,\n                 informed_bias=0.60,\n                 grid_cell_factor=1.5,\n                 ring_limit=2,\n                 dup_radius_ratio=0.45,\n                 connect_cap=3,\n                 connect_step_factor=1.5,\n                 compress_depth=3,\n                 edge_res=1.0,\n                 edge_cache_max=50000,\n                 point_cache_max=60000,\n                 smoothing_iters=60,\n                 smooth_patience=12):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.informed_bias = informed_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.ring_limit = ring_limit\n        self.dup_radius_ratio = dup_radius_ratio\n        self.connect_cap = connect_cap\n        self.connect_step_factor = connect_step_factor\n        self.compress_depth = compress_depth\n        self.edge_res = edge_res\n        self.edge_cache_max = max(1000, int(edge_cache_max))\n        self.point_cache_max = max(1000, int(point_cache_max))\n        self.smoothing_iters = smoothing_iters\n        self.smooth_patience = smooth_patience\n\n        self.dim = 2\n        self.bounds = None\n        self.is_3d = False\n\n        self.cell = 1.0\n        self.q_point = 0.5\n        self.q_edge = 1.0\n\n        self._edge_cache = {}\n        self._point_cache = {}\n        self._rng_state = 2463534242\n\n        self.start = None\n        self.goal = None\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Quantization and grid\n        self.cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self.q_point = max(0.5, self.edge_res * 0.5)\n        self.q_edge = max(1.0, self.edge_res)\n\n        # reset caches\n        self._edge_cache = {}\n        self._point_cache = {}\n\n        # start/goal validity\n        if not self._point_free(self.start, obstacles) or not self._point_free(self.goal, obstacles):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight connection\n        if self._edge_free(self.start, self.goal, obstacles):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        best_len = float('inf')\n        d_sg = self._dist(self.start, self.goal)\n        dup_radius = max(0.5, self.step_size * self.dup_radius_ratio)\n\n        for it in range(self.max_iter):\n            grow_from_start = (it % 2 == 0)\n            tree1 = tree_a if grow_from_start else tree_b\n            tree2 = tree_b if grow_from_start else tree_a\n            grid1 = grid_a if grow_from_start else grid_b\n            grid2 = grid_b if grow_from_start else grid_a\n            other_root_pos = self.goal if grow_from_start else self.start\n\n            # Sample a target\n            if best_len < float('inf') and self._rand() < self.informed_bias:\n                x_rand = self._sample_informed(best_len, obstacles)\n            else:\n                if self._rand() < self.goal_bias:\n                    x_rand = other_root_pos\n                else:\n                    x_rand = self._sample_free(obstacles)\n\n            # Nearest and steer\n            near = self._nearest_by_grid(tree1, grid1, x_rand)\n            if near is None:\n                continue\n            x_new = self._steer(near.position, x_rand, self.step_size)\n            if not self._in_bounds(x_new):\n                continue\n            if self._has_near_duplicate(grid1, x_new, dup_radius):\n                continue\n\n            # Mandatory checks before insertion\n            if not self._point_free(x_new, obstacles):\n                continue\n            if not self._edge_free(near.position, x_new, obstacles):\n                continue\n\n            # Insert node\n            new_cost = near.cost + self._dist(near.position, x_new)\n            new_node = Node(x_new, near, new_cost)\n            near.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((near, new_node))\n            self._grid_insert(grid1, new_node)\n\n            # Shallow multi-ancestor LOS compression\n            self._compress_chain(new_node, obstacles, edges, self.compress_depth)\n\n            # Attempt to connect the other tree\n            other_near = self._nearest_by_grid(tree2, grid2, new_node.position)\n            connected = False\n            last_other = other_near\n\n            # Direct bridge first\n            if other_near is not None and self._edge_free(new_node.position, other_near.position, obstacles):\n                connected = True\n                last_other = other_near\n            else:\n                # Limited greedy connect from the other tree toward new_node\n                current = other_near\n                for _ in range(self.connect_cap):\n                    if current is None:\n                        break\n                    step = self.step_size * self.connect_step_factor\n                    nxt_pos = self._steer(current.position, new_node.position, step)\n                    if not self._in_bounds(nxt_pos):\n                        break\n                    if self._has_near_duplicate(grid2, nxt_pos, dup_radius):\n                        break\n                    if not self._point_free(nxt_pos, obstacles):\n                        break\n                    if not self._edge_free(current.position, nxt_pos, obstacles):\n                        break\n                    nxt_cost = current.cost + self._dist(current.position, nxt_pos)\n                    nxt_node = Node(nxt_pos, current, nxt_cost)\n                    current.add_child(nxt_node)\n                    tree2.append(nxt_node)\n                    nodes.append(nxt_node)\n                    edges.append((current, nxt_node))\n                    self._grid_insert(grid2, nxt_node)\n                    self._compress_chain(nxt_node, obstacles, edges, self.compress_depth)\n                    last_other = nxt_node\n                    # Try to close the bridge\n                    if self._edge_free(new_node.position, last_other.position, obstacles):\n                        connected = True\n                        break\n                    current = nxt_node\n\n            if connected:\n                path = self._extract_path(new_node, last_other, grow_from_start)\n                best_len = self._path_length(path)\n                path = self._smooth_path(path, obstacles, self.smoothing_iters, self.smooth_patience)\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._rng_state = (1664525 * self._rng_state + 1013904223) % (1 << 32)\n        return self._rng_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp_tuple(b)\n        if d <= 1e-12:\n            return self._clamp_tuple(a)\n        r = step / d\n        return self._clamp_tuple(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    # Collision and caching\n    def _qpos(self, p, q):\n        return tuple(int(p[i] // q) for i in range(self.dim))\n\n    def _edge_key(self, a, b, q):\n        qa = self._qpos(a, q)\n        qb = self._qpos(b, q)\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _point_key(self, p, q):\n        return self._qpos(p, q)\n\n    def _point_free(self, p, obstacles):\n        key = self._point_key(p, self.q_point)\n        cached = self._point_cache.get(key)\n        if cached is not None:\n            return cached\n        free = True\n        if self.is_3d:\n            px, py, pz = p\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    free = False\n                    break\n        else:\n            px, py = p\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    free = False\n                    break\n        self._point_cache[key] = free\n        if len(self._point_cache) > self.point_cache_max:\n            self._prune_half(self._point_cache)\n        return free\n\n    def _edge_free(self, a, b, obstacles):\n        key = self._edge_key(a, b, self.q_edge)\n        cached = self._edge_cache.get(key)\n        if cached is not None:\n            return cached\n        d = self._dist(a, b)\n        steps = int(d / self.edge_res)\n        if steps < 1:\n            steps = 1\n        free = True\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if not self._point_free(p, obstacles):\n                free = False\n                break\n        self._edge_cache[key] = free\n        if len(self._edge_cache) > self.edge_cache_max:\n            self._prune_half(self._edge_cache)\n        return free\n\n    def _prune_half(self, dct):\n        cnt = 0\n        to_del = []\n        for k in dct:\n            if (cnt % 2) == 0:\n                to_del.append(k)\n            cnt += 1\n            if len(to_del) >= len(dct) // 2:\n                break\n        for k in to_del:\n            try:\n                del dct[k]\n            except:\n                pass\n\n    # Spatial hash\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell) for i in range(self.dim))\n\n    def _grid_insert(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _nearest_by_grid(self, tree, grid, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        if self.dim == 3:\n            for r in range(self.ring_limit + 1):\n                found = False\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                            if b:\n                                for n in b:\n                                    d = self._dist(n.position, pos)\n                                    if d < bestd:\n                                        bestd = d\n                                        best = n\n                                        found = True\n                if found and best is not None:\n                    return best\n        else:\n            for r in range(self.ring_limit + 1):\n                found = False\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy))\n                        if b:\n                            for n in b:\n                                d = self._dist(n.position, pos)\n                                if d < bestd:\n                                    bestd = d\n                                    best = n\n                                    found = True\n                if found and best is not None:\n                    return best\n        # fallback\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _has_near_duplicate(self, grid, pos, radius):\n        rng = int(max(1, radius // self.cell)) + 1\n        key = self._grid_key(pos)\n        r2 = radius * radius\n        if self.dim == 3:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            s = 0.0\n                            for i in range(self.dim):\n                                d = n.position[i] - pos[i]\n                                s += d * d\n                            if s <= r2:\n                                return True\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        s = 0.0\n                        for i in range(self.dim):\n                            d = n.position[i] - pos[i]\n                            s += d * d\n                        if s <= r2:\n                            return True\n        return False\n\n    # Sampling\n    def _sample_free(self, obstacles):\n        for _ in range(64):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and self._point_free(p, obstacles):\n                return p\n        return self._clamp_tuple(self.start)\n\n    def _sample_informed(self, best_len, obstacles):\n        # Rejection sample within the prolate ellipse defined by start/goal foci and perimeter best_len\n        for _ in range(48):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= best_len + 1e-9 and self._point_free(p, obstacles):\n                return p\n        # Fallback to uniform free if ellipse sampling failed\n        return self._sample_free(obstacles)\n\n    # Compression utilities\n    def _compress_chain(self, node, obstacles, edges, depth_limit):\n        depth = 0\n        cur = node\n        while depth < depth_limit:\n            p = cur.parent\n            if p is None:\n                break\n            gp = p.parent\n            if gp is None:\n                break\n            if not self._edge_free(gp.position, cur.position, obstacles):\n                break\n            # reparent\n            p.remove_child(cur)\n            self._edges_remove(edges, p, cur)\n            gp.add_child(cur)\n            edges.append((gp, cur))\n            old_cost = cur.cost\n            cur.cost = gp.cost + self._dist(gp.position, cur.position)\n            delta = cur.cost - old_cost\n            if abs(delta) > 1e-12:\n                self._propagate_cost(cur, delta)\n            depth += 1\n\n    def _propagate_cost(self, node, delta):\n        # Update subtree costs after reparenting\n        stack = list(node.children)\n        while stack:\n            n = stack.pop()\n            n.cost += delta\n            for c in n.children:\n                stack.append(c)\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # Paths and smoothing\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a, b, a_from_start):\n        # a is in the active tree (tree1), b in the opposite tree (tree2)\n        pa = self._path_to_root(a)\n        pb = []\n        cur = b\n        while cur is not None:\n            pb.append(cur.position)\n            cur = cur.parent\n        # If growing from start, pb goes b..goal; else b..start; concatenation stays correct\n        return pa + pb\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _smooth_path(self, path, obstacles, iters, patience):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        best_len = self._path_length(pts)\n        no_improve = 0\n        for _ in range(iters):\n            if len(pts) < 3:\n                break\n            i = int(self._uniform(0, len(pts) - 2))\n            j = int(self._uniform(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                continue\n            if self._edge_free(pts[i], pts[j], obstacles):\n                new_pts = pts[:i + 1] + pts[j:]\n                new_len = self._path_length(new_pts)\n                if new_len + 1e-9 < best_len:\n                    pts = new_pts\n                    best_len = new_len\n                    no_improve = 0\n                else:\n                    no_improve += 1\n            else:\n                no_improve += 1\n            if no_improve >= patience:\n                break\n        # forward LOS collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            k = 1\n            while k < len(pts) - 1:\n                nxt = pts[k + 1]\n                if self._edge_free(last, nxt, obstacles):\n                    k += 1\n                else:\n                    collapsed.append(pts[k])\n                    last = pts[k]\n                    k += 1\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
          "objective": -32.04681,
          "time_improvement": 57.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1606.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0160780668258667,
                    "num_nodes_avg": 54.5,
                    "path_length_avg": 178.9081741619695,
                    "smoothness_avg": 0.051583685968640866,
                    "success_improvement": 0.0,
                    "time_improvement": 36.94577918404633,
                    "node_improvement": 86.27549735582977,
                    "length_improvement": 1.9375947603861294,
                    "smoothness_improvement": 707.3967011761849,
                    "objective_score": 15.783274117326503
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027580070495605468,
                    "num_nodes_avg": 100.1,
                    "path_length_avg": 240.86804814126344,
                    "smoothness_avg": 0.10972615466856887,
                    "success_improvement": 0.0,
                    "time_improvement": 82.78368898030901,
                    "node_improvement": 93.27420546932743,
                    "length_improvement": 19.59131252809127,
                    "smoothness_improvement": 2723.332992176965,
                    "objective_score": 50.20655917183229
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024082136154174805,
                    "num_nodes_avg": 106.1,
                    "path_length_avg": 130.6210437346923,
                    "smoothness_avg": 0.11683429429214313,
                    "success_improvement": 0.0,
                    "time_improvement": 50.90452639893067,
                    "node_improvement": 86.50985378258105,
                    "length_improvement": 13.24772225711989,
                    "smoothness_improvement": 1386.1235995855145,
                    "objective_score": 30.150609271878707
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "QUILL-IBIT*: Quasi-Uniform Informed Bi-directional Incremental Tree-star. It grows two trees guided by low-discrepancy Halton sampling and adaptive corridor/elliptic domains once a solution exists. Parent choice and rewiring use hash-grid neighbors with an angle-aware tie-break while storing pure path-length costs. Collision checks are accelerated by a capacity-bounded cache and slab AABB tests with fast segment-AABB rejection. The planner uses progressive backoff stepping, cycle-safe rewiring, and micro-bridging between trees. Upon connection it performs greedy visibility pruning and corner rounding to return short, smooth paths quickly.",
          "planning_mechanism": "Alternate tree growth. Each iteration: sample (goal/corridor/halton or informed ellipse), find a hash-grid nearest, advance via progressive backoff, validate node and edge, select the best parent among nearby neighbors, insert and rewire (cycle-safe). Attempt a direct or short-step connect to the other tree. On first bridge, extract, greedily visibility-prune, then corner-round and return. Collision queries use cached slab AABB tests.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = None\n        self.children = []\n        self.cost = float(cost)\n        if parent is not None:\n            self.attach(parent)\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            # detach from old\n            plist = self.parent.children\n            for i in range(len(plist) - 1, -1, -1):\n                if plist[i] is self:\n                    plist.pop(i)\n                    break\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=6.0,\n        min_step=1.5,\n        goal_bias=0.18,\n        corridor_bias=0.55,\n        ellipse_bias=0.65,\n        grid_cell_factor=1.5,\n        neighbor_factor=2.2,\n        neighbor_cap=28,\n        dup_radius_ratio=0.45,\n        connect_steps=6,\n        heur_gate=1.02,\n        cache_capacity=100000,\n        smooth_iters=60,\n        corner_round_strength=0.35\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.min_step = float(min_step)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.ellipse_bias = float(ellipse_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neighbor_factor = float(neighbor_factor)\n        self.neighbor_cap = int(neighbor_cap)\n        self.dup_radius_ratio = float(dup_radius_ratio)\n        self.connect_steps = int(connect_steps)\n        self.heur_gate = float(heur_gate)\n        self.cache_capacity = int(cache_capacity)\n        self.smooth_iters = int(smooth_iters)\n        self.corner_round_strength = float(corner_round_strength)\n\n        self.dim = 2\n        self.bounds = None\n\n        # RNG and sampling\n        self._seed = 0x9E3779B97F4A7C15\n        self._halton_idx = 1\n\n        # Collision cache\n        self._edge_free_cache = {}\n        self._edge_block_cache = {}\n        self._cache_keys = []\n        self._cache_bin = 1.0\n\n        # Trees, grids, edges\n        self._edges = []\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        obstacles = list(map.obstacles)\n        is_3d = (self.dim == 3)\n\n        # init\n        self._seed = 0x9E3779B97F4A7C15\n        self._halton_idx = 1\n        self._edge_free_cache = {}\n        self._edge_block_cache = {}\n        self._cache_keys = []\n        self._cache_bin = max(0.5, 0.5 * self.step_size)\n        self._edges = []\n\n        # sanity\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_blocked(start, obstacles, is_3d) or self._point_blocked(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # quick straight-line\n        if self._edge_free(start, goal, obstacles, is_3d):\n            n0 = Node(start, None, 0.0)\n            n1 = Node(goal, n0, self._dist(start, goal))\n            self._edges = [(n0, n1)]\n            return PlannerResult(True, [start, goal], [n0, n1], self._edges)\n\n        # parameters\n        dsg = self._dist(start, goal)\n        cell = max(1.0, self.step_size * self.grid_cell_factor)\n        dup_r = max(0.5, self.step_size * self.dup_radius_ratio)\n        corridor_w = max(self.step_size * 1.2, 0.25 * dsg)\n\n        # roots\n        s_root = Node(start, None, 0.0)\n        g_root = Node(goal, None, 0.0)\n\n        tree_a = [s_root]\n        tree_b = [g_root]\n        nodes_all = [s_root, g_root]\n\n        grid_a = {}\n        grid_b = {}\n        self._grid_add(grid_a, s_root, cell)\n        self._grid_add(grid_b, g_root, cell)\n\n        c_best = float('inf')\n        have_solution = False\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            if active_start:\n                nodes_x, nodes_y = tree_a, tree_b\n                grid_x, grid_y = grid_a, grid_b\n                root_x, root_y = s_root, g_root\n                attractor = goal\n            else:\n                nodes_x, nodes_y = tree_b, tree_a\n                grid_x, grid_y = grid_b, grid_a\n                root_x, root_y = g_root, s_root\n                attractor = start\n\n            # Sample\n            r = self._rand()\n            if r < self.goal_bias:\n                x_rand = attractor\n            else:\n                if have_solution and self._rand() < self.ellipse_bias:\n                    x_rand = self._sample_informed_ellipse(root_x.position, root_y.position, c_best, obstacles, is_3d)\n                elif self._rand() < self.corridor_bias:\n                    x_rand = self._sample_corridor(root_x.position, root_y.position, corridor_w, obstacles, is_3d)\n                else:\n                    x_rand = self._halton_sample(obstacles, is_3d)\n\n            # Nearest\n            n_near = self._nearest(grid_x, nodes_x, x_rand, cell)\n            if n_near is None:\n                continue\n\n            # Advance with progressive backoff\n            x_try = self._advance(n_near.position, x_rand, obstacles, is_3d)\n            if x_try is None:\n                continue\n\n            if not self._in_bounds(x_try):\n                continue\n            if self._point_blocked(x_try, obstacles, is_3d):\n                continue\n            if self._near_duplicate(grid_x, x_try, dup_r, cell):\n                continue\n            if not self._edge_free(n_near.position, x_try, obstacles, is_3d):\n                continue\n\n            # Heuristic gate\n            g_new_pre = n_near.cost + self._dist(n_near.position, x_try)\n            f_gate = g_new_pre + self._dist(x_try, root_y.position)\n            if have_solution and f_gate >= c_best * self.heur_gate:\n                continue\n\n            # Parent selection among neighbors (angle-aware tie-breaker), store pure length\n            neigh_r = self._neighbor_radius(len(nodes_x))\n            neigh = self._neighbors(grid_x, x_try, neigh_r, cell, self.neighbor_cap)\n            parent, g_new = self._choose_parent(n_near, neigh, x_try, obstacles, is_3d)\n            if parent is None:\n                continue\n            if self._point_blocked(x_try, obstacles, is_3d):\n                continue\n            if not self._edge_free(parent.position, x_try, obstacles, is_3d):\n                continue\n\n            # Insert node\n            new_node = Node(x_try, parent, g_new)\n            nodes_x.append(new_node)\n            nodes_all.append(new_node)\n            self._grid_add(grid_x, new_node, cell)\n            self._edges.append((parent, new_node))\n\n            # Rewire neighbors (cycle-safe)\n            self._rewire_around(new_node, neigh, obstacles, is_3d)\n\n            # Attempt to connect to the other tree\n            other = self._nearest(grid_y, nodes_y, new_node.position, cell)\n            bridged = None\n            if other is not None and self._edge_free(new_node.position, other.position, obstacles, is_3d):\n                bridged = other\n            else:\n                cur = other\n                steps = 0\n                while cur is not None and steps < self.connect_steps:\n                    nxt_pos = self._advance(cur.position, new_node.position, obstacles, is_3d)\n                    if nxt_pos is None:\n                        break\n                    if not self._in_bounds(nxt_pos):\n                        break\n                    if self._point_blocked(nxt_pos, obstacles, is_3d):\n                        break\n                    if self._near_duplicate(grid_y, nxt_pos, dup_r, cell):\n                        break\n                    g2_pre = cur.cost + self._dist(cur.position, nxt_pos)\n                    f2 = g2_pre + self._dist(nxt_pos, root_x.position)\n                    if have_solution and f2 >= c_best * self.heur_gate:\n                        break\n                    # choose parent for the new step in other tree\n                    neigh_b = self._neighbors(grid_y, nxt_pos, neigh_r, cell, self.neighbor_cap)\n                    p_b, g2 = self._choose_parent(cur, neigh_b, nxt_pos, obstacles, is_3d)\n                    if p_b is None:\n                        break\n                    if self._point_blocked(nxt_pos, obstacles, is_3d):\n                        break\n                    if not self._edge_free(p_b.position, nxt_pos, obstacles, is_3d):\n                        break\n                    nxt = Node(nxt_pos, p_b, g2)\n                    nodes_y.append(nxt)\n                    nodes_all.append(nxt)\n                    self._grid_add(grid_y, nxt, cell)\n                    self._edges.append((p_b, nxt))\n                    self._rewire_around(nxt, neigh_b, obstacles, is_3d)\n\n                    cur = nxt\n                    steps += 1\n\n                    if self._edge_free(cur.position, new_node.position, obstacles, is_3d):\n                        bridged = cur\n                        break\n\n            if bridged is not None:\n                # Build path\n                if active_start:\n                    a_path = self._path_to_root(new_node)\n                    b_path = self._path_to_root(bridged)\n                    path = a_path + list(reversed(b_path))\n                else:\n                    a_path = self._path_to_root(new_node)\n                    b_path = self._path_to_root(bridged)\n                    path = b_path + list(reversed(a_path))\n\n                # Post-process: greedy visibility then corner rounding\n                path = self._greedy_visibility(path, obstacles, is_3d)\n                path = self._corner_round(path, obstacles, is_3d, self.smooth_iters, self.corner_round_strength)\n\n                L = self._path_length(path)\n                c_best = L\n                have_solution = True\n\n                # finalize edges from existing nodes_all\n                edges = []\n                for n in nodes_all:\n                    if n.parent is not None:\n                        edges.append((n.parent, n))\n                return PlannerResult(True, path, nodes_all, edges)\n\n        edges = []\n        for n in nodes_all:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        return PlannerResult(False, [], nodes_all, edges)\n\n    # ---- Geometry / utilities ----\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        out = []\n        for i in range(self.dim):\n            v = p[i]\n            if v < 0.0:\n                v = 0.0\n            elif v > self.bounds[i]:\n                v = self.bounds[i]\n            out.append(v)\n        return tuple(out)\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        r = step / max(1e-9, d)\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _path_to_root(self, node):\n        seq = []\n        cur = node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i-1], path[i])\n        return L\n\n    # ---- RNG and sampling ----\n    def _rand(self):\n        # 64-bit LCG\n        self._seed = (6364136223846793005 * self._seed + 1442695040888963407) & ((1 << 64) - 1)\n        return (self._seed >> 11) / float(1 << 53)\n\n    def _halton_value(self, index, base):\n        f = 1.0\n        r = 0.0\n        i = index\n        while i > 0:\n            f /= base\n            r += f * (i % base)\n            i //= base\n        return r\n\n    def _halton_sample(self, obstacles, is_3d):\n        # advance until a free point\n        bases = [2, 3, 5]\n        tries = 0\n        while True:\n            h = []\n            for d in range(self.dim):\n                v = self._halton_value(self._halton_idx, bases[d])\n                h.append(v * self.bounds[d])\n            self._halton_idx += 1\n            p = tuple(h)\n            if not self._point_blocked(p, obstacles, is_3d):\n                return p\n            tries += 1\n            if tries > 20:\n                # fallback uniform\n                u = []\n                for d in range(self.dim):\n                    u.append(self._rand() * self.bounds[d])\n                p2 = tuple(u)\n                if not self._point_blocked(p2, obstacles, is_3d):\n                    return p2\n\n    def _sample_corridor(self, a, b, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(a[i] + t * (b[i] - a[i]) for i in range(self.dim))\n        if self.dim == 2:\n            ax, ay = a\n            bx, by = b\n            vx = bx - ax\n            vy = by - ay\n            n = (vx * vx + vy * vy) ** 0.5\n            if n <= 1e-9:\n                p = (self._rand() * self.bounds[0], self._rand() * self.bounds[1])\n            else:\n                vx /= n\n                vy /= n\n                # perpendicular\n                px, py = -vy, vx\n                mag = (self._rand() * 2.0 - 1.0) * width\n                p = (base[0] + px * mag, base[1] + py * mag)\n        else:\n            # random vector orthogonal to AB\n            v = tuple(b[i] - a[i] for i in range(3))\n            vn = (v[0]*v[0] + v[1]*v[1] + v[2]*v[2]) ** 0.5\n            if vn <= 1e-9:\n                p = (self._rand()*self.bounds[0], self._rand()*self.bounds[1], self._rand()*self.bounds[2])\n            else:\n                v = (v[0]/vn, v[1]/vn, v[2]/vn)\n                r = (self._rand()*2.0-1.0, self._rand()*2.0-1.0, self._rand()*2.0-1.0)\n                dot = r[0]*v[0] + r[1]*v[1] + r[2]*v[2]\n                u = (r[0]-dot*v[0], r[1]-dot*v[1], r[2]-dot*v[2])\n                un = (u[0]*u[0] + u[1]*u[1] + u[2]*u[2]) ** 0.5\n                if un <= 1e-9:\n                    u = (v[1], -v[0], 0.0)\n                    un = (u[0]*u[0] + u[1]*u[1] + u[2]*u[2]) ** 0.5\n                u = (u[0]/un, u[1]/un, u[2]/un)\n                mag = (self._rand()*2.0 - 1.0) * width\n                p = (base[0] + u[0]*mag, base[1] + u[1]*mag, base[2] + u[2]*mag)\n        p = self._clamp(p)\n        if self._point_blocked(p, obstacles, is_3d):\n            return self._halton_sample(obstacles, is_3d)\n        return p\n\n    def _sample_informed_ellipse(self, a, b, c_best, obstacles, is_3d):\n        # reject-sample inside ellipse: dist(p,a) + dist(p,b) <= c_best\n        tries = 18\n        for _ in range(tries):\n            p = self._halton_sample(obstacles, is_3d)\n            if self._dist(p, a) + self._dist(p, b) <= c_best + 1e-9:\n                return p\n        # widen to corridor if rejection failed\n        w = max(self.step_size, 0.15 * c_best)\n        return self._sample_corridor(a, b, w, obstacles, is_3d)\n\n    # ---- Grid / NN ----\n    def _cell_key(self, pos, cell):\n        if self.dim == 3:\n            return (int(pos[0] // cell), int(pos[1] // cell), int(pos[2] // cell))\n        else:\n            return (int(pos[0] // cell), int(pos[1] // cell))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._cell_key(node.position, cell)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect(self, grid, key, ring):\n        out = []\n        if self.dim == 3:\n            for dx in range(-ring, ring + 1):\n                for dy in range(-ring, ring + 1):\n                    for dz in range(-ring, ring + 1):\n                        b = grid.get((key[0]+dx, key[1]+dy, key[2]+dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-ring, ring + 1):\n                for dy in range(-ring, ring + 1):\n                    b = grid.get((key[0]+dx, key[1]+dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, nodes, pos, cell):\n        key = self._cell_key(pos, cell)\n        best = None\n        bestd = float('inf')\n        found = False\n        for r in range(0, 3):\n            cand = self._grid_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            if best is not None:\n                found = True\n                break\n        if not found and nodes:\n            # sparse fallback: stride sampling\n            stride = max(1, len(nodes) // min(96, len(nodes)))\n            for i in range(0, len(nodes), stride):\n                n = nodes[i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, cell, cap):\n        ring = int(radius // cell) + 1\n        cand = self._grid_collect(grid, self._cell_key(pos, cell), ring)\n        out = []\n        rr = radius + 1e-9\n        for n in cand:\n            d = self._dist(n.position, pos)\n            if d <= rr:\n                out.append((d, n))\n        out.sort(key=lambda x: x[0])\n        return [n for (_, n) in out[:cap]]\n\n    def _neighbor_radius(self, ncount):\n        base = self.neighbor_factor * self.step_size\n        if ncount < 256:\n            return base * 2.0\n        if ncount < 1024:\n            return base * 1.6\n        return base * 1.3\n\n    def _near_duplicate(self, grid, pos, radius, cell):\n        cand = self._neighbors(grid, pos, radius, cell, 8)\n        return len(cand) > 0\n\n    # ---- Progressive step ----\n    def _advance(self, from_pos, toward, obstacles, is_3d):\n        step = self.step_size\n        while step >= self.min_step:\n            cand = self._steer(from_pos, toward, step)\n            if not self._in_bounds(cand):\n                step *= 0.5\n                continue\n            if self._point_blocked(cand, obstacles, is_3d):\n                step *= 0.5\n                continue\n            if not self._edge_free(from_pos, cand, obstacles, is_3d):\n                step *= 0.5\n                continue\n            return cand\n        return None\n\n    # ---- Parent / Rewiring ----\n    def _choose_parent(self, fallback, neighbors, new_pos, obstacles, is_3d):\n        best_p = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, new_pos) + self._angle_penalty(fallback, new_pos)\n        for n in neighbors:\n            c = n.cost + self._dist(n.position, new_pos) + self._angle_penalty(n, new_pos)\n            if c + 1e-12 < best_cost:\n                if not self._point_blocked(new_pos, obstacles, is_3d) and self._edge_free(n.position, new_pos, obstacles, is_3d):\n                    best_cost = c\n                    best_p = n\n        if best_p is None:\n            return None, float('inf')\n        true_cost = best_p.cost + self._dist(best_p.position, new_pos)\n        return best_p, true_cost\n\n    def _angle_penalty(self, parent, new_pos):\n        if parent is None or parent.parent is None:\n            return 0.0\n        a = parent.parent.position\n        b = parent.position\n        c = new_pos\n        v1 = tuple(b[i] - a[i] for i in range(self.dim))\n        v2 = tuple(c[i] - b[i] for i in range(self.dim))\n        n1 = 0.0\n        n2 = 0.0\n        dot = 0.0\n        for i in range(self.dim):\n            n1 += v1[i] * v1[i]\n            n2 += v2[i] * v2[i]\n            dot += v1[i] * v2[i]\n        if n1 <= 1e-9 or n2 <= 1e-9:\n            return 0.0\n        cosang = dot / ((n1 ** 0.5) * (n2 ** 0.5))\n        if cosang > 1.0:\n            cosang = 1.0\n        elif cosang < -1.0:\n            cosang = -1.0\n        # penalize deviation from straight line\n        return 0.05 * self.step_size * (1.0 - cosang)\n\n    def _is_ancestor(self, node, maybe_child):\n        cur = node\n        while cur is not None:\n            if cur is maybe_child:\n                return True\n            cur = cur.parent\n        return False\n\n    def _rewire_around(self, new_node, neighbors, obstacles, is_3d):\n        for m in neighbors:\n            if m is new_node or m is new_node.parent:\n                continue\n            # prevent cycles\n            if self._is_ancestor(m, new_node):\n                continue\n            alt = new_node.cost + self._dist(new_node.position, m.position)\n            if alt + 1e-12 < m.cost:\n                if (not self._point_blocked(new_node.position, obstacles, is_3d)) and \\\n                   (not self._point_blocked(m.position, obstacles, is_3d)) and \\\n                   self._edge_free(new_node.position, m.position, obstacles, is_3d):\n                    old_parent = m.parent\n                    old_cost = m.cost\n                    m.attach(new_node)\n                    m.cost = alt\n                    self._propagate_cost(m, alt - old_cost)\n                    # update edges list coherently\n                    self._remove_edge(old_parent, m)\n                    self._edges.append((new_node, m))\n\n    def _propagate_cost(self, node, delta):\n        if abs(delta) <= 0.0:\n            return\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    def _remove_edge(self, parent, child):\n        if parent is None or child is None:\n            return\n        for i in range(len(self._edges) - 1, -1, -1):\n            p, c = self._edges[i]\n            if p is parent and c is child:\n                self._edges.pop(i)\n                break\n\n    # ---- Collision ----\n    def _point_blocked(self, pos, obstacles, is_3d):\n        if is_3d:\n            x, y, z = pos\n            for o in obstacles:\n                ox, oy, oz, w, h, d = o\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n        else:\n            x, y = pos\n            for o in obstacles:\n                ox, oy, w, h = o\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        # quantized key for cache\n        qa = tuple(int(a[i] // self._cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self._cache_bin) for i in range(self.dim))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        if k in self._edge_block_cache:\n            return False\n        if k in self._edge_free_cache:\n            return True\n        # segment AABB quick reject\n        if is_3d:\n            ax, ay, az = a\n            bx, by, bz = b\n            minx = ax if ax < bx else bx\n            maxx = bx if bx > ax else ax\n            miny = ay if ay < by else by\n            maxy = by if by > ay else ay\n            minz = az if az < bz else bz\n            maxz = bz if bz > az else az\n            blocked = False\n            for o in obstacles:\n                ox, oy, oz, w, h, d = o\n                if maxx < ox or minx > ox + w or maxy < oy or miny > oy + h or maxz < oz or minz > oz + d:\n                    continue\n                if self._seg_box_3d(a, b, o):\n                    blocked = True\n                    break\n        else:\n            ax, ay = a\n            bx, by = b\n            minx = ax if ax < bx else bx\n            maxx = bx if bx > ax else ax\n            miny = ay if ay < by else by\n            maxy = by if by > ay else ay\n            blocked = False\n            for o in obstacles:\n                ox, oy, w, h = o\n                if maxx < ox or minx > ox + w or maxy < oy or miny > oy + h:\n                    continue\n                if self._seg_box_2d(a, b, o):\n                    blocked = True\n                    break\n        # cache store\n        self._cache_put(k, not blocked)\n        return not blocked\n\n    def _cache_put(self, key, free):\n        self._cache_keys.append(key)\n        if free:\n            self._edge_free_cache[key] = True\n        else:\n            self._edge_block_cache[key] = True\n        if len(self._cache_keys) > self.cache_capacity:\n            drop = int(max(1, self.cache_capacity * 0.1))\n            for _ in range(drop):\n                if not self._cache_keys:\n                    break\n                k = self._cache_keys.pop(0)\n                self._edge_free_cache.pop(k, None)\n                self._edge_block_cache.pop(k, None)\n\n    def _seg_box_2d(self, a, b, box):\n        x, y, w, h = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        ax, ay = a\n        bx, by = b\n        dx = bx - ax\n        dy = by - ay\n        t0, t1 = 0.0, 1.0\n\n        # X slabs\n        if dx == 0.0:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            tmin = (minx - ax) * inv\n            tmax = (maxx - ax) * inv\n            if tmin > tmax:\n                tmin, tmax = tmax, tmin\n            t0 = tmin if tmin > t0 else t0\n            t1 = tmax if tmax < t1 else t1\n            if t0 > t1:\n                return False\n\n        # Y slabs\n        if dy == 0.0:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            tmin = (miny - ay) * inv\n            tmax = (maxy - ay) * inv\n            if tmin > tmax:\n                tmin, tmax = tmax, tmin\n            t0 = tmin if tmin > t0 else t0\n            t1 = tmax if tmax < t1 else t1\n            if t0 > t1:\n                return False\n\n        return t1 >= 0.0 and t0 <= 1.0\n\n    def _seg_box_3d(self, a, b, box):\n        x, y, z, w, h, d = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        minz, maxz = z, z + d\n        ax, ay, az = a\n        bx, by, bz = b\n        dx = bx - ax\n        dy = by - ay\n        dz = bz - az\n        t0, t1 = 0.0, 1.0\n\n        # X\n        if dx == 0.0:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            tmin = (minx - ax) * inv\n            tmax = (maxx - ax) * inv\n            if tmin > tmax:\n                tmin, tmax = tmax, tmin\n            if tmin > t0:\n                t0 = tmin\n            if tmax < t1:\n                t1 = tmax\n            if t0 > t1:\n                return False\n\n        # Y\n        if dy == 0.0:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            tmin = (miny - ay) * inv\n            tmax = (maxy - ay) * inv\n            if tmin > tmax:\n                tmin, tmax = tmax, tmin\n            if tmin > t0:\n                t0 = tmin\n            if tmax < t1:\n                t1 = tmax\n            if t0 > t1:\n                return False\n\n        # Z\n        if dz == 0.0:\n            if az < minz or az > maxz:\n                return False\n        else:\n            inv = 1.0 / dz\n            tmin = (minz - az) * inv\n            tmax = (maxz - az) * inv\n            if tmin > tmax:\n                tmin, tmax = tmax, tmin\n            if tmin > t0:\n                t0 = tmin\n            if tmax < t1:\n                t1 = tmax\n            if t0 > t1:\n                return False\n\n        return t1 >= 0.0 and t0 <= 1.0\n\n    # ---- Post processing ----\n    def _greedy_visibility(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            # find farthest j visible from out[-1]\n            j = n - 1\n            jumped = False\n            while j > i + 1:\n                a = out[-1]\n                b = path[j]\n                if self._edge_free(a, b, obstacles, is_3d):\n                    out.append(b)\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(path[i+1])\n                i += 1\n        return out\n\n    def _corner_round(self, path, obstacles, is_3d, iters, strength):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            changed = False\n            for i in range(1, len(pts) - 1):\n                p0 = pts[i - 1]\n                p1 = pts[i]\n                p2 = pts[i + 1]\n                v1 = tuple(p1[d] - p0[d] for d in range(self.dim))\n                v2 = tuple(p2[d] - p1[d] for d in range(self.dim))\n                n1 = sum(v*v for v in v1) ** 0.5\n                n2 = sum(v*v for v in v2) ** 0.5\n                if n1 <= 1e-9 or n2 <= 1e-9:\n                    continue\n                u1 = tuple(v1[d] / n1 for d in range(self.dim))\n                u2 = tuple(v2[d] / n2 for d in range(self.dim))\n                bis = tuple(u1[d] + u2[d] for d in range(self.dim))\n                bn = sum(b*b for b in bis) ** 0.5\n                if bn <= 1e-9:\n                    continue\n                bis = tuple(bis[d] / bn for d in range(self.dim))\n                move = min(n1, n2) * 0.5 * strength\n                cand = tuple(p1[d] + bis[d] * move for d in range(self.dim))\n                cand = self._clamp(cand)\n                if self._point_blocked(cand, obstacles, is_3d):\n                    continue\n                if self._edge_free(p0, cand, obstacles, is_3d) and self._edge_free(cand, p2, obstacles, is_3d):\n                    old_len = self._dist(p0, p1) + self._dist(p1, p2)\n                    new_len = self._dist(p0, cand) + self._dist(cand, p2)\n                    if new_len + 1e-9 < old_len:\n                        pts[i] = cand\n                        changed = True\n            if not changed:\n                break\n        return pts",
          "objective": -31.85648,
          "time_improvement": 49.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1225.0,
          "node_improvement": 84.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.006536269187927246,
                    "num_nodes_avg": 45.0,
                    "path_length_avg": 156.24926070299097,
                    "smoothness_avg": 0.03718275041074938,
                    "success_improvement": 0.0,
                    "time_improvement": 74.01515769040475,
                    "node_improvement": 88.66784185343742,
                    "length_improvement": 14.357304280712906,
                    "smoothness_improvement": 481.99078756309143,
                    "objective_score": 33.228883813364625
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05136330127716064,
                    "num_nodes_avg": 175.0,
                    "path_length_avg": 245.71769390828157,
                    "smoothness_avg": 0.09162877415049606,
                    "success_improvement": 0.0,
                    "time_improvement": 67.94015169970548,
                    "node_improvement": 88.24161795336961,
                    "length_improvement": 17.97236118174695,
                    "smoothness_improvement": 2257.6743564306435,
                    "objective_score": 42.45383400111304
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04547719955444336,
                    "num_nodes_avg": 203.0,
                    "path_length_avg": 117.18736014682706,
                    "smoothness_avg": 0.08128197491280767,
                    "success_improvement": 0.0,
                    "time_improvement": 6.384561775474341,
                    "node_improvement": 74.18944691671965,
                    "length_improvement": 22.16973525290895,
                    "smoothness_improvement": 933.9007212796121,
                    "objective_score": 19.886713290785732
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "QUICKSILVER-BiRRT*: A fast, locally-optimal bidirectional planner with obstacle-binned collision tests, angle-aware parent selection, and bounded rewiring. It reduces planning time via a compact spatial hash for duplicate-free nearest/neighbor queries, obstacle-to-cell binning to filter segment tests, adaptive per-cell expansion throttling from obstacle density, and early capped greedy micro-bridges. Path length improves through visibility-aware parent choice with a small turn penalty, limited RRT* rewiring around each insertion, informed sampling once a provisional path exists, and strong shortcut/visibility collapse post-processing.",
          "planning_mechanism": "Alternate expanding two trees using hashed-grid nearest; steer, then pick the best LOS-feasible parent from a small unique neighborhood with an angle penalty, insert, and perform bounded local rewiring. Use obstacle-binned slab tests for node/edge checks. After each insertion, attempt a capped greedy connect toward the opposite tree; on success, extract and aggressively shortcut/collapse the path. Use informed sampling after the first solution to focus the search and reduce time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=10.0,\n        goal_bias=0.15,\n        corridor_bias=0.35,\n        informed_bias=0.75,\n        grid_cell_factor=1.0,\n        max_rings=3,\n        dupe_radius_ratio=0.4,\n        rewire_radius_factor=2.5,\n        angle_cost_weight=0.1,\n        connect_steps_cap=64,\n        cell_expand_limit_base=2,\n        obs_bin_factor=1.5,\n        smoothing_attempts=40\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.informed_bias = informed_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.max_rings = max_rings\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.rewire_radius_factor = rewire_radius_factor\n        self.angle_cost_weight = angle_cost_weight\n        self.connect_steps_cap = max(1, int(connect_steps_cap))\n        self.cell_expand_limit_base = max(1, int(cell_expand_limit_base))\n        self.obs_bin_factor = obs_bin_factor\n        self.smoothing_attempts = smoothing_attempts\n\n        self.dim = 2\n        self.bounds = None\n        self.start = None\n        self.goal = None\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.rewire_radius = max(self.step_size, self.step_size * self.rewire_radius_factor)\n\n        self.obs_cell = max(1.0, self.step_size * self.obs_bin_factor)\n        self._build_obstacle_grid(obstacles, is_3d)\n\n        if not self._segment_hits_any(self.start, self.goal, obstacles, is_3d):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes = [start_root, goal_root]\n        self.edges = []\n        self.edge_idx = {}\n\n        grid_a, grid_b = {}, {}\n        throttles_a, throttles_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n\n        best_path_len = float('inf')\n        d_sg = self._dist(self.start, self.goal)\n        base_corridor_w = max(self.step_size, 0.2 * d_sg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            throttles1 = throttles_a if active_start else throttles_b\n            throttles2 = throttles_b if active_start else throttles_a\n            other_root = self.goal if active_start else self.start\n\n            if best_path_len < float('inf') and self._rand() < self.informed_bias:\n                x_rand = self._sample_informed(best_path_len, obstacles, is_3d)\n            else:\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = other_root\n                elif r < self.goal_bias + self.corridor_bias:\n                    width = base_corridor_w\n                    if best_path_len < float('inf'):\n                        slack = max(0.0, best_path_len - d_sg)\n                        width = max(self.step_size, 0.15 * slack + base_corridor_w)\n                    x_rand = self._sample_corridor(width, obstacles, is_3d)\n                else:\n                    x_rand = self._sample_free(obstacles, is_3d)\n\n            nearest = self._nearest_hashed(grid1, tree1, x_rand)\n            if nearest is None:\n                continue\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._exists_close(grid1, new_pos, self.dupe_radius):\n                continue\n            kc = self._grid_key(new_pos)\n            if throttles1.get(kc, 0) >= self._cell_expand_limit_for_key(kc):\n                continue\n            if self._segment_hits_any(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            parent = nearest\n            parent_cost = parent.cost + self._dist(parent.position, new_pos)\n            neigh = self._nearby_nodes(grid1, new_pos, self.rewire_radius)\n            best_cost = parent_cost\n            best_parent = parent\n            for cand in neigh:\n                if cand is parent:\n                    continue\n                if self._segment_hits_any(cand.position, new_pos, obstacles, is_3d):\n                    continue\n                c = cand.cost + self._dist(cand.position, new_pos)\n                if self.angle_cost_weight > 0.0:\n                    prev = None\n                    if cand.parent is not None:\n                        prev = tuple(cand.position[i] - cand.parent.position[i] for i in range(self.dim))\n                    cur = tuple(new_pos[i] - cand.position[i] for i in range(self.dim))\n                    if prev is not None:\n                        cost_ang = self._angle_penalty(prev, cur)\n                        c += self.angle_cost_weight * cost_ang\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best_parent = cand\n\n            new_node = Node(new_pos, best_parent, best_cost)\n            best_parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            self._add_edge(best_parent, new_node)\n            self._grid_add(grid1, new_node)\n            throttles1[kc] = throttles1.get(kc, 0) + 1\n\n            neigh_rewire = self._nearby_nodes(grid1, new_pos, self.rewire_radius)\n            for m in neigh_rewire:\n                if m is new_node or m is best_parent:\n                    continue\n                new_cost = new_node.cost + self._dist(new_node.position, m.position)\n                if new_cost + 1e-9 < m.cost:\n                    if not self._segment_hits_any(new_node.position, m.position, obstacles, is_3d):\n                        old_parent = m.parent\n                        if old_parent is not None:\n                            # detach\n                            for i in range(len(old_parent.children)):\n                                if old_parent.children[i] is m:\n                                    old_parent.children.pop(i)\n                                    break\n                            self._remove_edge(old_parent, m)\n                        new_node.add_child(m)\n                        m.cost = new_cost\n                        self._add_edge(new_node, m)\n                        stack = [m]\n                        while stack:\n                            cur = stack.pop()\n                            for ch in cur.children:\n                                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                                stack.append(ch)\n\n            other_near = self._nearest_hashed(grid2, tree2, new_node.position)\n            if other_near is not None:\n                connected, meet_node, added_nodes = self._greedy_connect(tree2, grid2, throttles2, other_near, new_node.position, obstacles, is_3d)\n                if added_nodes:\n                    nodes.extend(added_nodes)\n                if connected:\n                    path = self._extract_path(new_node, meet_node)\n                    best_path_len = self._path_length(path)\n                    path = self._smooth_path(path, obstacles, is_3d, self.smoothing_attempts)\n                    return PlannerResult(True, path, nodes, self.edges)\n\n        return PlannerResult(False, [], nodes, self.edges)\n\n    def _rand(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _norm(self, v):\n        s = 0.0\n        for i in range(self.dim):\n            s += v[i] * v[i]\n        return s ** 0.5\n\n    def _angle_penalty(self, v_prev, v_cur):\n        n1 = self._norm(v_prev)\n        n2 = self._norm(v_cur)\n        if n1 <= 1e-12 or n2 <= 1e-12:\n            return 0.0\n        dot = 0.0\n        for i in range(self.dim):\n            dot += (v_prev[i] / n1) * (v_cur[i] / n2)\n        if dot > 1.0:\n            dot = 1.0\n        if dot < -1.0:\n            dot = -1.0\n        return 1.0 - dot\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp_tuple(to_pos)\n        if d <= 1e-12:\n            return self._clamp_tuple(from_pos)\n        r = step / d\n        return self._clamp_tuple(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _aabb_overlap(self, sa_min, sa_max, ob_min, ob_max):\n        for i in range(self.dim):\n            if sa_max[i] < ob_min[i] or sa_min[i] > ob_max[i]:\n                return False\n        return True\n\n    def _segment_intersects_box(self, a, b, box_min, box_max):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(self.dim):\n            ai = a[i]; bi = b[i]\n            di = bi - ai\n            if abs(di) < 1e-12:\n                if ai < box_min[i] or ai > box_max[i]:\n                    return False\n            else:\n                inv = 1.0 / di\n                t1 = (box_min[i] - ai) * inv\n                t2 = (box_max[i] - ai) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _segment_hits_any(self, a, b, obstacles, is_3d):\n        sa_min = tuple(min(a[i], b[i]) for i in range(self.dim))\n        sa_max = tuple(max(a[i], b[i]) for i in range(self.dim))\n        cand = self._obstacles_in_aabb(sa_min, sa_max)\n        if self.dim == 3:\n            for obs in cand:\n                ox, oy, oz, w, h, d = obs\n                ob_min = (ox, oy, oz)\n                ob_max = (ox + w, oy + h, oz + d)\n                if not self._aabb_overlap(sa_min, sa_max, ob_min, ob_max):\n                    continue\n                if self._segment_intersects_box(a, b, ob_min, ob_max):\n                    return True\n        else:\n            for obs in cand:\n                ox, oy, w, h = obs\n                ob_min = (ox, oy)\n                ob_max = (ox + w, oy + h)\n                if not self._aabb_overlap(sa_min, sa_max, ob_min, ob_max):\n                    continue\n                if self._segment_intersects_box(a, b, ob_min, ob_max):\n                    return True\n        return False\n\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            for _ in range(12):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n        else:\n            for _ in range(12):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d):\n        for _ in range(40):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= best_len and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        return self._sample_corridor(max(self.step_size, 0.2 * self._dist(self.start, self.goal)), obstacles, is_3d)\n\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _cells_at_ring(self, key, r):\n        if self.dim == 3:\n            out = []\n            if r == 0:\n                return [key]\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    out.append((key[0] + dx, key[1] + dy, key[2] - r))\n                    out.append((key[0] + dx, key[1] + dy, key[2] + r))\n            for dx in range(-r, r + 1):\n                for dz in range(-r + 1, r):\n                    out.append((key[0] + dx, key[1] - r, key[2] + dz))\n                    out.append((key[0] + dx, key[1] + r, key[2] + dz))\n            for dy in range(-r + 1, r):\n                for dz in range(-r + 1, r):\n                    out.append((key[0] - r, key[1] + dy, key[2] + dz))\n                    out.append((key[0] + r, key[1] + dy, key[2] + dz))\n            uniq = []\n            seen = set()\n            for c in out:\n                if c not in seen:\n                    uniq.append(c)\n                    seen.add(c)\n            return uniq\n        else:\n            if r == 0:\n                return [key]\n            out = []\n            for dx in range(-r, r + 1):\n                out.append((key[0] + dx, key[1] - r))\n                out.append((key[0] + dx, key[1] + r))\n            for dy in range(-r + 1, r):\n                out.append((key[0] - r, key[1] + dy))\n                out.append((key[0] + r, key[1] + dy))\n            uniq = []\n            seen = set()\n            for c in out:\n                if c not in seen:\n                    uniq.append(c)\n                    seen.add(c)\n            return uniq\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.max_rings + 1):\n            cells = self._cells_at_ring(key, r)\n            found = False\n            for c in cells:\n                bucket = grid.get(c)\n                if not bucket:\n                    continue\n                for n in bucket:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                        found = True\n            if found and best is not None:\n                return best\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.cell_size) + 1\n        r2 = radius * radius\n        if self.dim == 3:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not bucket:\n                            continue\n                        for n in bucket:\n                            s = 0.0\n                            for i in range(self.dim):\n                                d = n.position[i] - pos[i]\n                                s += d * d\n                            if s <= r2:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((key[0] + dx, key[1] + dy))\n                    if not bucket:\n                        continue\n                    for n in bucket:\n                        s = 0.0\n                        for i in range(self.dim):\n                            d = n.position[i] - pos[i]\n                            s += d * d\n                        if s <= r2:\n                            return True\n        return False\n\n    def _nearby_nodes(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.cell_size) + 1\n        out = []\n        if self.dim == 3:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not bucket:\n                            continue\n                        for n in bucket:\n                            if self._dist(n.position, pos) <= radius:\n                                out.append(n)\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((key[0] + dx, key[1] + dy))\n                    if not bucket:\n                        continue\n                    for n in bucket:\n                        if self._dist(n.position, pos) <= radius:\n                            out.append(n)\n        return out\n\n    def _greedy_connect(self, tree, grid, throttles, from_node, target_pos, obstacles, is_3d):\n        current = from_node\n        steps = 0\n        added_nodes = []\n        while steps < self.connect_steps_cap:\n            next_pos = self._steer(current.position, target_pos, self.step_size)\n            if not self._in_bounds(next_pos):\n                break\n            if self._is_in_obstacle(next_pos, obstacles, is_3d):\n                break\n            if self._exists_close(grid, next_pos, self.dupe_radius):\n                break\n            k = self._grid_key(next_pos)\n            if throttles.get(k, 0) >= self._cell_expand_limit_for_key(k):\n                break\n            if self._segment_hits_any(current.position, next_pos, obstacles, is_3d):\n                break\n            new_cost = current.cost + self._dist(current.position, next_pos)\n            q = Node(next_pos, current, new_cost)\n            current.add_child(q)\n            tree.append(q)\n            self._grid_add(grid, q)\n            throttles[k] = throttles.get(k, 0) + 1\n            self._add_edge(current, q)\n            added_nodes.append(q)\n            current = q\n            steps += 1\n            if self._dist(current.position, target_pos) <= self.step_size:\n                if not self._segment_hits_any(current.position, target_pos, obstacles, is_3d):\n                    return True, current, added_nodes\n                else:\n                    break\n        return False, current, added_nodes\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node):\n        path_a = self._path_to_root(a_node)\n        path_b = []\n        cur = b_node\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _smooth_path(self, path, obstacles, is_3d, attempts):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        tries = 0\n        while tries < attempts and len(pts) >= 3:\n            i = int(self._uniform(0, len(pts) - 2))\n            j = int(self._uniform(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._segment_hits_any(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n            tries += 1\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            k = 1\n            while k < len(pts) - 1:\n                nxt = pts[k + 1]\n                if self._segment_hits_any(last, nxt, obstacles, is_3d):\n                    collapsed.append(pts[k])\n                    last = pts[k]\n                k += 1\n            collapsed.append(pts[-1])\n            pts = collapsed\n        if len(pts) >= 3:\n            collapsed = [pts[-1]]\n            last = pts[-1]\n            k = len(pts) - 2\n            while k > 0:\n                prev = pts[k - 1]\n                if self._segment_hits_any(prev, last, obstacles, is_3d):\n                    collapsed.append(pts[k])\n                    last = pts[k]\n                k -= 1\n            collapsed.append(pts[0])\n            collapsed.reverse()\n            pts = collapsed\n        return pts\n\n    def _add_edge(self, parent, child):\n        key = (id(parent), id(child))\n        if key in self.edge_idx:\n            return\n        self.edges.append((parent, child))\n        self.edge_idx[key] = len(self.edges) - 1\n\n    def _remove_edge(self, parent, child):\n        key = (id(parent), id(child))\n        idx = self.edge_idx.get(key)\n        if idx is None:\n            return\n        last_idx = len(self.edges) - 1\n        if idx != last_idx:\n            last_edge = self.edges[last_idx]\n            self.edges[idx] = last_edge\n            self.edge_idx[(id(last_edge[0]), id(last_edge[1]))] = idx\n        self.edges.pop()\n        del self.edge_idx[key]\n\n    def _build_obstacle_grid(self, obstacles, is_3d):\n        self.obs_grid = {}\n        if self.dim == 3:\n            for obs in obstacles:\n                ox, oy, oz, w, h, d = obs\n                min_k = (int(ox // self.obs_cell), int(oy // self.obs_cell), int(oz // self.obs_cell))\n                max_k = (int((ox + w) // self.obs_cell), int((oy + h) // self.obs_cell), int((oz + d) // self.obs_cell))\n                for i in range(min_k[0], max_k[0] + 1):\n                    for j in range(min_k[1], max_k[1] + 1):\n                        for k in range(min_k[2], max_k[2] + 1):\n                            key = (i, j, k)\n                            bucket = self.obs_grid.get(key)\n                            if bucket is None:\n                                self.obs_grid[key] = [obs]\n                            else:\n                                bucket.append(obs)\n        else:\n            for obs in obstacles:\n                ox, oy, w, h = obs\n                min_k = (int(ox // self.obs_cell), int(oy // self.obs_cell))\n                max_k = (int((ox + w) // self.obs_cell), int((oy + h) // self.obs_cell))\n                for i in range(min_k[0], max_k[0] + 1):\n                    for j in range(min_k[1], max_k[1] + 1):\n                        key = (i, j)\n                        bucket = self.obs_grid.get(key)\n                        if bucket is None:\n                            self.obs_grid[key] = [obs]\n                        else:\n                            bucket.append(obs)\n\n    def _obs_key_from_point(self, p):\n        return tuple(int(p[i] // self.obs_cell) for i in range(self.dim))\n\n    def _obstacles_in_aabb(self, a_min, a_max):\n        min_k = self._obs_key_from_point(a_min)\n        max_k = self._obs_key_from_point(a_max)\n        seen = set()\n        result = []\n        if self.dim == 3:\n            for i in range(min_k[0], max_k[0] + 1):\n                for j in range(min_k[1], max_k[1] + 1):\n                    for k in range(min_k[2], max_k[2] + 1):\n                        bucket = self.obs_grid.get((i, j, k))\n                        if not bucket:\n                            continue\n                        for obs in bucket:\n                            if id(obs) in seen:\n                                continue\n                            seen.add(id(obs))\n                            result.append(obs)\n        else:\n            for i in range(min_k[0], max_k[0] + 1):\n                for j in range(min_k[1], max_k[1] + 1):\n                    bucket = self.obs_grid.get((i, j))\n                    if not bucket:\n                        continue\n                    for obs in bucket:\n                        if id(obs) in seen:\n                            continue\n                        seen.add(id(obs))\n                        result.append(obs)\n        return result\n\n    def _cell_expand_limit_for_key(self, key):\n        # Adaptive throttle: allow more expansions in cells with higher obstacle density\n        if self.dim == 3:\n            ob_bucket = self.obs_grid.get((key[0], key[1], key[2]), [])\n        else:\n            ob_bucket = self.obs_grid.get((key[0], key[1]), [])\n        dens = len(ob_bucket)\n        return self.cell_expand_limit_base + (1 if dens > 0 else 0)",
          "objective": -31.5924,
          "time_improvement": 57.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1552.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020659923553466797,
                    "num_nodes_avg": 64.7,
                    "path_length_avg": 183.73319960225547,
                    "smoothness_avg": 0.05099212056528696,
                    "success_improvement": 0.0,
                    "time_improvement": 17.866776867650763,
                    "node_improvement": 83.70687484260891,
                    "length_improvement": -0.7070781408554467,
                    "smoothness_improvement": 698.137418008862,
                    "objective_score": 8.42647326582627
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028574299812316895,
                    "num_nodes_avg": 105.0,
                    "path_length_avg": 240.58846662664308,
                    "smoothness_avg": 0.10241331344370867,
                    "success_improvement": 0.0,
                    "time_improvement": 82.16454755649897,
                    "node_improvement": 92.94497077202178,
                    "length_improvement": 19.68464488497925,
                    "smoothness_improvement": 2535.1683202346803,
                    "objective_score": 49.135992799110646
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014296674728393554,
                    "num_nodes_avg": 81.7,
                    "path_length_avg": 128.14900585743325,
                    "smoothness_avg": 0.11965477360316448,
                    "success_improvement": 0.0,
                    "time_improvement": 70.57009923731559,
                    "node_improvement": 89.61220597584233,
                    "length_improvement": 14.889532109401287,
                    "smoothness_improvement": 1421.9998882355792,
                    "objective_score": 37.21474847801334
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "FALCON-IBiRRT*: Fast AABB-Filtered Adaptive Corridor Informed BiRRT* with local rewiring and heuristic gating. It uses slab-based box-line intersection for collision checks, hash-grid neighbors for parent selection/rewiring, adaptive corridor/ellipse sampling after the first path, and an f-cost gate to prune weak expansions. On connection it prunes by visibility then applies bounded shortcut and a light rubber-band pass for shorter, smoother paths.",
          "planning_mechanism": "Alternate growing from start and goal. Each iteration: sample in a guided corridor (or informed ellipse after a solution), pick a hash-grid nearest, steer one step, do node and slab-precise edge checks, apply a g+h gate versus current best, choose a low-cost, low-angle parent among nearby neighbors and rewire cheaper ones. Attempt a short validated connect to the other tree. Upon bridge, extract, visibility-prune, shortcut, and lightly rubber-band the path, then return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            ch = self.parent.children\n            for i in range(len(ch)-1, -1, -1):\n                if ch[i] is self:\n                    ch.pop(i)\n                    break\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=6.0,\n        goal_bias=0.15,\n        corridor_bias=0.55,\n        grid_cell_factor=1.6,\n        min_sep_factor=0.45,\n        neighbor_factor=2.6,\n        neighbor_max=24,\n        connect_steps=5,\n        heur_gate=1.02,\n        smoothing_iters=80\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.min_sep_factor = min_sep_factor\n        self.neighbor_factor = neighbor_factor\n        self.neighbor_max = neighbor_max\n        self.connect_steps = connect_steps\n        self.heur_gate = heur_gate\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self._edge_cache = {}\n        self._lcg = 1103515245\n        self._seed = 2463534242\n\n        self.cell_size = 1.0\n        self.min_sep = 1.0\n        self.corridor_w = 1.0\n        self.angle_w = 0.1\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        self._edge_cache = {}\n        self._seed = 2463534242\n\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        dsg = self._dist(start, goal)\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step_size * self.min_sep_factor)\n        self.corridor_w = max(self.step_size * 1.2, 0.25 * dsg)\n        self.angle_w = 0.05 * self.step_size\n\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, dsg)\n            s.children.append(g)\n            nodes = [s, g]\n            edges = [(s, g)]\n            return PlannerResult(True, [start, goal], nodes, edges)\n\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        all_nodes = [start_root, goal_root]\n\n        grid_a = {}\n        grid_b = {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n\n        best_path = None\n        c_best = float('inf')\n        informed = False\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            if active_start:\n                nodes_x, nodes_y = tree_a, tree_b\n                grid_x, grid_y = grid_a, grid_b\n                root_x, root_y = start_root, goal_root\n                attractor = goal\n            else:\n                nodes_x, nodes_y = tree_b, tree_a\n                grid_x, grid_y = grid_b, grid_a\n                root_x, root_y = goal_root, start_root\n                attractor = start\n\n            # Sampling\n            r = self._rand()\n            if r < self.goal_bias:\n                x_rand = attractor\n            else:\n                if informed and self._rand() < 0.6:\n                    x_rand = self._ellipse_sample(root_x.position, root_y.position, c_best)\n                elif self._rand() < self.corridor_bias:\n                    x_rand = self._corridor_sample(root_x.position, root_y.position, self.corridor_w)\n                else:\n                    x_rand = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n            # Nearest\n            n_near = self._nearest_hashed(grid_x, nodes_x, x_rand)\n            if n_near is None:\n                continue\n\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n            if not self._in_bounds(x_new_pos):\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                continue\n            if self._near_duplicate(grid_x, x_new_pos, self.min_sep):\n                continue\n\n            g_cost = n_near.cost + self._dist(n_near.position, x_new_pos)\n            f_cost = g_cost + self._dist(x_new_pos, root_y.position)\n            if informed and f_cost >= c_best * self.heur_gate:\n                continue\n\n            if self._edge_blocked(n_near.position, x_new_pos, obstacles, is_3d):\n                continue\n\n            neigh_r = self._neighbor_radius(len(nodes_x))\n            neigh = self._neighbors_in_radius(grid_x, x_new_pos, neigh_r, self.neighbor_max)\n            parent, new_cost = self._choose_best_parent_angle(x_new_pos, n_near, neigh, obstacles, is_3d)\n            if parent is None:\n                continue\n            if self._edge_blocked(parent.position, x_new_pos, obstacles, is_3d):\n                continue\n\n            x_new = Node(x_new_pos, None, new_cost)\n            x_new.attach(parent)\n            nodes_x.append(x_new)\n            all_nodes.append(x_new)\n            self._grid_add(grid_x, x_new)\n\n            self._rewire_neighbors(x_new, neigh, obstacles, is_3d)\n\n            # Try direct connect to other tree\n            other_near = self._nearest_hashed(grid_y, nodes_y, x_new.position)\n            bridged = None\n            if other_near is not None and not self._edge_blocked(x_new.position, other_near.position, obstacles, is_3d):\n                bridged = other_near\n            else:\n                cur = other_near\n                steps = 0\n                while cur is not None and steps < self.connect_steps:\n                    step_pos = self._steer(cur.position, x_new.position, self.step_size)\n                    if not self._in_bounds(step_pos):\n                        break\n                    if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                        break\n                    if self._near_duplicate(grid_y, step_pos, self.min_sep):\n                        break\n                    g2 = cur.cost + self._dist(cur.position, step_pos)\n                    f2 = g2 + self._dist(step_pos, root_x.position)\n                    if informed and f2 >= c_best * self.heur_gate:\n                        break\n                    if self._edge_blocked(cur.position, step_pos, obstacles, is_3d):\n                        break\n\n                    neigh_b = self._neighbors_in_radius(grid_y, step_pos, neigh_r, self.neighbor_max)\n                    p_b, c_b = self._choose_best_parent_angle(step_pos, cur, neigh_b, obstacles, is_3d)\n                    if p_b is None:\n                        break\n                    if self._edge_blocked(p_b.position, step_pos, obstacles, is_3d):\n                        break\n\n                    nxt = Node(step_pos, None, c_b)\n                    nxt.attach(p_b)\n                    nodes_y.append(nxt)\n                    all_nodes.append(nxt)\n                    self._grid_add(grid_y, nxt)\n\n                    self._rewire_neighbors(nxt, neigh_b, obstacles, is_3d)\n\n                    cur = nxt\n                    steps += 1\n\n                    if not self._edge_blocked(cur.position, x_new.position, obstacles, is_3d):\n                        bridged = cur\n                        break\n\n            if bridged is not None:\n                if active_start:\n                    path_a = self._path_to_root(x_new)\n                    path_b = self._path_to_root(bridged)\n                    path = path_a + list(reversed(path_b))\n                else:\n                    path_a = self._path_to_root(x_new)\n                    path_b = self._path_to_root(bridged)\n                    path = path_b + list(reversed(path_a))\n\n                path = self._visibility_prune(path, obstacles, is_3d)\n                path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                path = self._rubber_band(path, obstacles, is_3d, passes=2)\n\n                L = self._path_length(path)\n                if L < c_best:\n                    c_best = L\n                    best_path = path\n                    informed = True\n                    edges = []\n                    for n in all_nodes:\n                        if n.parent is not None:\n                            edges.append((n.parent, n))\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n        edges = []\n        for n in all_nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        return PlannerResult(best_path is not None, best_path if best_path else [], all_nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._seed = (self._lcg * self._seed + 12345) % (1 << 31)\n        return self._seed / float(1 << 31)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5 if s > 0.0 else 0.0\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _clamp(self, p):\n        return tuple(self._clip(p[i], 0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _clip(self, x, lo, hi):\n        if x < lo:\n            return lo\n        if x > hi:\n            return hi\n        return x\n\n    # Collision with slab-based AABB filtering and cache\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        c = self._edge_cache.get(k)\n        if c is not None:\n            return c\n        if is_3d:\n            ax, ay, az = a\n            bx, by, bz = b\n            # quick reject: identical\n            if ax == bx and ay == by and az == bz:\n                blocked = self._is_in_obstacle(a, obstacles, True)\n            else:\n                blocked = False\n                for o in obstacles:\n                    if self._seg_box_intersect_3d(a, b, o):\n                        blocked = True\n                        break\n        else:\n            ax, ay = a\n            bx, by = b\n            if ax == bx and ay == by:\n                blocked = self._is_in_obstacle(a, obstacles, False)\n            else:\n                blocked = False\n                for o in obstacles:\n                    if self._seg_box_intersect_2d(a, b, o):\n                        blocked = True\n                        break\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _is_in_obstacle(self, p, obstacles, is_3d):\n        if is_3d:\n            x, y, z = p\n            for o in obstacles:\n                ox, oy, oz, w, h, d = o\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n        else:\n            x, y = p\n            for o in obstacles:\n                ox, oy, w, h = o\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n        return False\n\n    def _seg_box_intersect_2d(self, a, b, box):\n        x, y, w, h = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        tmin, tmax = 0.0, 1.0\n        ax, ay = a\n        bx, by = b\n        dx = bx - ax\n        dy = by - ay\n\n        if dx == 0.0:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            t1 = (minx - ax) * inv\n            t2 = (maxx - ax) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        if dy == 0.0:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            t1 = (miny - ay) * inv\n            t2 = (maxy - ay) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    def _seg_box_intersect_3d(self, a, b, box):\n        x, y, z, w, h, d = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        minz, maxz = z, z + d\n        tmin, tmax = 0.0, 1.0\n        ax, ay, az = a\n        bx, by, bz = b\n        dx = bx - ax\n        dy = by - ay\n        dz = bz - az\n\n        # X\n        if dx == 0.0:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            t1 = (minx - ax) * inv\n            t2 = (maxx - ax) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        # Y\n        if dy == 0.0:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            t1 = (miny - ay) * inv\n            t2 = (maxy - ay) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        # Z\n        if dz == 0.0:\n            if az < minz or az > maxz:\n                return False\n        else:\n            inv = 1.0 / dz\n            t1 = (minz - az) * inv\n            t2 = (maxz - az) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    # Hash grid\n    def _grid_key(self, pos):\n        if self.dim == 3:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        else:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        seen = set()\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            for n in b:\n                                if n not in seen:\n                                    seen.add(n)\n                                    out.append(n)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        for n in b:\n                            if n not in seen:\n                                seen.add(n)\n                                out.append(n)\n        return out\n\n    def _nearest_hashed(self, grid, nodes, pos):\n        k = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        found = False\n        for r in range(0, 3):\n            cand = self._grid_collect_ring(grid, k, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                found = True\n                break\n        if not found:\n            limit = min(96, len(nodes))\n            if limit == 0:\n                return None\n            step = max(1, len(nodes) // limit)\n            for i in range(0, len(nodes), step):\n                n = nodes[i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius, kmax):\n        ring = int(radius // self.cell_size) + 1\n        k = self._grid_key(pos)\n        cand = self._grid_collect_ring(grid, k, ring)\n        scored = []\n        rr = radius + 1e-9\n        for n in cand:\n            d = self._dist(n.position, pos)\n            if d <= rr:\n                scored.append((d, n))\n        scored.sort(key=lambda x: x[0])\n        res = [n for (_, n) in scored[:kmax]]\n        return res\n\n    def _neighbor_radius(self, ncount):\n        base = self.neighbor_factor * self.step_size\n        if ncount < 300:\n            return base * 2.2\n        if ncount < 1200:\n            return base * 1.8\n        return base * 1.4\n\n    def _near_duplicate(self, grid, pos, radius):\n        k = self._grid_key(pos)\n        cand = self._grid_collect_ring(grid, k, 1)\n        rr = radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # Parent selection with angle penalty\n    def _choose_best_parent_angle(self, new_pos, fallback, neighbors, obstacles, is_3d):\n        best_p = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, new_pos) + self._angle_penalty(fallback, new_pos)\n        for n in neighbors:\n            c = n.cost + self._dist(n.position, new_pos) + self._angle_penalty(n, new_pos)\n            if c + 1e-12 < best_cost:\n                if not self._edge_blocked(n.position, new_pos, obstacles, is_3d):\n                    best_cost = c\n                    best_p = n\n        if best_p is None:\n            return None, float('inf')\n        # remove angle penalty from stored cost; we only store path length\n        true_cost = best_p.cost + self._dist(best_p.position, new_pos)\n        return best_p, true_cost\n\n    def _angle_penalty(self, parent, new_pos):\n        if parent is None or parent.parent is None:\n            return 0.0\n        a = parent.parent.position\n        b = parent.position\n        c = new_pos\n        v1 = tuple(b[i] - a[i] for i in range(self.dim))\n        v2 = tuple(c[i] - b[i] for i in range(self.dim))\n        n1 = 0.0\n        n2 = 0.0\n        dot = 0.0\n        for i in range(self.dim):\n            n1 += v1[i] * v1[i]\n            n2 += v2[i] * v2[i]\n            dot += v1[i] * v2[i]\n        if n1 <= 1e-9 or n2 <= 1e-9:\n            return 0.0\n        cosang = dot / ((n1 ** 0.5) * (n2 ** 0.5))\n        if cosang > 1.0:\n            cosang = 1.0\n        elif cosang < -1.0:\n            cosang = -1.0\n        # penalty increases as angle deviates from straight line: 1 - cos(theta)\n        return self.angle_w * (1.0 - cosang)\n\n    def _rewire_neighbors(self, new_node, neighbors, obstacles, is_3d):\n        for m in neighbors:\n            if m is new_node or m is new_node.parent:\n                continue\n            alt = new_node.cost + self._dist(new_node.position, m.position)\n            if alt + 1e-12 < m.cost:\n                if not self._edge_blocked(new_node.position, m.position, obstacles, is_3d):\n                    old = m.cost\n                    m.attach(new_node)\n                    m.cost = alt\n                    self._propagate_cost(m, alt - old)\n\n    def _propagate_cost(self, node, delta):\n        if delta == 0.0:\n            return\n        q = [node]\n        while q:\n            cur = q.pop()\n            for ch in cur.children:\n                ch.cost += delta\n                q.append(ch)\n\n    # Sampling helpers\n    def _ellipse_sample(self, a, b, c_best):\n        tries = 12\n        for _ in range(tries):\n            p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n            if self._dist(p, a) + self._dist(p, b) <= c_best + 1e-9:\n                return p\n        return self._corridor_sample(a, b, max(self.step_size, 0.15 * c_best))\n\n    def _corridor_sample(self, a, b, width):\n        t = self._uniform(0.0, 1.0)\n        base = tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n        ab = tuple(b[i] - a[i] for i in range(self.dim))\n        abn = self._norm(ab)\n        if abn <= 1e-9:\n            return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n        v = tuple(ab[i] / abn for i in range(self.dim))\n        if self.dim == 2:\n            perp = (-v[1], v[0])\n            off = (self._uniform(-width, width),)\n            jitter = tuple(perp[i] * off[0] for i in range(2))\n            p = tuple(base[i] + jitter[i] for i in range(2))\n        else:\n            # project random vector orthogonal to v\n            r = tuple(self._uniform(-1.0, 1.0) for _ in range(3))\n            dot = r[0]*v[0] + r[1]*v[1] + r[2]*v[2]\n            u = (r[0] - dot*v[0], r[1] - dot*v[1], r[2] - dot*v[2])\n            un = self._norm(u)\n            if un <= 1e-9:\n                u = (v[1], -v[0], 0.0)\n                un = self._norm(u)\n            u = (u[0]/un, u[1]/un, u[2]/un)\n            mag = self._uniform(-width, width)\n            jitter = (u[0]*mag, u[1]*mag, u[2]*mag)\n            p = tuple(base[i] + jitter[i] for i in range(3))\n        return self._clamp(p)\n\n    def _norm(self, v):\n        s = 0.0\n        for i in range(len(v)):\n            s += v[i]*v[i]\n        return s ** 0.5 if s > 0.0 else 0.0\n\n    # Path utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i-1], path[i])\n        return L\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(out[-1], path[j], obstacles, is_3d):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i+1])\n                i += 1\n        return out\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i+1] + pts[j:]\n                n = len(pts)\n        return pts\n\n    def _rubber_band(self, path, obstacles, is_3d, passes=1):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(passes):\n            changed = False\n            for i in range(1, len(pts)-1):\n                prev = pts[i-1]\n                cur = pts[i]\n                nxt = pts[i+1]\n                mid = tuple(0.5*(prev[d] + nxt[d]) for d in range(self.dim))\n                newp = tuple(0.5*cur[d] + 0.5*mid[d] for d in range(self.dim))\n                if self._is_in_obstacle(newp, obstacles, is_3d):\n                    continue\n                if not self._edge_blocked(prev, newp, obstacles, is_3d) and not self._edge_blocked(newp, nxt, obstacles, is_3d):\n                    old_len = self._dist(prev, cur) + self._dist(cur, nxt)\n                    new_len = self._dist(prev, newp) + self._dist(newp, nxt)\n                    if new_len + 1e-9 < old_len:\n                        pts[i] = newp\n                        changed = True\n            if not changed:\n                break\n        return pts",
          "objective": -31.59206,
          "time_improvement": 49.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1496.0,
          "node_improvement": 84.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016694188117980957,
                    "num_nodes_avg": 71.0,
                    "path_length_avg": 163.0992747992678,
                    "smoothness_avg": 0.05614678174204176,
                    "success_improvement": 0.0,
                    "time_improvement": 39.474027697220166,
                    "node_improvement": 82.12037270209015,
                    "length_improvement": 10.602703009124085,
                    "smoothness_improvement": 778.8190589509786,
                    "objective_score": 22.097925409395394
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07330527305603027,
                    "num_nodes_avg": 250.0,
                    "path_length_avg": 238.45185700265174,
                    "smoothness_avg": 0.06942702786006637,
                    "success_improvement": 0.0,
                    "time_improvement": 55.701147868583675,
                    "node_improvement": 83.20231136195659,
                    "length_improvement": 20.397906676365686,
                    "smoothness_improvement": 1686.4074331064066,
                    "objective_score": 37.38112553192654
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025111293792724608,
                    "num_nodes_avg": 102.0,
                    "path_length_avg": 126.23467909600465,
                    "smoothness_avg": 0.16699201676546307,
                    "success_improvement": 0.0,
                    "time_improvement": 51.59980056201074,
                    "node_improvement": 87.0311506675143,
                    "length_improvement": 16.160936793897573,
                    "smoothness_improvement": 2024.1261271881847,
                    "objective_score": 35.297132880882685
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "Adaptive Corridor-Indexed Connect with Light Rewire (ACIC-LR): a tuned, obstacle-indexed, bidirectional RRT-Connect variant that improves speed and path quality via balanced sampling (goal/corridor/uniform), adaptive grid nearest search, short extend/connect bursts, grandparent visibility compression, and local cost-aware rewiring. Indexed slab collision tests dramatically cut checks; duplicate suppression is relaxed for better densification; an aggressive visibility+shortcut smoother finalizes short, smooth paths.",
          "planning_mechanism": "Mechanism: Pre-index AABBs of obstacles in a coarse grid for fast point/segment queries. Alternate tree growth: sample (goal/corridor/uniform), find nearest via adaptive grid rings, and extend a few steps with strict node+edge checks. On each insertion, attempt grandparent visibility compression and local rewiring of nearby nodes if cheaper and collision-free. Try a direct bridge to the other tree, else perform a greedy connect loop from the opposite tree toward the new node. Upon connection, extract start\u2192meetA and meetB\u2192goal, then run visibility compression and randomized shortcuts before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=5.5,\n                 goal_bias=0.17,\n                 corridor_bias=0.34,\n                 extend_steps=3,\n                 connect_steps=24,\n                 grid_cell=None,\n                 dupe_radius_ratio=0.35,\n                 rewire_radius_ratio=1.75,\n                 smoothing_iters=120,\n                 obs_cell=None,\n                 nn_rmax=6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.extend_steps = extend_steps\n        self.connect_steps = connect_steps\n        self.grid_cell = grid_cell\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.rewire_radius_ratio = rewire_radius_ratio\n        self.smoothing_iters = smoothing_iters\n        self.obs_cell = obs_cell\n        self.nn_rmax = nn_rmax\n\n        self.dim = 2\n        self.bounds = None\n        self.start = None\n        self.goal = None\n\n        self._lcg_state = 2463534242\n        self._obs_grid = None\n        self._obs_cell = None\n        self._obs_aabbs = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        obstacles = list(map.obstacles)\n        is_3d = (self.dim == 3)\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.9 * self.step_size)\n        if self.obs_cell is None:\n            self._obs_cell = max(1.0, 1.2 * self.step_size)\n        else:\n            self._obs_cell = max(1.0, self.obs_cell)\n\n        # Build obstacle AABBs and spatial index\n        self._build_obstacle_index(obstacles, is_3d)\n\n        # Validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obstacle(self.start, is_3d) or self._point_in_obstacle(self.goal, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight line\n        if not self._segment_blocked(self.start, self.goal, is_3d):\n            s_node = Node(self.start, None, 0.0)\n            g_node = Node(self.goal, s_node, self._dist(self.start, self.goal))\n            s_node.add_child(g_node)\n            return PlannerResult(True, [self.start, self.goal], [s_node, g_node], [(s_node, g_node)])\n\n        # Initialize trees\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        dupe_radius = self.step_size * self.dupe_radius_ratio\n        rewire_radius = self.step_size * self.rewire_radius_ratio\n        min_sep = max(0.2 * self.step_size, 1e-6)\n\n        # Precompute base corridor width\n        dsg = self._dist(self.start, self.goal)\n        base_corridor = max(self.step_size, 0.2 * dsg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            other_root_pos = self.goal if active_start else self.start\n\n            # Sample target\n            r = self._rand()\n            if r < self.goal_bias:\n                x_rand = other_root_pos\n            elif r < self.goal_bias + self.corridor_bias:\n                x_rand = self._sample_corridor(self.start, self.goal, base_corridor, is_3d)\n            else:\n                x_rand = self._sample_free(is_3d)\n\n            # Nearest in active tree (adaptive grid search)\n            nearest = self._nearest_hash(grid_a, x_rand, self.nn_rmax)\n            if nearest is None:\n                nearest = self._nearest_linear(tree_a, x_rand)\n\n            # Extend a few steps toward x_rand\n            cur = nearest\n            last_new = None\n            for _ in range(self.extend_steps):\n                new_pos = self._steer(cur.position, x_rand, self.step_size)\n                if self._dist(cur.position, new_pos) < min_sep:\n                    break\n                if not self._in_bounds(new_pos):\n                    break\n                if self._exists_close(grid_a, new_pos, dupe_radius):\n                    break\n                if self._point_in_obstacle(new_pos, is_3d):\n                    break\n                if self._segment_blocked(cur.position, new_pos, is_3d):\n                    break\n\n                new_cost = cur.cost + self._dist(cur.position, new_pos)\n                new_node = Node(new_pos, parent=cur, cost=new_cost)\n                cur.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((cur, new_node))\n                self._grid_add(grid_a, new_node)\n\n                # Grandparent visibility compression\n                gp = cur.parent\n                if gp is not None:\n                    if not self._segment_blocked(gp.position, new_node.position, is_3d):\n                        cur.remove_child(new_node)\n                        self._edges_remove(edges, cur, new_node)\n                        gp.add_child(new_node)\n                        new_node.cost = gp.cost + self._dist(gp.position, new_node.position)\n                        edges.append((gp, new_node))\n                        cur = new_node  # continue from the actual new node\n                    else:\n                        cur = new_node\n                else:\n                    cur = new_node\n\n                # Local rewiring around new node\n                self._rewire_neighbors(grid_a, new_node, rewire_radius, edges, is_3d)\n\n                last_new = new_node\n\n            if last_new is None:\n                continue\n\n            # Try immediate direct bridge to nearest in other tree\n            other_near = self._nearest_hash(grid_b, last_new.position, self.nn_rmax)\n            if other_near is None and tree_b:\n                other_near = self._nearest_linear(tree_b, last_new.position)\n\n            if other_near is not None and not self._segment_blocked(last_new.position, other_near.position, is_3d):\n                path = self._extract_path(last_new, other_near)\n                path = self._finalize_path(path, is_3d)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Greedy connect from the other tree toward last_new\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, last_new.position, self.step_size)\n                if self._dist(p.position, to_pos) < min_sep:\n                    break\n                if not self._in_bounds(to_pos):\n                    break\n                if self._exists_close(grid_b, to_pos, dupe_radius):\n                    break\n                if self._point_in_obstacle(to_pos, is_3d):\n                    break\n                if self._segment_blocked(p.position, to_pos, is_3d):\n                    break\n\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                edges.append((p, q))\n                self._grid_add(grid_b, q)\n\n                # Grandparent compression on opposite tree\n                gp2 = p.parent\n                if gp2 is not None and not self._segment_blocked(gp2.position, q.position, is_3d):\n                    p.remove_child(q)\n                    self._edges_remove(edges, p, q)\n                    gp2.add_child(q)\n                    q.cost = gp2.cost + self._dist(gp2.position, q.position)\n                    edges.append((gp2, q))\n\n                # Optional local rewire in opposite tree too\n                self._rewire_neighbors(grid_b, q, rewire_radius, edges, is_3d)\n\n                p = q\n                steps += 1\n\n                if not self._segment_blocked(last_new.position, p.position, is_3d):\n                    path = self._extract_path(last_new, p)\n                    path = self._finalize_path(path, is_3d)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # RNG\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Sampling\n    def _sample_free(self, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._point_in_obstacle(p, is_3d):\n                return p\n\n    def _sample_corridor(self, a, b, width, is_3d):\n        t = self._rand()\n        base = tuple(a[i] + t * (b[i] - a[i]) for i in range(self.dim))\n        if self.dim == 3:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._point_in_obstacle(p, is_3d):\n            return p\n        return self._sample_free(is_3d)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # Grid hashing for nodes\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hash(self, grid, pos, rmax):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, rmax + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        return None\n\n    def _nearest_linear(self, nodes, pos):\n        best = None\n        bestd = float('inf')\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                return True\n        return False\n\n    # Obstacle index\n    def _build_obstacle_index(self, obstacles, is_3d):\n        self._obs_grid = {}\n        self._obs_aabbs = []\n        for idx, obs in enumerate(obstacles):\n            if is_3d:\n                x, y, z, w, h, d = obs\n                minx, miny, minz = x, y, z\n                maxx, maxy, maxz = x + w, y + h, z + d\n                aabb = (minx, miny, minz, maxx, maxy, maxz)\n                ix0 = int(minx // self._obs_cell)\n                iy0 = int(miny // self._obs_cell)\n                iz0 = int(minz // self._obs_cell)\n                ix1 = int(maxx // self._obs_cell)\n                iy1 = int(maxy // self._obs_cell)\n                iz1 = int(maxz // self._obs_cell)\n                self._obs_aabbs.append(aabb)\n                for ix in range(ix0, ix1 + 1):\n                    for iy in range(iy0, iy1 + 1):\n                        for iz in range(iz0, iz1 + 1):\n                            key = (ix, iy, iz)\n                            bucket = self._obs_grid.get(key)\n                            if bucket is None:\n                                self._obs_grid[key] = [idx]\n                            else:\n                                bucket.append(idx)\n            else:\n                x, y, w, h = obs\n                minx, miny = x, y\n                maxx, maxy = x + w, y + h\n                aabb = (minx, miny, maxx, maxy)\n                ix0 = int(minx // self._obs_cell)\n                iy0 = int(miny // self._obs_cell)\n                ix1 = int(maxx // self._obs_cell)\n                iy1 = int(maxy // self._obs_cell)\n                self._obs_aabbs.append(aabb)\n                for ix in range(ix0, ix1 + 1):\n                    for iy in range(iy0, iy1 + 1):\n                        key = (ix, iy)\n                        bucket = self._obs_grid.get(key)\n                        if bucket is None:\n                            self._obs_grid[key] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _obs_keys_for_bbox(self, bmin, bmax, is_3d):\n        if is_3d:\n            ix0 = int(bmin[0] // self._obs_cell)\n            iy0 = int(bmin[1] // self._obs_cell)\n            iz0 = int(bmin[2] // self._obs_cell)\n            ix1 = int(bmax[0] // self._obs_cell)\n            iy1 = int(bmax[1] // self._obs_cell)\n            iz1 = int(bmax[2] // self._obs_cell)\n            keys = []\n            for ix in range(ix0, ix1 + 1):\n                for iy in range(iy0, iy1 + 1):\n                    for iz in range(iz0, iz1 + 1):\n                        keys.append((ix, iy, iz))\n            return keys\n        else:\n            ix0 = int(bmin[0] // self._obs_cell)\n            iy0 = int(bmin[1] // self._obs_cell)\n            ix1 = int(bmax[0] // self._obs_cell)\n            iy1 = int(bmax[1] // self._obs_cell)\n            keys = []\n            for ix in range(ix0, ix1 + 1):\n                for iy in range(iy0, iy1 + 1):\n                    keys.append((ix, iy))\n            return keys\n\n    def _gather_obstacles_bbox(self, bmin, bmax, is_3d):\n        keys = self._obs_keys_for_bbox(bmin, bmax, is_3d)\n        seen = {}\n        out = []\n        for k in keys:\n            bucket = self._obs_grid.get(k)\n            if not bucket:\n                continue\n            for idx in bucket:\n                if seen.get(idx) is None:\n                    seen[idx] = 1\n                    out.append(idx)\n        return out\n\n    # Collision helpers\n    def _point_in_obstacle(self, p, is_3d):\n        if self.dim == 3:\n            bmin = (p[0], p[1], p[2])\n            bmax = (p[0], p[1], p[2])\n            cand = self._gather_obstacles_bbox(bmin, bmax, True)\n            px, py, pz = p\n            for idx in cand:\n                minx, miny, minz, maxx, maxy, maxz = self._obs_aabbs[idx]\n                if minx <= px <= maxx and miny <= py <= maxy and minz <= pz <= maxz:\n                    return True\n        else:\n            bmin = (p[0], p[1])\n            bmax = (p[0], p[1])\n            cand = self._gather_obstacles_bbox(bmin, bmax, False)\n            px, py = p\n            for idx in cand:\n                minx, miny, maxx, maxy = self._obs_aabbs[idx]\n                if minx <= px <= maxx and miny <= py <= maxy:\n                    return True\n        return False\n\n    def _segment_blocked(self, a, b, is_3d):\n        if self.dim == 3:\n            bmin = (min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2]))\n            bmax = (max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2]))\n            cand = self._gather_obstacles_bbox(bmin, bmax, True)\n            for idx in cand:\n                if self._seg_box_intersect_3d(a, b, self._obs_aabbs[idx]):\n                    return True\n        else:\n            bmin = (min(a[0], b[0]), min(a[1], b[1]))\n            bmax = (max(a[0], b[0]), max(a[1], b[1]))\n            cand = self._gather_obstacles_bbox(bmin, bmax, False)\n            for idx in cand:\n                if self._seg_box_intersect_2d(a, b, self._obs_aabbs[idx]):\n                    return True\n        return False\n\n    def _seg_box_intersect_2d(self, p0, p1, aabb):\n        minx, miny, maxx, maxy = aabb\n        tmin = 0.0\n        tmax = 1.0\n        dx = p1[0] - p0[0]\n        dy = p1[1] - p0[1]\n        eps = 1e-12\n\n        if abs(dx) < eps:\n            if p0[0] < minx or p0[0] > maxx:\n                return False\n        else:\n            tx1 = (minx - p0[0]) / dx\n            tx2 = (maxx - p0[0]) / dx\n            if tx1 > tx2:\n                tx1, tx2 = tx2, tx1\n            if tx1 > tmin:\n                tmin = tx1\n            if tx2 < tmax:\n                tmax = tx2\n            if tmin > tmax:\n                return False\n\n        if abs(dy) < eps:\n            if p0[1] < miny or p0[1] > maxy:\n                return False\n        else:\n            ty1 = (miny - p0[1]) / dy\n            ty2 = (maxy - p0[1]) / dy\n            if ty1 > ty2:\n                ty1, ty2 = ty2, ty1\n            if ty1 > tmin:\n                tmin = ty1\n            if ty2 < tmax:\n                tmax = ty2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    def _seg_box_intersect_3d(self, p0, p1, aabb):\n        minx, miny, minz, maxx, maxy, maxz = aabb\n        tmin = 0.0\n        tmax = 1.0\n        dx = p1[0] - p0[0]\n        dy = p1[1] - p0[1]\n        dz = p1[2] - p0[2]\n        eps = 1e-12\n\n        if abs(dx) < eps:\n            if p0[0] < minx or p0[0] > maxx:\n                return False\n        else:\n            tx1 = (minx - p0[0]) / dx\n            tx2 = (maxx - p0[0]) / dx\n            if tx1 > tx2:\n                tx1, tx2 = tx2, tx1\n            if tx1 > tmin:\n                tmin = tx1\n            if tx2 < tmax:\n                tmax = tx2\n            if tmin > tmax:\n                return False\n\n        if abs(dy) < eps:\n            if p0[1] < miny or p0[1] > maxy:\n                return False\n        else:\n            ty1 = (miny - p0[1]) / dy\n            ty2 = (maxy - p0[1]) / dy\n            if ty1 > ty2:\n                ty1, ty2 = ty2, ty1\n            if ty1 > tmin:\n                tmin = ty1\n            if ty2 < tmax:\n                tmax = ty2\n            if tmin > tmax:\n                return False\n\n        if abs(dz) < eps:\n            if p0[2] < minz or p0[2] > maxz:\n                return False\n        else:\n            tz1 = (minz - p0[2]) / dz\n            tz2 = (maxz - p0[2]) / dz\n            if tz1 > tz2:\n                tz1, tz2 = tz2, tz1\n            if tz1 > tmin:\n                tmin = tz1\n            if tz2 < tmax:\n                tmax = tz2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    # Edges handling\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # Rewiring\n    def _rewire_neighbors(self, grid, new_node, radius, edges, is_3d):\n        # gather neighbors within radius\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, self._grid_key(new_node.position), r_cells)\n        for n in cand:\n            if n is new_node or n.parent is None:\n                continue\n            if self._is_ancestor(n, new_node):\n                continue\n            d = self._dist(new_node.position, n.position)\n            if d >= radius:\n                continue\n            if self._segment_blocked(new_node.position, n.position, is_3d):\n                continue\n            new_cost = new_node.cost + d\n            if new_cost + 1e-9 < n.cost:\n                old_parent = n.parent\n                old_cost = n.cost\n                if old_parent is not None:\n                    old_parent.remove_child(n)\n                    self._edges_remove(edges, old_parent, n)\n                new_node.add_child(n)\n                n.cost = new_cost\n                edges.append((new_node, n))\n                self._propagate_cost(n, n.cost - old_cost)\n\n    def _is_ancestor(self, node, potential_descendant):\n        # True if node is on the parent chain of potential_descendant\n        cur = potential_descendant\n        while cur is not None:\n            if cur is node:\n                return True\n            cur = cur.parent\n        return False\n\n    def _propagate_cost(self, node, delta):\n        for ch in node.children:\n            ch.cost += delta\n            self._propagate_cost(ch, delta)\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _visibility_compress(self, pts, is_3d):\n        if len(pts) <= 2:\n            return pts\n        out = [pts[0]]\n        anchor = pts[0]\n        for i in range(1, len(pts) - 1):\n            nxt = pts[i + 1]\n            if self._segment_blocked(anchor, nxt, is_3d):\n                out.append(pts[i])\n                anchor = pts[i]\n        out.append(pts[-1])\n        return out\n\n    def _remove_collinear(self, pts):\n        if len(pts) <= 2:\n            return pts\n        out = [pts[0]]\n        for i in range(1, len(pts) - 1):\n            a = out[-1]\n            b = pts[i]\n            c = pts[i + 1]\n            if self.dim == 2:\n                v1x = b[0] - a[0]; v1y = b[1] - a[1]\n                v2x = c[0] - b[0]; v2y = c[1] - b[1]\n                cross = abs(v1x * v2y - v1y * v2x)\n                if cross > 1e-9:\n                    out.append(b)\n            else:\n                v1 = (b[0] - a[0], b[1] - a[1], b[2] - a[2])\n                v2 = (c[0] - b[0], c[1] - b[1], c[2] - b[2])\n                cx = v1[1] * v2[2] - v1[2] * v2[1]\n                cy = v1[2] * v2[0] - v1[0] * v2[2]\n                cz = v1[0] * v2[1] - v1[1] * v2[0]\n                if (cx * cx + cy * cy + cz * cz) > 1e-9:\n                    out.append(b)\n        out.append(pts[-1])\n        return out\n\n    def _shortcut_path(self, pts, is_3d, iters):\n        if len(pts) <= 2:\n            return pts\n        out = list(pts)\n        for _ in range(iters):\n            n = len(out)\n            if n <= 2:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = out[i]\n            b = out[j]\n            if not self._segment_blocked(a, b, is_3d):\n                out = out[:i + 1] + out[j:]\n        return out\n\n    def _finalize_path(self, path, is_3d):\n        path = self._visibility_compress(path, is_3d)\n        path = self._shortcut_path(path, is_3d, self.smoothing_iters)\n        path = self._visibility_compress(path, is_3d)\n        path = self._remove_collinear(path)\n        return path",
          "objective": -31.24754,
          "time_improvement": 51.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 2065.0,
          "node_improvement": 81.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0181488037109375,
                    "num_nodes_avg": 80.7,
                    "path_length_avg": 180.7731365193801,
                    "smoothness_avg": 0.058919691953749284,
                    "success_improvement": 0.0,
                    "time_improvement": 27.84969697888804,
                    "node_improvement": 79.67766305716445,
                    "length_improvement": 0.9153793400696907,
                    "smoothness_improvement": 822.221125235103,
                    "objective_score": 13.015242323883742
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.032016539573669435,
                    "num_nodes_avg": 171.2,
                    "path_length_avg": 254.75345164906994,
                    "smoothness_avg": 0.1408503666438566,
                    "success_improvement": 0.0,
                    "time_improvement": 80.01597684904573,
                    "node_improvement": 88.49694282066787,
                    "length_improvement": 14.955965168005743,
                    "smoothness_improvement": 3524.1813841648673,
                    "objective_score": 50.5992790763415
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026413965225219726,
                    "num_nodes_avg": 199.6,
                    "path_length_avg": 132.51800698087368,
                    "smoothness_avg": 0.1532626146378892,
                    "success_improvement": 0.0,
                    "time_improvement": 45.626490768279396,
                    "node_improvement": 74.62174189446917,
                    "length_improvement": 11.987849592689066,
                    "smoothness_improvement": 1849.489145524495,
                    "objective_score": 30.128102713719734
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Dual-Mode Rewire-Connect (DMRC): a simplified, grid-accelerated bi-directional planner that pairs k-nearest cost-aware parent selection and local rewiring with incremental RRT-Connect bridging. It uses adaptive steps, full-ring nearest search (no early stop), strict node/edge collision checks, and lightweight visibility-plus-shortcut smoothing for fast, short, and smooth paths.",
          "planning_mechanism": "Mechanism: alternate tree expansions; sample (goal/corridor/uniform), find nearest via grid rings (collect all up to a fixed radius), steer with adaptive step, validate node and edge, choose best parent among nearby candidates, insert and locally rewire; attempt incremental connect toward the new node in the opposite tree and small multi-candidate direct bridges; on success, extract, visibility-compress, shortcut, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        for c in self.children:\n            if c is child:\n                child.parent = self\n                return\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=8.0,\n                 goal_bias=0.3,\n                 corridor_bias=0.4,\n                 grid_cell=None,\n                 k_near=8,\n                 rewire_radius_ratio=2.0,\n                 dupe_radius_ratio=0.5,\n                 connect_steps=12,\n                 smoothing_iters=20):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.grid_cell = grid_cell\n        self.k_near = k_near\n        self.rewire_radius_ratio = rewire_radius_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.connect_steps = connect_steps\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.start = None\n        self.goal = None\n        self._lcg_state = 2463534242\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        obstacles = list(map.obstacles)\n        is_3d = (self.dim == 3)\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.9 * self.step_size)\n\n        # Validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obstacles(self.start, obstacles, is_3d) or self._point_in_obstacles(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line check\n        if not self._segment_blocked(self.start, self.goal, obstacles, is_3d):\n            s_node = Node(self.start, None, 0.0)\n            g_node = Node(self.goal, s_node, self._dist(self.start, self.goal))\n            s_node.add_child(g_node)\n            return PlannerResult(True, [self.start, self.goal], [s_node, g_node], [(s_node, g_node)])\n\n        # Initialize trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        dupe_radius = max(0.1, self.dupe_radius_ratio * self.step_size)\n        min_sep = 0.25 * self.step_size\n        rewire_radius = max(self.step_size, self.rewire_radius_ratio * self.step_size)\n        corridor_width = max(self.step_size, 0.2 * self._dist(self.start, self.goal))\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            other_root_pos = self.goal if active_start else self.start\n\n            # Target sampling: goal / corridor / uniform\n            r = self._rand()\n            if r < self.goal_bias:\n                x_rand = other_root_pos\n            elif r < self.goal_bias + self.corridor_bias:\n                x_rand = self._sample_corridor(self.start, self.goal, corridor_width, obstacles, is_3d)\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest via full-ring collection (no early stop)\n            nearest = self._nearest_grid_full(grid_a, tree_a, x_rand, rmax=3)\n\n            # Adaptive step toward target\n            dnt = self._dist(nearest.position, x_rand)\n            step = min(self.step_size, max(0.5, 0.8 * dnt))\n            new_pos = self._steer(nearest.position, x_rand, step)\n\n            if not self._in_bounds(new_pos):\n                continue\n            if self._dist(nearest.position, new_pos) < min_sep:\n                continue\n            if self._exists_near(grid_a, new_pos, dupe_radius):\n                continue\n            # Node collision and edge collision\n            if self._point_in_obstacles(new_pos, obstacles, is_3d):\n                continue\n            if self._segment_blocked(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Choose best parent among nearby candidates (cost-aware)\n            parent = nearest\n            best_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            near_cands = self._collect_near_nodes(grid_a, new_pos, rewire_radius, tree_a)\n            # ensure nearest is included\n            if nearest not in near_cands:\n                near_cands.append(nearest)\n\n            # k-nearest by distance\n            dlist = []\n            for n in near_cands:\n                d = self._dist(n.position, new_pos)\n                dlist.append((d, n))\n            dlist.sort(key=lambda x: x[0])\n            for _, n in dlist[:self.k_near]:\n                if self._segment_blocked(n.position, new_pos, obstacles, is_3d):\n                    continue\n                cand_cost = n.cost + self._dist(n.position, new_pos)\n                if cand_cost < best_cost:\n                    best_cost = cand_cost\n                    parent = n\n\n            # Insert node (coherent, unique edge)\n            new_node = Node(new_pos, parent, best_cost)\n            parent.add_child(new_node)\n            tree_a.append(new_node)\n            self._add_edge(edges, parent, new_node)\n            self._grid_add(grid_a, new_node)\n\n            # Local rewiring: try to improve neighbors through new_node\n            for _, nbr in dlist[:self.k_near]:\n                if nbr is parent or nbr is new_node:\n                    continue\n                # Only consider if new_node offers a cheaper path\n                alt_cost = new_node.cost + self._dist(new_node.position, nbr.position)\n                if alt_cost + 1e-9 < nbr.cost:\n                    # Validate edge and separation\n                    if self._segment_blocked(new_node.position, nbr.position, obstacles, is_3d):\n                        continue\n                    # Rewire\n                    old_parent = nbr.parent\n                    if old_parent is not None:\n                        old_parent.remove_child(nbr)\n                        self._remove_edge(edges, old_parent, nbr)\n                    new_node.add_child(nbr)\n                    self._add_edge(edges, new_node, nbr)\n                    delta = alt_cost - nbr.cost\n                    nbr.cost = alt_cost\n                    self._propagate_cost(nbr, delta)\n\n            # Try small set of direct bridge attempts to other tree (k-nearest)\n            other_near = self._nearest_grid_full(grid_b, tree_b, new_node.position, rmax=2)\n            if other_near is not None:\n                cands = self._collect_near_nodes(grid_b, new_node.position, rewire_radius, tree_b)\n                if other_near not in cands:\n                    cands.append(other_near)\n                # sort by distance and try up to 3\n                cd = [(self._dist(n.position, new_node.position), n) for n in cands]\n                cd.sort(key=lambda x: x[0])\n                tried = 0\n                for _, n in cd:\n                    if tried >= 3:\n                        break\n                    if not self._segment_blocked(new_node.position, n.position, obstacles, is_3d):\n                        path = self._finalize_path(self._extract_path(new_node, n), obstacles, is_3d)\n                        return PlannerResult(True, path, start_tree + goal_tree, edges)\n                    tried += 1\n\n            # Incremental connect from the opposite tree toward new_node\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, new_node.position, self.step_size)\n                if not self._in_bounds(to_pos):\n                    break\n                if self._dist(p.position, to_pos) < min_sep:\n                    break\n                if self._exists_near(grid_b, to_pos, dupe_radius):\n                    break\n                if self._point_in_obstacles(to_pos, obstacles, is_3d):\n                    break\n                if self._segment_blocked(p.position, to_pos, obstacles, is_3d):\n                    break\n                q = Node(to_pos, p, p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                self._add_edge(edges, p, q)\n                self._grid_add(grid_b, q)\n                p = q\n                steps += 1\n\n                # Check direct visibility between new_node and latest opposite-tree node\n                if not self._segment_blocked(new_node.position, p.position, obstacles, is_3d):\n                    path = self._finalize_path(self._extract_path(new_node, p), obstacles, is_3d)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # -------- RNG --------\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # -------- Geometry --------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / max(1e-12, d)\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # -------- Grid NN --------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid_full(self, grid, tree, pos, rmax):\n        key = self._grid_key(pos)\n        cand = []\n        for r in range(0, rmax + 1):\n            cand.extend(self._collect_ring(grid, key, r))\n        if not cand:\n            # fallback linear\n            best = None\n            bestd = float('inf')\n            for n in tree:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            return best\n        best = None\n        bestd = float('inf')\n        for n in cand:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _collect_near_nodes(self, grid, pos, radius, tree):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._collect_ring(grid, key, r_cells)\n        if not cand:\n            return list(tree)  # degenerate fallback\n        return cand\n\n    def _exists_near(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._collect_ring(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                return True\n        return False\n\n    # -------- Collision --------\n    def _point_in_obstacles(self, p, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = p\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = p\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_blocked(self, a, b, obstacles, is_3d):\n        if is_3d:\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                aabb = (x, y, z, x + w, y + h, z + d)\n                if self._seg_box_intersect_3d(a, b, aabb):\n                    return True\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                aabb = (x, y, x + w, y + h)\n                if self._seg_box_intersect_2d(a, b, aabb):\n                    return True\n        return False\n\n    def _seg_box_intersect_2d(self, p0, p1, aabb):\n        minx, miny, maxx, maxy = aabb\n        tmin = 0.0\n        tmax = 1.0\n        dx = p1[0] - p0[0]\n        dy = p1[1] - p0[1]\n        eps = 1e-12\n\n        # X slab\n        if abs(dx) < eps:\n            if p0[0] < minx or p0[0] > maxx:\n                return False\n        else:\n            tx1 = (minx - p0[0]) / dx\n            tx2 = (maxx - p0[0]) / dx\n            if tx1 > tx2:\n                tx1, tx2 = tx2, tx1\n            if tx1 > tmin:\n                tmin = tx1\n            if tx2 < tmax:\n                tmax = tx2\n            if tmin > tmax:\n                return False\n\n        # Y slab\n        if abs(dy) < eps:\n            if p0[1] < miny or p0[1] > maxy:\n                return False\n        else:\n            ty1 = (miny - p0[1]) / dy\n            ty2 = (maxy - p0[1]) / dy\n            if ty1 > ty2:\n                ty1, ty2 = ty2, ty1\n            if ty1 > tmin:\n                tmin = ty1\n            if ty2 < tmax:\n                tmax = ty2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    def _seg_box_intersect_3d(self, p0, p1, aabb):\n        minx, miny, minz, maxx, maxy, maxz = aabb\n        tmin = 0.0\n        tmax = 1.0\n        dx = p1[0] - p0[0]\n        dy = p1[1] - p0[1]\n        dz = p1[2] - p0[2]\n        eps = 1e-12\n\n        # X slab\n        if abs(dx) < eps:\n            if p0[0] < minx or p0[0] > maxx:\n                return False\n        else:\n            tx1 = (minx - p0[0]) / dx\n            tx2 = (maxx - p0[0]) / dx\n            if tx1 > tx2:\n                tx1, tx2 = tx2, tx1\n            if tx1 > tmin:\n                tmin = tx1\n            if tx2 < tmax:\n                tmax = tx2\n            if tmin > tmax:\n                return False\n\n        # Y slab\n        if abs(dy) < eps:\n            if p0[1] < miny or p0[1] > maxy:\n                return False\n        else:\n            ty1 = (miny - p0[1]) / dy\n            ty2 = (maxy - p0[1]) / dy\n            if ty1 > ty2:\n                ty1, ty2 = ty2, ty1\n            if ty1 > tmin:\n                tmin = ty1\n            if ty2 < tmax:\n                tmax = ty2\n            if tmin > tmax:\n                return False\n\n        # Z slab\n        if abs(dz) < eps:\n            if p0[2] < minz or p0[2] > maxz:\n                return False\n        else:\n            tz1 = (minz - p0[2]) / dz\n            tz2 = (maxz - p0[2]) / dz\n            if tz1 > tz2:\n                tz1, tz2 = tz2, tz1\n            if tz1 > tmin:\n                tmin = tz1\n            if tz2 < tmax:\n                tmax = tz2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    # -------- Edges and costs --------\n    def _add_edge(self, edges, parent, child):\n        for e in edges:\n            if e[0] is parent and e[1] is child:\n                return\n        edges.append((parent, child))\n\n    def _remove_edge(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_cost(self, node, delta):\n        # Update subtree costs by delta\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur is not node:\n                cur.cost += delta\n            for ch in cur.children:\n                stack.append(ch)\n\n    # -------- Sampling --------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._point_in_obstacles(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, a, b, width, obstacles, is_3d):\n        # Pick a random point along the segment with uniform lateral jitter per axis\n        t = self._rand()\n        base = tuple(a[i] + t * (b[i] - a[i]) for i in range(self.dim))\n        if self.dim == 3:\n            p = (self._clamp_val(base[0] + (self._rand() * 2.0 - 1.0) * width, 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + (self._rand() * 2.0 - 1.0) * width, 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + (self._rand() * 2.0 - 1.0) * width, 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + (self._rand() * 2.0 - 1.0) * width, 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + (self._rand() * 2.0 - 1.0) * width, 0.0, self.bounds[1]))\n        if not self._point_in_obstacles(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # -------- Paths and smoothing --------\n    def _path_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        out.reverse()\n        return out\n\n    def _extract_path(self, meet_a, meet_b):\n        pa = self._path_to_root(meet_a)\n        pb = []\n        cur = meet_b\n        while cur is not None:\n            pb.append(cur.position)\n            cur = cur.parent\n        return pa + pb\n\n    def _visibility_compress(self, pts, obstacles, is_3d):\n        if len(pts) <= 2:\n            return pts\n        out = [pts[0]]\n        anchor = pts[0]\n        for i in range(1, len(pts) - 1):\n            nxt = pts[i + 1]\n            if self._segment_blocked(anchor, nxt, obstacles, is_3d):\n                out.append(pts[i])\n                anchor = pts[i]\n        out.append(pts[-1])\n        return out\n\n    def _shortcut(self, pts, obstacles, is_3d, iters):\n        if len(pts) <= 2:\n            return pts\n        out = list(pts)\n        n = len(out)\n        attempts = max(iters, 1) * n\n        i = 0\n        while attempts > 0 and n > 2:\n            attempts -= 1\n            i = i % (n - 2)\n            j = i + 2\n            improved = False\n            while j < n:\n                if not self._segment_blocked(out[i], out[j], obstacles, is_3d):\n                    out = out[:i + 1] + out[j:]\n                    n = len(out)\n                    improved = True\n                    break\n                j += 1\n            if not improved:\n                i += 1\n        return out\n\n    def _finalize_path(self, path, obstacles, is_3d):\n        path = self._visibility_compress(path, obstacles, is_3d)\n        path = self._shortcut(path, obstacles, is_3d, self.smoothing_iters)\n        path = self._visibility_compress(path, obstacles, is_3d)\n        return path",
          "objective": -30.46543,
          "time_improvement": 47.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1549.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024193310737609865,
                    "num_nodes_avg": 56.2,
                    "path_length_avg": 166.88782164225205,
                    "smoothness_avg": 0.05372709814226867,
                    "success_improvement": 0.0,
                    "time_improvement": 3.819847930224571,
                    "node_improvement": 85.8473936036263,
                    "length_improvement": 8.526140451117973,
                    "smoothness_improvement": 740.9457561874929,
                    "objective_score": 9.966367430675618
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0371060848236084,
                    "num_nodes_avg": 104.1,
                    "path_length_avg": 240.41186233560762,
                    "smoothness_avg": 0.10303720064392312,
                    "success_improvement": 0.0,
                    "time_improvement": 76.83919411559079,
                    "node_improvement": 93.00544245111874,
                    "length_improvement": 19.74360048059955,
                    "smoothness_improvement": 2551.221387263985,
                    "objective_score": 47.65402545935689
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018965983390808107,
                    "num_nodes_avg": 66.5,
                    "path_length_avg": 128.68380775913937,
                    "smoothness_avg": 0.11427431830439853,
                    "success_improvement": 0.0,
                    "time_improvement": 60.958263396056026,
                    "node_improvement": 91.54481881754609,
                    "length_improvement": 14.534342150818011,
                    "smoothness_improvement": 1353.560893979175,
                    "objective_score": 33.775888779203484
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "AURORA-BiRRT*: A*-guided, Unrolled-Rewire, Obstacle-Grid accelerated BiRRT with memoized edges and cell-pair sieve. It couples hashed nearest search, per-cell throttling, duplicate suppression, heuristic parent selection (g+h), bounded rewiring with full cost propagation, multi-step Connect, and quantized edge-collision caching; online LOS compression and cache-aware shortcutting yield smooth, short paths quickly.",
          "planning_mechanism": "Alternate tree growth with k-beam samples. Each beam selects a parent among local candidates minimizing g(parent)+d(parent,qn)+\u03bb\u00b7h(qn,other-tree), enforcing both node and edge validity before insertion. After insertion, LOS-compress to an ancestor, rewire neighbors if cheaper and propagate costs. A limited Connect grows the opposite tree unless a cached blocked cell-pair forbids it; direct edges terminate early. Once an incumbent exists, informed ellipse sampling narrows exploration; final shortcutting and LOS collapse return a concise path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=9.0,\n        collision_res=1.0,\n        beam_k=2,\n        goal_bias=0.2,\n        informed_bias=0.6,\n        grid_cell_factor=1.2,\n        per_cell_cap=6,\n        dupe_radius_ratio=0.45,\n        rewire_radius_factor=2.5,\n        neighbor_cap=24,\n        compress_depth=2,\n        connect_steps=3,\n        edge_cache_capacity=40000,\n        edge_cache_quant=0.8,\n        smoothing_iters=50,\n        no_improve_stop=12\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_res = collision_res\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.informed_bias = informed_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.per_cell_cap = per_cell_cap\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.rewire_radius_factor = rewire_radius_factor\n        self.neighbor_cap = neighbor_cap\n        self.compress_depth = compress_depth\n        self.connect_steps = connect_steps\n        self.edge_cache_capacity = edge_cache_capacity\n        self.edge_cache_quant = edge_cache_quant\n        self.smoothing_iters = smoothing_iters\n        self.no_improve_stop = no_improve_stop\n\n        self._rnd_state = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_from_scene()\n\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n\n        # Edge cache\n        self._tick = 0\n        self.ecache = {}\n        self._last_prune_size = 0\n        self.eq = max(0.25, self.edge_cache_quant)\n        # Collision stepping resolution for fallback sampling checks\n        self.edge_res = max(0.5, self.collision_res)\n\n        # Build obstacle grid\n        self._build_obstacle_grid()\n\n        # Validate endpoints\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        nodes = []\n        edges = []\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        throttles_a, throttles_b = {}, {}\n        anchors_a, anchors_b = [start_root], [goal_root]\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        best_path = None\n        best_len = float('inf')\n        sg = self._dist(self.start, self.goal)\n\n        blocked_pairs = set()\n        anchor_stride = 20\n        max_rings = 4\n\n        for it in range(self.max_iter):\n            side_start = (it % 2 == 0)\n            tree1 = tree_a if side_start else tree_b\n            grid1 = grid_a if side_start else grid_b\n            throttles1 = throttles_a if side_start else throttles_b\n            anchors1 = anchors_a if side_start else anchors_b\n\n            tree2 = tree_b if side_start else tree_a\n            grid2 = grid_b if side_start else grid_a\n            throttles2 = throttles_b if side_start else throttles_a\n            anchors2 = anchors_b if side_start else anchors_a\n\n            attractor = self.goal if side_start else self.start\n\n            progressed = False\n            for _ in range(self.beam_k):\n                sample = self._sample(attractor, best_len, sg)\n                if sample is None:\n                    continue\n                near = self._nearest_hashed(grid1, anchors1, sample, max_rings)\n                if near is None:\n                    continue\n                new_pos = self._steer(near.position, sample)\n                if not self._within_bounds(new_pos):\n                    continue\n                if self._point_in_obstacles(new_pos):\n                    continue\n                if self._has_nearby(grid1, new_pos, self.dupe_radius):\n                    continue\n\n                # Parent selection (A*-guided among local candidates)\n                rewire_r = self._rewire_radius(len(nodes))\n                parents = self._candidate_parents(grid1, anchors1, tree1, new_pos, rewire_r, self.neighbor_cap)\n                best_parent, best_new_cost = None, float('inf')\n                best_score = float('inf')\n                other_near = self._nearest_hashed(grid2, anchors2, new_pos, max_rings)\n                h_term = self._dist(new_pos, other_near.position if other_near else attractor)\n                lam = 0.1\n                for p in parents:\n                    if not self._edge_free(p.position, new_pos):\n                        continue\n                    gc = p.cost + self._dist(p.position, new_pos)\n                    f = gc + lam * h_term\n                    if f + 1e-9 < best_score:\n                        best_score = f\n                        best_parent = p\n                        best_new_cost = gc\n                if best_parent is None:\n                    continue\n\n                # Per-cell cap with cost admission\n                ckey = self._cell_of(new_pos)\n                bucket = grid1.get(ckey)\n                if bucket and len(bucket) >= self.per_cell_cap:\n                    best_bucket_cost = min(n.cost for n in bucket)\n                    if best_new_cost >= best_bucket_cost - 1e-9:\n                        continue\n\n                # Final validity before insertion\n                if self._point_in_obstacles(new_pos):\n                    continue\n                if not self._edge_free(best_parent.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos, best_parent, best_new_cost)\n                best_parent.add_child(new_node)\n                tree1.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                self._grid_insert(grid1, new_node)\n                throttles1[ckey] = throttles1.get(ckey, 0) + 1\n                if (len(tree1) % anchor_stride) == 0:\n                    anchors1.append(new_node)\n                progressed = True\n\n                # LOS compression to ancestors\n                self._compress_to_ancestors(new_node, edges, self.compress_depth)\n\n                # Rewiring around new_node\n                self._rewire_neighbors(grid1, new_node, rewire_r, edges)\n\n                # Try connect to the other tree\n                pair_key = self._pair_key(self._cell_of(new_node.position),\n                                          self._cell_of((other_near.position if other_near else attractor)))\n                if pair_key not in blocked_pairs:\n                    connected, path = self._attempt_connect(new_node, tree2, grid2, throttles2, anchors2, nodes, edges)\n                    if connected:\n                        path = self._shortcut(path)\n                        path = self._los_collapse(path)\n                        best_path = path\n                        best_len = self._path_len(path)\n                        return PlannerResult(True, path, nodes, edges)\n                    else:\n                        blocked_pairs.add(pair_key)\n\n            if not progressed:\n                continue\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= len(self.obstacles) * 2654435761\n        self._rnd_state = (s ^ 0xA5A5A5) & 0xffffffff\n        if self._rnd_state == 0:\n            self._rnd_state = 2463534242\n\n    def _rand(self):\n        self._rnd_state = (1664525 * self._rnd_state + 1013904223) & 0xffffffff\n        return self._rnd_state / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= self.step_size:\n            return self._clamp(b)\n        r = self.step_size / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Sampling\n    def _sample(self, attractor, best_len, sg):\n        for _ in range(24):\n            if best_len < float('inf') and self._rand() < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p and self._within_bounds(p) and not self._point_in_obstacles(p):\n                    return p\n            else:\n                if self._rand() < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n                if self._within_bounds(p) and not self._point_in_obstacles(p):\n                    return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # Node grid (for NN, dupes, neighbors)\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, anchors, pos, max_rings=4):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # fallback scan\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not bucket:\n                            continue\n                        for n in bucket:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((key[0] + dx, key[1] + dy))\n                    if not bucket:\n                        continue\n                    for n in bucket:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    def _candidate_parents(self, grid, anchors, tree, pos, radius, cap):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        if not cand:\n            cand = anchors[:]\n        if len(cand) > cap:\n            # Reservoir-like random subset\n            out = []\n            take = 0\n            for n in cand:\n                take += 1\n                if len(out) < cap:\n                    out.append(n)\n                else:\n                    j = int(self._rand_range(0, take))\n                    if j < len(out):\n                        out[j] = n\n            cand = out\n        return cand\n\n    # Obstacle spatial grid\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    # Edge checks with cache\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.eq) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.eq) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        if len(self.ecache) - self._last_prune_size > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self.ecache:\n            return\n        cutoff = self._tick - 3000\n        to_del = []\n        for k, v in self.ecache.items():\n            if v[1] < cutoff:\n                to_del.append(k)\n        if not to_del:\n            i = 0\n            for k in list(self.ecache.keys()):\n                if (i % 3) == 0:\n                    to_del.append(k)\n                i += 1\n        for k in to_del:\n            if k in self.ecache:\n                del self.ecache[k]\n        self._last_prune_size = len(self.ecache)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Compression and rewiring\n    def _compress_to_ancestors(self, node, edges, depth_limit):\n        depth = 0\n        curp = node.parent\n        while curp is not None and curp.parent is not None and depth < depth_limit:\n            gp = curp.parent\n            if self._edge_free(gp.position, node.position):\n                self._reparent(node, gp, edges)\n                curp = node.parent\n                depth += 1\n            else:\n                break\n\n    def _rewire_radius(self, n_nodes):\n        # simple schedule\n        return max(self.step_size * 1.5, self.rewire_radius_factor * self.step_size)\n\n    def _rewire_neighbors(self, grid, node, radius, edges):\n        key = self._cell_of(node.position)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        neigh = self._grid_ring_nodes(grid, key, r_cells)\n        count = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if d > radius:\n                continue\n            new_cost = node.cost + d\n            if new_cost + 1e-9 < nb.cost and self._edge_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n                count += 1\n                if count >= self.neighbor_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        old_parent = child.parent\n        if old_parent is new_parent:\n            return\n        if old_parent is not None:\n            old_parent.remove_child(child)\n            self._edges_remove(edges, old_parent, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        self._propagate_costs(child)\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                old = ch.cost\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                if abs(ch.cost - old) > 1e-12:\n                    stack.append(ch)\n\n    # Connect attempt\n    def _attempt_connect(self, new_node, other_tree, other_grid, throttles, anchors, nodes, edges):\n        other_near = self._nearest_hashed(other_grid, anchors, new_node.position, 4)\n        if other_near is None:\n            return False, []\n        # Try direct bridge first\n        if self._edge_free(new_node.position, other_near.position):\n            path = self._extract_path(new_node, other_near)\n            return True, self._ensure_bounds_and_valid(path)\n\n        p = other_near\n        steps = 0\n        last_q = None\n        while steps < self.connect_steps:\n            step_pos = self._steer(p.position, new_node.position)\n            if not self._within_bounds(step_pos):\n                break\n            if self._point_in_obstacles(step_pos):\n                break\n            if self._has_nearby(other_grid, step_pos, self.dupe_radius):\n                break\n            if not self._edge_free(p.position, step_pos):\n                break\n            cell = self._cell_of(step_pos)\n            bucket = other_grid.get(cell)\n            if bucket and len(bucket) >= self.per_cell_cap:\n                best_bucket_cost = min(n.cost for n in bucket)\n                new_c = p.cost + self._dist(p.position, step_pos)\n                if new_c >= best_bucket_cost - 1e-9:\n                    break\n\n            q = Node(step_pos, p, p.cost + self._dist(p.position, step_pos))\n            p.add_child(q)\n            other_tree.append(q)\n            nodes.append(q)\n            edges.append((p, q))\n            self._grid_insert(other_grid, q)\n            throttles[cell] = throttles.get(cell, 0) + 1\n            if (len(other_tree) % 20) == 0:\n                anchors.append(q)\n\n            self._compress_to_ancestors(q, edges, 1)\n            # local light rewiring\n            self._rewire_neighbors(other_grid, q, self._rewire_radius(len(nodes)), edges)\n\n            if self._edge_free(new_node.position, q.position):\n                path = self._extract_path(new_node, q)\n                return True, self._ensure_bounds_and_valid(path)\n\n            p = q\n            last_q = q\n            steps += 1\n        return False, []\n\n    def _pair_key(self, c1, c2):\n        return (c1, c2) if c1 <= c2 else (c2, c1)\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return pa + pb[::-1]\n\n    def _ensure_bounds_and_valid(self, path):\n        return [self._clamp(p) for p in path]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # Post smoothing\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        attempts = 0\n        no_improve = 0\n        best_len = self._path_len(pts)\n        while attempts < self.smoothing_iters:\n            i = int(self._rand_range(0, max(1, len(pts) - 2)))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                attempts += 1\n                continue\n            a, b = pts[i], pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= best_len + 1e-12:\n                    pts = new_pts\n                    best_len = L\n                    no_improve = 0\n                else:\n                    no_improve += 1\n            else:\n                no_improve += 1\n            attempts += 1\n            if no_improve >= self.no_improve_stop:\n                break\n        return pts\n\n    def _los_collapse(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = [path[0]]\n        last = path[0]\n        k = 1\n        while k < len(path) - 1:\n            nxt = path[k + 1]\n            if self._edge_free(last, nxt):\n                k += 1\n                continue\n            pts.append(path[k])\n            last = path[k]\n            k += 1\n        pts.append(path[-1])\n        return pts",
          "objective": -29.84258,
          "time_improvement": 46.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1759.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013257336616516114,
                    "num_nodes_avg": 49.0,
                    "path_length_avg": 163.59788282479164,
                    "smoothness_avg": 0.10284552152668414,
                    "success_improvement": 0.0,
                    "time_improvement": 48.00798880221262,
                    "node_improvement": 87.6605389070763,
                    "length_improvement": 10.329408049384693,
                    "smoothness_improvement": 1509.7557445171647,
                    "objective_score": 28.148820192880425
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01610586643218994,
                    "num_nodes_avg": 62.0,
                    "path_length_avg": 241.62656852319907,
                    "smoothness_avg": 0.0921645090196098,
                    "success_improvement": 0.0,
                    "time_improvement": 89.9462328864473,
                    "node_improvement": 95.83417321776524,
                    "length_improvement": 19.338096591802515,
                    "smoothness_improvement": 2271.4592004871693,
                    "objective_score": 49.944023823451545
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.048529839515686034,
                    "num_nodes_avg": 126.0,
                    "path_length_avg": 141.44566627862946,
                    "smoothness_avg": 0.12548275222835503,
                    "success_improvement": 0.0,
                    "time_improvement": 1.0637827328513305,
                    "node_improvement": 83.97965670692943,
                    "length_improvement": 6.058523376571766,
                    "smoothness_improvement": 1496.1313461713685,
                    "objective_score": 11.4349055766553
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "AIR-Connect*: Adaptive Informed Rewire BiRRT-Connect with cached edges and ring-hash neighbors. It alternates tree growth from start/goal, uses ellipse-gated sampling after first solution, cost-gated admission before expensive checks, LOS-cost parent selection with local RRT* rewiring, cached edge validity, and a short validated connect toward the opposite tree. On bridge, it visibility-prunes and applies bounded shortcuts for shorter, smoother paths.",
          "planning_mechanism": "Alternate expanding the two trees. For each sample: find a near node via ring-hash, steer one step, bounds+node-collision check, early cost-gate, then edge-collision. Select the best-cost parent among nearby LOS neighbors; insert and locally rewire cheaper neighbors under edge checks. Attempt a short validated connect to the other tree; if a direct or stepwise bridge succeeds, extract, prune, and shortcut the path. Use informed ellipse sampling after first path to focus and reduce time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=5.0,\n        goal_bias=0.25,\n        line_bias=0.25,\n        grid_cell_factor=1.5,\n        min_sep_factor=0.4,\n        ring_max=3,\n        neighbor_factor=3.0,\n        connect_steps=6,\n        occ_relax=1.05,\n        smoothing_iters=120\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.min_sep_factor = min_sep_factor\n        self.ring_max = ring_max\n        self.neighbor_factor = neighbor_factor\n        self.connect_steps = connect_steps\n        self.occ_relax = occ_relax\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Derived parameters\n        self.edge_res = max(0.5, min(1.0, 0.5 * self.step_size))\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.3, self.step_size * self.min_sep_factor)\n        self.occ_cell = max(0.5, 0.6 * self.step_size)\n\n        # Reset caches\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.append(g)\n            nodes = [s, g]\n            edges = [(s, g)]\n            return PlannerResult(True, [start, goal], nodes, edges)\n\n        # Initialize bi-trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n\n        start_nodes = [start_root]\n        goal_nodes = [goal_root]\n        all_nodes = [start_root, goal_root]\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root, self.cell_size)\n        self._grid_add(grid_goal, goal_root, self.cell_size)\n\n        occ_start = {self._grid_key(start, self.occ_cell): 0.0}\n        occ_goal = {self._grid_key(goal, self.occ_cell): 0.0}\n\n        success = False\n        best_path = None\n        c_best = float('inf')\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n\n            if active_start:\n                nodes_a, nodes_b = start_nodes, goal_nodes\n                grid_a, grid_b = grid_start, grid_goal\n                occ_a, occ_b = occ_start, occ_goal\n                attractor = goal\n                root_a = start_root\n                root_b = goal_root\n            else:\n                nodes_a, nodes_b = goal_nodes, start_nodes\n                grid_a, grid_b = grid_goal, grid_start\n                occ_a, occ_b = occ_goal, occ_start\n                attractor = start\n                root_a = goal_root\n                root_b = start_root\n\n            # Sample\n            if self._rand() < self.goal_bias:\n                x_rand = attractor\n            else:\n                if c_best < float('inf') and self._rand() < 0.6:\n                    x_rand = self._ellipse_sample(root_a.position, root_b.position, c_best)\n                elif self._rand() < self.line_bias:\n                    t = self._uniform(0.0, 1.0)\n                    base = tuple(root_a.position[i] + t * (root_b.position[i] - root_a.position[i]) for i in range(self.dim))\n                    jitter = 0.5 * self.step_size\n                    x_rand = tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n                else:\n                    x_rand = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n            # Nearest in active tree\n            n_near = self._nearest_hashed(grid_a, nodes_a, x_rand)\n            if n_near is None:\n                continue\n\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n            if not self._in_bounds(x_new_pos):\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                continue\n            if self._near_duplicate(grid_a, x_new_pos, self.min_sep):\n                continue\n\n            # Early cost-gated admission (cheap)\n            tentative_cost = n_near.cost + self._dist(n_near.position, x_new_pos)\n            if not self._occ_accept(occ_a, x_new_pos, tentative_cost, self.occ_cell, self.occ_relax):\n                continue\n\n            # Edge collision with nearest\n            if self._edge_blocked(n_near.position, x_new_pos, obstacles, is_3d):\n                continue\n\n            # Choose best parent among neighbors with LOS\n            neigh_r = self._neighbor_radius(len(nodes_a))\n            neigh = self._neighbors_in_radius(grid_a, x_new_pos, neigh_r)\n            parent, new_cost = self._choose_best_parent(x_new_pos, n_near, neigh, obstacles, is_3d)\n            if parent is None:\n                continue\n            if self._edge_blocked(parent.position, x_new_pos, obstacles, is_3d):\n                continue  # safety\n\n            # Insert new node\n            x_new = Node(x_new_pos, None, new_cost)\n            x_new.attach(parent)\n            nodes_a.append(x_new)\n            all_nodes.append(x_new)\n            self._grid_add(grid_a, x_new, self.cell_size)\n            self._occ_update(occ_a, x_new_pos, new_cost, self.occ_cell)\n\n            # Local RRT* rewiring around new node\n            self._rewire_neighbors(x_new, neigh, obstacles, is_3d)\n\n            # Try to connect to the other tree (direct, else short validated steps)\n            other_near = self._nearest_hashed(grid_b, nodes_b, x_new.position)\n            bridged_node_b = None\n\n            # Direct attempt\n            if (other_near is not None) and (not self._edge_blocked(x_new.position, other_near.position, obstacles, is_3d)):\n                bridged_node_b = other_near\n            else:\n                # Short validated connect from other tree toward x_new\n                cur = other_near\n                steps = 0\n                while cur is not None and steps < self.connect_steps:\n                    step_pos = self._steer(cur.position, x_new.position, self.step_size)\n                    if not self._in_bounds(step_pos):\n                        break\n                    if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                        break\n                    if self._near_duplicate(grid_b, step_pos, self.min_sep):\n                        break\n                    connect_cost = cur.cost + self._dist(cur.position, step_pos)\n                    if not self._occ_accept(occ_b, step_pos, connect_cost, self.occ_cell, self.occ_relax):\n                        break\n                    if self._edge_blocked(cur.position, step_pos, obstacles, is_3d):\n                        break\n\n                    # Parent selection for connect step\n                    neigh_b = self._neighbors_in_radius(grid_b, step_pos, neigh_r)\n                    p_b, c_b = self._choose_best_parent(step_pos, cur, neigh_b, obstacles, is_3d)\n                    if p_b is None:\n                        break\n                    if self._edge_blocked(p_b.position, step_pos, obstacles, is_3d):\n                        break\n\n                    nxt = Node(step_pos, None, c_b)\n                    nxt.attach(p_b)\n                    nodes_b.append(nxt)\n                    all_nodes.append(nxt)\n                    self._grid_add(grid_b, nxt, self.cell_size)\n                    self._occ_update(occ_b, step_pos, c_b, self.occ_cell)\n\n                    # light rewire on B-side (cheap subset)\n                    self._rewire_neighbors(nxt, neigh_b, obstacles, is_3d)\n\n                    cur = nxt\n                    steps += 1\n\n                    # Check final bridge\n                    if not self._edge_blocked(cur.position, x_new.position, obstacles, is_3d):\n                        bridged_node_b = cur\n                        break\n\n            if bridged_node_b is not None:\n                # Extract full path\n                if active_start:\n                    path = self._path_to_root(x_new)\n                    path_b = self._path_to_root(bridged_node_b)\n                    path_full = path + list(reversed(path_b))\n                else:\n                    path = self._path_to_root(x_new)\n                    path_b = self._path_to_root(bridged_node_b)\n                    path_full = path_b + list(reversed(path))\n\n                # Prune and smooth\n                path_full = self._visibility_prune(path_full, obstacles, is_3d)\n                path_full = self._shortcut_smooth(path_full, obstacles, is_3d, self.smoothing_iters)\n\n                L = self._path_length(path_full)\n                if L < c_best:\n                    c_best = L\n                    best_path = path_full\n                    success = True\n                    # Early stop on first good bridge to reduce time\n                    edges = []\n                    for n in all_nodes:\n                        if n.parent is not None:\n                            edges.append((n.parent, n))\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n        edges = []\n        for n in all_nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        return PlannerResult(success, best_path if best_path is not None else [], all_nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    def _clamp(self, p):\n        return tuple(self._clip(p[i], 0.0, self.bounds[i]) for i in range(self.dim))\n\n    # Collision and caching\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        cached = self._edge_cache.get(k)\n        if cached is not None:\n            return cached\n        blocked = self._segment_hits(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_hits(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Spatial hashing and neighbors\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        seen = set()\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            for n in b:\n                                if n not in seen:\n                                    seen.add(n)\n                                    cand.append(n)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        for n in b:\n                            if n not in seen:\n                                seen.add(n)\n                                cand.append(n)\n        return cand\n\n    def _nearest_hashed(self, grid, nodes, pos):\n        key = self._grid_key(pos, self.cell_size)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.ring_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback scan limited\n        limit = min(64, len(nodes))\n        if limit == 0:\n            return None\n        step = max(1, len(nodes) // limit)\n        for i in range(0, len(nodes), step):\n            n = nodes[i]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        r = int(radius // self.cell_size) + 1\n        key = self._grid_key(pos, self.cell_size)\n        cand = self._grid_ring_collect(grid, key, r)\n        res = []\n        rr = radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr + 1e-9:\n                res.append(n)\n        return res\n\n    def _neighbor_radius(self, ncount):\n        base = self.neighbor_factor * self.step_size\n        if ncount < 200:\n            return base * 2.5\n        if ncount < 1000:\n            return base * 2.0\n        return base * 1.5\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos, self.cell_size)\n        cand = self._grid_ring_collect(grid, key, 1)\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                return True\n        return False\n\n    # Admission ledger\n    def _occ_accept(self, occ_best, pos, cost, cell, relax):\n        k = self._grid_key(pos, cell)\n        prev = occ_best.get(k, float('inf'))\n        return cost < prev * relax\n\n    def _occ_update(self, occ_best, pos, cost, cell):\n        k = self._grid_key(pos, cell)\n        prev = occ_best.get(k, float('inf'))\n        if cost < prev:\n            occ_best[k] = cost\n\n    # Parent selection and rewiring\n    def _choose_best_parent(self, new_pos, fallback_nearest, neighbors, obstacles, is_3d):\n        best_parent = fallback_nearest\n        best_cost = fallback_nearest.cost + self._dist(fallback_nearest.position, new_pos)\n        # Evaluate neighbors with LOS\n        for n in neighbors:\n            c = n.cost + self._dist(n.position, new_pos)\n            if c + 1e-12 < best_cost:\n                if not self._edge_blocked(n.position, new_pos, obstacles, is_3d):\n                    best_cost = c\n                    best_parent = n\n        if best_parent is None:\n            return None, float('inf')\n        return best_parent, best_cost\n\n    def _rewire_neighbors(self, new_node, neighbors, obstacles, is_3d):\n        for m in neighbors:\n            if m is new_node or m is new_node.parent:\n                continue\n            alt = new_node.cost + self._dist(new_node.position, m.position)\n            if alt + 1e-12 < m.cost:\n                if not self._edge_blocked(new_node.position, m.position, obstacles, is_3d):\n                    old_cost = m.cost\n                    m.attach(new_node)\n                    m.cost = alt\n                    # Propagate cost change to descendants\n                    delta = alt - old_cost\n                    if abs(delta) > 0.0:\n                        self._propagate_cost(m, delta)\n\n    def _propagate_cost(self, node, delta):\n        q = [node]\n        while q:\n            cur = q.pop()\n            for ch in cur.children:\n                ch.cost += delta\n                q.append(ch)\n\n    # Sampling helpers\n    def _ellipse_sample(self, a, b, c_best):\n        # Sample uniformly in bounding box with quick rejection to keep it cheap\n        tries = 20\n        for _ in range(tries):\n            p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n            if self._dist(p, a) + self._dist(p, b) <= c_best + 1e-9:\n                return p\n        # Fallback to line jitter\n        t = self._uniform(0.0, 1.0)\n        base = tuple(a[i] + t * (b[i] - a[i]) for i in range(self.dim))\n        jitter = 0.5 * self.step_size\n        return tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n\n    # Path utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(out[-1], path[j], obstacles, is_3d):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i + 1])\n                i += 1\n        return out\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
          "objective": -29.76423,
          "time_improvement": 24.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 2154.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022998476028442384,
                    "num_nodes_avg": 61.0,
                    "path_length_avg": 156.6750662963223,
                    "smoothness_avg": 0.034451471616090565,
                    "success_improvement": 0.0,
                    "time_improvement": 16.617381254716395,
                    "node_improvement": 84.63863006799295,
                    "length_improvement": 14.123913487686588,
                    "smoothness_improvement": 439.24034335984834,
                    "objective_score": 15.655764185826111
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03999502658843994,
                    "num_nodes_avg": 145.0,
                    "path_length_avg": 236.64219232090036,
                    "smoothness_avg": 0.18735486162713155,
                    "success_improvement": 0.0,
                    "time_improvement": 75.83074593448201,
                    "node_improvement": 90.25734058993481,
                    "length_improvement": 21.002024835444043,
                    "smoothness_improvement": 4720.775535918357,
                    "objective_score": 58.954316361202814
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.062010884284973145,
                    "num_nodes_avg": 228.0,
                    "path_length_avg": 115.36831063996797,
                    "smoothness_avg": 0.11025750170008067,
                    "success_improvement": 0.0,
                    "time_improvement": -19.521486686135614,
                    "node_improvement": 71.01080737444374,
                    "length_improvement": 23.377861321535487,
                    "smoothness_improvement": 1302.4672832628123,
                    "objective_score": 14.682607203394669
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SAGE-BiRRT-Lite: Simple Adaptive Goal/Corridor-Biased Bidirectional RRT with Micro-Rewire and Greedy LOS smoothing. Two sparse trees grow with single-step, commit-only insertions using strict node and edge collision checks, accelerated by a hashed grid and duplicate suppression. After any feasible path is found, sampling narrows to an informed corridor around the start\u2013goal line, and a small local rewiring around each new node reduces path cost. A fast two-stage smoother (greedy line-of-sight collapse, then light random shortcuts) returns short, smooth paths quickly and robustly.",
          "planning_mechanism": "Initialize two trees and per-tree grids. Iteratively: select an active tree, sample a target with goal/corridor bias (corridor narrows after first solution), find grid-accelerated nearest, steer one step, and insert only if both node and edge are collision-free. Attempt a direct bridge to the other tree (and optionally a few commit-only steps from the opposite tree toward the new node). After insertion, rewire nearby nodes to the new node when it shortens their cost and the edge is free. On any successful connection, extract the path and apply greedy line-of-sight compression followed by a few random shortcuts; return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=7000,\n                 step_size=6.0,\n                 goal_bias=0.25,\n                 corridor_bias=0.5,\n                 collision_res=1.0,\n                 grid_cell=None,\n                 dupe_radius_ratio=0.5,\n                 r_max=3,\n                 connect_steps=2,\n                 rewire_radius_ratio=1.2,\n                 rewire_limit=6,\n                 smoothing_iters=60):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.collision_res = max(0.25, float(collision_res))\n        self.grid_cell = grid_cell\n        self.dupe_radius_ratio = max(0.1, float(dupe_radius_ratio))\n        self.r_max = max(1, int(r_max))\n        self.connect_steps = max(0, int(connect_steps))\n        self.rewire_radius_ratio = max(0.5, float(rewire_radius_ratio))\n        self.rewire_limit = max(0, int(rewire_limit))\n        self.smoothing_iters = max(0, int(smoothing_iters))\n\n        self.dim = 2\n        self.bounds = None\n\n        self._lcg_state = 2862933555777941757  # deterministic RNG seed\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = self._as_tuple(map.start)\n        goal = self._as_tuple(map.goal)\n        obstacles = list(map.obstacles)\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 1.5 * self.step_size)\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight line\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.collision_res):\n            n0 = Node(start, None, 0.0)\n            n1 = Node(goal, n0, self._dist(start, goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [start, goal], [n0, n1], [(n0, n1)])\n\n        # Setup\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n        grid_start, grid_goal = {}, {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        dsg = self._dist(start, goal)\n        corridor_w = max(self.step_size, 0.15 * dsg)\n        best_len = None  # incumbent path length once found\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = goal if active_start else start\n\n            # Adaptive corridor width after first solution\n            if best_len is not None:\n                corridor_w = max(self.step_size, 0.05 * dsg)\n\n            # Sample target\n            target = self._sample_target(start, goal, corridor_w, obstacles, is_3d, root_other, best_len)\n\n            # Nearest and steer\n            parent = self._nearest_hashed(grid_a, tree_a, target)\n            if parent is None:\n                continue\n            new_pos = self._steer(parent.position, target, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            # Edge collision check\n            if self._is_edge_in_obstacle(parent.position, new_pos, obstacles, is_3d, self.collision_res):\n                continue\n            # Duplicate suppression\n            if self._exists_close(grid_a, new_pos, self.step_size * self.dupe_radius_ratio):\n                continue\n\n            # Insert node (both node and edge validated)\n            new_node = Node(new_pos, parent, parent.cost + self._dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(grid_a, new_node)\n\n            # Local micro-rewire to shorten cost (commit-only with checks)\n            self._local_rewire(new_node, tree_a, grid_a, obstacles, is_3d, edges)\n\n            # Try direct bridge to the other tree\n            other_near = self._nearest_hashed(grid_b, tree_b, new_node.position)\n            if other_near is not None:\n                if not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.collision_res):\n                    path = self._extract_path(new_node, other_near)\n                    best_len = self._path_length(path)\n                    path = self._smooth_path(path, obstacles, is_3d)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Optional few-step guided connect from other tree (commit-only)\n            if self.connect_steps > 0:\n                p = other_near\n                steps = 0\n                while p is not None and steps < self.connect_steps:\n                    step_to = self._steer(p.position, new_node.position, self.step_size)\n                    if not self._in_bounds(step_to):\n                        break\n                    if self._is_in_obstacle(step_to, obstacles, is_3d):\n                        break\n                    if self._is_edge_in_obstacle(p.position, step_to, obstacles, is_3d, self.collision_res):\n                        break\n                    if self._exists_close(grid_b, step_to, self.step_size * self.dupe_radius_ratio):\n                        break\n                    q = Node(step_to, p, p.cost + self._dist(p.position, step_to))\n                    p.add_child(q)\n                    tree_b.append(q)\n                    edges.append((p, q))\n                    self._grid_add(grid_b, q)\n\n                    # Try final bridge\n                    if not self._is_edge_in_obstacle(q.position, new_node.position, obstacles, is_3d, self.collision_res):\n                        path = self._extract_path(new_node, q)\n                        best_len = self._path_length(path)\n                        path = self._smooth_path(path, obstacles, is_3d)\n                        return PlannerResult(True, path, start_tree + goal_tree, edges)\n                    p = q\n                    steps += 1\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- Random ----------\n    def _rand(self):\n        # 61-bit LCG for determinism\n        self._lcg_state = (6364136223846793005 * self._lcg_state + 1442695040888963407) % (1 << 61)\n        return (self._lcg_state & ((1 << 61) - 1)) / float(1 << 61)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _rand_int(self, a, b):\n        if b <= a:\n            return a\n        r = int(self._uniform(0.0, (b - a + 1)))\n        v = a + r\n        if v > b:\n            v = b\n        return v\n\n    # ---------- Geometry ----------\n    def _as_tuple(self, p):\n        if isinstance(p, tuple):\n            return p\n        return tuple(p[i] for i in range(len(p)))\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / max(1e-9, d)\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        # Coarse AABB overlap early-exit\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Sampling ----------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, start, goal, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            off = (self._uniform(-width, width),\n                   self._uniform(-width, width),\n                   self._uniform(-width, width))\n            p = self._clamp(tuple(base[i] + off[i] for i in range(3)))\n        else:\n            off = (self._uniform(-width, width),\n                   self._uniform(-width, width))\n            p = self._clamp(tuple(base[i] + off[i] for i in range(2)))\n        if not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_target(self, start, goal, corridor_w, obstacles, is_3d, root_other, best_len):\n        r = self._rand()\n        if r < self.goal_bias:\n            return root_other\n        elif r < self.goal_bias + self.corridor_bias:\n            # Narrow corridor after first solution\n            width = corridor_w\n            return self._sample_corridor(start, goal, width, obstacles, is_3d)\n        else:\n            return self._sample_free(obstacles, is_3d)\n\n    # ---------- Grid nearest ----------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        found = False\n        for r in range(0, self.r_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n                    found = True\n            if found:\n                return best\n        # Fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                di = n.position[i] - pos[i]\n                s += di * di\n            if s <= r2:\n                return True\n        return False\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                di = n.position[i] - pos[i]\n                s += di * di\n            if s <= r2:\n                out.append(n)\n        return out\n\n    # ---------- Rewiring ----------\n    def _local_rewire(self, new_node, tree, grid, obstacles, is_3d, edges):\n        if self.rewire_limit <= 0:\n            return\n        radius = self.step_size * self.rewire_radius_ratio\n        neigh = self._neighbors_in_radius(grid, new_node.position, radius)\n        count = 0\n        for v in neigh:\n            if v is new_node or v.parent is None:\n                continue\n            # Node collision check (existing node still valid)\n            if self._is_in_obstacle(v.position, obstacles, is_3d):\n                continue\n            new_cost = new_node.cost + self._dist(new_node.position, v.position)\n            if new_cost + 1e-9 < v.cost:\n                # Edge collision check\n                if not self._is_edge_in_obstacle(new_node.position, v.position, obstacles, is_3d, self.collision_res):\n                    old_parent = v.parent\n                    # Update edge list: remove old, add new\n                    self._remove_edge(edges, old_parent, v)\n                    old_parent.remove_child(v)\n                    new_node.add_child(v)\n                    v.cost = new_cost\n                    edges.append((new_node, v))\n                    self._propagate_cost(v)\n                    count += 1\n                    if count >= self.rewire_limit:\n                        break\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges)):\n            ep, ec = edges[i]\n            if ep is p and ec is c:\n                edges.pop(i)\n                return\n\n    def _propagate_cost(self, node):\n        # After rewiring, update subtree costs\n        for ch in node.children:\n            ch.cost = node.cost + self._dist(node.position, ch.position)\n            self._propagate_cost(ch)\n\n    # ---------- Path utilities ----------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        if not path or len(path) < 2:\n            return path\n        # Greedy LOS compression\n        pts = [path[0]]\n        last = path[0]\n        i = 1\n        while i < len(path):\n            far = i\n            j = i\n            while j < len(path) and not self._is_edge_in_obstacle(last, path[j], obstacles, is_3d, self.collision_res):\n                far = j\n                j += 1\n            last = path[far]\n            pts.append(last)\n            i = far + 1\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        # Light random shortcuts\n        for _ in range(self.smoothing_iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = self._rand_int(0, n - 3)\n            j = self._rand_int(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_res):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -29.19111,
          "time_improvement": 38.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1845.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018200445175170898,
                    "num_nodes_avg": 67.7,
                    "path_length_avg": 171.14563324796245,
                    "smoothness_avg": 0.04601411221187297,
                    "success_improvement": 0.0,
                    "time_improvement": 34.012985070885414,
                    "node_improvement": 82.95139763283808,
                    "length_improvement": 6.192366440685648,
                    "smoothness_improvement": 620.220777359775,
                    "objective_score": 17.020419272475888
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04422030448913574,
                    "num_nodes_avg": 169.5,
                    "path_length_avg": 238.8478777434046,
                    "smoothness_avg": 0.1240318285715561,
                    "success_improvement": 0.0,
                    "time_improvement": 73.27738308439075,
                    "node_improvement": 88.61116710340657,
                    "length_improvement": 20.26570355427738,
                    "smoothness_improvement": 3091.4282856612494,
                    "objective_score": 49.599778486189905
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04792101383209228,
                    "num_nodes_avg": 201.5,
                    "path_length_avg": 126.62498239156014,
                    "smoothness_avg": 0.15128039712234756,
                    "success_improvement": 0.0,
                    "time_improvement": 7.6357177814591655,
                    "node_improvement": 74.3801652892562,
                    "length_improvement": 15.901715929235335,
                    "smoothness_improvement": 1824.2754850388828,
                    "objective_score": 20.953122317173364
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "EC-Guide BiRRT with Edge-Cached LOS Compression and Elliptic Focus (EC-GBiRRT). This planner grows two trees from start and goal using a small beam of guided samples, compresses each new extension via multi-ancestor line-of-sight (LOS) with a shared edge-collision memo cache, and attempts a zero-step direct connect to the other tree. After a first path, sampling narrows to a prolate ellipse corridor to accelerate convergence. Early-terminating forward LOS shortcutting finalizes the path. These choices cut repeated collision checks, reduce tree depth, and avoid micro-step connects, improving planning time and path quality.",
          "planning_mechanism": "Each iteration alternates trees: generate a few biased samples, pick a nearby node via a grid hash, steer one step, and validate node/edge. Select the cheapest LOS-ancestor parent using cached edge checks, insert the node, then try a direct LOS link to the other tree\u2019s nearest node; if it succeeds, extract and lightly shortcut the path. A shared bounded edge-cache stores free/blocked results, multi-ancestor compression shortens chains, a per-cell cap limits redundant local growth, and corridor-biased sampling activates once a provisional path exists.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        beam_width=2,\n        goal_bias=0.2,\n        los_lookback_depth=10,\n        min_separation_factor=0.6,\n        grid_cell_factor=1.2,\n        per_cell_cap=12,\n        edge_cache_capacity=20000,\n        shortcut_attempts=60,\n        no_improve_stop=12\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.los_lookback_depth = los_lookback_depth\n        self.min_separation_factor = min_separation_factor\n        self.grid_cell_factor = grid_cell_factor\n        self.per_cell_cap = per_cell_cap\n        self.edge_cache_capacity = edge_cache_capacity\n        self.shortcut_attempts = shortcut_attempts\n        self.no_improve_stop = no_improve_stop\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dims = len(self.bounds)\n        self.is_3d = self.dims == 3\n        self.obstacles = map.obstacles\n        self.start = map.start\n        self.goal = map.goal\n\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n        self.ecache = {}\n        self._tick = 0\n        self._last_prune = 0\n        self.ecache_quant = max(0.5, self.step_size * 0.5)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(self.start, parent=None, cost=0.0)\n        goal_root = Node(self.goal, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        incumbent_len = None\n        best_path = None\n\n        for _ in range(self.max_iter):\n            # Alternate trees each loop\n            for active_tree, active_grid, other_tree, other_grid, attractor in [\n                (tree_a, grid_a, tree_b, grid_b, self.goal),\n                (tree_b, grid_b, tree_a, grid_a, self.start),\n            ]:\n                progress = False\n                for _b in range(self.beam_width):\n                    sample = self._guided_sample(attractor, incumbent_len)\n                    if sample is None:\n                        continue\n\n                    nearest = self._nearest_in_grid(active_grid, sample)\n                    if nearest is None:\n                        continue\n\n                    new_pos = self._steer(nearest.position, sample)\n                    if not self._within_bounds(new_pos):\n                        continue\n                    if self._in_obstacle(new_pos):\n                        continue\n                    # Check edge to nearest; required before any parent selection\n                    if not self._edge_free(nearest.position, new_pos):\n                        continue\n                    # Duplicate suppression\n                    if self._has_nearby(active_grid, new_pos, self.min_separation):\n                        continue\n\n                    # Parent selection via LOS ancestors using cached edge checks\n                    parent = self._select_parent(nearest, new_pos)\n                    if parent is None:\n                        # Safety: though nearest->new_pos was free, parent selection failed; fallback\n                        parent = nearest\n\n                    # Per-cell growth limit; allow insert if bucket light or cost improves the bucket\n                    cell_key = self._cell_of(new_pos)\n                    bucket = active_grid.get(cell_key)\n                    if bucket and len(bucket) >= self.per_cell_cap:\n                        # Allow only if this is significantly cheaper than the best in bucket\n                        best_bucket_cost = min(n.cost for n in bucket)\n                        cand_cost = parent.cost + self._distance(parent.position, new_pos)\n                        if cand_cost >= best_bucket_cost - 1e-6:\n                            continue\n\n                    new_cost = parent.cost + self._distance(parent.position, new_pos)\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node)\n                    progress = True\n\n                    # Attempt direct LOS connect (no micro-steps)\n                    other_near = self._nearest_in_grid(other_grid, new_node.position)\n                    if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                        path_a = self._path_from_root(new_node)\n                        path_b = self._path_from_root(other_near)\n                        # Merge with direct bridge segment ensured free\n                        raw_path = path_a + path_b[::-1]\n                        # Path might duplicate joint if new_node coincides with other_near; dedup\n                        if len(raw_path) >= 2 and self._distance(raw_path[-1], raw_path[-2]) <= 1e-9:\n                            raw_path.pop()  # remove duplicate\n                        smoothed = self._shortcut(raw_path)\n                        final_path = smoothed if smoothed else raw_path\n                        best_path = final_path\n                        incumbent_len = self._path_length(final_path)\n                        return PlannerResult(True, final_path, nodes, edges)\n\n                # If we found no progress from this side in this alternation, continue to the other\n                if not progress:\n                    continue\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # ---------- Geometry and metrics ----------\n    def _distance(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._distance(a, b)\n        if d <= 1e-12:\n            return a\n        if d <= self.step_size:\n            return b\n        r = self.step_size / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n\n    def _path_from_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        length = 0.0\n        for i in range(1, len(path)):\n            length += self._distance(path[i - 1], path[i])\n        return length\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, attractor, incumbent_len):\n        # Corridor-biased sampling if incumbent exists; else mild goal bias\n        # Try limited attempts to avoid heavy rejection\n        for _ in range(20):\n            if incumbent_len is not None and self._distance(self.start, self.goal) > 1e-9:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.05)\n                if p is None:\n                    continue\n            else:\n                if self._rand() < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            if self._within_bounds(p) and not self._in_obstacle(p):\n                return p\n        # Fallback hard-attractor\n        return attractor if self._within_bounds(attractor) and not self._in_obstacle(attractor) else None\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        # Rejection sample in the bounding box of the ellipse/spheroid\n        # Limited attempts for speed; returns None on failure\n        cx = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum_dist\n        # Direction vector and its norm\n        v = tuple(f2[i] - f1[i] for i in range(self.dims))\n        vd = self._distance(f1, f2)\n        # Bounding box extents\n        ext = [half, half, half] if self.is_3d else [half, half]\n        # Try a few samples\n        for _ in range(12):\n            p = tuple(cx[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._within_bounds(p):\n                continue\n            # ellipse condition: dist(p,f1)+dist(p,f2) <= max_sum_dist\n            if self._distance(p, f1) + self._distance(p, f2) <= max_sum_dist and not self._in_obstacle(p):\n                return p\n        return None\n\n    # ---------- Grid spatial hash ----------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _has_nearby(self, grid, pos, radius):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if bucket:\n                            for n in bucket:\n                                if self._distance(n.position, pos) <= radius:\n                                    return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if bucket:\n                        for n in bucket:\n                            if self._distance(n.position, pos) <= radius:\n                                return True\n        return False\n\n    def _nearest_in_grid(self, grid, pos, max_ring=5):\n        cell = self._cell_of(pos)\n        best = None\n        best_d = 1e100\n        if self.is_3d:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if bucket:\n                                for n in bucket:\n                                    d = self._distance(n.position, pos)\n                                    if d < best_d:\n                                        best = n\n                                        best_d = d\n                                        found = True\n                if found:\n                    return best\n        else:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if bucket:\n                            for n in bucket:\n                                d = self._distance(n.position, pos)\n                                if d < best_d:\n                                    best = n\n                                    best_d = d\n                                    found = True\n                if found:\n                    return best\n        # Rare fallback: scan all buckets\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._distance(n.position, pos)\n                if d < best_d:\n                    best = n\n                    best_d = d\n        return best\n\n    # ---------- Obstacles ----------\n    def _in_obstacle(self, pos):\n        if self.is_3d:\n            px, py, pz = pos\n            for obs in self.obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in self.obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.ecache_quant) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.ecache_quant) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]  # True if free, False if blocked\n        # Compute and cache\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        # Bounded pruning\n        if len(self.ecache) - self._last_prune > self.edge_cache_capacity:\n            self._prune_cache()\n        return free\n\n    def _prune_cache(self):\n        # Drop roughly oldest 40%\n        if not self.ecache:\n            return\n        cutoff = self._tick - 2000\n        to_remove = []\n        for k, v in self.ecache.items():\n            if v[1] < cutoff:\n                to_remove.append(k)\n        if not to_remove:\n            # If nothing older than cutoff, remove every 3rd entry to bound size\n            i = 0\n            for k in list(self.ecache.keys()):\n                if i % 3 == 0:\n                    to_remove.append(k)\n                i += 1\n        for k in to_remove:\n            if k in self.ecache:\n                del self.ecache[k]\n        self._last_prune = len(self.ecache)\n\n    def _segment_hits_obstacle(self, a, b):\n        dist = self._distance(a, b)\n        # Resolution tuned for speed while preserving safety\n        resolution = max(0.5, min(1.0, self.step_size * 0.5))\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            p = tuple(a[d] + (b[d] - a[d]) * t for d in range(self.dims))\n            if self._in_obstacle(p):\n                return True\n        return False\n\n    # ---------- Parent selection ----------\n    def _select_parent(self, nearest, new_pos):\n        best = nearest\n        best_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        cur = nearest\n        depth = 0\n        while cur is not None and depth < self.los_lookback_depth:\n            if self._edge_free(cur.position, new_pos):\n                cand = cur.cost + self._distance(cur.position, new_pos)\n                if cand + 1e-9 < best_cost:\n                    best_cost = cand\n                    best = cur\n            cur = cur.parent\n            depth += 1\n        return best\n\n    # ---------- Shortcut smoothing ----------\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        attempts = 0\n        no_improve = 0\n        i = 0\n        while attempts < self.shortcut_attempts and i < len(pts) - 2:\n            improved = False\n            # Try to jump from i to a farther j\n            j = len(pts) - 1\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    # Remove intermediates\n                    del pts[i + 1:j]\n                    improved = True\n                    no_improve = 0\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n                no_improve += 1\n            attempts += 1\n            if no_improve >= self.no_improve_stop:\n                break\n        return pts\n\n    # ---------- Random helpers ----------\n    def _rand(self):\n        # expects 'random' module available\n        return random.random()\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()",
          "objective": -29.11471,
          "time_improvement": 51.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 1571.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02822730541229248,
                    "num_nodes_avg": 65.6,
                    "path_length_avg": 182.96020324956595,
                    "smoothness_avg": 0.05732726413788967,
                    "success_improvement": 0.0,
                    "time_improvement": -10.700544274551492,
                    "node_improvement": 83.48023167967766,
                    "length_improvement": -0.28338659103527,
                    "smoothness_improvement": 797.2961719045505,
                    "objective_score": 0.6062856225361433
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01984243392944336,
                    "num_nodes_avg": 86.6,
                    "path_length_avg": 243.5413235727727,
                    "smoothness_avg": 0.09042567896577892,
                    "success_improvement": 0.0,
                    "time_improvement": 87.61375486797985,
                    "node_improvement": 94.18128065578178,
                    "length_improvement": 18.698896243086562,
                    "smoothness_improvement": 2226.7178507734366,
                    "objective_score": 48.63705346011307
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01169896125793457,
                    "num_nodes_avg": 78.1,
                    "path_length_avg": 133.4682422714018,
                    "smoothness_avg": 0.1405957321950529,
                    "success_improvement": 0.0,
                    "time_improvement": 76.14970532839176,
                    "node_improvement": 90.06993006993007,
                    "length_improvement": 11.356748558062376,
                    "smoothness_improvement": 1688.3673358236224,
                    "objective_score": 38.100797412473064
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "Segment-Slab Indexed Bi-Connect (SSIBC): a fast bidirectional planner that minimizes planning time via an obstacle grid index and slab-based segment\u2013AABB intersection, performing only necessary collision tests. It grows two RRT-Connect style trees with balanced goal/corridor/uniform sampling, uses a grid-hash nearest, duplicate suppression, per-cell throttling, and immediate bridge attempts. Early visibility compression and bounded shortcutting finalize a short, smooth path with minimal post-processing.",
          "planning_mechanism": "Mechanism: Pre-index obstacles into a coarse grid. Each iteration alternates trees, samples a target (goal/corridor/uniform), picks a nearest via grid rings, steers once, and validates using indexed node and edge checks with slab intersections against only overlapping obstacles. On insertion, attempt grandparent visibility compression and a direct or short greedy connect to the opposite tree. On success, extract, visibility-compress, and lightly shortcut the path; otherwise continue until iteration cap.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=10.0,\n                 goal_bias=0.3,\n                 corridor_bias=0.5,\n                 connect_steps=5,\n                 grid_cell=None,\n                 dupe_radius_ratio=0.6,\n                 max_per_cell=8,\n                 smoothing_iters=6,\n                 obs_cell=None):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.connect_steps = connect_steps\n        self.grid_cell = grid_cell\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.max_per_cell = max_per_cell\n        self.smoothing_iters = smoothing_iters\n        self.obs_cell = obs_cell\n\n        self.dim = 2\n        self.bounds = None\n        self.start = None\n        self.goal = None\n\n        self._lcg_state = 2463534242\n\n        # Obstacle index\n        self._obs_grid = None\n        self._obs_cell = None\n        self._obs_aabbs = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        obstacles = list(map.obstacles)\n        is_3d = (self.dim == 3)\n\n        # Grid cell defaults\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.8 * self.step_size)\n        if self.obs_cell is None:\n            self._obs_cell = max(1.0, 1.5 * self.step_size)\n        else:\n            self._obs_cell = max(1.0, self.obs_cell)\n\n        # Build obstacle AABBs and spatial index\n        self._build_obstacle_index(obstacles, is_3d)\n\n        # Validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obstacle(self.start, is_3d) or self._point_in_obstacle(self.goal, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line check\n        if not self._segment_blocked(self.start, self.goal, is_3d):\n            s_node = Node(self.start, None, 0.0)\n            g_node = Node(self.goal, s_node, self._dist(self.start, self.goal))\n            s_node.add_child(g_node)\n            path = [self.start, self.goal]\n            return PlannerResult(True, path, [s_node, g_node], [(s_node, g_node)])\n\n        # Initialize trees and hashed grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        dupe_radius = self.step_size * self.dupe_radius_ratio\n        min_sep = 0.25 * self.step_size\n\n        # Corridor width\n        dsg = self._dist(self.start, self.goal)\n        base_corridor = max(self.step_size, 0.18 * dsg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            other_root_pos = self.goal if active_start else self.start\n\n            # Sample target\n            r = self._rand()\n            if r < self.goal_bias:\n                x_rand = other_root_pos\n            elif r < self.goal_bias + self.corridor_bias:\n                x_rand = self._sample_corridor(self.start, self.goal, base_corridor, is_3d)\n            else:\n                x_rand = self._sample_free(is_3d)\n\n            # Nearest in active tree\n            nearest = self._nearest_hash(grid_a, x_rand, 3)\n            if nearest is None:\n                nearest = self._nearest_linear(tree_a, x_rand)\n\n            # Steer and validate\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._dist(nearest.position, new_pos) < min_sep:\n                continue\n            if self._exists_close(grid_a, new_pos, dupe_radius):\n                continue\n            if not self._grid_can_add(grid_a, new_pos, self.max_per_cell):\n                continue\n            if self._point_in_obstacle(new_pos, is_3d):\n                continue\n            if self._segment_blocked(nearest.position, new_pos, is_3d):\n                continue\n\n            # Add node\n            new_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, new_node)\n\n            # Grandparent visibility compression\n            gp = nearest.parent\n            if gp is not None:\n                if not self._segment_blocked(gp.position, new_node.position, is_3d):\n                    nearest.remove_child(new_node)\n                    self._edges_remove(edges, nearest, new_node)\n                    gp.add_child(new_node)\n                    new_node.cost = gp.cost + self._dist(gp.position, new_node.position)\n                    edges.append((gp, new_node))\n\n            # Try direct bridge to nearest in the other tree\n            other_near = self._nearest_hash(grid_b, new_node.position, 3)\n            if other_near is None and tree_b:\n                other_near = self._nearest_linear(tree_b, new_node.position)\n\n            if other_near is not None and not self._segment_blocked(new_node.position, other_near.position, is_3d):\n                path = self._extract_path(new_node, other_near)\n                path = self._finalize_path(path, is_3d)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Greedy short connect from the opposite tree\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, new_node.position, self.step_size)\n                if self._dist(p.position, to_pos) < min_sep:\n                    break\n                if not self._in_bounds(to_pos):\n                    break\n                if self._exists_close(grid_b, to_pos, dupe_radius):\n                    break\n                if not self._grid_can_add(grid_b, to_pos, self.max_per_cell):\n                    break\n                if self._point_in_obstacle(to_pos, is_3d):\n                    break\n                if self._segment_blocked(p.position, to_pos, is_3d):\n                    break\n\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                edges.append((p, q))\n                self._grid_add(grid_b, q)\n\n                p = q\n                steps += 1\n\n                if not self._segment_blocked(new_node.position, p.position, is_3d):\n                    path = self._extract_path(new_node, p)\n                    path = self._finalize_path(path, is_3d)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # RNG\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Sampling\n    def _sample_free(self, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._point_in_obstacle(p, is_3d):\n                return p\n\n    def _sample_corridor(self, a, b, width, is_3d):\n        t = self._rand()\n        base = tuple(a[i] + t * (b[i] - a[i]) for i in range(self.dim))\n        if self.dim == 3:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._point_in_obstacle(p, is_3d):\n            return p\n        return self._sample_free(is_3d)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # Grid hashing for nodes\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_bucket_len(self, grid, key):\n        b = grid.get(key)\n        return 0 if b is None else len(b)\n\n    def _grid_can_add(self, grid, pos, cap):\n        key = self._grid_key(pos)\n        return self._grid_bucket_len(grid, key) < cap\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hash(self, grid, pos, rmax):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, rmax + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        return None\n\n    def _nearest_linear(self, nodes, pos):\n        best = None\n        bestd = float('inf')\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                return True\n        return False\n\n    # Obstacle index\n    def _build_obstacle_index(self, obstacles, is_3d):\n        self._obs_grid = {}\n        self._obs_aabbs = []\n        for idx, obs in enumerate(obstacles):\n            if is_3d:\n                x, y, z, w, h, d = obs\n                minx, miny, minz = x, y, z\n                maxx, maxy, maxz = x + w, y + h, z + d\n                aabb = (minx, miny, minz, maxx, maxy, maxz)\n            else:\n                x, y, w, h = obs\n                minx, miny = x, y\n                maxx, maxy = x + w, y + h\n                aabb = (minx, miny, maxx, maxy)\n            self._obs_aabbs.append(aabb)\n            # Index into grid\n            if is_3d:\n                ix0 = int(minx // self._obs_cell)\n                iy0 = int(miny // self._obs_cell)\n                iz0 = int(minz // self._obs_cell)\n                ix1 = int(maxx // self._obs_cell)\n                iy1 = int(maxy // self._obs_cell)\n                iz1 = int(maxz // self._obs_cell)\n                for ix in range(ix0, ix1 + 1):\n                    for iy in range(iy0, iy1 + 1):\n                        for iz in range(iz0, iz1 + 1):\n                            key = (ix, iy, iz)\n                            bucket = self._obs_grid.get(key)\n                            if bucket is None:\n                                self._obs_grid[key] = [idx]\n                            else:\n                                bucket.append(idx)\n            else:\n                ix0 = int(minx // self._obs_cell)\n                iy0 = int(miny // self._obs_cell)\n                ix1 = int(maxx // self._obs_cell)\n                iy1 = int(maxy // self._obs_cell)\n                for ix in range(ix0, ix1 + 1):\n                    for iy in range(iy0, iy1 + 1):\n                        key = (ix, iy)\n                        bucket = self._obs_grid.get(key)\n                        if bucket is None:\n                            self._obs_grid[key] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _obs_keys_for_bbox(self, bmin, bmax, is_3d):\n        if is_3d:\n            ix0 = int(bmin[0] // self._obs_cell)\n            iy0 = int(bmin[1] // self._obs_cell)\n            iz0 = int(bmin[2] // self._obs_cell)\n            ix1 = int(bmax[0] // self._obs_cell)\n            iy1 = int(bmax[1] // self._obs_cell)\n            iz1 = int(bmax[2] // self._obs_cell)\n            keys = []\n            for ix in range(ix0, ix1 + 1):\n                for iy in range(iy0, iy1 + 1):\n                    for iz in range(iz0, iz1 + 1):\n                        keys.append((ix, iy, iz))\n            return keys\n        else:\n            ix0 = int(bmin[0] // self._obs_cell)\n            iy0 = int(bmin[1] // self._obs_cell)\n            ix1 = int(bmax[0] // self._obs_cell)\n            iy1 = int(bmax[1] // self._obs_cell)\n            keys = []\n            for ix in range(ix0, ix1 + 1):\n                for iy in range(iy0, iy1 + 1):\n                    keys.append((ix, iy))\n            return keys\n\n    def _gather_obstacles_bbox(self, bmin, bmax, is_3d):\n        keys = self._obs_keys_for_bbox(bmin, bmax, is_3d)\n        seen = {}\n        out = []\n        for k in keys:\n            bucket = self._obs_grid.get(k)\n            if not bucket:\n                continue\n            for idx in bucket:\n                if seen.get(idx) is None:\n                    seen[idx] = 1\n                    out.append(idx)\n        return out\n\n    # Collision helpers\n    def _point_in_obstacle(self, p, is_3d):\n        if is_3d:\n            bmin = (p[0], p[1], p[2])\n            bmax = (p[0], p[1], p[2])\n        else:\n            bmin = (p[0], p[1])\n            bmax = (p[0], p[1])\n        cand = self._gather_obstacles_bbox(bmin, bmax, is_3d)\n        if self.dim == 3:\n            px, py, pz = p\n            for idx in cand:\n                minx, miny, minz, maxx, maxy, maxz = self._obs_aabbs[idx]\n                if minx <= px <= maxx and miny <= py <= maxy and minz <= pz <= maxz:\n                    return True\n        else:\n            px, py = p\n            for idx in cand:\n                minx, miny, maxx, maxy = self._obs_aabbs[idx]\n                if minx <= px <= maxx and miny <= py <= maxy:\n                    return True\n        return False\n\n    def _segment_blocked(self, a, b, is_3d):\n        # Query only obstacles overlapping the segment's bbox\n        if self.dim == 3:\n            bmin = (min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2]))\n            bmax = (max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2]))\n            cand = self._gather_obstacles_bbox(bmin, bmax, True)\n            for idx in cand:\n                aa = self._obs_aabbs[idx]\n                if self._seg_box_intersect_3d(a, b, aa):\n                    return True\n        else:\n            bmin = (min(a[0], b[0]), min(a[1], b[1]))\n            bmax = (max(a[0], b[0]), max(a[1], b[1]))\n            cand = self._gather_obstacles_bbox(bmin, bmax, False)\n            for idx in cand:\n                aa = self._obs_aabbs[idx]\n                if self._seg_box_intersect_2d(a, b, aa):\n                    return True\n        return False\n\n    def _seg_box_intersect_2d(self, p0, p1, aabb):\n        # Slab method\n        minx, miny, maxx, maxy = aabb\n        tmin = 0.0\n        tmax = 1.0\n        dx = p1[0] - p0[0]\n        dy = p1[1] - p0[1]\n        eps = 1e-12\n\n        # X slab\n        if abs(dx) < eps:\n            if p0[0] < minx or p0[0] > maxx:\n                return False\n        else:\n            tx1 = (minx - p0[0]) / dx\n            tx2 = (maxx - p0[0]) / dx\n            if tx1 > tx2:\n                tx1, tx2 = tx2, tx1\n            if tx1 > tmin:\n                tmin = tx1\n            if tx2 < tmax:\n                tmax = tx2\n            if tmin > tmax:\n                return False\n\n        # Y slab\n        if abs(dy) < eps:\n            if p0[1] < miny or p0[1] > maxy:\n                return False\n        else:\n            ty1 = (miny - p0[1]) / dy\n            ty2 = (maxy - p0[1]) / dy\n            if ty1 > ty2:\n                ty1, ty2 = ty2, ty1\n            if ty1 > tmin:\n                tmin = ty1\n            if ty2 < tmax:\n                tmax = ty2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    def _seg_box_intersect_3d(self, p0, p1, aabb):\n        minx, miny, minz, maxx, maxy, maxz = aabb\n        tmin = 0.0\n        tmax = 1.0\n        dx = p1[0] - p0[0]\n        dy = p1[1] - p0[1]\n        dz = p1[2] - p0[2]\n        eps = 1e-12\n\n        # X slab\n        if abs(dx) < eps:\n            if p0[0] < minx or p0[0] > maxx:\n                return False\n        else:\n            tx1 = (minx - p0[0]) / dx\n            tx2 = (maxx - p0[0]) / dx\n            if tx1 > tx2:\n                tx1, tx2 = tx2, tx1\n            if tx1 > tmin:\n                tmin = tx1\n            if tx2 < tmax:\n                tmax = tx2\n            if tmin > tmax:\n                return False\n\n        # Y slab\n        if abs(dy) < eps:\n            if p0[1] < miny or p0[1] > maxy:\n                return False\n        else:\n            ty1 = (miny - p0[1]) / dy\n            ty2 = (maxy - p0[1]) / dy\n            if ty1 > ty2:\n                ty1, ty2 = ty2, ty1\n            if ty1 > tmin:\n                tmin = ty1\n            if ty2 < tmax:\n                tmax = ty2\n            if tmin > tmax:\n                return False\n\n        # Z slab\n        if abs(dz) < eps:\n            if p0[2] < minz or p0[2] > maxz:\n                return False\n        else:\n            tz1 = (minz - p0[2]) / dz\n            tz2 = (maxz - p0[2]) / dz\n            if tz1 > tz2:\n                tz1, tz2 = tz2, tz1\n            if tz1 > tmin:\n                tmin = tz1\n            if tz2 < tmax:\n                tmax = tz2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    # Edges handling\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _visibility_compress(self, pts, is_3d):\n        if len(pts) <= 2:\n            return pts\n        out = [pts[0]]\n        anchor = pts[0]\n        for i in range(1, len(pts) - 1):\n            nxt = pts[i + 1]\n            if self._segment_blocked(anchor, nxt, is_3d):\n                out.append(pts[i])\n                anchor = pts[i]\n        out.append(pts[-1])\n        return out\n\n    def _shortcut_path(self, pts, is_3d, iters):\n        if len(pts) <= 2:\n            return pts\n        out = list(pts)\n        n = len(out)\n        for _ in range(iters):\n            if n <= 2:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = out[i]\n            b = out[j]\n            if not self._segment_blocked(a, b, is_3d):\n                out = out[:i + 1] + out[j:]\n                n = len(out)\n        return out\n\n    def _finalize_path(self, path, is_3d):\n        path = self._visibility_compress(path, is_3d)\n        path = self._shortcut_path(path, is_3d, self.smoothing_iters)\n        path = self._visibility_compress(path, is_3d)\n        return path",
          "objective": -29.08702,
          "time_improvement": 52.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 1629.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015787076950073243,
                    "num_nodes_avg": 52.2,
                    "path_length_avg": 176.55175032048717,
                    "smoothness_avg": 0.04850662757739136,
                    "success_improvement": 0.0,
                    "time_improvement": 42.76282407571483,
                    "node_improvement": 86.85469654998741,
                    "length_improvement": 3.229188007827852,
                    "smoothness_improvement": 659.2340554138854,
                    "objective_score": 18.06253030448059
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.030048704147338866,
                    "num_nodes_avg": 81.7,
                    "path_length_avg": 253.09902101377867,
                    "smoothness_avg": 0.105831649531053,
                    "success_improvement": 0.0,
                    "time_improvement": 81.84137311996358,
                    "node_improvement": 94.51051535308741,
                    "length_improvement": 15.50826173421144,
                    "smoothness_improvement": 2623.124569890014,
                    "objective_score": 46.972991825966005
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03628108501434326,
                    "num_nodes_avg": 84.6,
                    "path_length_avg": 137.5475279305066,
                    "smoothness_avg": 0.13389689603270416,
                    "success_improvement": 0.0,
                    "time_improvement": 30.07083724895054,
                    "node_improvement": 89.24348378893832,
                    "length_improvement": 8.647481257993979,
                    "smoothness_improvement": 1603.1586342951978,
                    "objective_score": 22.22553310095754
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "LITHE-BRRT: Lightweight Informed Thrifty Heuristic Bidirectional RRT with hashed-nearest lookup, cached exact collision checks, micro-LOS compression, and k-bridge connection. It trims expansions with duplicate gating and incumbent-aware sampling, avoids global rewiring, and returns a smoothed line-of-sight\u2013collapsed path quickly.",
          "planning_mechanism": "Grow two trees in alternation with a tiny guided beam. For each sample, steer from the hashed-nearest and pick a cheap LOS parent from a compact neighborhood; enforce node and edge validity before insertion, then compress the new node to a visible ancestor. Attempt a k-nearest direct bridge to the opposite tree; on success, merge, shortcut briefly with cache-aided checks, and perform forward LOS collapse. Use informed-ellipse/corridor sampling once an incumbent exists and memoized segment\u2013AABB tests to curb collision cost.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        # Keep coherent parent/child relation without duplicates\n        for c in self.children:\n            if c is child:\n                child.parent = self\n                return\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i, c in enumerate(self.children):\n            if c is child:\n                self.children.pop(i)\n                break\nclass Planner:\n    def __init__(self,\n                 max_iter=4500,\n                 step_size=9.0,\n                 beam_k=2,\n                 goal_bias=0.2,\n                 corridor_bias=0.4,\n                 informed_bias=0.65,\n                 grid_cell_factor=1.0,\n                 dupe_radius_ratio=0.5,\n                 parent_ring_cells=2,\n                 parent_cap=8,\n                 connect_k=4,\n                 connect_radius_factor=3.0,\n                 anchor_stride=24,\n                 edge_cache_capacity=30000,\n                 edge_cache_quant=1.0,\n                 smoothing_attempts=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.informed_bias = informed_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.parent_ring_cells = max(1, int(parent_ring_cells))\n        self.parent_cap = max(1, int(parent_cap))\n        self.connect_k = max(1, int(connect_k))\n        self.connect_radius_factor = connect_radius_factor\n        self.anchor_stride = max(1, int(anchor_stride))\n        self.edge_cache_capacity = edge_cache_capacity\n        self.edge_cache_quant = max(0.25, edge_cache_quant)\n        self.smoothing_attempts = smoothing_attempts\n\n        self._rng = 2463534242\n\n    # Entry\n    def plan(self, map):\n        # Scene\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n        self.is_3d = (self.dim == 3)\n\n        # Basic validation\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Build obstacle grid for fast collision\n        self._build_obstacle_grid()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Config derived\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.connect_radius = self.connect_radius_factor * self.step_size\n\n        # Edge cache\n        self._tick = 0\n        self._ecache = {}  # key -> (free_bool, last_tick)\n\n        # Direct early exit\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Trees and structures\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        anchors_a, anchors_b = [start_root], [goal_root]\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n\n        best_len = float('inf')\n        sg = self._dist(self.start, self.goal)\n\n        # Main loop\n        for it in range(self.max_iter):\n            grow_a = (it % 2 == 0)\n            tree1 = tree_a if grow_a else tree_b\n            tree2 = tree_b if grow_a else tree_a\n            grid1 = grid_a if grow_a else grid_b\n            grid2 = grid_b if grow_a else grid_a\n            anchors1 = anchors_a if grow_a else anchors_b\n            anchors2 = anchors_b if grow_a else anchors_a\n            other_root = self.goal if grow_a else self.start\n\n            best_cand = None  # (parent, new_pos, other_hint, g_new)\n\n            # Guided beam: select one best candidate to commit\n            for _ in range(self.beam_k):\n                xr = self._sample(other_root, sg, best_len)\n                if xr is None:\n                    continue\n                nearest = self._nearest(grid1, anchors1, tree1, xr)\n                if nearest is None:\n                    continue\n                xnew = self._steer(nearest.position, xr)\n                if not self._in_bounds(xnew):\n                    continue\n                if self._point_blocked(xnew):\n                    continue\n                if self._has_close(grid1, xnew, self.dupe_radius):\n                    continue\n\n                # Choose a parent among a compact neighborhood\n                parent, gnew = self._choose_parent(grid1, nearest, xnew)\n                if parent is None:\n                    continue\n                # Enforce both node and edge validity before insertion\n                if self._point_blocked(xnew):\n                    continue\n                if not self._edge_free(parent.position, xnew):\n                    continue\n\n                # Heuristic score to rank the beam\n                other_near = self._nearest(grid2, anchors2, tree2, xnew)\n                h = self._dist(xnew, other_near.position if other_near else other_root)\n                # Incumbent-aware pruning\n                if best_len < float('inf') and (gnew + h) >= 1.02 * best_len:\n                    continue\n\n                score = gnew + 0.4 * h\n                if best_cand is None or score < best_cand[4]:\n                    best_cand = (parent, xnew, other_near, gnew, score)\n\n            if best_cand is None:\n                continue\n\n            parent, xnew, hint_other, gnew, _ = best_cand\n\n            # Final validity (both checks) before adding node/edge\n            if self._point_blocked(xnew):\n                continue\n            if not self._edge_free(parent.position, xnew):\n                continue\n\n            # Insert node\n            new_node = Node(xnew, parent, gnew)\n            parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(grid1, new_node)\n\n            # Micro-LOS compression to visible ancestor (node-only)\n            self._compress_new_node(new_node, edges)\n\n            # Periodic anchor for fallback nearest\n            if (len(tree1) % self.anchor_stride) == 0:\n                anchors1.append(new_node)\n\n            # Attempt k-bridge to the opposite tree (direct edges only)\n            candidates = self._k_near(grid2, anchors2, tree2, new_node.position, self.connect_radius, self.connect_k)\n            bridged = None\n            for q in candidates:\n                # Both checks: node q was already valid; check edge only\n                if self._edge_free(new_node.position, q.position):\n                    bridged = q\n                    break\n\n            if bridged is not None:\n                if grow_a:\n                    path = self._merge_path(new_node, bridged)\n                else:\n                    path = self._merge_path(bridged, new_node)\n                best_len = self._path_len(path)\n                path = self._shortcut(path)\n                path = self._forward_los(path)\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= self.step_size:\n            return self._clamp(b)\n        r = self.step_size / max(d, 1e-12)\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Sampling\n    def _sample(self, attractor, sg, best_len):\n        for _ in range(24):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._ellipse_sample(best_len * 1.01)\n                if p and not self._point_blocked(p):\n                    return p\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                elif r < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_sample(sg)\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._in_bounds(p) and not self._point_blocked(p):\n                    return p\n        return None\n\n    def _ellipse_sample(self, max_sum):\n        c = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [half] * self.dim\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dim))\n            if self._in_bounds(p) and (self._dist(p, self.start) + self._dist(p, self.goal)) <= max_sum:\n                return p\n        return None\n\n    def _corridor_sample(self, sg):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        width = max(self.step_size, 0.2 * sg)\n        if self.is_3d:\n            for _ in range(16):\n                ox = self._rand_range(-width, width)\n                oy = self._rand_range(-width, width)\n                oz = self._rand_range(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp((base[0] + ox, base[1] + oy, base[2] + oz))\n                    if not self._point_blocked(p):\n                        return p\n        else:\n            for _ in range(16):\n                ox = self._rand_range(-width, width)\n                oy = self._rand_range(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp((base[0] + ox, base[1] + oy))\n                    if not self._point_blocked(p):\n                        return p\n        return tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n\n    # Node grid for NN/dupes\n    def _cell_key(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _ring_nodes(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, anchors, tree, pos):\n        k = self._cell_key(pos)\n        best, bestd = None, 1e100\n        for r in range(0, 3):\n            cand = self._ring_nodes(grid, k, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallbacks\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _has_close(self, grid, pos, radius):\n        k = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell_size) + 1)\n        r2 = radius * radius\n        cand = self._ring_nodes(grid, k, rc)\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    def _choose_parent(self, grid, nearest, pos):\n        # Evaluate a compact neighborhood around the target cell\n        k = self._cell_key(pos)\n        cand = self._ring_nodes(grid, k, self.parent_ring_cells)\n        if not cand:\n            cand = [nearest]\n        # Reservoir to cap candidates\n        picked = []\n        seen = 0\n        for n in cand:\n            seen += 1\n            if len(picked) < self.parent_cap:\n                picked.append(n)\n            else:\n                j = int(self._rand_range(0, seen))\n                if j < self.parent_cap:\n                    picked[j] = n\n        best_p = None\n        best_g = 1e100\n        for p in picked:\n            d = self._dist(p.position, pos)\n            g = p.cost + d\n            if g < best_g and self._edge_free(p.position, pos):\n                best_g = g\n                best_p = p\n        if best_p is None:\n            # fallback to nearest if edge is free\n            if self._edge_free(nearest.position, pos):\n                return nearest, nearest.cost + self._dist(nearest.position, pos)\n            return None, None\n        return best_p, best_g\n\n    def _k_near(self, grid, anchors, tree, pos, radius, k):\n        key = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell_size) + 1)\n        cand = self._ring_nodes(grid, key, rc)\n        # Filter by radius\n        near = []\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                near.append((s, n))\n        if not near:\n            # fallbacks\n            lst = list(anchors) if anchors else []\n            if not lst:\n                lst = list(tree)\n            for n in lst:\n                s = 0.0\n                for i in range(self.dim):\n                    d = n.position[i] - pos[i]\n                    s += d * d\n                near.append((s, n))\n        near.sort(key=lambda x: x[0])\n        out = []\n        for i in range(min(k, len(near))):\n            out.append(near[i][1])\n        return out\n\n    # Obstacle grid and collisions\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self._obs_grid = {}\n        if self.is_3d:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self._obs_grid.get(k)\n                            if b is None:\n                                self._obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self._obs_grid.get(k)\n                        if b is None:\n                            self._obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            lst = self._obs_grid.get((cx, cy, cz))\n            if not lst:\n                return False\n            px, py, pz = p\n            for idx in lst:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            lst = self._obs_grid.get((cx, cy))\n            if not lst:\n                return False\n            px, py = p\n            for idx in lst:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.edge_cache_quant) for i in range(self.dim))\n        qb = tuple(int(b[i] / self.edge_cache_quant) for i in range(self.dim))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        k = self._edge_key(a, b)\n        hit = self._ecache.get(k)\n        if hit is not None:\n            self._tick += 1\n            self._ecache[k] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._seg_hits_any(a, b)\n        self._tick += 1\n        self._ecache[k] = (free, self._tick)\n        if len(self._ecache) > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self._ecache:\n            return\n        cutoff = self._tick - 3000\n        to_del = []\n        for k, v in self._ecache.items():\n            if v[1] < cutoff:\n                to_del.append(k)\n        if not to_del:\n            # Fallback partial clear\n            i = 0\n            for k in list(self._ecache.keys()):\n                if (i % 3) == 0:\n                    to_del.append(k)\n                i += 1\n        for k in to_del:\n            if k in self._ecache:\n                del self._ecache[k]\n\n    def _seg_hits_any(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self._obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            cand.update(bkt)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self._obs_grid.get((cx, cy))\n                    if bkt:\n                        cand.update(bkt)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_2d(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _seg_aabb_3d(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Compression for the newly inserted node (no subtree propagation needed)\n    def _compress_new_node(self, node, edges):\n        cur_parent = node.parent\n        if cur_parent is None:\n            return\n        gp = cur_parent.parent\n        while gp is not None and self._edge_free(gp.position, node.position):\n            # Update edges coherently\n            cur_parent.remove_child(node)\n            self._remove_edge(edges, cur_parent, node)\n            gp.add_child(node)\n            edges.append((gp, node))\n            node.cost = gp.cost + self._dist(gp.position, node.position)\n            cur_parent = gp\n            gp = cur_parent.parent\n\n    def _remove_edge(self, edges, parent, child):\n        for i, e in enumerate(edges):\n            if e[0] is parent and e[1] is child:\n                edges.pop(i)\n                return\n\n    # Paths\n    def _to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_path(self, a_node, b_node):\n        pa = self._to_root(a_node)\n        pb = self._to_root(b_node)\n        pb.reverse()\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[1:]\n        return pa + pb\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    # Post smoothing\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        tries = 0\n        bestL = self._path_len(pts)\n        while tries < self.smoothing_attempts and len(pts) >= 3:\n            i = int(self._rand_range(0, max(1, len(pts) - 2)))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= bestL + 1e-12:\n                    pts = new_pts\n                    bestL = L\n            tries += 1\n        return pts\n\n    def _forward_los(self, path):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        anchor = path[0]\n        k = 1\n        while k < len(path) - 1:\n            nxt = path[k + 1]\n            if self._edge_free(anchor, nxt):\n                k += 1\n                continue\n            out.append(path[k])\n            anchor = path[k]\n            k += 1\n        out.append(path[-1])\n        return out",
          "objective": -28.8814,
          "time_improvement": 48.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1567.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022646141052246094,
                    "num_nodes_avg": 78.2,
                    "path_length_avg": 170.39434253860537,
                    "smoothness_avg": 0.05185034231215988,
                    "success_improvement": 0.0,
                    "time_improvement": 17.894796895408025,
                    "node_improvement": 80.30722739864015,
                    "length_improvement": 6.604160783447385,
                    "smoothness_improvement": 711.5704520057756,
                    "objective_score": 12.888787798719715
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.037246417999267575,
                    "num_nodes_avg": 115.8,
                    "path_length_avg": 240.92396356066416,
                    "smoothness_avg": 0.1012788889951575,
                    "success_improvement": 0.0,
                    "time_improvement": 77.49174793860553,
                    "node_improvement": 92.2193106228583,
                    "length_improvement": 19.5726463516592,
                    "smoothness_improvement": 2505.978762080556,
                    "objective_score": 47.52100600297996
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026037073135375975,
                    "num_nodes_avg": 75.2,
                    "path_length_avg": 140.84422616719021,
                    "smoothness_avg": 0.12445020180890005,
                    "success_improvement": 0.0,
                    "time_improvement": 49.81542795302638,
                    "node_improvement": 90.43865225683408,
                    "length_improvement": 6.457971261089232,
                    "smoothness_improvement": 1482.997381050845,
                    "objective_score": 26.234398047815677
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "Beam-guided BiRRT with ancestor line-of-sight compression and spatial hashing (BG-Connect-LOS). The planner alternates tree growth from start and goal using a small beam of guided samples, accelerates nearest lookups with a grid hash, suppresses near-duplicate nodes, and selects a parent among recent ancestors that maintains direct line-of-sight to the new point to compress chains. A short, capped greedy connect links the two trees. Upon success, a bounded shortcut pass refines the path. This reduces expansions and collision checks while improving path quality and smoothness.",
          "planning_mechanism": "At each iteration, pick the active tree and generate a small beam of guided samples biased toward the opposite root. For each sample: find a nearby node via spatial hashing, steer by a fixed step, enforce node and edge collision checks, reject near-duplicates, and pick an ancestor parent with clear line-of-sight to minimize added cost. Insert the node and attempt a capped greedy connect from the opposite tree toward it; if the two trees meet, extract and lightly shortcut the path. Alternate trees and stop early on success.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        beam_width=3,\n        goal_bias=0.15,\n        connect_steps_limit=20,\n        min_separation_factor=0.6,\n        grid_cell_factor=1.0,\n        los_lookback_depth=8,\n        shortcut_attempts=40\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.connect_steps_limit = connect_steps_limit\n        self.min_separation_factor = min_separation_factor\n        self.grid_cell_factor = grid_cell_factor\n        self.los_lookback_depth = los_lookback_depth\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dims = len(bounds)\n        is_3d = dims == 3\n\n        # Parameters derived from step_size\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root = Node(goal_position, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root, is_3d)\n        self._grid_insert(grid_b, goal_root, is_3d)\n\n        success_state = False\n        extracted_path = []\n\n        for _ in range(self.max_iter):\n            # Alternate trees by swapping references each loop\n            for active_tree, active_grid, other_tree, other_grid, attractor in [\n                (tree_a, grid_a, tree_b, grid_b, goal_position),\n                (tree_b, grid_b, tree_a, grid_a, start_position),\n            ]:\n                made_progress = False\n\n                for _beam in range(self.beam_width):\n                    sample = self._sample_guided(bounds, obstacles, is_3d, attractor)\n\n                    nearest = self._nearest_by_grid(active_tree, active_grid, sample, is_3d)\n                    if nearest is None:\n                        continue\n\n                    new_pos = self._steer(nearest.position, sample)\n                    if not self._within_bounds(new_pos, bounds):\n                        continue\n                    if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                        continue\n                    if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                        continue\n                    if self._has_near_duplicate(active_grid, new_pos, self.min_separation, is_3d):\n                        continue\n\n                    # Choose parent among LOS-capable ancestors to compress path\n                    parent = self._choose_ancestor_parent(nearest, new_pos, obstacles, is_3d)\n                    new_cost = parent.cost + self._distance(parent.position, new_pos)\n\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node, is_3d)\n                    made_progress = True\n\n                    # Try capped greedy connect from the opposite tree toward new_node\n                    connect_node = self._attempt_connect(\n                        other_tree, other_grid, new_node.position, obstacles, is_3d, nodes, edges, bounds\n                    )\n                    if connect_node is not None:\n                        # Trees meet at new_node.position; extract path\n                        path_a = self._path_from_root(new_node)\n                        path_b = self._path_from_root(connect_node)\n                        # Remove duplicate joint if equal\n                        if path_a and path_b and path_a[-1] == path_b[-1]:\n                            path_b = path_b[:-1]\n                        raw_path = path_a + path_b[::-1]\n                        # Light shortcut smoothing\n                        smoothed = self._shortcut_path(raw_path, obstacles, is_3d, attempts=self.shortcut_attempts)\n                        extracted_path = smoothed if smoothed else raw_path\n                        success_state = True\n                        return PlannerResult(True, extracted_path, nodes, edges)\n\n                # If neither beam sample made progress for this tree, continue with the other\n                if not made_progress:\n                    continue\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # --------- Core Geometry / Utilities ---------\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _within_bounds(self, pos, bounds):\n        for i in range(len(bounds)):\n            if pos[i] < 0.0 or pos[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= 1e-9:\n            return from_pos\n        if dist <= self.step_size:\n            return to_pos\n        r = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * r for d in range(len(from_pos)))\n\n    def _sample_guided(self, bounds, obstacles, is_3d, target):\n        # Mild guidance: with some probability sample exactly target, else blend toward target\n        while True:\n            if random.random() < self.goal_bias:\n                p = target\n            else:\n                rand = tuple(random.uniform(0.0, bounds[d]) for d in range(len(bounds)))\n                alpha = 0.2\n                p = tuple(alpha * target[d] + (1.0 - alpha) * rand[d] for d in range(len(bounds)))\n            if self._within_bounds(p, bounds) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _path_from_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\n\n    # --------- Spatial Hash (Grid) ---------\n\n    def _cell_of(self, pos):\n        # integer grid cell indices\n        if len(pos) == 3:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        else:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node, is_3d):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _has_near_duplicate(self, grid, pos, radius, is_3d):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if bucket:\n                            for n in bucket:\n                                if self._distance(n.position, pos) <= radius:\n                                    return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if bucket:\n                        for n in bucket:\n                            if self._distance(n.position, pos) <= radius:\n                                return True\n        return False\n\n    def _nearest_by_grid(self, tree, grid, pos, is_3d, ring_limit=3):\n        # Search neighborhood rings; fallback to linear scan if not found\n        cell = self._cell_of(pos)\n        best = None\n        best_d = float(\"inf\")\n\n        if is_3d:\n            for ring in range(0, ring_limit + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if bucket:\n                                for n in bucket:\n                                    d = self._distance(n.position, pos)\n                                    if d < best_d:\n                                        best_d = d\n                                        best = n\n                                        found = True\n                if found and best is not None:\n                    return best\n        else:\n            for ring in range(0, ring_limit + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if bucket:\n                            for n in bucket:\n                                d = self._distance(n.position, pos)\n                                if d < best_d:\n                                    best_d = d\n                                    best = n\n                                    found = True\n                if found and best is not None:\n                    return best\n\n        # Fallback\n        if not tree:\n            return None\n        return min(tree, key=lambda n: self._distance(n.position, pos))\n\n    # --------- Parent selection via LOS to ancestors ---------\n\n    def _choose_ancestor_parent(self, nearest, new_pos, obstacles, is_3d):\n        best_parent = nearest\n        best_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        steps = 0\n        cur = nearest\n        while cur is not None and steps < self.los_lookback_depth:\n            if not self._is_edge_in_obstacle(cur.position, new_pos, obstacles, is_3d):\n                cand_cost = cur.cost + self._distance(cur.position, new_pos)\n                if cand_cost < best_cost:\n                    best_cost = cand_cost\n                    best_parent = cur\n            cur = cur.parent\n            steps += 1\n        return best_parent\n\n    # --------- Connect attempt ---------\n\n    def _attempt_connect(self, tree, grid, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest_by_grid(tree, grid, target_pos, is_3d)\n        if nearest is None:\n            return None\n\n        current = nearest\n        for _ in range(self.connect_steps_limit):\n            step_pos = self._steer(current.position, target_pos)\n            if not self._within_bounds(step_pos, bounds):\n                return None\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                return None\n\n            # If close enough to target and direct edge exists, finalize with exact target node\n            if self._distance(step_pos, target_pos) <= 1e-6 or (\n                self._distance(step_pos, target_pos) <= self.step_size and\n                not self._is_edge_in_obstacle(step_pos, target_pos, obstacles, is_3d) and\n                not self._is_in_obstacle(target_pos, obstacles, is_3d)\n            ):\n                # Add intermediate step node if it is not exactly current\n                if self._distance(current.position, step_pos) > 1e-9:\n                    if not self._has_near_duplicate(grid, step_pos, self.min_separation, is_3d):\n                        new_node = Node(step_pos, parent=current, cost=current.cost + self._distance(current.position, step_pos))\n                        current.add_child(new_node)\n                        tree.append(new_node)\n                        nodes.append(new_node)\n                        edges.append((current, new_node))\n                        self._grid_insert(grid, new_node, is_3d)\n                        current = new_node\n                    else:\n                        # If duplicate exists, try using current as is\n                        pass\n                # Add final node at the exact target position to guarantee path merge\n                final_node = Node(target_pos, parent=current, cost=current.cost + self._distance(current.position, target_pos))\n                current.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((current, final_node))\n                self._grid_insert(grid, final_node, is_3d)\n                return final_node\n\n            # Regular step addition with duplicate suppression\n            if self._has_near_duplicate(grid, step_pos, self.min_separation, is_3d):\n                # Progress is negligible; stop trying to avoid loops\n                return None\n\n            new_node = Node(step_pos, parent=current, cost=current.cost + self._distance(current.position, step_pos))\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node, is_3d)\n            current = new_node\n\n        return None\n\n    # --------- Collision Checking ---------\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d):\n        distance = self._distance(from_pos, to_pos)\n        resolution = max(0.5, min(1.0, self.step_size * 0.5))\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    # --------- Shortcut Smoothing (bounded) ---------\n\n    def _shortcut_path(self, path, obstacles, is_3d, attempts=40):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        n = len(pts)\n        tries = 0\n        i = 0\n        # Greedy forward skipping with bounded iterations\n        while i < len(pts) - 2 and tries < attempts:\n            j = len(pts) - 1\n            improved = False\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                    # Remove intermediates\n                    del pts[i + 1:j]\n                    improved = True\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n            tries += 1\n        return pts",
          "objective": -28.86257,
          "time_improvement": 43.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1410.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03400664329528809,
                    "num_nodes_avg": 52.1,
                    "path_length_avg": 171.51876006638196,
                    "smoothness_avg": 0.050501544373221775,
                    "success_improvement": 0.0,
                    "time_improvement": -33.36568499023374,
                    "node_improvement": 86.87987912364643,
                    "length_improvement": 5.987849718937115,
                    "smoothness_improvement": 690.45883529979,
                    "objective_score": -2.964701489208901
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.030187082290649415,
                    "num_nodes_avg": 92.2,
                    "path_length_avg": 234.31486940525366,
                    "smoothness_avg": 0.08620583217892899,
                    "success_improvement": 0.0,
                    "time_improvement": 81.1563136658539,
                    "node_improvement": 93.8050124302896,
                    "length_improvement": 21.77895221296278,
                    "smoothness_improvement": 2118.138153515002,
                    "objective_score": 48.004956195108846
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009754443168640136,
                    "num_nodes_avg": 73.2,
                    "path_length_avg": 124.45355479806292,
                    "smoothness_avg": 0.11960663519260235,
                    "success_improvement": 0.0,
                    "time_improvement": 80.11393158758125,
                    "node_improvement": 90.69294342021614,
                    "length_improvement": 17.343874744565582,
                    "smoothness_improvement": 1421.3875712064366,
                    "objective_score": 41.54744217904591
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "SAGE-IBiRRT: Spatially-Accelerated Guided Expansion Bi-directional RRT*-Lite with Lazy Edge Checks and Early Visibility Compression. It uses an obstacle-grid index and edge-validity cache to prune collision work, informed corridor sampling to reduce wasted expansions, adaptive neighbor radii for cost-aware parent selection and local rewiring, and a minimal simultaneous connect. A lightweight LOS compression plus bounded shortcutting yields short, smooth paths quickly while strictly enforcing node and edge validity for every insertion and rewire.",
          "planning_mechanism": "Alternate expansion between start/goal trees: draw a guided sample (goal/corridor/informed/uniform), find nearest via grid, steer once, and commit only if the node is free and the edge is clear (lazy-checked using an obstacle spatial index and edge cache). Select a best parent from nearby neighbors and locally rewire cheaper neighbors (with coherent cost propagation). Attempt a direct bridge to the other tree; if blocked, perform a short, symmetric two-sided connect. On success, extract, visibility-compress, then lightly shortcut the path, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        exists = False\n        for c in self.children:\n            if c is child:\n                exists = True\n                break\n        if not exists:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        idx = -1\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                idx = i\n                break\n        if idx >= 0:\n            self.children.pop(idx)\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=7.0,\n                 edge_res=1.0,\n                 grid_cell=None,\n                 goal_bias=0.20,\n                 corridor_bias=0.50,\n                 informed_bias=0.60,\n                 neighbor_gamma=2.2,\n                 min_sep_ratio=0.25,\n                 dupe_radius_ratio=0.55,\n                 connect_limit=4,\n                 smoothing_iters=40):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.edge_res = float(edge_res)\n        self.grid_cell = grid_cell\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.neighbor_gamma = float(neighbor_gamma)\n        self.min_sep_ratio = float(min_sep_ratio)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.connect_limit = int(connect_limit)\n        self.smoothing_iters = int(smoothing_iters)\n\n        self.dim = 2\n        self.bounds = None\n        self.start = None\n        self.goal = None\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Normalize step and edge resolution\n        self.step_size = max(1.0, self.step_size)\n        self.edge_res = max(0.5, min(self.edge_res, 0.5 * self.step_size))\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size)\n\n        # Validate endpoints\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Build obstacle spatial index\n        self._build_obstacle_index(obstacles, is_3d)\n\n        # Edge validity cache\n        self._edge_cache = {}\n\n        # Early straight line\n        if not self._edge_blocked(self.start, self.goal, obstacles, is_3d, self.edge_res):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes = [n0, n1]\n            edges = [(n0, n1)]\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        dupe_radius = self.step_size * self.dupe_radius_ratio\n        min_sep = self.step_size * self.min_sep_ratio\n\n        dsg = self._dist(self.start, self.goal)\n        corridor_w = max(self.step_size, 0.12 * dsg)\n\n        have_solution = False\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            # Alternate active tree\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = self.goal if active_start else self.start\n\n            # Adaptive neighbor radius\n            n_nodes = max(1, len(tree_a))\n            rn = self._neighbor_radius(n_nodes)\n\n            # Guided sampling\n            r = self._rand()\n            if have_solution and r < self.informed_bias:\n                x_rand = self._sample_informed(best_len, obstacles, is_3d)\n            else:\n                if r < self.goal_bias:\n                    x_rand = root_other\n                elif r < self.goal_bias + self.corridor_bias:\n                    x_rand = self._sample_corridor(self.start, self.goal, corridor_w, obstacles, is_3d)\n                else:\n                    x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest and steer\n            near = self._nearest_grid(grid_a, tree_a, x_rand)\n            if near is None:\n                near = tree_a[0]\n            new_pos = self._steer(near.position, x_rand, self.step_size)\n            if (not self._in_bounds(new_pos)) or self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._dist(near.position, new_pos) < min_sep:\n                continue\n            if self._exists_close(grid_a, new_pos, dupe_radius):\n                continue\n            if self._edge_blocked(near.position, new_pos, obstacles, is_3d, self.edge_res):\n                continue\n\n            # Best parent among neighbors\n            best_parent = near\n            best_cost = near.cost + self._dist(near.position, new_pos)\n            neigh = self._neighbors_within(grid_a, new_pos, rn)\n            for nb in neigh:\n                if nb is near:\n                    continue\n                if self._edge_blocked(nb.position, new_pos, obstacles, is_3d, self.edge_res):\n                    continue\n                cand_cost = nb.cost + self._dist(nb.position, new_pos)\n                if cand_cost + 1e-12 < best_cost:\n                    best_parent = nb\n                    best_cost = cand_cost\n\n            # Insert node (both checks)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked(best_parent.position, new_pos, obstacles, is_3d, self.edge_res):\n                continue\n            new_node = Node(new_pos, parent=best_parent, cost=best_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((best_parent, new_node))\n            self._grid_add(grid_a, new_node)\n\n            # Local rewiring\n            for nb in neigh:\n                if nb is new_node or nb is best_parent:\n                    continue\n                new_cost = new_node.cost + self._dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if self._edge_blocked(new_node.position, nb.position, obstacles, is_3d, self.edge_res):\n                        continue\n                    old_parent = nb.parent\n                    old_cost = nb.cost\n                    if old_parent is not None:\n                        old_parent.remove_child(nb)\n                        self._remove_edge(edges, old_parent, nb)\n                    new_node.add_child(nb)\n                    edges.append((new_node, nb))\n                    nb.cost = new_cost\n                    self._propagate_delta(nb, new_cost - old_cost)\n\n            # Attempt direct bridge\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None:\n                if (not self._is_in_obstacle(other_near.position, obstacles, is_3d)) and \\\n                   (not self._edge_blocked(new_node.position, other_near.position, obstacles, is_3d, self.edge_res)):\n                    edges.append((new_node, other_near))\n                    path = self._extract_path(new_node, other_near)\n                    have_solution = True\n                    best_len = self._path_length(path)\n                    path = self._postprocess(path, obstacles, is_3d)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Short symmetric connect (bounded)\n            if other_near is not None:\n                steps = 0\n                a_tip = new_node\n                b_tip = other_near\n                while steps < self.connect_limit:\n                    # Grow other tree one step toward a_tip\n                    to_b = self._steer(b_tip.position, a_tip.position, self.step_size)\n                    if (not self._in_bounds(to_b)) or self._is_in_obstacle(to_b, obstacles, is_3d):\n                        break\n                    if self._dist(b_tip.position, to_b) < min_sep:\n                        break\n                    if self._exists_close(grid_b, to_b, dupe_radius):\n                        break\n                    if self._edge_blocked(b_tip.position, to_b, obstacles, is_3d, self.edge_res):\n                        break\n                    qb = Node(to_b, parent=b_tip, cost=b_tip.cost + self._dist(b_tip.position, to_b))\n                    b_tip.add_child(qb)\n                    tree_b.append(qb)\n                    edges.append((b_tip, qb))\n                    self._grid_add(grid_b, qb)\n                    b_tip = qb\n\n                    # Try to connect now\n                    if not self._edge_blocked(a_tip.position, b_tip.position, obstacles, is_3d, self.edge_res):\n                        edges.append((a_tip, b_tip))\n                        path = self._extract_path(a_tip, b_tip)\n                        have_solution = True\n                        best_len = self._path_length(path)\n                        path = self._postprocess(path, obstacles, is_3d)\n                        return PlannerResult(True, path, start_tree + goal_tree, edges)\n                    steps += 1\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # RNG\n    def _rand(self):\n        return self._lcg()\n\n    def _lcg(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2166136261\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry/basic\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_blocked(self, a, b, obstacles, is_3d, res):\n        # Edge cache\n        k = self._edge_key(a, b, res)\n        hit = self._edge_cache.get(k, None)\n        if hit is not None:\n            return hit\n\n        # Potential obstacle collection via spatial index\n        pot = self._potential_obstacles_for_segment(a, b, is_3d)\n\n        if not pot:\n            self._edge_cache[k] = False\n            return False\n\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if not self._in_bounds(p):\n                self._edge_cache[k] = True\n                return True\n            if self._point_hits_any(pot, p, is_3d):\n                self._edge_cache[k] = True\n                return True\n        self._edge_cache[k] = False\n        return False\n\n    def _point_hits_any(self, pot_indices, p, is_3d):\n        if is_3d:\n            px, py, pz = p\n            for idx in pot_indices:\n                x, y, z, w, h, d = self._obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = p\n            for idx in pot_indices:\n                x, y, w, h = self._obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        for _ in range(64):\n            if is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        if is_3d:\n            return (0.5 * self.bounds[0], 0.5 * self.bounds[1], 0.5 * self.bounds[2])\n        return (0.5 * self.bounds[0], 0.5 * self.bounds[1])\n\n    def _sample_corridor(self, s, g, width, obstacles, is_3d):\n        for _ in range(24):\n            t = self._rand()\n            base = tuple(s[i] + t * (g[i] - s[i]) for i in range(self.dim))\n            if self.dim == 3:\n                p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                     self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                     self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n            else:\n                p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                     self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, c_best, obstacles, is_3d):\n        if not (c_best > 0.0 and c_best < float('inf')):\n            return self._sample_free(obstacles, is_3d)\n        for _ in range(40):\n            p = self._sample_free(obstacles, is_3d)\n            ds = self._dist(p, self.start)\n            dg = self._dist(p, self.goal)\n            if ds + dg <= c_best + 1e-9:\n                return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # Grid for nodes\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        return out\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Expand small rings then fallback\n        for r in range(0, 3):\n            cand = self._grid_collect_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback full scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _neighbors_within(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._grid_collect_ring(grid, key, r_cells)\n        res = []\n        r2 = radius * radius\n        for n in cand:\n            d2 = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d2 += dd * dd\n            if d2 <= r2:\n                res.append(n)\n        return res\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._grid_collect_ring(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            d2 = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d2 += dd * dd\n            if d2 <= r2:\n                return True\n        return False\n\n    # Neighbor radius scaling\n    def _neighbor_radius(self, n):\n        # Mildly shrinking with n; bounded by grid and step size scales\n        base = max(2.0 * self.step_size, 2.0 * self.grid_cell)\n        return base * (self.neighbor_gamma / (1.0 + 0.15 * (n ** (1.0 / max(1, self.dim)))))\n\n    # Edges/cost propagation\n    def _remove_edge(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_delta(self, node, delta):\n        stack = []\n        for ch in node.children:\n            stack.append(ch)\n        while stack:\n            cur = stack.pop()\n            cur.cost += delta\n            for ch in cur.children:\n                stack.append(ch)\n\n    # Path utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a, b):\n        pa = self._path_to_root(a)\n        tail = []\n        cur = b\n        while cur is not None:\n            tail.append(cur.position)\n            cur = cur.parent\n        if pa and tail and pa[-1] == tail[0]:\n            return pa + tail[1:]\n        return pa + tail\n\n    def _path_length(self, path):\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _postprocess(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path[:]\n        pts = self._visibility_compress(path, obstacles, is_3d)\n        tries = 0\n        while tries < self.smoothing_iters and len(pts) >= 3:\n            n = len(pts)\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n            tries += 1\n        return pts\n\n    def _visibility_compress(self, path, obstacles, is_3d):\n        out = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            found = False\n            while j > i + 1:\n                if not self._edge_blocked(path[i], path[j], obstacles, is_3d, self.edge_res):\n                    out.append(path[j])\n                    i = j\n                    found = True\n                    break\n                j -= 1\n            if not found:\n                out.append(path[i + 1])\n                i += 1\n        return out\n\n    # Obstacle spatial index\n    def _build_obstacle_index(self, obstacles, is_3d):\n        self._obstacles = obstacles[:]  # keep reference for point checks\n        self._obs_grid = {}\n        self._obs_cell = max(self.edge_res * 2.0, 4.0)\n        for idx in range(len(obstacles)):\n            if is_3d:\n                x, y, z, w, h, d = obstacles[idx]\n                minc = (x, y, z)\n                maxc = (x + w, y + h, z + d)\n                keys = self._obs_cells_for_aabb(minc, maxc, is_3d)\n                for k in keys:\n                    lst = self._obs_grid.get(k)\n                    if lst is None:\n                        self._obs_grid[k] = [idx]\n                    else:\n                        lst.append(idx)\n            else:\n                x, y, w, h = obstacles[idx]\n                minc = (x, y)\n                maxc = (x + w, y + h)\n                keys = self._obs_cells_for_aabb(minc, maxc, is_3d)\n                for k in keys:\n                    lst = self._obs_grid.get(k)\n                    if lst is None:\n                        self._obs_grid[k] = [idx]\n                    else:\n                        lst.append(idx)\n\n    def _obs_cell_key(self, p):\n        return tuple(int(p[i] // self._obs_cell) for i in range(self.dim))\n\n    def _obs_cells_for_aabb(self, minc, maxc, is_3d):\n        keys = []\n        if is_3d:\n            kmin = self._obs_cell_key(minc)\n            kmax = self._obs_cell_key(maxc)\n            for ix in range(kmin[0], kmax[0] + 1):\n                for iy in range(kmin[1], kmax[1] + 1):\n                    for iz in range(kmin[2], kmax[2] + 1):\n                        keys.append((ix, iy, iz))\n        else:\n            kmin = self._obs_cell_key(minc)\n            kmax = self._obs_cell_key(maxc)\n            for ix in range(kmin[0], kmax[0] + 1):\n                for iy in range(kmin[1], kmax[1] + 1):\n                    keys.append((ix, iy))\n        return keys\n\n    def _segment_aabb(self, a, b):\n        minc = []\n        maxc = []\n        for i in range(self.dim):\n            lo = a[i] if a[i] < b[i] else b[i]\n            hi = a[i] if a[i] > b[i] else b[i]\n            minc.append(lo)\n            maxc.append(hi)\n        return tuple(minc), tuple(maxc)\n\n    def _potential_obstacles_for_segment(self, a, b, is_3d):\n        minc, maxc = self._segment_aabb(a, b)\n        keys = self._obs_cells_for_aabb(minc, maxc, is_3d)\n        seen = {}\n        pot = []\n        for k in keys:\n            lst = self._obs_grid.get(k)\n            if lst:\n                for idx in lst:\n                    if idx not in seen:\n                        seen[idx] = True\n                        pot.append(idx)\n        return pot\n\n    # Edge cache key\n    def _edge_key(self, a, b, res):\n        qa = self._qpoint(a, res)\n        qb = self._qpoint(b, res)\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _qpoint(self, p, res):\n        # Quantize to integer grid keyed by edge resolution\n        return tuple(int(p[i] / res + 0.5) for i in range(self.dim))",
          "objective": -28.78327,
          "time_improvement": 37.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1581.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02105083465576172,
                    "num_nodes_avg": 59.4,
                    "path_length_avg": 158.89745927686258,
                    "smoothness_avg": 0.04635275815124314,
                    "success_improvement": 0.0,
                    "time_improvement": 16.312715512747353,
                    "node_improvement": 85.04155124653741,
                    "length_improvement": 12.905784678982112,
                    "smoothness_improvement": 625.5213216923456,
                    "objective_score": 15.764892069675202
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04598712921142578,
                    "num_nodes_avg": 119.1,
                    "path_length_avg": 233.59991208209476,
                    "smoothness_avg": 0.11220745960734521,
                    "success_improvement": 0.0,
                    "time_improvement": 71.29584061723972,
                    "node_improvement": 91.99758113283613,
                    "length_improvement": 22.017625546338735,
                    "smoothness_improvement": 2787.178755463388,
                    "objective_score": 48.53522129029209
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03740205764770508,
                    "num_nodes_avg": 116.2,
                    "path_length_avg": 129.24038750024965,
                    "smoothness_avg": 0.11240107099581824,
                    "success_improvement": 0.0,
                    "time_improvement": 23.007352002905463,
                    "node_improvement": 85.22568340750158,
                    "length_improvement": 14.164688388251761,
                    "smoothness_improvement": 1329.733326482767,
                    "objective_score": 22.04968526623653
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "FALCON-BiRRT: Fast Anchored-Grid, Local-Optimal, Cached-Neighborhood Bidirectional RRT. It reduces planning time via duplicate-free ring-hash nearest search, per-cell expansion throttling, memoized edge collision checks, and single-pass parent selection that avoids redundant LOS tests. Early direct-bridge attempts and strictly bounded micro-connection steps speed convergence; constant-time edge bookkeeping and cheap ancestor LOS compression keep the tree lean without costly scans.",
          "planning_mechanism": "Alternate growing two trees. For a tiny beam each side: sample from goal/corridor/uniform (switch to ellipse-informed once a provisional path exists), pick a nearest via exact grid rings, steer, perform node and edge checks, and select the best-cost LOS-feasible parent from a unique local neighborhood (cached). Insert, apply quick ancestor compression, then try a direct bridge to the opposite tree; otherwise add at most two guided micro-steps from the opposite tree. On success, extract and lightly shortcut/LOS-collapse the path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=12.0,\n        collision_step=1.0,\n        beam_k=2,\n        goal_bias=0.25,\n        corridor_bias=0.5,\n        informed_bias=0.65,\n        grid_cell_factor=1.0,\n        min_sep_ratio=0.4,\n        dupe_radius_ratio=0.6,\n        cell_expand_limit=2,\n        max_rings=3,\n        parent_search_rings=2,\n        parent_k=16,\n        connect_micro_steps=2,\n        smoothing_attempts=20,\n        anchors_stride=24,\n        edge_cache_max=16000,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_step = collision_step\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.informed_bias = informed_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.min_sep_ratio = min_sep_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.cell_expand_limit = max(1, int(cell_expand_limit))\n        self.max_rings = max_rings\n        self.parent_search_rings = parent_search_rings\n        self.parent_k = parent_k\n        self.connect_micro_steps = connect_micro_steps\n        self.smoothing_attempts = smoothing_attempts\n        self.anchors_stride = max(1, int(anchors_stride))\n        self.edge_cache_max = edge_cache_max\n\n        # runtime\n        self.bounds = None\n        self.dim = 2\n        self.edge_res = 1.0\n        self.cache_bin = 1.0\n        self.edge_cache = None\n        self.cell_size = 1.0\n        self.min_sep = 1.0\n        self.dupe_radius = 1.0\n        self.start = None\n        self.goal = None\n\n    # ------------------ Public entry ------------------\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Discretizations\n        self.edge_res = max(0.75, min(self.collision_step, self.step_size * 0.5))\n        self.cache_bin = max(1.0, self.edge_res)\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step_size * self.min_sep_ratio)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.edge_cache = {}\n\n        # Validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Trivial straight path\n        if not self._edge_blocked_memo(self.start, self.goal, obstacles, is_3d):\n            n0 = Node(self.start)\n            n1 = Node(self.goal, parent=n0, cost=self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Init trees\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n        edge_index = {}  # child_id -> index in edges\n\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        anchors_a, anchors_b = [start_root], [goal_root]\n        throttles_a, throttles_b = {}, {}\n\n        best_path_len = float('inf')\n        d_sg = self._dist(self.start, self.goal)\n        base_corridor_w = max(self.step_size, 0.2 * d_sg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            anchors1 = anchors_a if active_start else anchors_b\n            anchors2 = anchors_b if active_start else anchors_a\n            throttles1 = throttles_a if active_start else throttles_b\n            throttles2 = throttles_b if active_start else throttles_a\n            other_root = self.goal if active_start else self.start\n\n            best_candidate = None  # (parent, new_pos, score)\n\n            for _ in range(self.beam_k):\n                # sampling\n                x_rand = None\n                r = self._rand()\n                if best_path_len < float('inf') and r < self.informed_bias:\n                    x_rand = self._sample_informed(best_path_len, obstacles, is_3d)\n                else:\n                    r2 = self._rand()\n                    if r2 < self.goal_bias:\n                        x_rand = other_root\n                    elif r2 < self.goal_bias + self.corridor_bias:\n                        width = base_corridor_w\n                        if best_path_len < float('inf'):\n                            slack = max(0.0, best_path_len - d_sg)\n                            width = max(self.step_size, 0.15 * slack + base_corridor_w)\n                        x_rand = self._sample_corridor(width, obstacles, is_3d)\n                    else:\n                        x_rand = self._sample_free(obstacles, is_3d)\n\n                nearest = self._nearest_hashed(grid1, tree1, anchors1, x_rand)\n                if nearest is None:\n                    continue\n\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._exists_close(grid1, new_pos, self.dupe_radius):\n                    continue\n\n                # Throttle expansions per cell\n                kcell = self._grid_key(new_pos)\n                if throttles1.get(kcell, 0) >= self.cell_expand_limit:\n                    continue\n\n                # Parent selection with cached LOS; returns None if no LOS-feasible parent\n                parent = self._choose_parent(nearest, grid1, new_pos, obstacles, is_3d)\n                if parent is None:\n                    continue\n\n                # Bridge score: distance to nearest node on opposite tree\n                near2 = self._nearest_hashed(grid2, tree2, anchors2, new_pos)\n                score = self._dist(new_pos, near2.position) if near2 else self._dist(new_pos, other_root)\n\n                if best_candidate is None or score < best_candidate[2]:\n                    best_candidate = (parent, new_pos, score)\n\n            if best_candidate is None:\n                continue\n\n            parent, new_pos, _ = best_candidate\n\n            # Final safety checks (fast due to cache)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked_memo(parent.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Insert node\n            new_cost = parent.cost + self._dist(parent.position, new_pos)\n            new_node = Node(new_pos, parent=parent, cost=new_cost)\n            parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            edge_index[id(new_node)] = len(edges) - 1\n            self._grid_add(grid1, new_node)\n            kc = self._grid_key(new_pos)\n            throttles1[kc] = throttles1.get(kc, 0) + 1\n            if len(tree1) % self.anchors_stride == 0:\n                anchors1.append(new_node)\n\n            # Cheap multi-ancestor LOS compression without O(E) scans\n            self._compress_to_ancestor(new_node, obstacles, is_3d, edges, edge_index)\n\n            # Try direct bridge to nearest on other tree\n            other_near = self._nearest_hashed(grid2, tree2, anchors2, new_node.position)\n            if other_near is not None and not self._edge_blocked_memo(new_node.position, other_near.position, obstacles, is_3d):\n                path = self._extract_path(new_node, other_near)\n                best_path_len = self._path_length(path)\n                path = self._smooth_path(path, obstacles, is_3d, self.smoothing_attempts)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Bounded micro-connect from the opposite side\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_micro_steps:\n                step_pos = self._steer(p.position, new_node.position, self.step_size)\n                if not self._in_bounds(step_pos) or self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._exists_close(grid2, step_pos, self.dupe_radius):\n                    break\n                if self._edge_blocked_memo(p.position, step_pos, obstacles, is_3d):\n                    break\n\n                q = Node(step_pos, parent=p, cost=p.cost + self._dist(p.position, step_pos))\n                p.add_child(q)\n                tree2.append(q)\n                nodes.append(q)\n                edges.append((p, q))\n                edge_index[id(q)] = len(edges) - 1\n                self._grid_add(grid2, q)\n                k2 = self._grid_key(step_pos)\n                throttles2[k2] = throttles2.get(k2, 0) + 1\n                if len(tree2) % self.anchors_stride == 0:\n                    anchors2.append(q)\n\n                # Try bridge\n                if not self._edge_blocked_memo(new_node.position, q.position, obstacles, is_3d):\n                    path = self._extract_path(new_node, q)\n                    best_path_len = self._path_length(path)\n                    path = self._smooth_path(path, obstacles, is_3d, self.smoothing_attempts)\n                    return PlannerResult(True, path, nodes, edges)\n\n                p = q\n                steps += 1\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # ------------------ RNG ------------------\n    def _rand(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------------ Geometry ------------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp_tuple(to_pos)\n        if d <= 1e-12:\n            return self._clamp_tuple(from_pos)\n        r = step / d\n        return self._clamp_tuple(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ------------------ Collision ------------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked_memo(self, a, b, obstacles, is_3d):\n        key = self._edge_key_q(a, b)\n        state = self.edge_cache.get(key)\n        if state is not None:\n            return state == 1\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d)\n        self.edge_cache[key] = 1 if blocked else 2\n        if len(self.edge_cache) > self.edge_cache_max:\n            self.edge_cache.clear()\n        return blocked\n\n    # ------------------ Sampling ------------------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n        else:\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d):\n        for _ in range(40):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= best_len and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        return self._sample_corridor(max(self.step_size, 0.2 * self._dist(self.start, self.goal)), obstacles, is_3d)\n\n    # ------------------ Grid hashing ------------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _cells_at_ring(self, key, r):\n        if self.dim == 3:\n            out = []\n            if r == 0:\n                return [key]\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    dz = -r\n                    out.append((key[0] + dx, key[1] + dy, key[2] + dz))\n                    dz = r\n                    out.append((key[0] + dx, key[1] + dy, key[2] + dz))\n            for dx in range(-r, r + 1):\n                for dz in range(-r + 1, r):\n                    dy = -r\n                    out.append((key[0] + dx, key[1] + dy, key[2] + dz))\n                    dy = r\n                    out.append((key[0] + dx, key[1] + dy, key[2] + dz))\n            for dy in range(-r + 1, r):\n                for dz in range(-r + 1, r):\n                    dx = -r\n                    out.append((key[0] + dx, key[1] + dy, key[2] + dz))\n                    dx = r\n                    out.append((key[0] + dx, key[1] + dy, key[2] + dz))\n            return out\n        else:\n            out = []\n            if r == 0:\n                return [key]\n            for dx in range(-r, r + 1):\n                out.append((key[0] + dx, key[1] - r))\n                out.append((key[0] + dx, key[1] + r))\n            for dy in range(-r + 1, r):\n                out.append((key[0] - r, key[1] + dy))\n                out.append((key[0] + r, key[1] + dy))\n            return out\n\n    def _nearest_hashed(self, grid, tree, anchors, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.max_rings + 1):\n            cells = self._cells_at_ring(key, r)\n            found = False\n            for c in cells:\n                bucket = grid.get(c)\n                if not bucket:\n                    continue\n                for n in bucket:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                        found = True\n            if found and best is not None:\n                return best\n        # Fallback anchors\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # Rare: full scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.cell_size) + 1\n        r2 = radius * radius\n        # scan unique cells in square neighborhood\n        if self.dim == 3:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not bucket:\n                            continue\n                        for n in bucket:\n                            s = 0.0\n                            for i in range(self.dim):\n                                d = n.position[i] - pos[i]\n                                s += d * d\n                            if s <= r2:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((key[0] + dx, key[1] + dy))\n                    if not bucket:\n                        continue\n                    for n in bucket:\n                        s = 0.0\n                        for i in range(self.dim):\n                            d = n.position[i] - pos[i]\n                            s += d * d\n                        if s <= r2:\n                            return True\n        return False\n\n    def _nearby_unique(self, grid, pos, rings, limit):\n        key = self._grid_key(pos)\n        out = []\n        seen = set()\n        for r in range(0, rings + 1):\n            cells = self._cells_at_ring(key, r)\n            for c in cells:\n                bucket = grid.get(c)\n                if not bucket:\n                    continue\n                for n in bucket:\n                    ni = id(n)\n                    if ni in seen:\n                        continue\n                    seen.add(ni)\n                    out.append(n)\n                    if len(out) >= limit:\n                        return out\n        return out\n\n    # ------------------ Parent selection ------------------\n    def _choose_parent(self, nearest, grid, new_pos, obstacles, is_3d):\n        # collect candidates\n        candidates = self._nearby_unique(grid, new_pos, self.parent_search_rings, self.parent_k)\n        if not candidates:\n            candidates = [nearest]\n        # pick best-cost LOS-feasible parent\n        best_parent = None\n        best_cost = float('inf')\n        for cand in candidates:\n            if self._edge_blocked_memo(cand.position, new_pos, obstacles, is_3d):\n                continue\n            c = cand.cost + self._dist(cand.position, new_pos)\n            if c < best_cost:\n                best_cost = c\n                best_parent = cand\n        return best_parent\n\n    # ------------------ Ancestor compression ------------------\n    def _compress_to_ancestor(self, node, obstacles, is_3d, edges, edge_index):\n        # try to reattach to highest ancestor with LOS\n        parent = node.parent\n        if parent is None:\n            return\n        gp = parent.parent\n        reattached = False\n        best_ancestor = parent\n        while gp is not None:\n            if not self._edge_blocked_memo(gp.position, node.position, obstacles, is_3d):\n                best_ancestor = gp\n                gp = gp.parent\n                reattached = True\n            else:\n                break\n        if reattached and best_ancestor is not node.parent:\n            # Remove from old parent's children\n            try:\n                node.parent.children.remove(node)\n            except:\n                pass\n            # Attach to best_ancestor\n            best_ancestor.add_child(node)\n            node.cost = best_ancestor.cost + self._dist(best_ancestor.position, node.position)\n            # Update edge list in O(1)\n            idx = edge_index.get(id(node))\n            if idx is not None and 0 <= idx < len(edges):\n                edges[idx] = (best_ancestor, node)\n\n    # ------------------ Paths ------------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node):\n        path_a = self._path_to_root(a_node)\n        path_b = []\n        cur = b_node\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _smooth_path(self, path, obstacles, is_3d, attempts):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        tries = 0\n        while tries < attempts and len(pts) >= 3:\n            i = int(self._uniform(0, len(pts) - 2))\n            j = int(self._uniform(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked_memo(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n            tries += 1\n        # Forward LOS collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            k = 1\n            while k < len(pts) - 1:\n                nxt = pts[k + 1]\n                if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d):\n                    collapsed.append(pts[k])\n                    last = pts[k]\n                k += 1\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
          "objective": -28.40747,
          "time_improvement": 44.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1642.0,
          "node_improvement": 94.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021186280250549316,
                    "num_nodes_avg": 37.0,
                    "path_length_avg": 177.04952784733854,
                    "smoothness_avg": 0.05535322200644312,
                    "success_improvement": 0.0,
                    "time_improvement": 15.774253536826022,
                    "node_improvement": 90.68244774615965,
                    "length_improvement": 2.9563482575709426,
                    "smoothness_improvement": 766.3981258463125,
                    "objective_score": 10.338075644821934
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03812704086303711,
                    "num_nodes_avg": 56.0,
                    "path_length_avg": 241.21451065323953,
                    "smoothness_avg": 0.10777176937410071,
                    "success_improvement": 0.0,
                    "time_improvement": 76.20193570479022,
                    "node_improvement": 96.23731774507827,
                    "length_improvement": 19.475653369223178,
                    "smoothness_improvement": 2673.0452508634708,
                    "objective_score": 47.91119898728832
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.029011011123657227,
                    "num_nodes_avg": 38.5,
                    "path_length_avg": 131.85393637672433,
                    "smoothness_avg": 0.12471249417006176,
                    "success_improvement": 0.0,
                    "time_improvement": 40.280436212295214,
                    "node_improvement": 95.1048951048951,
                    "length_improvement": 12.428893668321003,
                    "smoothness_improvement": 1486.3337205244136,
                    "objective_score": 26.973135667303232
               }
          ],
          "success_rate": 1.0
     }
]