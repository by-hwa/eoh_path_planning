[
     {
          "operator": "m3",
          "algorithm_description": "SAGE-Connect*: Simple Adaptive Grid Explorer with Informed Bidirectional Growth, Gentle Rewiring, and Fast Smoothing. It builds two trees from start and goal using a compact spatial hash, adaptive neighbor radius, LOS-aware stepping, lightweight k-best parenting, capped local rewiring, and a restrained greedy connect. Once a valid bridge is found, the path is shortcut-pruned and elastically smoothed with collision-aware line search for robust, short, and smooth trajectories.",
          "planning_mechanism": "Alternate expanding start/goal trees. Each iteration: draw a target (goal/segment/uniform; switch to informed-ellipse once a path exists), pick nearest via grid, steer with LOS-adaptive step, enforce node and edge collision checks, suppress duplicates, select a low-cost parent from nearby nodes, add the node, and locally rewire a few neighbors if the new route is cheaper (cycle-safe, edge-checked). Attempt a short greedy connect from the other tree; on success, assemble the bidirectional path, then apply shortcutting and visibility pruning followed by elastic midpoint smoothing before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        pts.reverse()\n        return pts\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step=6.0,\n        connect_factor=1.9,\n        goal_bias=0.16,\n        line_bias=0.22,\n        informed_bias=0.45,\n        grid_cell_factor=1.6,\n        neighbor_radius_scale=3.0,\n        dupe_ratio=0.4,\n        rewire_cap=12,\n        connect_steps=12,\n        shortcut_attempts=90,\n        smooth_passes=6\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step)\n        self.connect_step = float(step * connect_factor)\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neighbor_radius_scale = float(neighbor_radius_scale)\n        self.dupe_ratio = float(dupe_ratio)\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_steps = int(max(1, connect_steps))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.smooth_passes = int(max(0, smooth_passes))\n        self._rng = 123456789\n        self._eindex = {}\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n        self._eindex = {}\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step * self.dupe_ratio)\n\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            self._edges_add(edges, n0, n1)\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Trees and grids\n        Ta, Tb = [], []\n        Ga, Gb = {}, {}\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        Ta.append(start_root)\n        Tb.append(goal_root)\n        nodes.extend([start_root, goal_root])\n        self._grid_add(Ga, start_root)\n        self._grid_add(Gb, goal_root)\n\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            # Sample a common target for both directions for coherence\n            sample = self._sample_target(best_len)\n            if sample is None:\n                continue\n\n            # Expand from start side\n            res = self._expand_and_maybe_connect(Ta, Ga, Tb, Gb, sample, nodes, edges)\n            if res is not None:\n                path, L = res\n                best_len = L\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n            # Expand from goal side\n            res = self._expand_and_maybe_connect(Tb, Gb, Ta, Ga, sample, nodes, edges)\n            if res is not None:\n                path, L = res\n                best_len = L\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # Core expansion and connection\n    def _expand_and_maybe_connect(self, Ta, Ga, Tb, Gb, target, nodes, edges):\n        na = self._nearest(Ga, target)\n        if na is None:\n            return None\n        q_new = self._steer_dynamic(na.position, target)\n        if (not self._in_bounds(q_new)) or self._point_blocked(q_new):\n            return None\n        if self._too_close(Ga, q_new, self.dupe_radius):\n            return None\n\n        parent = self._select_parent(Ga, q_new, na)\n        if parent is None:\n            return None\n        # Both checks before adding node/edge\n        if self._point_blocked(q_new) or (not self._edge_free(parent.position, q_new)):\n            return None\n\n        cost = parent.cost + self._dist(parent.position, q_new)\n        nn = Node(q_new, parent, cost)\n        parent.add_child(nn)\n        Ta.append(nn)\n        nodes.append(nn)\n        self._grid_add(Ga, nn)\n        self._edges_add(edges, parent, nn)\n\n        # Gentle local rewiring\n        if self.rewire_cap > 0:\n            self._rewire_neighbors(Ga, nn, edges, self.rewire_cap)\n\n        # Try greedy connect from the opposite tree\n        meet, ok = self._greedy_connect(Tb, Gb, nn.position, nodes, edges)\n        if ok:\n            pa = nn.path_to_root()\n            pb = meet.path_to_root()\n            # Determine which root belongs to which\n            if Ta[0].position == self.start:\n                # pa: start->..., pb: goal->...\n                path = pa + pb[-2::-1]\n            else:\n                # pa: goal->..., pb: start->...\n                path = pb + pa[-2::-1]\n            L = self._path_len(path)\n            return (self._dedup(path), L)\n        return None\n\n    # RNG\n    def _seed_rng(self):\n        s = 2166136261\n        for v in self.start + self.goal:\n            s ^= int(v * 10007 + 0.5) & 0xffffffff\n            s = (s * 16777619) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Sampling\n    def _sample_target(self, best_len):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._sample_informed_ellipse(self.start, self.goal, best_len * 1.01)\n            if p is not None and self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        r2 = self._rand()\n        if r2 < self.goal_bias:\n            return self.goal\n        if r2 < self.goal_bias + self.line_bias:\n            t = self._rand()\n            if self.is3:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t,\n                     self.start[2] + (self.goal[2] - self.start[2]) * t)\n            else:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t)\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        # Uniform\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_informed_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if self._in_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and (not self._point_blocked(p)):\n                return p\n        return None\n\n    # Geometry helpers\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(self._lerp(a, b, r))\n\n    def _steer_dynamic(self, a, b):\n        if self._edge_free(a, b):\n            d = self._dist(a, b)\n            step = self.connect_step if d > self.connect_step else d\n            return self._steer(a, b, step)\n        return self._steer(a, b, self.step)\n\n    # Node grid\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 3):\n            cand = self._grid_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n            if best is not None:\n                return best\n        # fallback\n        for lst in grid.values():\n            for n in lst:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n        return best\n\n    def _neighbors_within(self, grid, pos, radius, cap):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        seen = {}\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            i2 = id(n)\n                            if i2 in seen:\n                                continue\n                            seen[i2] = True\n                            d2 = 0.0\n                            p = n.position\n                            for i in range(self.dim):\n                                di = p[i] - pos[i]\n                                d2 += di * di\n                            if d2 <= r2:\n                                out.append(n)\n                                if len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        i2 = id(n)\n                        if i2 in seen:\n                            continue\n                        seen[i2] = True\n                        d2 = 0.0\n                        p = n.position\n                        for i in range(self.dim):\n                            di = p[i] - pos[i]\n                            d2 += di * di\n                        if d2 <= r2:\n                            out.append(n)\n                            if len(out) >= cap:\n                                return out\n        return out\n\n    def _adaptive_radius(self, n_nodes):\n        t = float(max(1, n_nodes))\n        base = 1.2 * self.step\n        extra = self.neighbor_radius_scale * self.step / ((1.0 + t) ** (1.0 / 3.0))\n        r = base + extra\n        if r < 1.05 * self.step:\n            r = 1.05 * self.step\n        return r\n\n    def _too_close(self, grid, pos, radius):\n        nb = self._neighbors_within(grid, pos, radius, 1)\n        return len(nb) > 0\n\n    # Parent selection\n    def _select_parent(self, grid, newp, fallback_near):\n        r = self._adaptive_radius(len(grid))\n        neigh = self._neighbors_within(grid, newp, r, 96)\n        best = fallback_near\n        best_cost = fallback_near.cost + self._dist(fallback_near.position, newp)\n        for n in neigh:\n            if n is fallback_near:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                best = n\n                best_cost = c\n        return best\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _rewire_neighbors(self, grid, node, edges, cap):\n        r = self._adaptive_radius(len(grid))\n        neigh = self._neighbors_within(grid, node.position, r, 128)\n        cnt = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            if self._point_blocked(nb.position) or self._point_blocked(node.position):\n                continue\n            if not self._edge_free(node.position, nb.position):\n                continue\n            newc = node.cost + self._dist(node.position, nb.position)\n            if newc + 1e-12 < nb.cost:\n                self._reparent(nb, node, edges)\n                cnt += 1\n                if cnt >= cap:\n                    break\n\n    def _reparent(self, child, new_parent, edges):\n        if child is new_parent or child.parent is new_parent:\n            return\n        if self._point_blocked(child.position) or self._point_blocked(new_parent.position):\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._edges_remove(edges, old, child)\n        new_parent.add_child(child)\n        self._edges_add(edges, new_parent, child)\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        stack = list(child.children)\n        while stack:\n            n = stack.pop()\n            n.cost = n.parent.cost + self._dist(n.parent.position, n.position)\n            for c in n.children:\n                stack.append(c)\n\n    # Greedy connect\n    def _greedy_connect(self, T, G, target_pos, nodes, edges):\n        cur = self._nearest(G, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < self.connect_steps:\n            # Visible? insert exact meeting point\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                    if not self._too_close(G, target_pos, 0.75 * self.dupe_radius):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                            return cur, True\n                        cur.add_child(nn)\n                        T.append(nn)\n                        nodes.append(nn)\n                        self._grid_add(G, nn)\n                        self._edges_add(edges, cur, nn)\n                        return nn, True\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            if self._too_close(G, nxt, 0.75 * self.dupe_radius):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                return cur, False\n            cur.add_child(nn)\n            T.append(nn)\n            nodes.append(nn)\n            self._grid_add(G, nn)\n            self._edges_add(edges, cur, nn)\n            cur = nn\n            steps += 1\n        # Final visibility check\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                if not self._too_close(G, target_pos, 0.75 * self.dupe_radius):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                        return cur, True\n                    cur.add_child(nn)\n                    T.append(nn)\n                    nodes.append(nn)\n                    self._grid_add(G, nn)\n                    self._edges_add(edges, cur, nn)\n                    return nn, True\n            return cur, True\n        return cur, False\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(3.5, self.step * 1.6)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Edge bookkeeping\n    def _edges_add(self, edges, parent, child):\n        key = (id(parent), id(child))\n        if key in self._eindex:\n            return\n        edges.append((parent, child))\n        self._eindex[key] = len(edges) - 1\n\n    def _edges_remove(self, edges, parent, child):\n        key = (id(parent), id(child))\n        idx = self._eindex.get(key)\n        if idx is None:\n            return\n        last = len(edges) - 1\n        if idx != last:\n            edges[idx] = edges[last]\n            pk, ck = id(edges[idx][0]), id(edges[idx][1])\n            self._eindex[(pk, ck)] = idx\n        edges.pop()\n        self._eindex.pop(key, None)\n\n    # Path utilities and smoothing\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _elastic_smooth(self, pts, passes):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = list(pts)\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                b = cur[i]\n                c = cur[i + 1]\n                target = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                t = 1.0\n                best = b\n                while t > 1e-3:\n                    cand = tuple(b[k] + (target[k] - b[k]) * t for k in range(self.dim))\n                    cand = self._clamp(cand)\n                    if (not self._point_blocked(cand)) and self._edge_free(a, cand) and self._edge_free(cand, c):\n                        best = cand\n                        break\n                    t *= 0.5\n                if best != b:\n                    cur[i] = best\n                    moved = True\n            if not moved:\n                break\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._shortcut(path, self.shortcut_attempts)\n        p2 = self._visibility_prune(p1)\n        p3 = self._elastic_smooth(p2, self.smooth_passes)\n        return self._dedup(p3)",
          "objective": -47.53913,
          "time_improvement": 86.0,
          "length_improvement": 21.0,
          "smoothness_improvement": 1812.0,
          "node_improvement": 93.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.004579019546508789,
                    "num_nodes_avg": 30.0,
                    "path_length_avg": 146.96078572191126,
                    "smoothness_avg": 0.03859037591406768,
                    "success_improvement": 0.0,
                    "time_improvement": 81.43988774523116,
                    "node_improvement": 92.44522790229162,
                    "length_improvement": 19.448464603147585,
                    "smoothness_improvement": 504.0231833977275,
                    "objective_score": 38.621161002446534
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023305273056030272,
                    "num_nodes_avg": 122.0,
                    "path_length_avg": 229.66193713526982,
                    "smoothness_avg": 0.11885248032537557,
                    "success_improvement": 0.0,
                    "time_improvement": 86.065738755588,
                    "node_improvement": 91.80272794463482,
                    "length_improvement": 23.332234931912975,
                    "smoothness_improvement": 2958.1599247532718,
                    "objective_score": 54.609862209590545
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.004154682159423828,
                    "num_nodes_avg": 32.0,
                    "path_length_avg": 120.49632735979439,
                    "smoothness_avg": 0.1630888303105967,
                    "success_improvement": 0.0,
                    "time_improvement": 91.76911192279043,
                    "node_improvement": 95.93134138588684,
                    "length_improvement": 19.972076786142434,
                    "smoothness_improvement": 1974.4778835855395,
                    "objective_score": 49.38636906645029
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "MINI-Connect BiRRT+: A compact bidirectional RRT-Connect with informed bias, duplicate suppression, obstacle binning, and safe corner smoothing. It emphasizes fast, robust planning with competitive path length and high smoothness through a simple expansion core and lightweight post-processing.",
          "planning_mechanism": "Planning mechanism: Alternate single-step growth from start/goal trees toward a biased target; validate both node and edge before insertion. After each accepted step, greedily connect the opposite tree with repeated steps toward the new point. On meeting, assemble and refine the path via visibility pruning, randomized shortcuts, and collision-aware corner smoothing. An incumbent path, updated opportunistically by cross-tree visibility, enables informed sampling.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=8.0,\n        goal_bias=0.25,\n        corridor_bias=0.25,\n        informed_bias=0.50,\n        grid_cell_factor=2.0,\n        dup_factor=0.5,\n        shortcut_trials=120,\n        smooth_passes=3\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dup_factor = float(dup_factor)\n        self.shortcut_trials = int(max(0, shortcut_trials))\n        self.smooth_passes = int(max(0, smooth_passes))\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if getattr(map, \"obstacles\", None) else []\n\n        nodes = []\n        edges = []\n        self._nodes = nodes\n        self._edges = edges\n\n        # Validate endpoints\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight-line solution\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Derived params\n        self.node_cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_radius = max(0.4, self.step * self.dup_factor)\n        self.corridor_w = max(self.step, 0.15 * self._dist(self.start, self.goal))\n\n        # Trees and node grids\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, a_root)\n        self._grid_add(Gb, b_root)\n        nodes.extend([a_root, b_root])\n\n        best_path = None\n        best_len = None\n\n        for it in range(self.max_iter):\n            grow_a = (it & 1) == 0\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            attractor = self.goal if grow_a else self.start\n\n            target = self._sample_target(attractor, best_len)\n            if target is None:\n                continue\n\n            # Extend one step from nearest towards target\n            base = self._nearest(G, target, T)\n            if base is None:\n                continue\n            new_node = self._extend_from(base, target, T, G)\n            if new_node is None:\n                continue\n\n            # Opportunistic incumbent update via direct cross-tree visibility\n            other = self._nearest(Gopp, new_node.position, Topp)\n            if other is not None and self._edge_free(new_node.position, other.position):\n                cand = self._assemble(new_node, other, grow_a)\n                L = self._path_len(cand)\n                if best_len is None or L < best_len:\n                    best_len = L\n                    best_path = cand\n\n            # Try greedy connect from opposite tree towards the new node\n            meet = self._connect_towards(Topp, Gopp, new_node.position)\n            if meet is not None and meet.position == new_node.position:\n                raw = self._assemble(new_node, meet, grow_a)\n                path = self._postprocess(raw)\n                return PlannerResult(True, path, Ta + Tb, edges)\n\n        # Fallback to best found\n        if best_path is not None:\n            path = self._postprocess(best_path)\n            return PlannerResult(True, path, Ta + Tb, edges)\n\n        return PlannerResult(False, [], Ta + Tb, edges)\n\n    # ---------- RNG ----------\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            s ^= (int((v + 0.5) * 977) + 41) & 0xffffffff\n            s = (s * 1664525 + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) + 17) * 1103515245 & 0xffffffff\n        self._rng = s if s != 0 else 2463534242\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # ---------- Node spatial hashing ----------\n    def _cell_key(self, p):\n        return tuple(int(p[i] // self.node_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_query(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        span = int(radius // self.node_cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.dim == 3:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _nearest(self, grid, pos, tree):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        # expand ring up to radius 3\n        for r in range(0, 4):\n            cand = []\n            if self.dim == 3:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                            if lst:\n                                cand.extend(lst)\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy))\n                        if lst:\n                            cand.extend(lst)\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                if best is not None:\n                    return best\n        # fallback light scan\n        if not tree:\n            return None\n        step = max(1, len(tree) // 64)\n        for i in range(0, len(tree), step):\n            n = tree[i]\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        return best\n\n    def _has_duplicate(self, grid, pos, radius):\n        return len(self._grid_query(grid, pos, radius)) > 0\n\n    # ---------- Obstacles & collision ----------\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self.dim == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            self._obin_add((i, j, k), idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        self._obin_add((i, j), idx)\n\n    def _obin_add(self, key, idx):\n        lst = self.obin.get(key)\n        if lst is None:\n            self.obin[key] = [idx]\n        else:\n            lst.append(idx)\n\n    def _bucket_candidates(self, a, b):\n        if self.dim == 3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self.obin.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            return cand\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self.obin.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            return cand\n\n    def _point_blocked(self, p):\n        if self.dim == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            lst = self.obin.get((ix, iy, iz))\n            if not lst:\n                return False\n            x, y, z = p\n            for idx in lst:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            lst = self.obin.get((ix, iy))\n            if not lst:\n                return False\n            x, y = p\n            for idx in lst:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            q = p1[i]\n            d = q - p\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _edge_free(self, a, b):\n        cand = self._bucket_candidates(a, b)\n        if not cand:\n            return True\n        if self.dim == 3:\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    # ---------- Expansion ----------\n    def _extend_from(self, base, target, tree, grid):\n        newp = self._steer(base.position, target, self.step)\n        if newp == base.position:\n            return None\n        if (not self._in_bounds(newp)) or self._point_blocked(newp):\n            return None\n        if not self._edge_free(base.position, newp):\n            return None\n        if self._has_duplicate(grid, newp, self.dup_radius):\n            return None\n        nn = Node(newp, base, base.cost + self._dist(base.position, newp))\n        base.add_child(nn)\n        tree.append(nn)\n        self._nodes.append(nn)\n        self._edges.append((base, nn))\n        self._grid_add(grid, nn)\n        return nn\n\n    def _connect_towards(self, tree, grid, target_point):\n        # Greedy multiple steps toward target; returns last added node, or None if blocked immediately.\n        base = self._nearest(grid, target_point, tree)\n        if base is None:\n            return None\n        last = None\n        cap = 64\n        while cap > 0:\n            cap -= 1\n            nxt = self._extend_from(base, target_point, tree, grid)\n            if nxt is None:\n                break\n            last = nxt\n            base = nxt\n            if nxt.position == target_point:\n                return nxt\n            # If we are very close and can snap exactly\n            if self._dist(nxt.position, target_point) <= self.step and self._edge_free(nxt.position, target_point):\n                # Snap: ensure point-valid and no duplicate\n                tp = target_point\n                if (not self._point_blocked(tp)) and (not self._has_duplicate(grid, tp, self.dup_radius)):\n                    snap = Node(tp, nxt, nxt.cost + self._dist(nxt.position, tp))\n                    nxt.add_child(snap)\n                    tree.append(snap)\n                    self._nodes.append(snap)\n                    self._edges.append((nxt, snap))\n                    self._grid_add(grid, snap)\n                    return snap\n                else:\n                    # cannot snap; stop\n                    break\n        return last\n\n    # ---------- Sampling ----------\n    def _sample_target(self, attractor, best_len):\n        tries = 18\n        while tries > 0:\n            tries -= 1\n            r = self._rand()\n            p = None\n            if best_len is not None and r < self.informed_bias:\n                p = self._sample_informed(best_len * 1.02)\n            if p is None:\n                r2 = self._rand()\n                if r2 < self.goal_bias:\n                    p = attractor\n                elif r2 < self.goal_bias + self.corridor_bias:\n                    t = self._rand()\n                    base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n                    if self.dim == 3:\n                        p = (self._rand_range(base[0] - self.corridor_w, base[0] + self.corridor_w),\n                             self._rand_range(base[1] - self.corridor_w, base[1] + self.corridor_w),\n                             self._rand_range(base[2] - self.corridor_w, base[2] + self.corridor_w))\n                    else:\n                        p = (self._rand_range(base[0] - self.corridor_w, base[0] + self.corridor_w),\n                             self._rand_range(base[1] - self.corridor_w, base[1] + self.corridor_w))\n                else:\n                    if self.dim == 3:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]),\n                             self._rand_range(0.0, self.bounds[2]))\n                    else:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]))\n            if p is None:\n                continue\n            p = self._clamp(p)\n            if not self._point_blocked(p):\n                return p\n        return None\n\n    def _sample_informed(self, max_sum):\n        c = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        for _ in range(24):\n            if self.dim == 3:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half),\n                     self._rand_range(c[2] - half, c[2] + half))\n            else:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half))\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= max_sum + 1e-9:\n                return p\n        return None\n\n    # ---------- Path assembly and postprocess ----------\n    def _trace(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _assemble(self, u, v, a_side):\n        pu = self._trace(u)\n        pv = self._trace(v)\n        if a_side:\n            # start->u + v->goal reversed\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        out[0] = pts[0]\n        out[-1] = pts[-1]\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3 or attempts <= 0:\n            return pts[:]\n        cur = list(pts)\n        best = self._path_len(cur)\n        stall = 0\n        for _ in range(attempts):\n            if len(cur) < 3:\n                break\n            i = int(self._rand_range(0, len(cur) - 2))\n            j = int(self._rand_range(i + 2, len(cur)))\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    cur = cand\n                    best = L\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            if stall > 64:\n                break\n        return cur\n\n    def _smooth_corners(self, pts, passes):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = list(pts)\n        for _ in range(passes):\n            k = 1\n            while k < len(cur) - 1:\n                a = cur[k - 1]\n                b = cur[k]\n                c = cur[k + 1]\n                # Weighted corner pull\n                newp = tuple(0.25 * a[i] + 0.5 * b[i] + 0.25 * c[i] for i in range(self.dim))\n                if (not self._point_blocked(newp)) and self._edge_free(a, newp) and self._edge_free(newp, c):\n                    cur[k] = newp\n                k += 1\n        cur[0] = pts[0]\n        cur[-1] = pts[-1]\n        return cur\n\n    def _postprocess(self, path):\n        p0 = self._visibility_prune(path)\n        p1 = self._shortcut(p0, self.shortcut_trials)\n        p2 = self._smooth_corners(p1, self.smooth_passes)\n        return p2",
          "objective": -42.99999,
          "time_improvement": 72.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 2430.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014277505874633788,
                    "num_nodes_avg": 76.0,
                    "path_length_avg": 167.21355485066445,
                    "smoothness_avg": 0.04013469633201503,
                    "success_improvement": 0.0,
                    "time_improvement": 42.1290717238007,
                    "node_improvement": 80.86124401913875,
                    "length_improvement": 8.347600918014143,
                    "smoothness_improvement": 528.1951514840665,
                    "objective_score": 20.288257825369026
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022111225128173827,
                    "num_nodes_avg": 121.0,
                    "path_length_avg": 242.3049263601756,
                    "smoothness_avg": 0.1876430362390729,
                    "success_improvement": 0.0,
                    "time_improvement": 86.77966198339568,
                    "node_improvement": 91.869918699187,
                    "length_improvement": 19.111641220372025,
                    "smoothness_improvement": 4728.1904762473905,
                    "objective_score": 61.14183570847888
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.007026815414428711,
                    "num_nodes_avg": 81.0,
                    "path_length_avg": 121.51158192729731,
                    "smoothness_avg": 0.167728285331934,
                    "success_improvement": 0.0,
                    "time_improvement": 86.07909606654616,
                    "node_improvement": 89.70120788302607,
                    "length_improvement": 19.297793043634346,
                    "smoothness_improvement": 2033.4914090080024,
                    "objective_score": 47.569861691184464
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "BiCon-Lite*: Simplified Bi-directional RRT-Connect with local best-parent and light rewiring. It grows two trees from start and goal using uniform sampling with small goal bias and informed sampling once a path bound is known. Each added node is chosen from a few nearest candidates by lowest path cost if the edge is collision-free; after insertion, nearby nodes can be rewired if cheaper. Trees greedily connect toward each other; upon connection, the path is visibility-pruned and shortcut for length and smoothness.",
          "planning_mechanism": "Alternate expanding start/goal trees. For each iteration: sample a target (uniform, goal-biased, or informed ellipse), steer one step from the nearest node, reject if outside/duplicate/colliding, then pick a best feasible parent among k-nearest to insert. Lightly rewire nearby neighbors if the new route is cheaper (cycle-safe). Attempt a greedy connect from the opposite tree toward the new node by incremental steps; if it reaches within one step and the final edge is free, extract the full path (start-to-A, cross-edge, B-to-goal), then prune and shortcut. Always check node and edge collisions before adding any node or edge.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n\n    def attach(self, new_parent):\n        if new_parent is self.parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            if self not in new_parent.children:\n                new_parent.children.append(self)\n\n    def is_ancestor_of(self, other):\n        cur = other\n        while cur is not None:\n            if cur is self:\n                return True\n            cur = cur.parent\n        return False\n\n    def propagate_cost(self, delta):\n        if delta == 0.0:\n            return\n        self.cost += delta\n        for c in self.children:\n            c.propagate_cost(delta)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=10.0,\n        goal_bias=0.1,\n        informed_bias=0.5,\n        dupe_radius_ratio=0.5,\n        neighbor_radius_factor=2.5,\n        k_near=5,\n        shortcut_attempts=80\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.neighbor_radius_factor = float(neighbor_radius_factor)\n        self.k_near = int(k_near)\n        self.shortcut_attempts = int(shortcut_attempts)\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obstacle(self.start) or self._point_in_obstacle(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        self._seed_rng()\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.neighbor_radius = max(self.step_size * 1.5, self.step_size * self.neighbor_radius_factor)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            edges = [(n0, n1)]\n            return PlannerResult(True, self._finalize_path([self.start, self.goal]), [n0, n1], edges)\n\n        nodes = []\n        edges = []\n\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        A = [a_root]\n        B = [b_root]\n\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            grow_A = (it % 2 == 0)\n            T = A if grow_A else B\n            O = B if grow_A else A\n            attractor = self.goal if grow_A else self.start\n\n            qrand = self._sample(attractor, best_len)\n            if qrand is None:\n                continue\n\n            qnear = self._nearest_in(T, qrand)\n            if qnear is None:\n                continue\n\n            qnew_pos = self._steer(qnear.position, qrand)\n            if not self._in_bounds(qnew_pos):\n                continue\n            if self._point_in_obstacle(qnew_pos):\n                continue\n            if self._has_near_in(T, qnew_pos, self.dupe_radius):\n                continue\n\n            parent = self._best_parent(T, qnew_pos, qnear)\n            if parent is None:\n                continue\n            if not self._edge_free(parent.position, qnew_pos):\n                continue\n\n            qnew_cost = parent.cost + self._dist(parent.position, qnew_pos)\n            qnew = Node(qnew_pos, parent, qnew_cost)\n            T.append(qnew)\n            nodes.append(qnew)\n            edges.append((parent, qnew))\n\n            self._light_rewire(T, qnew, edges)\n\n            ok, last_other, added = self._connect_toward(O, qnew.position, nodes, edges)\n            if ok and last_other is not None:\n                edges.append((last_other, qnew))\n                path = self._extract_path(qnew, last_other)\n                best_len = self._path_len(path)\n                return PlannerResult(True, self._finalize_path(path), nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0xA5A5A5A5\n        for v in self.start + self.goal:\n            s ^= (int(v * 1315423911) + (s << 7) + (s >> 3)) & 0xffffffff\n            s &= 0xffffffff\n        s ^= (len(self.obstacles) * 0x9E3779B9) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            tgt = a\n        elif d <= self.step_size:\n            tgt = b\n        else:\n            r = self.step_size / d\n            tgt = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n        out = tuple(max(0.0, min(tgt[i], self.bounds[i])) for i in range(self.dims))\n        return out\n\n    # Nearest and neighbors\n    def _nearest_in(self, nodes_list, pos):\n        best = None\n        bd = 1e100\n        for n in nodes_list:\n            d = self._dist(n.position, pos)\n            if d < bd:\n                bd = d\n                best = n\n        return best\n\n    def _k_nearest_in(self, nodes_list, pos, k):\n        if not nodes_list:\n            return []\n        pairs = []\n        for n in nodes_list:\n            pairs.append((self._dist(n.position, pos), n))\n        pairs.sort(key=lambda x: x[0])\n        out = [n for _, n in pairs[:max(1, k)]]\n        return out\n\n    def _neighbors_radius(self, nodes_list, pos, radius):\n        out = []\n        r = float(radius)\n        for n in nodes_list:\n            if self._dist(n.position, pos) <= r:\n                out.append(n)\n        return out\n\n    def _has_near_in(self, nodes_list, pos, radius):\n        r = float(radius)\n        for n in nodes_list:\n            if self._dist(n.position, pos) <= r:\n                return True\n        return False\n\n    # Parent selection\n    def _best_parent(self, nodes_list, qpos, fallback):\n        cands = self._k_nearest_in(nodes_list, qpos, self.k_near)\n        if fallback not in cands:\n            cands.append(fallback)\n        best = None\n        best_cost = 1e100\n        for p in cands:\n            if not self._edge_free(p.position, qpos):\n                continue\n            c = p.cost + self._dist(p.position, qpos)\n            if c < best_cost:\n                best_cost = c\n                best = p\n        return best\n\n    # Light rewiring\n    def _light_rewire(self, nodes_list, qnew, edges):\n        nbrs = self._neighbors_radius(nodes_list, qnew.position, self.neighbor_radius)\n        rewired = 0\n        for w in nbrs:\n            if w is qnew or w is qnew.parent:\n                continue\n            if w.is_ancestor_of(qnew):\n                continue\n            d = self._dist(qnew.position, w.position)\n            cand_cost = qnew.cost + d\n            if cand_cost + 1e-12 < w.cost and self._edge_free(qnew.position, w.position):\n                oldp = w.parent\n                self._replace_edge(edges, oldp, w, qnew)\n                w.attach(qnew)\n                delta = cand_cost - w.cost\n                w.propagate_cost(delta)\n                rewired += 1\n                if rewired >= 10:\n                    break\n\n    # Connect toward a target (other tree growth)\n    def _connect_toward(self, tree_nodes, target_pos, all_nodes, edges):\n        if not tree_nodes:\n            return False, None, []\n        cur = self._nearest_in(tree_nodes, target_pos)\n        added = []\n        for _ in range(1000):\n            nxt = self._steer(cur.position, target_pos)\n            if self._dist(cur.position, nxt) <= 1e-9:\n                break\n            if not self._in_bounds(nxt):\n                break\n            if self._point_in_obstacle(nxt):\n                break\n            if self._has_near_in(tree_nodes, nxt, self.dupe_radius):\n                # If very close to some node, snap to the nearest and continue\n                cur = self._nearest_in(tree_nodes, nxt)\n                if self._dist(cur.position, target_pos) <= self.step_size and self._edge_free(cur.position, target_pos):\n                    return True, cur, added\n                continue\n            if not self._edge_free(cur.position, nxt):\n                break\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            q = Node(nxt, cur, new_cost)\n            tree_nodes.append(q)\n            all_nodes.append(q)\n            edges.append((cur, q))\n            added.append(q)\n            cur = q\n            if self._dist(cur.position, target_pos) <= self.step_size and self._edge_free(cur.position, target_pos):\n                return True, cur, added\n        return False, cur, added\n\n    # Collision\n    def _point_in_obstacle(self, p):\n        if self.is3d:\n            px, py, pz = p\n            for x, y, z, w, h, d in self.obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            px, py = p\n            for x, y, w, h in self.obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        if self.is3d:\n            for x, y, z, w, h, d in self.obstacles:\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return False\n            return True\n        else:\n            for x, y, w, h in self.obstacles:\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return False\n            return True\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Edges\n    def _replace_edge(self, edges, old_parent, child, new_parent):\n        if old_parent is not None:\n            rm = -1\n            for i, (u, v) in enumerate(edges):\n                if u is old_parent and v is child:\n                    rm = i\n                    break\n            if rm >= 0:\n                edges.pop(rm)\n        if new_parent is not None:\n            exists = False\n            for u, v in edges:\n                if u is new_parent and v is child:\n                    exists = True\n                    break\n            if not exists:\n                edges.append((new_parent, child))\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        for _ in range(24):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p is not None and not self._point_in_obstacle(p):\n                    return p\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n                if self._in_bounds(p) and not self._point_in_obstacle(p):\n                    return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(16):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._in_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Path ops\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        return pa + pb[::-1]\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(pruned[-1], path[j]):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best_L = self._path_len(pts)\n        tries = 0\n        while tries < attempts and len(pts) > 2:\n            n = len(pts)\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                cand = pts[:i + 1] + pts[j:]\n                L = self._path_len(cand)\n                if L <= best_L + 1e-12:\n                    pts = cand\n                    best_L = L\n            tries += 1\n        return pts\n\n    def _finalize_path(self, path):\n        if not path:\n            return []\n        p = self._visibility_prune(path)\n        p = self._shortcut(p, self.shortcut_attempts)\n        return p",
          "objective": -42.61971,
          "time_improvement": 88.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1715.0,
          "node_improvement": 94.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.005434727668762207,
                    "num_nodes_avg": 33.0,
                    "path_length_avg": 172.03461483544805,
                    "smoothness_avg": 0.051447969062332066,
                    "success_improvement": 0.0,
                    "time_improvement": 77.97145118473429,
                    "node_improvement": 91.68975069252078,
                    "length_improvement": 5.705101545770078,
                    "smoothness_improvement": 705.2724368784732,
                    "objective_score": 30.3408584672747
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.012911844253540038,
                    "num_nodes_avg": 78.0,
                    "path_length_avg": 254.30361579440722,
                    "smoothness_avg": 0.12651907716440625,
                    "success_improvement": 0.0,
                    "time_improvement": 92.27998699936137,
                    "node_improvement": 94.75912114493046,
                    "length_improvement": 15.106133324099327,
                    "smoothness_improvement": 3155.4269834480324,
                    "objective_score": 52.52481101150817
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0025941610336303713,
                    "num_nodes_avg": 30.0,
                    "path_length_avg": 125.19016890049133,
                    "smoothness_avg": 0.10884440067125287,
                    "success_improvement": 0.0,
                    "time_improvement": 94.86067807289716,
                    "node_improvement": 96.18563254926892,
                    "length_improvement": 16.854650731526867,
                    "smoothness_improvement": 1284.492742480391,
                    "objective_score": 44.99345757318722
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "ZIP-Connect: a zero-idle, proximity-gated bi-directional RRT-Connect that accelerates planning by accept-on-Halton sampling, micro-grid nearest queries, and intermittent meeting attempts. It reduces collision checks by only trying goal/opposite-tree connections when geometrically near, avoids greedy multi-step linking, enforces duplicate spacing, and performs a single-pass visibility prune with a tiny shortcut budget.",
          "planning_mechanism": "Alternate expanding start/goal trees. Per iteration: draw a free sample via goal bias then Halton scanning; find the nearest via a 0\u20131 ring micro-grid; steer one step; if node and edge are free and not too-close, insert. Attempt an exact meeting to the attractor or the opposite tree only when within a small distance window, then stitch through the meeting node. Finalize with a greedy line-of-sight prune and a couple of shortcuts.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=2500,\n        step_size=8.0,\n        goal_bias=0.07,\n        grid_cell_factor=1.0,\n        min_separation_mult=0.5,\n        connect_window_mult=2.5,\n        smooth_shortcuts=2\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.min_sep_mult = float(min_separation_mult)\n        self.conn_mult = float(connect_window_mult)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self._rng = 1\n        self._hidx = 1\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step * self.min_sep_mult)\n        self.conn_win = max(self.step * 1.5, self.step * self.conn_mult)\n\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Quick straight-line test\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize trees and grids\n        root_s = Node(self.start, None, 0.0)\n        root_g = Node(self.goal, None, 0.0)\n        Ta = [root_s]\n        Tb = [root_g]\n        Ga = {}\n        Gb = {}\n        self._grid_add(Ga, root_s)\n        self._grid_add(Gb, root_g)\n        nodes.extend([root_s, root_g])\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            T_src = Ta if active_start else Tb\n            T_dst = Tb if active_start else Ta\n            G_src = Ga if active_start else Gb\n            G_dst = Gb if active_start else Ga\n            attractor = self.goal if active_start else self.start\n            other_root = root_g if active_start else root_s\n\n            q_rand = self._sample_free(attractor)\n            if q_rand is None:\n                continue\n\n            n_near = self._nearest(G_src, q_rand, T_src)\n            if n_near is None:\n                continue\n\n            q_new = self._steer(n_near.position, q_rand, self.step)\n            if (not self._in_bounds(q_new)) or self._point_in_obstacles(q_new):\n                continue\n            if self._too_close(G_src, q_new, self.min_sep):\n                continue\n            if not self._edge_free(n_near.position, q_new):\n                continue\n\n            nn = self._insert_node(T_src, G_src, n_near, q_new, nodes, edges)\n            if nn is None:\n                continue\n\n            # Opportunistic direct connect to attractor (goal/start) only when near\n            d_att = self._dist(nn.position, attractor)\n            if d_att <= self.conn_win and self._edge_free(nn.position, attractor):\n                meet = self._insert_node(T_src, G_src, nn, attractor, nodes, edges)\n                if meet is not None:\n                    if active_start:\n                        pa = self._trace_to_root(meet)\n                        pb = self._trace_to_root(root_g)\n                    else:\n                        pa = self._trace_to_root(root_s)\n                        pb = self._trace_to_root(meet)\n                    # Stitch via exact meeting at attractor\n                    path = pa if active_start else pb\n                    path = self._finalize_path(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n            # Intermittent opposite-tree meeting when close\n            n_other = self._nearest(G_dst, nn.position, T_dst)\n            if n_other is not None:\n                d_opp = self._dist(nn.position, n_other.position)\n                if d_opp <= self.conn_win and self._edge_free(n_other.position, nn.position):\n                    # Prefer inserting an exact meeting into the opposite tree if allowable\n                    if (not self._too_close(G_dst, nn.position, self.min_sep)) and (not self._point_in_obstacles(nn.position)):\n                        meetB = self._insert_node(T_dst, G_dst, n_other, nn.position, nodes, edges)\n                    else:\n                        meetB = n_other\n                    if meetB is not None:\n                        if active_start:\n                            pa = self._trace_to_root(nn)\n                            pb = self._trace_to_root(meetB)\n                            path = pa + pb[-2::-1]\n                        else:\n                            pa = self._trace_to_root(meetB)\n                            pb = self._trace_to_root(nn)\n                            path = pa + pb[-2::-1]\n                        path = self._finalize_path(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG and Halton\n    def _seed_rng(self):\n        s = 0xA17E5EED\n        for v in self.start + self.goal:\n            iv = int(v * 1315423911) & 0xffffffff\n            s ^= (iv * 1103515245 + 12345) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 1\n        self._rng = s & 0xffffffff\n        self._hidx = 1\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _radical_inverse(self, base, i):\n        inv = 1.0 / base\n        f = inv\n        x = 0.0\n        n = i\n        while n > 0:\n            x += (n % base) * f\n            n //= base\n            f *= inv\n        return x\n\n    def _halton_point(self, idx):\n        if self.is3:\n            return (\n                self._radical_inverse(2, idx) * self.bounds[0],\n                self._radical_inverse(3, idx) * self.bounds[1],\n                self._radical_inverse(5, idx) * self.bounds[2],\n            )\n        else:\n            return (\n                self._radical_inverse(2, idx) * self.bounds[0],\n                self._radical_inverse(3, idx) * self.bounds[1],\n            )\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        out = []\n        for i in range(self.dim):\n            out.append(a[i] + (b[i] - a[i]) * r)\n        return self._clamp(tuple(out))\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # Spatial hash\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        else:\n            return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos, T_list):\n        key = self._cell_key(pos)\n        # Micro-ring search for speed; small random fallback\n        for r in (0, 1):\n            cand = self._collect_ring(grid, key, r)\n            if cand:\n                best = None\n                bestd = 1e100\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                return best\n        if not T_list:\n            return None\n        m = min(16, len(T_list))\n        best = None\n        bestd = 1e100\n        for _ in range(m):\n            j = int(self._rand_range(0, len(T_list)))\n            if j >= len(T_list):\n                j = len(T_list) - 1\n            n = T_list[j]\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius, limit=None):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n                                if limit is not None and len(out) >= limit:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n                            if limit is not None and len(out) >= limit:\n                                return out\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors_in_radius(grid, pos, radius, limit=1)) > 0\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            bucket = self.obin.get(key)\n                            if bucket is None:\n                                self.obin[key] = [idx]\n                            else:\n                                bucket.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        bucket = self.obin.get(key)\n                        if bucket is None:\n                            self.obin[key] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Sampling\n    def _sample_free(self, attractor):\n        r = self._rand()\n        if r < self.goal_bias:\n            return attractor\n        # Try a short Halton scan to find a free sample\n        trials = 0\n        idx = self._hidx\n        while trials < 6:\n            p = self._halton_point(idx)\n            idx += 1\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                self._hidx = idx\n                return p\n            trials += 1\n        # Fallback to uniform random attempts\n        tries = 0\n        while tries < 6:\n            if self.is3:\n                p = (\n                    self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]),\n                )\n            else:\n                p = (\n                    self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                )\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n            tries += 1\n        return None\n\n    # Insert node (assumes checks done)\n    def _insert_node(self, tree, grid, parent, pos, nodes, edges):\n        if (not self._in_bounds(pos)) or self._point_in_obstacles(pos):\n            return None\n        if self._too_close(grid, pos, self.min_sep):\n            return None\n        if not self._edge_free(parent.position, pos):\n            return None\n        new_cost = parent.cost + self._dist(parent.position, pos)\n        nn = Node(pos, parent, new_cost)\n        parent.add_child(nn)\n        tree.append(nn)\n        nodes.append(nn)\n        edges.append((parent, nn))\n        self._grid_add(grid, nn)\n        return nn\n\n    # Path utilities\n    def _trace_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        return out[::-1]\n\n    def _prune_visibility(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3 or attempts <= 0:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._prune_visibility(path)\n        p2 = self._shortcut(p1, self.smooth_shortcuts)\n        out = []\n        last = None\n        for p in p2:\n            if (last is None) or (p != last):\n                out.append(p)\n                last = p\n        return out",
          "objective": -42.25413,
          "time_improvement": 82.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1949.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.006530570983886719,
                    "num_nodes_avg": 51.0,
                    "path_length_avg": 165.30934267335007,
                    "smoothness_avg": 0.06354030894209622,
                    "success_improvement": 0.0,
                    "time_improvement": 73.52967609821906,
                    "node_improvement": 87.15688743389575,
                    "length_improvement": 9.391329786573037,
                    "smoothness_improvement": 894.54381493312,
                    "objective_score": 32.16641977607514
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.012840461730957032,
                    "num_nodes_avg": 115.0,
                    "path_length_avg": 229.6388777300784,
                    "smoothness_avg": 0.11761146977996584,
                    "success_improvement": 0.0,
                    "time_improvement": 92.32266672748835,
                    "node_improvement": 92.27306322650003,
                    "length_improvement": 23.33993282509405,
                    "smoothness_improvement": 2926.2278295561136,
                    "objective_score": 56.3318988610835
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010579800605773926,
                    "num_nodes_avg": 124.0,
                    "path_length_avg": 139.48550177732233,
                    "smoothness_avg": 0.1672303632461557,
                    "success_improvement": 0.0,
                    "time_improvement": 79.0402366958931,
                    "node_improvement": 84.23394787031151,
                    "length_improvement": 7.360371305336757,
                    "smoothness_improvement": 2027.1578768296877,
                    "objective_score": 38.26408317611842
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SWIFT-Connect: a lean bidirectional RRT-Connect with spatial hashing and duplicate suppression. It alternates tree growth, validates nodes and edges before commitment, greedily connects to the opposite tree, and exits on the first feasible bridge. Lightweight LOS collapse and shortcutting polish the path. The design trades heavy optimization for fast, robust, generalizable solves.",
          "planning_mechanism": "Alternate expanding start and goal trees. For each goal-biased sample, extend the active tree one validated step, then greedily advance the opposite tree toward it with multi-step connect; on a collision-free join, assemble the path and smooth via LOS and random shortcuts. Nearest lookups use a coarse grid; all samples stay within bounds and all nodes/edges are collision-checked before insertion.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            i = 0\n            while i < len(self.parent.children):\n                if self.parent.children[i] is self:\n                    self.parent.children.pop(i)\n                    break\n                i += 1\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=5.0,\n                 goal_bias=0.3,\n                 cell_factor=1.6,\n                 dupe_radius_ratio=0.4,\n                 smooth_shortcuts=80):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.cell_factor = float(cell_factor)\n        self.dupe_ratio = float(dupe_radius_ratio)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._build_obs_grid()\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        self.cell = max(1.0, self.step * self.cell_factor)\n        self.dupe_radius = max(0.5, self.dupe_ratio * self.step)\n\n        self._nodes = []\n        self._edges = []\n        rootA = Node(self.start, None, 0.0)\n        rootB = Node(self.goal, None, 0.0)\n        self._nodes.append(rootA)\n        self._nodes.append(rootB)\n\n        self._gridA = {}\n        self._gridB = {}\n        self._grid_add(self._gridA, rootA)\n        self._grid_add(self._gridB, rootB)\n\n        for it in range(self.max_iter):\n            use_A = (it % 2 == 0)\n            active_grid = self._gridA if use_A else self._gridB\n            other_grid = self._gridB if use_A else self._gridA\n            attractor = self.goal if use_A else self.start\n\n            target = self._sample_target(attractor)\n            if target is None:\n                continue\n\n            new_node = self._extend_one(active_grid, target)\n            if new_node is None:\n                continue\n\n            q_reached, ok = self._connect_greedy(other_grid, new_node.position)\n            if ok and self._edge_free(q_reached.position, new_node.position):\n                join = Node(new_node.position, q_reached, q_reached.cost + self._dist(q_reached.position, new_node.position))\n                join.attach(q_reached)\n                self._nodes.append(join)\n                self._edges.append((q_reached, join))\n                self._grid_add(other_grid, join)\n\n                if use_A:\n                    path1 = self._trace_to_root(new_node)\n                    path2 = self._trace_to_root(q_reached)\n                    path = path1 + list(reversed(path2))\n                else:\n                    path1 = self._trace_to_root(q_reached)\n                    path2 = self._trace_to_root(new_node)\n                    path = path1 + list(reversed(path2))\n\n                path = self._postprocess(path)\n                return PlannerResult(True, path, self._nodes, self._edges)\n\n        return PlannerResult(False, [], self._nodes, self._edges)\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _same_pos(self, a, b, eps=1e-9):\n        for i in range(self.dims):\n            if abs(a[i] - b[i]) > eps:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    def _build_obs_grid(self):\n        self.obs_cell = max(4.0, self.step * 2.0)\n        self._ogrid = {}\n        if self.is3d:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self._ogrid.get(k)\n                            if b is None:\n                                self._ogrid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self._ogrid.get(k)\n                        if b is None:\n                            self._ogrid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _cell_candidates(self, a, b):\n        if self.is3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            out = []\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        lst = self._ogrid.get((cx, cy, cz))\n                        if lst:\n                            out.extend(lst)\n            return out\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            out = []\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    lst = self._ogrid.get((cx, cy))\n                    if lst:\n                        out.extend(lst)\n            return out\n\n    def _point_blocked(self, p):\n        if self.is3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self._ogrid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            x0, y0, z0 = p\n            i = 0\n            while i < len(bucket):\n                x, y, z, w, h, d = self.obstacles[bucket[i]]\n                if x <= x0 <= x + w and y <= y0 <= y + h and z <= z0 <= z + d:\n                    return True\n                i += 1\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self._ogrid.get((cx, cy))\n            if not bucket:\n                return False\n            x0, y0 = p\n            i = 0\n            while i < len(bucket):\n                x, y, w, h = self.obstacles[bucket[i]]\n                if x <= x0 <= x + w and y <= y0 <= y + h:\n                    return True\n                i += 1\n            return False\n\n    def _seg_aabb_hit(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(self.dims):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _edge_free(self, a, b):\n        cand = self._cell_candidates(a, b)\n        if not cand:\n            return True\n        if self.is3d:\n            i = 0\n            while i < len(cand):\n                x, y, z, w, h, d = self.obstacles[cand[i]]\n                if self._seg_aabb_hit(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return False\n                i += 1\n            return True\n        else:\n            i = 0\n            while i < len(cand):\n                x, y, w, h = self.obstacles[cand[i]]\n                if self._seg_aabb_hit(a, b, (x, y), (x + w, y + h)):\n                    return False\n                i += 1\n            return True\n\n    def _cell_key(self, pos):\n        if self.is3d:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is3d:\n            dx = -r\n            while dx <= r:\n                dy = -r\n                while dy <= r:\n                    dz = -r\n                    while dz <= r:\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n                        dz += 1\n                    dy += 1\n                dx += 1\n        else:\n            dx = -r\n            while dx <= r:\n                dy = -r\n                while dy <= r:\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n                    dy += 1\n                dx += 1\n        return out\n\n    def _nearest(self, grid, pos):\n        k = self._cell_key(pos)\n        best = None\n        bd = 1e100\n        max_r = 2\n        r = 0\n        while r <= max_r:\n            cand = self._grid_ring(grid, k, r)\n            if cand:\n                i = 0\n                while i < len(cand):\n                    n = cand[i]\n                    d = self._dist(n.position, pos)\n                    if d < bd:\n                        bd = d\n                        best = n\n                    i += 1\n                if best is not None:\n                    return best\n            r += 1\n        for b in grid.values():\n            i = 0\n            while i < len(b):\n                n = b[i]\n                d = self._dist(n.position, pos)\n                if d < bd:\n                    bd = d\n                    best = n\n                i += 1\n        return best\n\n    def _has_close(self, grid, pos, radius):\n        k = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell) + 1)\n        lst = self._grid_ring(grid, k, rc)\n        r2 = radius * radius\n        i = 0\n        while i < len(lst):\n            n = lst[i]\n            s = 0.0\n            p = n.position\n            j = 0\n            while j < self.dims:\n                d = p[j] - pos[j]\n                s += d * d\n                j += 1\n            if s <= r2:\n                return True\n            i += 1\n        return False\n\n    def _extend_one(self, grid, target):\n        qnear = self._nearest(grid, target)\n        if qnear is None:\n            return None\n        qpos = self._steer(qnear.position, target, self.step)\n        if self._same_pos(qpos, qnear.position):\n            return None\n        if not self._in_bounds(qpos):\n            return None\n        if self._point_blocked(qpos):\n            return None\n        if not self._edge_free(qnear.position, qpos):\n            return None\n        if self._has_close(grid, qpos, self.dupe_radius):\n            return None\n        new_node = Node(qpos, qnear, qnear.cost + self._dist(qnear.position, qpos))\n        new_node.attach(qnear)\n        self._nodes.append(new_node)\n        self._edges.append((qnear, new_node))\n        self._grid_add(grid, new_node)\n        return new_node\n\n    def _connect_greedy(self, grid, target_pos):\n        qnear = self._nearest(grid, target_pos)\n        if qnear is None:\n            return None, False\n        cur = qnear\n        max_steps = max(1, int(self._dist(qnear.position, target_pos) / max(1e-9, self.step)) + 2)\n        if max_steps > 64:\n            max_steps = 64\n        steps = 0\n        while steps < max_steps:\n            if self._dist(cur.position, target_pos) <= self.step and self._edge_free(cur.position, target_pos):\n                return cur, True\n            qpos = self._steer(cur.position, target_pos, self.step)\n            if self._same_pos(qpos, cur.position):\n                break\n            if not self._in_bounds(qpos):\n                break\n            if self._point_blocked(qpos):\n                break\n            if not self._edge_free(cur.position, qpos):\n                break\n            if self._has_close(grid, qpos, self.dupe_radius):\n                break\n            nxt = Node(qpos, cur, cur.cost + self._dist(cur.position, qpos))\n            nxt.attach(cur)\n            self._nodes.append(nxt)\n            self._edges.append((cur, nxt))\n            self._grid_add(grid, nxt)\n            cur = nxt\n            steps += 1\n        return cur, False\n\n    def _sample_target(self, attractor):\n        if self._rand() < self.goal_bias:\n            return attractor\n        return self._random_free()\n\n    def _random_free(self):\n        tries = 64\n        while tries > 0:\n            tries -= 1\n            if self.is3d:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n            else:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n            if not self._point_blocked(p):\n                return p\n        return None\n\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        s = 0.0\n        i = 1\n        while i < len(path):\n            s += self._dist(path[i - 1], path[i])\n            i += 1\n        return s\n\n    def _los_collapse(self, path, rounds=3):\n        if len(path) < 3:\n            return path[:]\n        cur = path[:]\n        r = 0\n        while r < rounds:\n            out = [cur[0]]\n            anchor = cur[0]\n            i = 1\n            while i < len(cur) - 1:\n                if self._edge_free(anchor, cur[i + 1]):\n                    i += 1\n                    continue\n                out.append(cur[i])\n                anchor = cur[i]\n                i += 1\n            out.append(cur[-1])\n            if len(out) == len(cur):\n                break\n            cur = out\n            r += 1\n        return cur\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = path[:]\n        best = self._path_len(pts)\n        t = 0\n        while t < attempts and len(pts) >= 3:\n            n = len(pts)\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j > n - 1:\n                t += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                cand = pts[:i + 1] + pts[j:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    pts = cand\n                    best = L\n            t += 1\n        return pts\n\n    def _postprocess(self, path):\n        p = path[:]\n        p = self._los_collapse(p, rounds=3)\n        p = self._shortcut(p, self.smooth_shortcuts)\n        p = self._los_collapse(p, rounds=2)\n        return p",
          "objective": -41.85803,
          "time_improvement": 74.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1880.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007715272903442383,
                    "num_nodes_avg": 73.0,
                    "path_length_avg": 160.85834898192107,
                    "smoothness_avg": 0.04902467731266237,
                    "success_improvement": 0.0,
                    "time_improvement": 68.72773096737596,
                    "node_improvement": 81.6167212289096,
                    "length_improvement": 11.83098995935377,
                    "smoothness_improvement": 667.3426587338824,
                    "objective_score": 31.05362655949446
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025490784645080568,
                    "num_nodes_avg": 183.3,
                    "path_length_avg": 234.9419709193859,
                    "smoothness_avg": 0.12316192274741442,
                    "success_improvement": 0.0,
                    "time_improvement": 84.75901776753946,
                    "node_improvement": 87.68393469058657,
                    "length_improvement": 21.56960767742916,
                    "smoothness_improvement": 3069.0449822382448,
                    "objective_score": 53.71469484791056
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.015743160247802736,
                    "num_nodes_avg": 173.6,
                    "path_length_avg": 123.84164743815386,
                    "smoothness_avg": 0.15742682886839948,
                    "success_improvement": 0.0,
                    "time_improvement": 68.81104618621191,
                    "node_improvement": 77.92752701843611,
                    "length_improvement": 17.75027447711989,
                    "smoothness_improvement": 1902.4576431662642,
                    "objective_score": 40.80576675796682
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "NOVA-BRRT*: A bidirectional RRT*-Connect variant with dual spatial hashes, exact-bridge meeting, density-aware duplicate control, and lazy local rewiring. It uses obstacle binning and slab-segment tests for fast collision checks, selects best-cost parents within an adaptive radius, rewires cheaper neighbors, and connects greedily from the opposite tree with insertion of the exact meeting node for kink-free junctions. After a connection, a compact visibility prune + guided shortcut + midpoint relaxation yields smooth, short paths with minimal overhead.",
          "planning_mechanism": "Alternate growing start/goal trees. Each iteration: biased/informed sample (goal/corridor/ellipse), find a near node via grid, steer one step, choose the best parent among neighbors and verify node+edge, add and locally rewire. Greedily extend the other tree toward the new node; if visibility holds, insert the exact meeting node. On connection, assemble a continuous path (no duplicate junction), visibility-prune, shortcut, midpoint-smooth, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        pts = []\n        cur = self\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5500,\n        step_size=6.0,\n        connect_mult=2.0,\n        grid_cell_factor=1.4,\n        goal_bias=0.10,\n        corridor_bias=0.25,\n        rewire_factor=2.4,\n        smooth_shortcuts=90\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_step = float(connect_mult) * self.step\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.rewire_factor = float(rewire_factor)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self._rng = 123456789\n\n    def plan(self, map):\n        # Scene\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n        self._edges_set = {}\n\n        # Basic validation\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Seed RNG and structures\n        self._seed_from_scene()\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_radius = max(0.5, 0.35 * self.step)\n        self.rewire_base = max(1.2 * self.step, self.rewire_factor * self.step)\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        # Corridor width for biased sampling\n        sg = self._dist(self.start, self.goal)\n        corridor_w = max(self.step, 0.18 * sg)\n        best_len = None  # enable informed sampling after first solution\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            Ta = tree_a if active_start else tree_b\n            Tb = tree_b if active_start else tree_a\n            Ga = grid_a if active_start else grid_b\n            Gb = grid_b if active_start else grid_a\n            attract = self.goal if active_start else self.start\n\n            # Sample target\n            target = self._sample_target(attract, best_len, corridor_w)\n            if target is None:\n                continue\n\n            na = self._nearest(Ga, target)\n            if na is None:\n                continue\n\n            newp = self._steer(na.position, target, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            # Density-aware duplicate suppression\n            if self._too_close(Ga, newp, self._adaptive_dup_radius(Ga, newp)):\n                continue\n\n            # Choose best parent within adaptive radius\n            rew_rad = self._adaptive_rewire_radius(len(Ta))\n            parent, new_cost = self._choose_parent(Ga, newp, na, rew_rad)\n            # Strict checks before commit\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, new_cost)\n            parent.add_child(nn)\n            Ta.append(nn)\n            nodes.append(nn)\n            self._add_edge(edges, parent, nn)\n            self._grid_add(Ga, nn)\n\n            # Local rewiring\n            self._local_rewire(Ga, nn, rew_rad, edges)\n\n            # Try to connect from the other tree\n            meet_node, reached = self._connect_toward(Tb, Gb, nn.position, nodes, edges)\n            if not reached:\n                continue\n\n            # Build final path without duplicate junction\n            if active_start:\n                pa = self._trace_to_root(nn)         # start -> ... -> nn\n                pb = self._trace_to_root(meet_node)  # goal  -> ... -> nn\n                path = pa + pb[-2::-1]\n            else:\n                pa = self._trace_to_root(meet_node)  # start -> ... -> nn\n                pb = self._trace_to_root(nn)         # goal  -> ... -> nn\n                path = pa + pb[-2::-1]\n\n            # Smoothing\n            path = self._visibility_prune(path)\n            path = self._shortcut(path, self.smooth_shortcuts)\n            path = self._midpoint_relax(path, iters=6)\n\n            return PlannerResult(True, self._dedup(path), nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG utilities\n    def _seed_from_scene(self):\n        s = 0x9E3779B9 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= (q ^ (q >> 13) ^ ((q << 7) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 29) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_pt(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp_pt(a)\n        if d2 <= step * step:\n            return self._clamp_pt(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp_pt(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial hash for nodes\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found_any = False\n        for r in range(0, 4):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found_any = True\n            if found_any:\n                return best\n        # fallback\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors_in_radius(grid, pos, radius)) > 0\n\n    # Obstacles: binning and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.2)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        # Slab method\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Sampling\n    def _sample_target(self, attract, best_len, corridor_w):\n        r = self._rand()\n        # Informed ellipse after first solution\n        if best_len is not None and r < 0.60:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        # Goal bias\n        if r < self.goal_bias:\n            if self._in_bounds(attract) and (not self._point_in_obstacles(attract)):\n                return attract\n        # Corridor-biased\n        if r < self.goal_bias + self.corridor_bias:\n            t = self._rand()\n            base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n            if self.is3:\n                p = (\n                    self._clamp(base[0] + self._rand_range(-corridor_w, corridor_w), 0.0, self.bounds[0]),\n                    self._clamp(base[1] + self._rand_range(-corridor_w, corridor_w), 0.0, self.bounds[1]),\n                    self._clamp(base[2] + self._rand_range(-corridor_w, corridor_w), 0.0, self.bounds[2]),\n                )\n            else:\n                p = (\n                    self._clamp(base[0] + self._rand_range(-corridor_w, corridor_w), 0.0, self.bounds[0]),\n                    self._clamp(base[1] + self._rand_range(-corridor_w, corridor_w), 0.0, self.bounds[1]),\n                )\n            if (not self._point_in_obstacles(p)) and self._in_bounds(p):\n                return p\n        # Uniform\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _clamp(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(28):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Parenting and rewiring\n    def _choose_parent(self, grid, newp, fallback, radius):\n        parent = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        neigh = self._neighbors_in_radius(grid, newp, radius)\n        for n in neigh:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                parent = n\n                best_cost = c\n        return parent, best_cost\n\n    def _local_rewire(self, grid, nn, radius, edges):\n        neigh = self._neighbors_in_radius(grid, nn.position, radius)\n        for nb in neigh:\n            if nb is nn or nb is nn.parent:\n                continue\n            cand = nn.cost + self._dist(nn.position, nb.position)\n            if cand + 1e-12 < nb.cost and self._edge_free(nn.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, oldp, nb)\n                nn.add_child(nb)\n                nb.cost = cand\n                self._add_edge(edges, nn, nb)\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    # Connect from other tree toward target, optionally inserting exact meeting node\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        # First, try direct visibility to exact meeting\n        if self._edge_free(cur.position, target_pos):\n            if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    # Strict checks already done above\n                    cur.add_child(nn)\n                    tree.append(nn)\n                    nodes.append(nn)\n                    self._add_edge(edges, cur, nn)\n                    self._grid_add(grid, nn)\n                    return nn, True\n            return cur, True  # meet at current if too close to insert node\n\n        # Greedy stepwise connect\n        while steps < 48:\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if self._too_close(grid, nxt, self.dup_radius * 0.75):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            self._add_edge(edges, cur, nn)\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n            if self._edge_free(cur.position, target_pos):\n                if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                    if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        mn = Node(target_pos, cur, new_cost)\n                        cur.add_child(mn)\n                        tree.append(mn)\n                        nodes.append(mn)\n                        self._add_edge(edges, cur, mn)\n                        self._grid_add(grid, mn)\n                        return mn, True\n                return cur, True\n        return cur, False\n\n    # Path helpers\n    def _trace_to_root(self, node):\n        return node.path_from_root()\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _midpoint_relax(self, pts, iters=6):\n        if len(pts) < 3 or iters <= 0:\n            return pts[:]\n        out = pts[:]\n        for _ in range(iters):\n            changed = False\n            for i in range(1, len(out) - 1):\n                a = out[i - 1]\n                c = out[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                if self._point_in_obstacles(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if mid != out[i]:\n                        out[i] = mid\n                        changed = True\n            if not changed:\n                break\n        return out\n\n    # Adaptive radii\n    def _adaptive_rewire_radius(self, n_nodes):\n        decay = pow(0.5, n_nodes / 3000.0)\n        return max(1.2 * self.step, self.rewire_base * decay)\n\n    def _adaptive_dup_radius(self, grid, pos):\n        # Slightly reduce duplicate radius in dense areas to allow refinement\n        base = self.dup_radius\n        neigh = self._neighbors_in_radius(grid, pos, 2.5 * self.dup_radius)\n        if len(neigh) > 12:\n            return 0.6 * base\n        if len(neigh) > 6:\n            return 0.8 * base\n        return base\n\n    # Edge bookkeeping\n    def _add_edge(self, edges, a, b):\n        key = (a, b)\n        if key in self._edges_set:\n            return\n        edges.append((a, b))\n        self._edges_set[key] = 1\n\n    def _remove_edge(self, edges, a, b):\n        key = (a, b)\n        if key in self._edges_set:\n            # remove from list\n            for i in range(len(edges) - 1, -1, -1):\n                ea, eb = edges[i]\n                if ea is a and eb is b:\n                    edges.pop(i)\n                    break\n            del self._edges_set[key]",
          "objective": -40.90484,
          "time_improvement": 74.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1621.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009995555877685547,
                    "num_nodes_avg": 55.0,
                    "path_length_avg": 160.51471104652452,
                    "smoothness_avg": 0.04571645372029039,
                    "success_improvement": 0.0,
                    "time_improvement": 59.48507376866201,
                    "node_improvement": 86.14958448753463,
                    "length_improvement": 12.019343357036162,
                    "smoothness_improvement": 615.5617755907475,
                    "objective_score": 28.13493702277404
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.030689311027526856,
                    "num_nodes_avg": 142.0,
                    "path_length_avg": 228.58360131426812,
                    "smoothness_avg": 0.11916107389456083,
                    "success_improvement": 0.0,
                    "time_improvement": 81.65081025910044,
                    "node_improvement": 90.45891285359134,
                    "length_improvement": 23.692214467138992,
                    "smoothness_improvement": 2966.1002595593727,
                    "objective_score": 53.541073055810394
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009439635276794433,
                    "num_nodes_avg": 83.0,
                    "path_length_avg": 124.8569736985716,
                    "smoothness_avg": 0.10854185440910273,
                    "success_improvement": 0.0,
                    "time_improvement": 81.29903119622774,
                    "node_improvement": 89.446916719644,
                    "length_improvement": 17.075943119591432,
                    "smoothness_improvement": 1280.6443763574832,
                    "objective_score": 41.038497112410596
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SIMPLE-BiRRT-i: a simplified informed bi-directional RRT with spatial hashing and ghost-connect. It grows two trees from start and goal with small-step steering, hashed nearest search, light duplicate suppression, and early termination upon a valid bridge. It maintains coherence (node/edge checks before add), avoids heavy rewiring/compression, and performs greedy visibility pruning followed by bounded shortcut smoothing for shorter, smoother paths.",
          "planning_mechanism": "Alternate expanding start and goal trees. Each iteration: sample uniformly with goal-bias and optionally inside the informed ellipse if a path bound exists; choose a hashed-nearest parent; steer one step; validate node and edge; insert into the active tree. Try to connect to the opposite tree by direct line or a ghost (non-committal) short-step chain; if feasible, commit the chain, extract the bi-tree path, prune by visibility, shortcut, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        goal_bias=0.15,\n        informed_bias=0.5,\n        dupe_radius_ratio=0.35,\n        connect_radius_factor=3.0,\n        connect_steps=6,\n        smoothing_iters=60,\n        cell_factor=1.0\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.connect_radius_factor = float(connect_radius_factor)\n        self.connect_steps = int(connect_steps)\n        self.smoothing_iters = int(smoothing_iters)\n        self.cell_factor = float(cell_factor)\n        self._rng = 1234567\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_from_scene()\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Direct path early exit\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        self.cell_size = max(1.0, self.step_size * self.cell_factor)\n        self.dupe_radius = max(0.25, self.step_size * self.dupe_radius_ratio)\n        self.connect_radius = max(self.step_size, self.connect_radius_factor * self.step_size)\n\n        # Trees\n        nodes = []\n        edges = []\n\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        nodes.extend([root_a, root_b])\n        edges.extend([])\n\n        tree_a, tree_b = [root_a], [root_b]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, root_a)\n        self._grid_insert(grid_b, root_b)\n\n        best_len = float('inf')  # enables informed sampling when a bound appears\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            tree = tree_a if side_a else tree_b\n            other_tree = tree_b if side_a else tree_a\n            grid = grid_a if side_a else grid_b\n            other_grid = grid_b if side_a else grid_a\n            attractor = self.goal if side_a else self.start\n\n            s = self._sample(attractor, best_len)\n            if s is None:\n                continue\n\n            parent = self._nearest_hashed(grid, tree, s, 2)\n            if parent is None:\n                continue\n\n            new_pos = self._steer(parent.position, s)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n            if self._has_nearby(grid, new_pos, self.dupe_radius):\n                continue\n\n            new_node = Node(new_pos, parent, parent.cost + self._dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(grid, new_node)\n\n            # Try to connect directly to nearest in the opposite tree\n            near_other = self._nearest_hashed(other_grid, other_tree, new_node.position, 2)\n            if near_other is not None:\n                if self._dist(near_other.position, new_node.position) <= self.connect_radius and self._edge_free(near_other.position, new_node.position):\n                    path = self._extract_path(new_node, near_other, side_a)\n                    path = self._finalize_path(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n                # Ghost-connect: plan a short chain without committing, commit only if bridging succeeds\n                ok, chain_positions, last_pos = self._ghost_connect_positions(near_other.position, new_node.position, other_grid)\n                if ok and self._edge_free(last_pos, new_node.position):\n                    # Commit chain into the opposite tree\n                    prev = near_other\n                    for p in chain_positions:\n                        if self._has_nearby(other_grid, p, self.dupe_radius):\n                            prev = self._nearest_hashed(other_grid, other_tree, p, 1)\n                            if prev is None:\n                                prev = near_other\n                            continue\n                        if self._point_in_obstacles(p):\n                            ok = False\n                            break\n                        if not self._edge_free(prev.position, p):\n                            ok = False\n                            break\n                        q = Node(p, prev, prev.cost + self._dist(prev.position, p))\n                        prev.add_child(q)\n                        other_tree.append(q)\n                        nodes.append(q)\n                        edges.append((prev, q))\n                        self._grid_insert(other_grid, q)\n                        prev = q\n                    if ok and self._edge_free(prev.position, new_node.position):\n                        # We do not add a cross-tree edge; extract bi-tree path\n                        path = self._extract_path(new_node, prev, side_a)\n                        L = self._path_len(path)\n                        if L < best_len:\n                            best_len = L\n                        path = self._finalize_path(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1103515245 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 1) * 2654435761\n        if s == 0:\n            s = 1234567\n        self._rng = s & 0x7fffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0x7fffffff\n        return self._rng / float(1 << 31)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= self.step_size:\n            return tuple(b)\n        r = self.step_size / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n\n    # Obstacles\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            px, py, pz = p\n            for o in self.obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            px, py = p\n            for o in self.obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            for o in self.obstacles:\n                x, y, z, w, h, d = o\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            for o in self.obstacles:\n                x, y, w, h = o\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Spatial hashing\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, tree, pos, max_rings):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        any_found = False\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n                    any_found = True\n        if any_found:\n            return best\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n            if p and self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        if r < self.goal_bias:\n            p = attractor\n        else:\n            p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n        if self._in_bounds(p) and not self._point_in_obstacles(p):\n            return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [half] * self.dim\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dim))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # Ghost connect (non-committal)\n    def _ghost_connect_positions(self, from_pos, to_pos, other_grid):\n        chain = []\n        cur = from_pos\n        steps = 0\n        while steps < self.connect_steps:\n            nxt = self._steer(cur, to_pos)\n            if not self._in_bounds(nxt):\n                return False, None, None\n            if self._point_in_obstacles(nxt):\n                return False, None, None\n            if not self._edge_free(cur, nxt):\n                return False, None, None\n            if self._has_nearby(other_grid, nxt, self.dupe_radius):\n                return False, None, None\n            chain.append(nxt)\n            cur = nxt\n            if self._dist(cur, to_pos) <= self.step_size or self._edge_free(cur, to_pos):\n                return True, chain, cur\n            steps += 1\n        return False, None, None\n\n    # Paths and smoothing\n    def _path_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        return out[::-1]\n\n    def _extract_path(self, a_node, b_node, a_forward=True):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return (pa + pb[::-1]) if a_forward else (pb + pa[::-1])\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(pruned[-1], path[j]):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best_L = self._path_len(pts)\n        for _ in range(self.smoothing_iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                continue\n            a, b = pts[i], pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= best_L + 1e-12:\n                    pts = new_pts\n                    best_L = L\n        return pts\n\n    def _finalize_path(self, path):\n        if not path:\n            return []\n        p = self._visibility_prune(path)\n        p = self._shortcut(p)\n        return p",
          "objective": -40.79252,
          "time_improvement": 68.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 2580.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007870960235595702,
                    "num_nodes_avg": 48.0,
                    "path_length_avg": 179.5861954290845,
                    "smoothness_avg": 0.06548709066523807,
                    "success_improvement": 0.0,
                    "time_improvement": 68.09668444484818,
                    "node_improvement": 87.91236464366659,
                    "length_improvement": 1.565960559945877,
                    "smoothness_improvement": 925.0151764044653,
                    "objective_score": 25.993657551444304
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0211273193359375,
                    "num_nodes_avg": 158.0,
                    "path_length_avg": 237.3530114017347,
                    "smoothness_avg": 0.18862965381071545,
                    "success_improvement": 0.0,
                    "time_improvement": 87.36794088130645,
                    "node_improvement": 89.38386078075656,
                    "length_improvement": 20.764732966468724,
                    "smoothness_improvement": 4753.576856997666,
                    "objective_score": 62.437106329261496
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026227736473083497,
                    "num_nodes_avg": 250.0,
                    "path_length_avg": 127.39626037258856,
                    "smoothness_avg": 0.16982997215257256,
                    "success_improvement": 0.0,
                    "time_improvement": 48.039932985286335,
                    "node_improvement": 68.21360457724094,
                    "length_improvement": 15.389469818547017,
                    "smoothness_improvement": 2060.2247102361403,
                    "objective_score": 33.94678533789481
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "FIBER-Connect*: Fast Informed Bi-directional Edge-Refining RRT* with priority-balanced growth, adaptive neighbor/rewire radii, short validated bridges, and online visibility-prune/shortcutting for smooth, compact paths with low search cost.",
          "planning_mechanism": "Per iteration, expand the smaller tree: sample (uniform/goal; informed ellipse after first path), steer one step, validate node and parent edge, pick the lowest-cost parent among nearby neighbors, insert, then locally rewire to reduce cost. Attempt a short, validated bridge to the opposite tree; if blocked, allow at most one assisted hop on the passive tree before retrying. On a bridge, extract the bi-tree path, apply visibility pruning and length-nonincreasing shortcuts, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=5.5,\n        goal_bias=0.25,\n        informed_bias=0.6,\n        grid_cell_factor=1.0,\n        neighbor_base=3.2,\n        rewire_base=2.6,\n        connect_factor=3.0,\n        dupe_ratio=0.45,\n        ring_cap=4,\n        bridge_hops=1,\n        smooth_iters=80\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neighbor_base = float(neighbor_base)\n        self.rewire_base = float(rewire_base)\n        self.connect_factor = float(connect_factor)\n        self.dupe_ratio = float(dupe_ratio)\n        self.ring_cap = int(ring_cap)\n        self.bridge_hops = int(bridge_hops)\n        self.smooth_iters = int(smooth_iters)\n        self._rng = 123456789\n\n    def plan(self, map):\n        # Scene\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        # Validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_rng()\n        # Build obstacle index and ensure start/goal free\n        self._build_obs_index()\n        if self._in_obs(self.start) or self._in_obs(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Straight line early exit\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            edges = [(n0, n1)]\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], edges)\n\n        # Parameters\n        self.space_extent = max(1.0, max(self.bounds))\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius_base = max(0.3, self.dupe_ratio * self.step_size)\n        self.connect_radius = max(self.step_size, self.connect_factor * self.step_size)\n\n        # Trees and spatial hashes\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes = [start_root, goal_root]\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        # Informed sampling bookkeeping\n        have_solution = False\n        best_path = []\n        best_len = 1e100\n        c_min = self._dist(self.start, self.goal)\n\n        for it in range(self.max_iter):\n            # Choose the tree with fewer nodes to keep balance\n            expand_a = (len(tree_a) <= len(tree_b))\n            active_tree = tree_a if expand_a else tree_b\n            passive_tree = tree_b if expand_a else tree_a\n            active_grid = grid_a if expand_a else grid_b\n            passive_grid = grid_b if expand_a else grid_a\n            attractor = self.goal if expand_a else self.start\n\n            # Radii adapt to tree size\n            n_active = max(2, len(active_tree))\n            parent_radius = self._adaptive_radius(n_active, self.neighbor_base)\n            rewire_radius = self._adaptive_radius(n_active, self.rewire_base)\n            dupe_radius = self.dupe_radius_base * (0.35 if have_solution else 1.0)\n\n            # Sample\n            x_rand = self._sample(attractor, have_solution, best_len, c_min)\n            if x_rand is None:\n                continue\n\n            # Nearest and steer\n            nearest = self._nearest(active_grid, x_rand)\n            if nearest is None:\n                continue\n            x_new = self._steer(nearest.position, x_rand, self.step_size)\n            if self._dist2(nearest.position, x_new) < 1e-10:\n                continue\n            if not self._in_bounds(x_new):\n                continue\n            if self._in_obs(x_new):\n                continue\n            if self._has_nearby(active_grid, x_new, dupe_radius):\n                continue\n\n            # Choose lowest-cost parent among neighbors (ties broken by smoother turn)\n            parent, new_cost = self._choose_parent(active_grid, x_new, nearest, parent_radius)\n            if parent is None:\n                continue\n\n            # Validate both checks before adding\n            if self._in_obs(x_new):\n                continue\n            if not self._edge_free(parent.position, x_new):\n                continue\n\n            # Insert node\n            new_node = Node(x_new, parent, new_cost)\n            parent.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            self._grid_insert(active_grid, new_node)\n\n            # Local rewiring\n            self._rewire(new_node, active_grid, rewire_radius)\n\n            # Try a short, validated bridge\n            bnode = self._best_bridge_candidate(passive_grid, new_node.position, self.connect_radius)\n            bridged = None\n            if bnode is not None and self._edge_free(bnode.position, new_node.position):\n                bridged = bnode\n            else:\n                # One assisted hop on passive tree if allowed\n                hops = 0\n                while bridged is None and hops < self.bridge_hops:\n                    hops += 1\n                    near_p = self._nearest(passive_grid, new_node.position)\n                    if near_p is None:\n                        break\n                    x_step = self._steer(near_p.position, new_node.position, self.step_size)\n                    if not self._in_bounds(x_step) or self._in_obs(x_step):\n                        break\n                    if self._has_nearby(passive_grid, x_step, dupe_radius):\n                        break\n                    # Select parent for the hop\n                    hop_parent, hop_cost = self._choose_parent(passive_grid, x_step, near_p, parent_radius)\n                    if hop_parent is None:\n                        break\n                    if not self._edge_free(hop_parent.position, x_step):\n                        break\n                    # Insert hop node in passive tree\n                    hop_node = Node(x_step, hop_parent, hop_cost)\n                    hop_parent.add_child(hop_node)\n                    passive_tree.append(hop_node)\n                    nodes.append(hop_node)\n                    self._grid_insert(passive_grid, hop_node)\n                    # Light rewiring on passive tree\n                    self._rewire(hop_node, passive_grid, rewire_radius)\n                    # Retry direct bridge\n                    if self._edge_free(hop_node.position, new_node.position):\n                        bridged = hop_node\n                        break\n\n            if bridged is not None:\n                path = self._extract_path(new_node, bridged, expand_a)\n                # Visibility prune then length-nonincreasing shortcuts\n                path = self._visibility_prune(path)\n                path = self._shortcut_nonincreasing(path, self.smooth_iters)\n                best_path = path\n                best_len = self._path_len(path)\n                edges = self._collect_edges(nodes)\n                return PlannerResult(True, best_path, nodes, edges)\n\n            # Optional online smoothing of incumbent (if already found, keep improving lightly)\n            if have_solution and best_path:\n                best_path = self._shortcut_nonincreasing(best_path, 4)\n                best_len = self._path_len(best_path)\n\n        # Finalize\n        edges = self._collect_edges(nodes)\n        if best_path:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # -------------------- RNG --------------------\n    def _seed_rng(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 17) * 2654435761\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # -------------------- Geometry --------------------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        d = d2 ** 0.5\n        if d <= step:\n            q = []\n            for i in range(self.dim):\n                v = b[i]\n                if v < 0.0:\n                    v = 0.0\n                if v > self.bounds[i]:\n                    v = self.bounds[i]\n                q.append(v)\n            return tuple(q)\n        r = step / d\n        q = []\n        for i in range(self.dim):\n            v = a[i] + (b[i] - a[i]) * r\n            if v < 0.0:\n                v = 0.0\n            if v > self.bounds[i]:\n                v = self.bounds[i]\n            q.append(v)\n        return tuple(q)\n\n    # -------------------- Obstacles --------------------\n    def _build_obs_index(self):\n        self.obs_cell = max(3.0, self.step_size * 1.3)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, ob in enumerate(self.obstacles):\n                x, y, z, w, h, d = ob\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, ob in enumerate(self.obstacles):\n                x, y, w, h = ob\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _in_obs(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            b = self.obs_grid.get((cx, cy, cz))\n            if not b:\n                return False\n            px, py, pz = p\n            for idx in b:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            b = self.obs_grid.get((cx, cy))\n            if not b:\n                return False\n            px, py = p\n            for idx in b:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        arr = self.obs_grid.get((cx, cy, cz))\n                        if arr:\n                            for idx in arr:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    arr = self.obs_grid.get((cx, cy))\n                    if arr:\n                        for idx in arr:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # -------------------- Spatial hashing --------------------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _neighbors_within(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        out = []\n        r2 = radius * radius\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_of(pos)\n        best = None\n        bestd2 = 1e100\n        got = False\n        for r in range(0, self.ring_cap + 1):\n            cand = []\n            if self.is_3d:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                            if b:\n                                cand.extend(b)\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy))\n                        if b:\n                            cand.extend(b)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n                    got = True\n            if got:\n                return best\n        # Fallback random probe\n        buckets = list(grid.values())\n        tries = 0\n        while tries < 32 and buckets:\n            b = buckets[int(self._rand_range(0, len(buckets)))]\n            if b:\n                n = b[int(self._rand_range(0, len(b)))]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            tries += 1\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        ns = self._neighbors_within(grid, pos, radius)\n        return len(ns) > 0\n\n    # -------------------- Parent selection and rewiring --------------------\n    def _choose_parent(self, grid, new_pos, fallback, radius):\n        cand = self._neighbors_within(grid, new_pos, radius)\n        if fallback not in cand:\n            cand.append(fallback)\n        best = None\n        best_cost = 1e100\n        best_smooth = -1.0\n        for n in cand:\n            if not self._edge_free(n.position, new_pos):\n                continue\n            c = n.cost + self._dist(n.position, new_pos)\n            if c + 1e-12 < best_cost:\n                best_cost = c\n                best = n\n                best_smooth = self._smooth_score(n, new_pos)\n            elif abs(c - best_cost) <= 1e-12:\n                sc = self._smooth_score(n, new_pos)\n                if sc > best_smooth:\n                    best_smooth = sc\n                    best = n\n        if best is None:\n            return None, None\n        return best, best_cost\n\n    def _smooth_score(self, parent, new_pos):\n        # Cosine of turn angle; higher is smoother. If no grandparent, neutral.\n        if parent.parent is None:\n            return 0.0\n        a = parent.parent.position\n        b = parent.position\n        c = new_pos\n        ab = tuple(b[i] - a[i] for i in range(self.dim))\n        bc = tuple(c[i] - b[i] for i in range(self.dim))\n        nab = self._dist(a, b)\n        nbc = self._dist(b, c)\n        if nab <= 1e-12 or nbc <= 1e-12:\n            return 0.0\n        dot = 0.0\n        for i in range(self.dim):\n            dot += ab[i] * bc[i]\n        cosang = dot / (nab * nbc)\n        if cosang < -1.0:\n            cosang = -1.0\n        if cosang > 1.0:\n            cosang = 1.0\n        return cosang\n\n    def _rewire(self, pivot, grid, radius):\n        neighbors = self._neighbors_within(grid, pivot.position, radius)\n        for nb in neighbors:\n            if nb is pivot or nb.parent is pivot:\n                continue\n            # prevent cycles: if nb is ancestor of pivot, skip\n            if self._is_ancestor(nb, pivot):\n                continue\n            if not self._edge_free(pivot.position, nb.position):\n                continue\n            new_c = pivot.cost + self._dist(pivot.position, nb.position)\n            if new_c + 1e-12 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    try:\n                        oldp.children.remove(nb)\n                    except:\n                        pass\n                pivot.add_child(nb)\n                nb.cost = new_c\n                self._propagate_cost(nb)\n\n    def _is_ancestor(self, node, potential_child):\n        cur = potential_child\n        while cur is not None:\n            if cur is node:\n                return True\n            cur = cur.parent\n        return False\n\n    def _propagate_cost(self, node):\n        # Update subtree costs after rewiring\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if newc + 1e-12 < ch.cost:\n                    ch.cost = newc\n                stack.append(ch)\n\n    # -------------------- Bridging and paths --------------------\n    def _best_bridge_candidate(self, grid_other, pos, radius):\n        cand = self._neighbors_within(grid_other, pos, radius)\n        if not cand:\n            return None\n        best = None\n        bestd2 = 1e100\n        for n in cand:\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd2:\n                bestd2 = d2\n                best = n\n        return best\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node, a_from_start):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if a_from_start:\n            return pa + list(reversed(pb))\n        else:\n            return pb + list(reversed(pa))\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(pruned[-1], path[j]):\n                    # Accept only if not longer than original subpath\n                    seg = self._dist(pruned[-1], path[j])\n                    walk = 0.0\n                    for k in range(i + 1, j + 1):\n                        walk += self._dist(path[k - 1], path[k])\n                    if seg + 1e-9 <= walk:\n                        pruned.append(path[j])\n                        i = j\n                        advanced = True\n                        break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _shortcut_nonincreasing(self, path, iters):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        bestL = self._path_len(pts)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                newL = self._path_len(new_pts)\n                if newL <= bestL + 1e-12:\n                    pts = new_pts\n                    bestL = newL\n        return pts\n\n    def _collect_edges(self, nodes):\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        return edges\n\n    # -------------------- Sampling --------------------\n    def _sample(self, attractor, informed, best_len, c_min):\n        r = self._rand()\n        if informed and best_len < 1e99 and r < self.informed_bias:\n            p = self._informed_sample(self.start, self.goal, best_len * 1.01, c_min)\n            if p is not None and self._in_bounds(p) and not self._in_obs(p):\n                return p\n        if r < self.goal_bias:\n            p = attractor\n            return p if self._in_bounds(p) and not self._in_obs(p) else None\n        # Uniform\n        p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n        if self._in_bounds(p) and not self._in_obs(p):\n            return p\n        return None\n\n    def _informed_sample(self, f1, f2, c_best, c_min):\n        if not (c_best > c_min + 1e-9):\n            return None\n        center = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        a_vec = tuple(f2[i] - f1[i] for i in range(self.dim))\n        a_len = self._dist((0.0,) * self.dim, a_vec)\n        if a_len <= 1e-12:\n            return None\n        a_hat = tuple(a_vec[i] / a_len for i in range(self.dim))\n        r1 = 0.5 * c_best\n        r2_sq = max(0.0, 0.25 * (c_best * c_best - c_min * c_min))\n        if self.is_3d:\n            # Build orthonormal basis [a_hat, v, w]\n            # Simple fixed aux and cross to form basis\n            u = (1.0, 0.0, 0.0) if abs(a_hat[0]) < 0.9 else (0.0, 1.0, 0.0)\n            v = self._normalize(self._cross(a_hat, u))\n            w = self._cross(a_hat, v)\n            for _ in range(32):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                z = self._rand_range(-1.0, 1.0)\n                if x * x + y * y + z * z > 1.0:\n                    continue\n                px = r1 * x\n                r2 = (r2_sq ** 0.5)\n                py = r2 * y\n                pz = r2 * z\n                ex = center[0] + px * a_hat[0] + py * v[0] + pz * w[0]\n                ey = center[1] + px * a_hat[1] + py * v[1] + pz * w[1]\n                ez = center[2] + px * a_hat[2] + py * v[2] + pz * w[2]\n                p = (ex, ey, ez)\n                if self._in_bounds(p) and not self._in_obs(p):\n                    return p\n            return None\n        else:\n            # 2D ellipse with axes r1, r2\n            perp = (-a_hat[1], a_hat[0])\n            for _ in range(32):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                if x * x + y * y > 1.0:\n                    continue\n                r2 = (r2_sq ** 0.5)\n                px = r1 * x\n                py = r2 * y\n                ex = center[0] + px * a_hat[0] + py * perp[0]\n                ey = center[1] + px * a_hat[1] + py * perp[1]\n                p = (ex, ey)\n                if self._in_bounds(p) and not self._in_obs(p):\n                    return p\n            return None\n\n    def _normalize(self, v):\n        n = self._dist((0.0,) * len(v), v)\n        if n <= 1e-12:\n            return v\n        return tuple(v[i] / n for i in range(len(v)))\n\n    def _cross(self, a, b):\n        return (a[1] * b[2] - a[2] * b[1],\n                a[2] * b[0] - a[0] * b[2],\n                a[0] * b[1] - a[1] * b[0])\n\n    # -------------------- Radii --------------------\n    def _adaptive_radius(self, n, base_mult):\n        # Decays with n; lower-bounded by 1.5*step_size\n        decay = (1.0 / (n ** (1.0 / max(2, self.dim))))\n        r = base_mult * self.step_size * 0.5 + self.space_extent * 0.05 * decay\n        return max(1.5 * self.step_size, r)",
          "objective": -40.1344,
          "time_improvement": 63.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1814.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012674951553344726,
                    "num_nodes_avg": 45.0,
                    "path_length_avg": 153.35894992834636,
                    "smoothness_avg": 0.03846541732582647,
                    "success_improvement": 0.0,
                    "time_improvement": 48.6246954693179,
                    "node_improvement": 88.66784185343742,
                    "length_improvement": 15.941529416200709,
                    "smoothness_improvement": 502.0673101398352,
                    "objective_score": 26.66266284121497
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05657989978790283,
                    "num_nodes_avg": 140.0,
                    "path_length_avg": 233.83827885399037,
                    "smoothness_avg": 0.11832797178444796,
                    "success_improvement": 0.0,
                    "time_improvement": 66.17078448590458,
                    "node_improvement": 90.5932943626957,
                    "length_improvement": 21.93805185687287,
                    "smoothness_improvement": 2944.6639422069725,
                    "objective_score": 47.73738617092995
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013706851005554199,
                    "num_nodes_avg": 79.0,
                    "path_length_avg": 115.01768024557694,
                    "smoothness_avg": 0.16483033391240323,
                    "success_improvement": 0.0,
                    "time_improvement": 72.84520158496316,
                    "node_improvement": 89.95549904640814,
                    "length_improvement": 23.61073333426484,
                    "smoothness_improvement": 1996.6296808560942,
                    "objective_score": 46.003148880328325
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "FENRIR-Connect: A fast, cost-aware BiRRT*-Connect variant with spatial hashing for nodes and obstacles, adaptive neighbor radius, duplicate suppression, and exact seam insertion. It prioritizes early direct-visibility connections, chooses lowest-cost parents, incrementally rewires local neighbors, and finishes with light visibility pruning plus a few randomized shortcuts for short, smooth paths at low planning time.",
          "planning_mechanism": "Alternate expansion from start and goal: sample (goal-biased; informed ellipse after first path), steer one step, pick the best-cost parent within an adaptive radius, add only if node and edge are collision-free, locally rewire cheaper neighbors, then greedily connect the opposite tree and insert the exact meeting point if visible; upon connection, extract and finalize the path via visibility pruning and brief shortcut smoothing, then return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=5.5,\n        connect_mult=2.2,\n        goal_bias=0.14,\n        grid_cell_factor=1.8,\n        rewire_base=2.6,\n        dup_radius_factor=0.35,\n        smooth_attempts=120\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_step = float(step_size * connect_mult)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.rewire_base = float(rewire_base)\n        self.dup_factor = float(dup_radius_factor)\n        self.smooth_attempts = int(max(0, smooth_attempts))\n        self._rng = 88172645463393265 % (1 << 32)\n\n    # ------------------ Public API ------------------\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n\n        # Spatial params\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_radius = max(0.5, self.dup_factor * self.step)\n\n        # Build obstacle bins\n        self._build_obs_bins()\n\n        # Start/goal validity\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Direct visibility\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            final = self._finalize_path(path)\n            return PlannerResult(True, final, nodes, edges)\n\n        # Initialize trees and node grids\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        Ta, Tb = [root_a], [root_b]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, root_a)\n        self._grid_add(Gb, root_b)\n        nodes.extend([root_a, root_b])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            # Alternate expansion\n            active_from_start = (it % 2 == 0)\n            tree = Ta if active_from_start else Tb\n            other_tree = Tb if active_from_start else Ta\n            grid = Ga if active_from_start else Gb\n            other_grid = Gb if active_from_start else Ga\n            attractor = self.goal if active_from_start else self.start\n\n            s = self._sample(attractor, best_len)\n            if s is None:\n                continue\n\n            near = self._nearest(grid, s)\n            if near is None:\n                continue\n\n            newp = self._steer(near.position, s, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(grid, newp, self.dup_radius):\n                continue\n\n            # Parent selection within adaptive radius\n            radius = self._rewire_radius(len(tree))\n            parent, new_cost = self._best_parent(grid, near, newp, radius)\n            if parent is None:\n                continue\n\n            # Strict checks before adding node/edge\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, new_cost)\n            parent.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(grid, nn)\n\n            # Local rewiring\n            self._rewire_neighbors(grid, nn, radius, edges)\n\n            # Greedy connect other tree toward nn; insert exact meeting if visible\n            meet, reached = self._connect_toward(other_tree, other_grid, nn.position, nodes, edges)\n            if reached:\n                if active_from_start:\n                    pa = self._trace_to_root(nn)        # start -> ... -> meet\n                    pb = self._trace_to_root(meet)      # goal  -> ... -> meet\n                    path = pa + pb[-2::-1]\n                else:\n                    pa = self._trace_to_root(meet)      # start -> ... -> meet\n                    pb = self._trace_to_root(nn)        # goal  -> ... -> meet\n                    path = pa + pb[-2::-1]\n\n                path = self._dedup(path)\n                best_len = self._path_len(path)\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # ------------------ RNG ------------------\n    def _seed_from_scene(self):\n        s = 2166136261 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= q\n            s = (s * 16777619) & 0xffffffff\n        s ^= ((len(self.obstacles) + 97) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        # 32-bit LCG\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------------ Geometry ------------------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a[i] for i in range(self.dim))\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # ------------------ Spatial hash (nodes) ------------------\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, ring):\n        out = []\n        if self.is3:\n            for dx in range(-ring, ring + 1):\n                for dy in range(-ring, ring + 1):\n                    for dz in range(-ring, ring + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-ring, ring + 1):\n                for dy in range(-ring, ring + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        k = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        for r in range(0, 4):\n            cand = self._grid_collect(grid, k, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found = True\n            if found:\n                return best\n        # fallback scan\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_radius(self, grid, pos, radius):\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        k = self._cell_key(pos)\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((k[0] + dx, k[1] + dy, k[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((k[0] + dx, k[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        neigh = self._neighbors_radius(grid, pos, radius)\n        return len(neigh) > 0\n\n    # ------------------ Obstacles and collision ------------------\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.25)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        # Collect candidate obstacles via bin bounds\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_overlap(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_overlap(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_overlap(self, p0, p1, bmin, bmax):\n        # Slab method\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            q = p1[i]\n            d = q - p\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t0 = (mn - p) * inv\n                t1 = (mx - p) * inv\n                if t0 > t1:\n                    tt = t0\n                    t0 = t1\n                    t1 = tt\n                if t0 > tmin:\n                    tmin = t0\n                if t1 < tmax:\n                    tmax = t1\n                if tmin > tmax:\n                    return False\n        return True\n\n    # ------------------ Parenting and rewiring ------------------\n    def _rewire_radius(self, n_nodes):\n        # Smooth decay with tree size; keep generous early radius\n        base = max(self.step * 1.5, self.step * self.rewire_base)\n        scale = 1.0 / (1.0 + 0.002 * n_nodes)\n        # dimension-aware shrink\n        exp = 1.0 / float(self.dim if self.dim > 0 else 1)\n        r = base * (scale ** exp)\n        return max(self.step * 1.25, r)\n\n    def _best_parent(self, grid, near, newp, radius):\n        parent = None\n        best = 1e100\n        neigh = self._neighbors_radius(grid, newp, radius)\n        if not neigh:\n            neigh = [near]\n        for n in neigh:\n            if not self._edge_free(n.position, newp):\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c < best:\n                best = c\n                parent = n\n        return parent, best if parent is not None else (None, None)\n\n    def _rewire_neighbors(self, grid, pivot, radius, edges):\n        neigh = self._neighbors_radius(grid, pivot.position, radius)\n        for nb in neigh:\n            if nb is pivot or nb.parent is None:\n                continue\n            cand = pivot.cost + self._dist(pivot.position, nb.position)\n            if cand + 1e-12 < nb.cost and self._edge_free(pivot.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, (oldp, nb))\n                pivot.add_child(nb)\n                nb.cost = cand\n                edges.append((pivot, nb))\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _remove_edge(self, edges, e):\n        # remove first match\n        for i in range(len(edges)):\n            if edges[i][0] is e[0] and edges[i][1] is e[1]:\n                edges.pop(i)\n                return\n\n    # ------------------ Connect other tree ------------------\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n\n        # Direct connect if visible\n        if self._edge_free(cur.position, target_pos):\n            # Insert exact meeting if not too close\n            if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    nc = Node(target_pos, cur, cur.cost + self._dist(cur.position, target_pos))\n                    cur.add_child(nc)\n                    tree.append(nc)\n                    nodes.append(nc)\n                    edges.append((cur, nc))\n                    self._grid_add(grid, nc)\n                    return nc, True\n            return cur, True\n\n        # Greedy bounded stepping\n        steps = 0\n        limit = 64\n        here = cur\n        while steps < limit:\n            nxt = self._steer(here.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                break\n            if not self._edge_free(here.position, nxt):\n                break\n            if self._too_close(grid, nxt, self.dup_radius * 0.75):\n                break\n            nn = Node(nxt, here, here.cost + self._dist(here.position, nxt))\n            here.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((here, nn))\n            self._grid_add(grid, nn)\n            here = nn\n            steps += 1\n            if self._edge_free(here.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                    if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                        meet = Node(target_pos, here, here.cost + self._dist(here.position, target_pos))\n                        here.add_child(meet)\n                        tree.append(meet)\n                        nodes.append(meet)\n                        edges.append((here, meet))\n                        self._grid_add(grid, meet)\n                        return meet, True\n                return here, True\n\n        # Final direct try\n        if self._edge_free(here.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    meet = Node(target_pos, here, here.cost + self._dist(here.position, target_pos))\n                    here.add_child(meet)\n                    tree.append(meet)\n                    nodes.append(meet)\n                    edges.append((here, meet))\n                    self._grid_add(grid, meet)\n                    return meet, True\n            return here, True\n\n        return here, False\n\n    # ------------------ Sampling ------------------\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.6:\n            p = self._sample_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            if self._in_bounds(attractor) and (not self._point_in_obstacles(attractor)):\n                return attractor\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(32):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum + 1e-9:\n                return p\n        return None\n\n    # ------------------ Path utilities ------------------\n    def _trace_to_root(self, node):\n        cur = node\n        pts = []\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        n = len(cur)\n        tries = 0\n        while tries < attempts and n > 2:\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cur = cur[:i + 1] + cur[j:]\n                n = len(cur)\n            tries += 1\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._visibility_prune(path)\n        p1 = self._shortcut(p0, max(20, self.smooth_attempts))\n        p2 = self._visibility_prune(p1)\n        return self._dedup(p2)",
          "objective": -40.03655,
          "time_improvement": 75.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1190.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.00911562442779541,
                    "num_nodes_avg": 42.0,
                    "path_length_avg": 160.0835385997664,
                    "smoothness_avg": 0.0506179669795133,
                    "success_improvement": 0.0,
                    "time_improvement": 63.051694596676235,
                    "node_improvement": 89.42331906320827,
                    "length_improvement": 12.255675807468933,
                    "smoothness_improvement": 692.2811019039884,
                    "objective_score": 29.73031937300417
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02603757381439209,
                    "num_nodes_avg": 162.0,
                    "path_length_avg": 231.3416199523067,
                    "smoothness_avg": 0.08683134390642434,
                    "success_improvement": 0.0,
                    "time_improvement": 84.43209162029012,
                    "node_improvement": 89.11509776254786,
                    "length_improvement": 22.77150846059685,
                    "smoothness_improvement": 2134.233020801344,
                    "objective_score": 49.66369766645187
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010724067687988281,
                    "num_nodes_avg": 75.0,
                    "path_length_avg": 117.01222962601585,
                    "smoothness_avg": 0.06631602341986054,
                    "success_improvement": 0.0,
                    "time_improvement": 78.75442753856959,
                    "node_improvement": 90.46408137317228,
                    "length_improvement": 22.286048606012514,
                    "smoothness_improvement": 743.5349229609544,
                    "objective_score": 40.715632039983156
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SAGE-Connect: A simplified adaptive BiRRT-Connect with local cost-aware parenting and light rewiring. It uses a uniform spatial hash for nearest/neighbor queries, coarse obstacle binning for fast collision checks, adaptive rewire radius, and minimal biased/informed sampling. It inserts only strictly node- and edge-free states, creates the exact meeting node to reduce kinks, and applies a compact densify+shortcut+visibility smoother for short, smooth paths.",
          "planning_mechanism": "Alternate growth from start/goal trees: sample (uniform with small goal bias; ellipse after first solution), steer one step, choose the best-cost parent among nearby nodes, add after node+edge checks, locally rewire cheaper neighbors, then greedily extend the opposite tree toward the new node and insert the exact meeting point; upon connection, extract, densify, shortcut, visibility-prune, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=6.0,\n        connect_mult=2.0,\n        goal_bias=0.12,\n        grid_cell_factor=1.6,\n        rewire_base=2.2,\n        smooth_iters=120\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_mult = float(connect_mult)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.rewire_base = float(rewire_base)\n        self.smooth_iters = int(max(0, smooth_iters))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.connect_step = max(self.step, self.step * self.connect_mult)\n        self.dup_radius = max(0.5, 0.4 * self.step)\n\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            Ta = tree_a if active_start else tree_b\n            Tb = tree_b if active_start else tree_a\n            Ga = grid_a if active_start else grid_b\n            Gb = grid_b if active_start else grid_a\n            attractor = self.goal if active_start else self.start\n\n            sample = self._sample(attractor, best_len)\n            if sample is None:\n                continue\n\n            na = self._nearest(Ga, sample)\n            if na is None:\n                continue\n\n            newp = self._steer(na.position, sample, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(Ga, newp, self.dup_radius):\n                continue\n            if not self._edge_free(na.position, newp):\n                continue\n\n            rew_rad = self._adaptive_rewire_radius(len(Ta))\n            parent, new_cost = self._choose_parent(Ga, newp, na, rew_rad)\n\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, new_cost)\n            parent.add_child(nn)\n            Ta.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(Ga, nn)\n\n            self._local_rewire(Ga, nn, rew_rad, edges)\n\n            meet_node, reached = self._connect_toward(Tb, Gb, nn.position, nodes, edges)\n            if reached:\n                if active_start:\n                    pa = self._trace_to_root(nn)        # start -> ... -> nn\n                    pb = self._trace_to_root(meet_node) # goal  -> ... -> nn\n                    path = pa + pb[-2::-1]              # avoid duplicate nn\n                else:\n                    pa = self._trace_to_root(meet_node) # start -> ... -> nn\n                    pb = self._trace_to_root(nn)        # goal  -> ... -> nn\n                    path = pa + pb[-2::-1]\n\n                path = self._dedup(path)\n                best_len = self._path_len(path)\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0x9E3779B9 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= (q ^ (q >> 13) ^ ((q << 7) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 13) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial hash\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found_any = False\n        for r in range(0, 4):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found_any = True\n            if found_any:\n                return best\n        # fallback\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors_in_radius(grid, pos, radius)) > 0\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.2)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Parenting and rewiring\n    def _choose_parent(self, grid, newp, fallback, radius):\n        parent = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        neigh = self._neighbors_in_radius(grid, newp, radius)\n        for n in neigh:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                parent = n\n                best_cost = c\n        return parent, best_cost\n\n    def _local_rewire(self, grid, nn, radius, edges):\n        neigh = self._neighbors_in_radius(grid, nn.position, radius)\n        for nb in neigh:\n            if nb is nn or nb is nn.parent:\n                continue\n            cand = nn.cost + self._dist(nn.position, nb.position)\n            if cand + 1e-12 < nb.cost and self._edge_free(nn.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, (oldp, nb))\n                nn.add_child(nb)\n                nb.cost = cand\n                edges.append((nn, nb))\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _remove_edge(self, edges, e):\n        try:\n            idx = edges.index(e)\n            edges.pop(idx)\n        except:\n            pass\n\n    def _adaptive_rewire_radius(self, n_nodes):\n        # Shrink with tree size without log; simple exponential decay\n        base = max(self.step * 1.2, self.step * self.rewire_base)\n        decay = pow(0.5, n_nodes / 2500.0)\n        return max(self.step * 1.2, base * decay)\n\n    # BiRRT-Connect growth from other tree toward target; insert exact meeting node if visible\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < 64:\n            if self._edge_free(cur.position, target_pos):\n                # Insert the exact meeting point for a clean junction\n                if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                    if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        cur.add_child(nn)\n                        tree.append(nn)\n                        nodes.append(nn)\n                        edges.append((cur, nn))\n                        self._grid_add(grid, nn)\n                        return nn, True\n                # If too close, treat current as meeting node\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            if self._too_close(grid, nxt, self.dup_radius * 0.75):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n        # Final try after capped steps\n        if self._edge_free(cur.position, target_pos):\n            if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    cur.add_child(nn)\n                    tree.append(nn)\n                    nodes.append(nn)\n                    edges.append((cur, nn))\n                    self._grid_add(grid, nn)\n                    return nn, True\n            return cur, True\n        return cur, False\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.55:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Path utilities\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _densify(self, pts, seg_len):\n        if len(pts) < 2:\n            return pts[:]\n        out = [pts[0]]\n        for i in range(1, len(pts)):\n            a = out[-1]\n            b = pts[i]\n            d = self._dist(a, b)\n            if d <= seg_len * 1.05:\n                out.append(b)\n                continue\n            nseg = int(d / seg_len)\n            if nseg < 1:\n                out.append(b)\n                continue\n            for k in range(1, nseg + 1):\n                t = k / float(nseg + 1)\n                inter = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n                if self._edge_free(out[-1], inter):\n                    out.append(inter)\n                else:\n                    break\n            if self._edge_free(out[-1], b):\n                out.append(b)\n            else:\n                out.append(b)\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._densify(path, seg_len=max(1.0, 0.5 * self.step))\n        p1 = self._shortcut(p0, self.smooth_iters)\n        p2 = self._visibility_prune(p1)\n        p3 = self._shortcut(p2, max(20, self.smooth_iters // 2))\n        return self._dedup(p3)",
          "objective": -39.95809,
          "time_improvement": 69.0,
          "length_improvement": 21.0,
          "smoothness_improvement": 1361.0,
          "node_improvement": 85.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008446240425109863,
                    "num_nodes_avg": 40.0,
                    "path_length_avg": 154.00203649529243,
                    "smoothness_avg": 0.0463463750398735,
                    "success_improvement": 0.0,
                    "time_improvement": 65.76490472936995,
                    "node_improvement": 89.92697053638882,
                    "length_improvement": 15.589043478498803,
                    "smoothness_improvement": 625.4214121382626,
                    "objective_score": 32.21000456660158
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02304682731628418,
                    "num_nodes_avg": 136.0,
                    "path_length_avg": 230.09301068249903,
                    "smoothness_avg": 0.08849989105200873,
                    "success_improvement": 0.0,
                    "time_improvement": 86.220263890156,
                    "node_improvement": 90.86205738090439,
                    "length_improvement": 23.188330174083777,
                    "smoothness_improvement": 2177.1659406631616,
                    "objective_score": 50.66490697481287
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02282891273498535,
                    "num_nodes_avg": 204.0,
                    "path_length_avg": 115.03810237530747,
                    "smoothness_avg": 0.10863321186734835,
                    "success_improvement": 0.0,
                    "time_improvement": 54.77338134763434,
                    "node_improvement": 74.06230133502861,
                    "length_improvement": 23.597169928095134,
                    "smoothness_improvement": 1281.8064364830614,
                    "objective_score": 36.99934854356269
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "BLITZ-BiRRT: Ultra-fast bidirectional RRT-Connect with hashed k-nearest parenting, single-hop connection, and capped leaf-only rewiring. It minimizes work per iteration, avoids chain growth in the passive tree, uses fast-decaying neighbor radii, and finishes with quick visibility pruning and few shortcuts.",
          "planning_mechanism": "Alternate expansions from start and goal: sample with goal/informed bias, steer one step, pick the best parent among k local hashed neighbors, insert after node and edge checks, optionally rewire a few leaf neighbors, then attempt a single line-of-sight connect from the opposite tree by inserting only the exact meeting node. On success, extract and quickly prune/shortcut the path; else continue.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=7.5,\n        goal_bias=0.2,\n        grid_cell_factor=1.6,\n        k_near=8,\n        ring_cap=2,\n        rewire_k=3,\n        smooth_iters=50\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.k_near = int(max(1, k_near))\n        self.ring_cap = int(max(1, ring_cap))\n        self.rewire_k = int(max(0, rewire_k))\n        self.smooth_iters = int(max(0, smooth_iters))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_radius = max(0.5, 0.45 * self.step)\n\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            Ta = tree_a if active_start else tree_b\n            Tb = tree_b if active_start else tree_a\n            Ga = grid_a if active_start else grid_b\n            Gb = grid_b if active_start else grid_a\n            attractor = self.goal if active_start else self.start\n\n            sample = self._sample(attractor, best_len)\n            if sample is None:\n                continue\n\n            near = self._nearest_limited(Ga, sample)\n            if near is None:\n                continue\n\n            newp = self._steer(near.position, sample, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(Ga, newp, self.dup_radius):\n                continue\n\n            parent, pcost = self._choose_parent_knn(Ga, newp, near, len(Ta))\n            if parent is None:\n                continue\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, pcost)\n            parent.add_child(nn)\n            Ta.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(Ga, nn)\n\n            if self.rewire_k > 0:\n                self._leaf_rewire(Ga, nn, self.rewire_k, edges)\n\n            meet_node, reached = self._try_direct_connect(Tb, Gb, nn.position, nodes, edges)\n            if reached:\n                if active_start:\n                    pa = self._trace_to_root(nn)\n                    pb = self._trace_to_root(meet_node)\n                    path = pa + pb[-2::-1]\n                else:\n                    pa = self._trace_to_root(meet_node)\n                    pb = self._trace_to_root(nn)\n                    path = pa + pb[-2::-1]\n\n                path = self._dedup(path)\n                best_len = self._path_len(path)\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0x9E3779B9 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= (q ^ (q >> 13) ^ ((q << 7) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 17) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(min(max(a[i], 0.0), self.bounds[i]) for i in range(self.dim))\n        if d2 <= step * step:\n            tgt = b\n        else:\n            d = d2 ** 0.5\n            r = step / d\n            tgt = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n        return tuple(min(max(tgt[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # Spatial hash grid\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest_limited(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        for r in range(0, self.ring_cap + 1):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found = True\n            if found:\n                return best\n        # fallback limited scan\n        cnt = 0\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                cnt += 1\n                if cnt >= 128:\n                    return best\n        return best\n\n    def _k_nearest_limited(self, grid, pos, k):\n        key = self._cell_key(pos)\n        cand = []\n        for r in range(0, self.ring_cap + 1):\n            cand.extend(self._grid_collect_ring(grid, key, r))\n            if len(cand) >= k:\n                break\n        if len(cand) < k:\n            for lst in grid.values():\n                cand.extend(lst)\n                if len(cand) >= 4 * k:\n                    break\n        # select k closest\n        scored = []\n        seen = set()\n        for n in cand:\n            if n in seen:\n                continue\n            seen.add(n)\n            scored.append((self._dist2(n.position, pos), n))\n        scored.sort(key=lambda x: x[0])\n        out = []\n        for i in range(min(k, len(scored))):\n            out.append(scored[i][1])\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell) + 1)\n        r2 = radius * radius\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                return True\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            return True\n        return False\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.2)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Parenting and lightweight rewiring\n    def _parent_radius(self, n_nodes):\n        base = self.step * 2.0\n        decay = pow(0.35, n_nodes / 2000.0)\n        return max(self.step * 1.1, base * decay)\n\n    def _choose_parent_knn(self, grid, newp, fallback, n_nodes):\n        cand = self._k_nearest_limited(grid, newp, self.k_near)\n        if fallback not in cand:\n            cand.append(fallback)\n        scored = []\n        for n in cand:\n            c = n.cost + self._dist(n.position, newp)\n            scored.append((c, n))\n        scored.sort(key=lambda x: x[0])\n        for c, n in scored:\n            if self._edge_free(n.position, newp):\n                return n, c\n        # fallback if none visible\n        if self._edge_free(fallback.position, newp):\n            return fallback, fallback.cost + self._dist(fallback.position, newp)\n        return None, 0.0\n\n    def _leaf_rewire(self, grid, nn, k, edges):\n        neigh = self._k_nearest_limited(grid, nn.position, k + 2)\n        for nb in neigh:\n            if nb is nn or nb is nn.parent:\n                continue\n            if len(nb.children) != 0:\n                continue\n            cand_cost = nn.cost + self._dist(nn.position, nb.position)\n            if cand_cost + 1e-12 < nb.cost and self._edge_free(nn.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, (oldp, nb))\n                nn.add_child(nb)\n                nb.cost = cand_cost\n                edges.append((nn, nb))\n\n    def _remove_edge(self, edges, e):\n        try:\n            idx = edges.index(e)\n            edges.pop(idx)\n        except:\n            pass\n\n    # Single-hop connect\n    def _try_direct_connect(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest_limited(grid, target_pos)\n        if cur is None:\n            return None, False\n        if self._edge_free(cur.position, target_pos):\n            if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    cur.add_child(nn)\n                    tree.append(nn)\n                    nodes.append(nn)\n                    edges.append((cur, nn))\n                    self._grid_add(grid, nn)\n                    return nn, True\n                return cur, True\n        return cur, False\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.6:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(20):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Path utilities\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._visibility_prune(path)\n        p2 = self._shortcut(p1, self.smooth_iters)\n        return self._dedup(p2)",
          "objective": -39.63489,
          "time_improvement": 74.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1481.0,
          "node_improvement": 91.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0037497520446777345,
                    "num_nodes_avg": 34.0,
                    "path_length_avg": 158.58377479850697,
                    "smoothness_avg": 0.06862027615570403,
                    "success_improvement": 0.0,
                    "time_improvement": 84.80115269876273,
                    "node_improvement": 91.4379249559305,
                    "length_improvement": 13.07772011221747,
                    "smoothness_improvement": 974.0563331514488,
                    "objective_score": 38.157259542716545
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028076863288879393,
                    "num_nodes_avg": 111.0,
                    "path_length_avg": 232.17028789754096,
                    "smoothness_avg": 0.0872747392675918,
                    "success_improvement": 0.0,
                    "time_improvement": 83.21279707599672,
                    "node_improvement": 92.54182624470873,
                    "length_improvement": 22.494875248593353,
                    "smoothness_improvement": 2145.641902808952,
                    "objective_score": 49.18897378599979
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02327275276184082,
                    "num_nodes_avg": 98.0,
                    "path_length_avg": 128.55489761473706,
                    "smoothness_avg": 0.11192261290302685,
                    "success_improvement": 0.0,
                    "time_improvement": 53.89408482264104,
                    "node_improvement": 87.53973299427845,
                    "length_improvement": 14.619958130688596,
                    "smoothness_improvement": 1323.6473748585636,
                    "objective_score": 31.55843719949829
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "FALCON-RRT*: Fast Adaptive Local-Connect Optimalizing Bidirectional RRT*. It blends hashed-grid adaptive KNN parenting, dynamic local rewiring with cost propagation, short micro-chain growth, and guided dual-tree bridging. AABB-binned collision with slab tests, informed-corridor sampling, and a three-stage smoother (visibility, corner-cut, shortcuts) jointly improve speed, length, and smoothness while preserving robustness.",
          "planning_mechanism": "Alternate tree growth with micro-chains toward biased samples; for each proposed point, select the best collision-free parent among adaptive KNN and commit; locally rewire neighbors and propagate improved costs; greedily extend the opposite tree a few steps toward the new node and bridge if line-of-sight holds; upon connection, compress by visibility, deterministically cut corners, and random-shortcut the path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        seq = []\n        cur = self\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        return seq[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=7.0,\n        goal_bias=0.20,\n        corridor_bias=0.35,\n        informed_bias=0.25,\n        grid_cell_factor=1.4,\n        k_near_base=8,\n        chain_steps=2,\n        connect_steps=3,\n        smooth_shortcuts=100,\n        corner_passes=2\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.k_near_base = int(max(1, k_near_base))\n        self.chain_steps = int(max(1, chain_steps))\n        self.connect_steps = int(max(1, connect_steps))\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self.corner_passes = int(max(0, corner_passes))\n\n        # runtime state\n        self._rng = 123456789\n\n    # ----------------- Public API -----------------\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n        self._edge_idx = {}\n\n        # Validate start/goal\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Init trees and grids\n        cell = max(1.0, self.step * self.grid_cell_factor)\n        self.cell = cell\n        self.dupe_radius = max(0.4, 0.35 * self.step)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            # Choose active and passive trees\n            active_start_side = (it % 2 == 0)\n            Ta = start_tree if active_start_side else goal_tree\n            Tb = goal_tree if active_start_side else start_tree\n            Ga = grid_a if active_start_side else grid_b\n            Gb = grid_b if active_start_side else grid_a\n            attractor = self.goal if active_start_side else self.start\n\n            # Sample\n            target = self._sample(attractor, best_len)\n            if target is None:\n                continue\n\n            # Nearest and micro-chain grow\n            nearest = self._nearest(Ga, target)\n            if nearest is None:\n                continue\n\n            last_new = self._extend_chain(Ta, Ga, nearest, target, nodes, edges)\n            if last_new is None:\n                continue\n\n            # Rewiring around the last new node\n            self._local_rewire(Ta, Ga, last_new, edges)\n\n            # Try growing the passive tree toward last_new and bridge\n            other_near = self._nearest(Gb, last_new.position)\n            if other_near is None:\n                continue\n            other_last = self._greedy_connect(Tb, Gb, other_near, last_new.position, nodes, edges, self.connect_steps)\n\n            if other_last is not None:\n                if self._edge_free(other_last.position, last_new.position):\n                    # Record bridge for output coherence\n                    self._add_edge_tuple(edges, self._edge_idx, other_last, last_new)\n                    # Assemble path without changing parents across trees\n                    if active_start_side:\n                        pa = last_new.path_from_root()\n                        pb = other_last.path_from_root()\n                        raw = pa + pb[-2::-1]\n                    else:\n                        pa = last_new.path_from_root()\n                        pb = other_last.path_from_root()\n                        raw = pb + pa[-2::-1]\n                    # Smooth\n                    path = self._finalize_path(raw)\n                    best_len = self._path_len(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # ----------------- RNG -----------------\n    def _seed_rng(self):\n        s = 0xA3C59AC3 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int((v + 1.2345) * 2654435761) & 0xffffffff\n            s ^= (q ^ (q >> 16) ^ ((q << 5) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ----------------- Geometry -----------------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(min(max(a[i], 0.0), self.bounds[i]) for i in range(self.dim))\n        if d2 <= step * step:\n            tgt = b\n        else:\n            d = d2 ** 0.5\n            r = step / d\n            tgt = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n        return tuple(min(max(tgt[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # ----------------- Spatial hash grid -----------------\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        r = 0\n        # expand until some candidates found\n        while r <= 4:\n            cand = self._collect_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                        found = True\n                if found:\n                    return best\n            r += 1\n        # fallback: limited scan\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _k_nearest(self, grid, pos, k):\n        key = self._cell_key(pos)\n        cand = []\n        r = 0\n        while len(cand) < k and r <= 5:\n            cand.extend(self._collect_ring(grid, key, r))\n            r += 1\n        # dedup and sort\n        seen = set()\n        scored = []\n        for n in cand:\n            if n in seen:\n                continue\n            seen.add(n)\n            scored.append((self._dist2(n.position, pos), n))\n        scored.sort(key=lambda x: x[0])\n        out = []\n        m = min(k, len(scored))\n        for i in range(m):\n            out.append(scored[i][1])\n        return out\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        cells = max(1, int(radius // self.cell) + 1)\n        r2 = radius * radius\n        if self.is3:\n            for dx in range(-cells, cells + 1):\n                for dy in range(-cells, cells + 1):\n                    for dz in range(-cells, cells + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                return True\n        else:\n            for dx in range(-cells, cells + 1):\n                for dy in range(-cells, cells + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            return True\n        return False\n\n    # ----------------- Obstacles and collision -----------------\n    def _build_obs_bins(self):\n        # obstacle bin cell slightly larger than step to limit candidates\n        self.obs_cell = max(4.0, self.step * 1.1)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            bucket = self.obin.get(key)\n                            if bucket is None:\n                                self.obin[key] = [idx]\n                            else:\n                                bucket.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        bucket = self.obin.get(key)\n                        if bucket is None:\n                            self.obin[key] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        # Collect potentially intersecting obstacles via segment AABB covered bins\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # ----------------- Parenting, rewiring, and edges -----------------\n    def _adaptive_k(self, n_nodes):\n        # scale neighbors sublinearly with tree size\n        return max(self.k_near_base, int(4 + (n_nodes ** 0.5)))\n\n    def _best_parent(self, grid, newp, fallback, step_cap):\n        # Gather candidates around newp; prefer those that can reach in one step\n        k = self._adaptive_k(len(grid))\n        cand = self._k_nearest(grid, newp, k)\n        if fallback not in cand:\n            cand.append(fallback)\n        best = None\n        best_cost = 1e100\n        for n in cand:\n            d = self._dist(n.position, newp)\n            if d > step_cap + 1e-9:\n                continue\n            # edge collision check\n            if not self._edge_free(n.position, newp):\n                continue\n            c = n.cost + d\n            if c < best_cost:\n                best_cost = c\n                best = n\n        return best, best_cost\n\n    def _local_rewire(self, tree, grid, nn, edges):\n        # Try to rewire nearby nodes to nn if cheaper and visible; then propagate cost improvements\n        k = self._adaptive_k(len(grid))\n        neigh = self._k_nearest(grid, nn.position, k)\n        for nb in neigh:\n            if nb is nn or nb is nn.parent:\n                continue\n            # Only consider if nn can reach within one step\n            d = self._dist(nn.position, nb.position)\n            if d > self.step + 1e-9:\n                continue\n            new_cost = nn.cost + d\n            if new_cost + 1e-12 < nb.cost and self._edge_free(nn.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge_tuple(edges, self._edge_idx, oldp, nb)\n                nn.add_child(nb)\n                delta = new_cost - nb.cost\n                nb.cost = new_cost\n                # propagate cost delta to subtree\n                stack = [nb]\n                while stack:\n                    cur = stack.pop()\n                    for ch in cur.children:\n                        ch.cost += delta\n                        stack.append(ch)\n                self._add_edge_tuple(edges, self._edge_idx, nn, nb)\n\n    def _add_edge_tuple(self, edges, edge_map, a, b):\n        edges.append((a, b))\n        edge_map[(id(a), id(b))] = len(edges) - 1\n\n    def _remove_edge_tuple(self, edges, edge_map, a, b):\n        key = (id(a), id(b))\n        idx = edge_map.get(key)\n        if idx is None:\n            return\n        last_idx = len(edges) - 1\n        if idx != last_idx:\n            edges[idx] = edges[last_idx]\n            pa, pb = edges[idx]\n            edge_map[(id(pa), id(pb))] = idx\n        edges.pop()\n        try:\n            del edge_map[key]\n        except:\n            pass\n\n    # ----------------- Growth/connection -----------------\n    def _extend_chain(self, tree, grid, start_node, target, nodes, edges):\n        cur = start_node\n        last = None\n        for _ in range(self.chain_steps):\n            prop = self._steer(cur.position, target, self.step)\n            if (not self._in_bounds(prop)) or self._point_blocked(prop):\n                break\n            if self._exists_close(grid, prop, self.dupe_radius):\n                break\n            parent, pcost = self._best_parent(grid, prop, cur, self.step)\n            if parent is None:\n                break\n            # Node collision and Edge collision checked above via _point_blocked and _edge_free(parent, prop)\n            nn = Node(prop, parent, pcost)\n            parent.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            self._grid_add(grid, nn)\n            self._add_edge_tuple(edges, self._edge_idx, parent, nn)\n            last = nn\n            cur = nn\n            # small early stop if close to target\n            if self._dist(cur.position, target) <= self.step:\n                break\n        return last\n\n    def _greedy_connect(self, tree, grid, from_node, target_pos, nodes, edges, max_steps):\n        cur = from_node\n        last_new = None\n        for _ in range(max_steps):\n            nxt = self._steer(cur.position, target_pos, self.step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                break\n            if not self._edge_free(cur.position, nxt):\n                break\n            if self._exists_close(grid, nxt, self.dupe_radius * 0.5):\n                # too dense to add another node here\n                break\n            nn = Node(nxt, cur, cur.cost + self._dist(cur.position, nxt))\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            self._grid_add(grid, nn)\n            self._add_edge_tuple(edges, self._edge_idx, cur, nn)\n            last_new = nn\n            cur = nn\n            if self._dist(cur.position, target_pos) <= self.step:\n                break\n        return last_new\n\n    # ----------------- Sampling -----------------\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        # informed sampling if path known\n        if best_len is not None and r < self.informed_bias:\n            p = self._sample_informed_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        # goal bias toward attractor\n        if r < self.goal_bias:\n            return attractor\n        # corridor-biased sampling\n        if r < self.goal_bias + self.corridor_bias:\n            t = self._rand()\n            base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n            width = max(self.step, 0.18 * self._dist(self.start, self.goal))\n            if self.is3:\n                # sample small random vector inside ball\n                for _ in range(5):\n                    vx = self._rand_range(-1.0, 1.0)\n                    vy = self._rand_range(-1.0, 1.0)\n                    vz = self._rand_range(-1.0, 1.0)\n                    s2 = vx * vx + vy * vy + vz * vz\n                    if s2 < 1e-12 or s2 > 1.0:\n                        continue\n                    inv = (s2 ** 0.5)\n                    vx /= inv\n                    vy /= inv\n                    vz /= inv\n                    rad = self._rand() * width\n                    p = (self._clamp(base[0] + vx * rad, 0.0, self.bounds[0]),\n                         self._clamp(base[1] + vy * rad, 0.0, self.bounds[1]),\n                         self._clamp(base[2] + vz * rad, 0.0, self.bounds[2]))\n                    if not self._point_blocked(p):\n                        return p\n            else:\n                # 2D: jitter perpendicular-ish\n                ang = self._rand_range(0.0, 6.283185307179586)\n                rad = self._rand() * width\n                p = (self._clamp(base[0] + rad * (1.0 * (ang - int(ang / 6.283185307179586) * 6.283185307179586) * 0.0 + (1.0) * (self._cos_sin(ang)[1])), 0.0, self.bounds[0]),\n                     self._clamp(base[1] + rad * (self._cos_sin(ang)[0]), 0.0, self.bounds[1]))\n                if not self._point_blocked(p):\n                    return p\n        # uniform in bounds, reject obstacles with a few attempts\n        for _ in range(8):\n            if self.is3:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n            else:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n            if not self._point_blocked(p):\n                return p\n        # fallback\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_informed_ellipse(self, f1, f2, max_sum):\n        # simple bounded retries to avoid wasting time\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half) for _ in range(self.dim)]\n        for _ in range(10):\n            if self.is3:\n                p = (self._clamp(c[0] + self._rand_range(-ext[0], ext[0]), 0.0, self.bounds[0]),\n                     self._clamp(c[1] + self._rand_range(-ext[1], ext[1]), 0.0, self.bounds[1]),\n                     self._clamp(c[2] + self._rand_range(-ext[2], ext[2]), 0.0, self.bounds[2]))\n            else:\n                p = (self._clamp(c[0] + self._rand_range(-ext[0], ext[0]), 0.0, self.bounds[0]),\n                     self._clamp(c[1] + self._rand_range(-ext[1], ext[1]), 0.0, self.bounds[1]))\n            if self._dist(p, f1) + self._dist(p, f2) <= max_sum and (not self._point_blocked(p)):\n                return p\n        return None\n\n    def _clamp(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    def _cos_sin(self, ang):\n        # Very rough polynomial approximations for cos/sin to avoid imports; acceptable for jitter\n        x = ang\n        # wrap to [-pi, pi]\n        pi = 3.141592653589793\n        two = 2.0 * pi\n        k = int(x / two)\n        x = x - k * two\n        if x > pi:\n            x -= two\n        if x < -pi:\n            x += two\n        x2 = x * x\n        # cos approx: 1 - x^2/2 + x^4/24\n        c = 1.0 - 0.5 * x2 + (x2 * x2) / 24.0\n        # sin approx: x - x^3/6 + x^5/120\n        s = x - (x * x2) / 6.0 + (x * x2 * x2) / 120.0\n        return (c, s)\n\n    # ----------------- Path utilities and smoothing -----------------\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return list(pts)\n        out = [pts[0]]\n        anchor = pts[0]\n        i = 1\n        while i < len(pts):\n            far = i\n            j = i\n            while j < len(pts):\n                if self._edge_free(anchor, pts[j]):\n                    far = j\n                    j += 1\n                else:\n                    break\n            out.append(pts[far])\n            anchor = pts[far]\n            i = far + 1\n        out[0] = pts[0]\n        out[-1] = pts[-1]\n        return out\n\n    def _corner_cut_pass(self, pts):\n        if len(pts) < 3:\n            return list(pts)\n        out = list(pts)\n        changed = False\n        i = 1\n        while i < len(out) - 1:\n            a = out[i - 1]\n            c = out[i + 1]\n            if self._edge_free(a, c):\n                out = out[:i] + out[i + 1:]\n                changed = True\n            else:\n                i += 1\n        return out, changed\n\n    def _shortcut_random(self, pts, attempts):\n        if len(pts) < 3:\n            return list(pts)\n        cur = list(pts)\n        n = len(cur)\n        tries = 0\n        while tries < attempts and n > 2:\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n                n = len(cur)\n            tries += 1\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._visibility_prune(path)\n        p2 = p1\n        for _ in range(self.corner_passes):\n            p2, changed = self._corner_cut_pass(p2)\n            if not changed:\n                break\n        p3 = self._shortcut_random(p2, self.smooth_shortcuts)\n        return self._dedup(p3)",
          "objective": -39.48194,
          "time_improvement": 80.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1729.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0066203117370605465,
                    "num_nodes_avg": 51.0,
                    "path_length_avg": 169.2632587687305,
                    "smoothness_avg": 0.052038861274425266,
                    "success_improvement": 0.0,
                    "time_improvement": 73.16593044572372,
                    "node_improvement": 87.15688743389575,
                    "length_improvement": 7.224125720885088,
                    "smoothness_improvement": 714.5211831407076,
                    "objective_score": 29.856860481951706
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01932368278503418,
                    "num_nodes_avg": 125.0,
                    "path_length_avg": 249.76071253052902,
                    "smoothness_avg": 0.12334472792906206,
                    "success_improvement": 0.0,
                    "time_improvement": 88.44633815345315,
                    "node_improvement": 91.6011556809783,
                    "length_improvement": 16.622685193802127,
                    "smoothness_improvement": 3073.748691231289,
                    "objective_score": 51.87625601847366
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010326528549194336,
                    "num_nodes_avg": 75.0,
                    "path_length_avg": 135.88985314178007,
                    "smoothness_avg": 0.11794162873048301,
                    "success_improvement": 0.0,
                    "time_improvement": 79.5419968476445,
                    "node_improvement": 90.46408137317228,
                    "length_improvement": 9.748429922675173,
                    "smoothness_improvement": 1400.2088119062716,
                    "objective_score": 36.71270106742981
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "FALCON-IRRTConnect: Fast Adaptive Local-Optimal RRT-Connect with hashed neighbors and obstacle-binned collisions. It couples rapid bidirectional connect growth for early success with light, radius-limited RRT*-style parent selection and bounded local rewiring. Coarse obstacle binning and cached segment tests cut collision cost; a uniform grid hash enables sublinear nearest/neighbor queries. After a connection, a compact shortcut + visibility + elastic refinement shortens and smooths the path.",
          "planning_mechanism": "Alternate expanding start/goal trees: sample (goal/informed biased), steer one step, pick best-cost parent from nearby nodes, add only if node- and edge-free, and locally rewire cheaper neighbors. Then greedily extend the opposite tree toward the new node, inserting the exact meeting node when visible. On success, extract the path and run shortcut, visibility prune, and elastic smoothing; return the improved path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5200,\n        step_size=5.5,\n        connect_mult=2.4,\n        goal_bias=0.14,\n        grid_cell_factor=1.5,\n        dup_radius_factor=0.38,\n        rewire_base=2.0,\n        rewire_decay=3200.0,\n        neighbor_cap=14,\n        smooth_iters=140,\n        elastic_sweeps=20\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_step = float(connect_mult) * self.step\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dup_radius_factor = float(dup_radius_factor)\n        self.rewire_base = float(rewire_base)\n        self.rewire_decay = float(rewire_decay)\n        self.neighbor_cap = int(neighbor_cap)\n        self.smooth_iters = int(max(0, smooth_iters))\n        self.elastic_sweeps = int(max(0, elastic_sweeps))\n        self._rng = 123456789\n\n    # --------- Public API ----------\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        # RNG seed from scene\n        self._seed_from_scene()\n\n        # Spatial hashing and parameters\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_radius = max(0.5, self.dup_radius_factor * self.step)\n\n        # Collision acceleration and caches\n        self._build_obs_bins()\n        self._edge_cache = {}  # canonical (a,b) -> bool (True if hits obstacle)\n        self._free_cache = {}  # canonical (a,b) -> bool (True if free)\n\n        # Validate start and goal\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight-line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            final = self._finalize_path(path)\n            return PlannerResult(True, final, nodes, edges)\n\n        # Initialize trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        Ta, Tb = [start_root], [goal_root]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, start_root)\n        self._grid_add(Gb, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = Ta if active_start else Tb\n            tree_b = Tb if active_start else Ta\n            grid_a = Ga if active_start else Gb\n            grid_b = Gb if active_start else Ga\n            attractor = self.goal if active_start else self.start\n\n            # Sampling with goal and informed elliptical bias\n            sample = self._sample(attractor, best_len)\n            if sample is None:\n                continue\n\n            # Nearest and steer\n            na = self._nearest(grid_a, sample)\n            if na is None:\n                continue\n            newp = self._steer(na.position, sample, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(grid_a, newp, self.dup_radius):\n                continue\n            # Edge collision check parent->newp before adding\n            if not self._edge_free(na.position, newp):\n                continue\n\n            # Cost-aware parent selection within adaptive radius\n            rew_rad = self._adaptive_rewire_radius(len(tree_a))\n            parent, new_cost = self._choose_parent(grid_a, newp, na, rew_rad)\n\n            # Validate chosen parent again (node+edge)\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._in_bounds(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            # Insert node\n            nn = Node(newp, parent, new_cost)\n            parent.add_child(nn)\n            tree_a.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(grid_a, nn)\n\n            # Local bounded rewiring\n            self._local_rewire(grid_a, nn, rew_rad, edges, cap=self.neighbor_cap)\n\n            # Try to greedily connect opposite tree toward new point\n            meet_node, reached = self._connect_toward(tree_b, grid_b, nn.position, nodes, edges)\n            if reached:\n                # Build full path with exact meeting node if inserted\n                if active_start:\n                    pa = self._trace_to_root(nn)\n                    pb = self._trace_to_root(meet_node)\n                    path = pa + pb[-2::-1]\n                else:\n                    pa = self._trace_to_root(meet_node)\n                    pb = self._trace_to_root(nn)\n                    path = pa + pb[-2::-1]\n\n                path = self._dedup(path)\n                best_len = self._path_len(path)\n\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # --------- RNG ----------\n    def _seed_from_scene(self):\n        s = 0x9E3779B9 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= (q ^ (q >> 13) ^ ((q << 7) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 17) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # --------- Geometry ----------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # --------- Spatial hash ----------\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        for r in range(0, 4):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found = True\n            if found:\n                return best\n        # fallback scan\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius, cap=None):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n                                if cap is not None and len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n                            if cap is not None and len(out) >= cap:\n                                return out\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        nb = self._neighbors_in_radius(grid, pos, radius, cap=1)\n        return len(nb) > 0\n\n    # --------- Obstacles / collision ----------\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.2)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy1, iy0 - 1, -1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        key = self._canon_seg(a, b)\n        val = self._free_cache.get(key)\n        if val is not None:\n            return val\n        blk = self._edge_hits_any(a, b)\n        res = not blk\n        self._free_cache[key] = res\n        self._edge_cache[key] = blk\n        return res\n\n    def _edge_hits_any(self, a, b):\n        key = self._canon_seg(a, b)\n        cached = self._edge_cache.get(key)\n        if cached is not None:\n            return cached\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                self._edge_cache[key] = False\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    self._edge_cache[key] = True\n                    return True\n            self._edge_cache[key] = False\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                self._edge_cache[key] = False\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    self._edge_cache[key] = True\n                    return True\n            self._edge_cache[key] = False\n            return False\n\n    def _canon_seg(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # --------- Parenting / rewiring ----------\n    def _adaptive_rewire_radius(self, n_nodes):\n        base = max(self.step * 1.2, self.step * self.rewire_base)\n        decay = pow(0.5, n_nodes / max(1.0, self.rewire_decay))\n        return max(self.step * 1.2, base * decay)\n\n    def _choose_parent(self, grid, newp, fallback, radius):\n        parent = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        neigh = self._neighbors_in_radius(grid, newp, radius, cap=self.neighbor_cap * 2)\n        for n in neigh:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                parent = n\n                best_cost = c\n        return parent, best_cost\n\n    def _local_rewire(self, grid, nn, radius, edges, cap=14):\n        neigh = self._neighbors_in_radius(grid, nn.position, radius, cap=cap)\n        for nb in neigh:\n            if nb is nn or nb is nn.parent:\n                continue\n            cand_cost = nn.cost + self._dist(nn.position, nb.position)\n            if cand_cost + 1e-12 < nb.cost and self._edge_free(nn.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, (oldp, nb))\n                nn.add_child(nb)\n                nb.cost = cand_cost\n                edges.append((nn, nb))\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _remove_edge(self, edges, e):\n        try:\n            idx = edges.index(e)\n            edges.pop(idx)\n        except:\n            pass\n\n    # --------- BiRRT-Connect toward target ----------\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < 64:\n            # If direct visibility, insert exact meeting node if valid\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                    if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        # Ensure node and edge checks before adding\n                        if (not self._point_in_obstacles(nn.position)) and self._edge_free(cur.position, nn.position):\n                            cur.add_child(nn)\n                            tree.append(nn)\n                            nodes.append(nn)\n                            edges.append((cur, nn))\n                            self._grid_add(grid, nn)\n                            return nn, True\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if self._too_close(grid, nxt, self.dup_radius * 0.75):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            # Checks before adding (node+edge already ensured above)\n            if self._point_in_obstacles(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                return cur, False\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n        # Final visibility attempt\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    if (not self._point_in_obstacles(nn.position)) and self._edge_free(cur.position, nn.position):\n                        cur.add_child(nn)\n                        tree.append(nn)\n                        nodes.append(nn)\n                        edges.append((cur, nn))\n                        self._grid_add(grid, nn)\n                        return nn, True\n            return cur, True\n        return cur, False\n\n    # --------- Sampling ----------\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.6:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(28):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # --------- Path utilities ----------\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _elastic_refine(self, pts, sweeps):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(sweeps):\n            changed = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                b = cur[i + 1]\n                # Try corner cut first\n                if self._edge_free(a, b):\n                    cur = cur[:i] + cur[i + 1:]\n                    changed = True\n                    break\n                # Try small relaxation toward midpoint\n                mid = tuple(0.5 * (a[k] + b[k]) for k in range(self.dim))\n                if self._in_bounds(mid) and (not self._point_in_obstacles(mid)):\n                    if self._edge_free(a, mid) and self._edge_free(mid, b):\n                        cur[i] = mid\n                        changed = True\n            if not changed:\n                break\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._shortcut(path, self.smooth_iters)\n        p2 = self._visibility_prune(p1)\n        p3 = self._elastic_refine(p2, self.elastic_sweeps)\n        return self._dedup(p3)",
          "objective": -39.28686,
          "time_improvement": 58.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 2409.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013451361656188964,
                    "num_nodes_avg": 62.0,
                    "path_length_avg": 158.49463611924995,
                    "smoothness_avg": 0.04911862032665335,
                    "success_improvement": 0.0,
                    "time_improvement": 45.4776770916583,
                    "node_improvement": 84.38680433140266,
                    "length_improvement": 13.126578434811004,
                    "smoothness_improvement": 668.8130709033614,
                    "objective_score": 24.8633155429009
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027135133743286133,
                    "num_nodes_avg": 156.0,
                    "path_length_avg": 245.64654428530534,
                    "smoothness_avg": 0.20810072097894103,
                    "success_improvement": 0.0,
                    "time_improvement": 83.77585872639358,
                    "node_improvement": 89.51824228986092,
                    "length_improvement": 17.996112973824765,
                    "smoothness_improvement": 5254.581439678919,
                    "objective_score": 62.203332600607524
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02812962532043457,
                    "num_nodes_avg": 229.0,
                    "path_length_avg": 122.99494476089357,
                    "smoothness_avg": 0.11045249123540399,
                    "success_improvement": 0.0,
                    "time_improvement": 44.27207935962878,
                    "node_improvement": 70.8836617927527,
                    "length_improvement": 18.312614079707338,
                    "smoothness_improvement": 1304.9475357594947,
                    "objective_score": 30.79392993451051
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "AURORA-BiRRT*: Adaptive Unified Rewire-Optimized Receding-Envelope BiRRT with Curvature-Aware Smoothing. It grows two trees with adaptive step sizing in clutter, dynamic-radius best-parent selection, bounded rewiring, and multi-step micro-bridging. Sampling blends goal, corridor, and informed prolate-ellipse regions using an incumbent path. A voxelized obstacle index accelerates exact slab-based segment-AABB checks. On connection, visibility compression, probabilistic shortcuts, and an angle-aware elastic smoother produce shorter, smoother paths quickly and robustly.",
          "planning_mechanism": "Alternate expanding start/goal trees. Each iteration: biased target sampling (goal/corridor/informed/uniform), ring-hash nearest, adaptive steer with local clutter feedback, and strict node+edge collision checks. Select a least-cost parent from radius-limited neighbors, insert, then leap to a visible ancestor and rewire a few cheaper neighbors. Attempt direct or multi-step micro-bridge to the opposite tree. Maintain an incumbent best length to focus informed sampling. On success, assemble and postprocess the path (visibility prune, bounded shortcuts, curvature-aware elastic smoothing) and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        pts = []\n        cur = self\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=7.0,\n        goal_bias=0.2,\n        corridor_bias=0.4,\n        informed_bias=0.5,\n        grid_cell_factor=1.25,\n        dupe_radius_factor=0.35,\n        connect_factor=2.75,\n        rewire_radius_mult=2.0,\n        neighbor_cap=48,\n        bridge_trials=2,\n        rewire_cap=8,\n        shortcut_trials=120,\n        smooth_iters=18\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dupe_radius_factor = float(dupe_radius_factor)\n        self.connect_factor = float(connect_factor)\n        self.rewire_radius_mult = float(rewire_radius_mult)\n        self.neighbor_cap = int(neighbor_cap)\n        self.bridge_trials = int(max(0, bridge_trials))\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.shortcut_trials = int(max(0, shortcut_trials))\n        self.smooth_iters = int(max(0, smooth_iters))\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if getattr(map, \"obstacles\", None) else []\n\n        # Validate endpoints\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_rng()\n        self._build_obs_index()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if self._segment_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Derived params\n        self.cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_r = max(0.5, self.step_size * self.dupe_radius_factor)\n        self.connect_dist = max(self.step_size, self.connect_factor * self.step_size)\n        self.corridor_w = max(self.step_size, 0.2 * self._dist(self.start, self.goal))\n\n        # Trees and grids\n        nodes = []\n        edges = []\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_put(Ga, a_root)\n        self._grid_put(Gb, b_root)\n\n        best_len = float('inf')\n        best_path = None\n\n        for it in range(self.max_iter):\n            grow_a = (it % 2 == 0)\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            attractor = self.goal if grow_a else self.start\n\n            target = self._sample_target(attractor, best_len)\n            if target is None:\n                continue\n\n            near = self._nearest(G, target, T)\n            if near is None:\n                continue\n\n            new_pos = self._steer_adaptive(near.position, target)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._point_blocked(new_pos):\n                continue\n            if self._has_duplicate(G, new_pos, self.dupe_r):\n                continue\n\n            parent, new_cost = self._choose_parent(G, T, new_pos)\n            if parent is None:\n                continue\n            if self._point_blocked(new_pos) or not self._segment_free(parent.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            T.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_put(G, new_node)\n\n            # Ancestor visibility leap\n            self._ancestor_leap(new_node, edges)\n\n            # Local bounded rewiring\n            self._rewire_local(G, new_node, edges)\n\n            # Try to connect to the opposite tree\n            other = self._nearest(Gopp, new_node.position, Topp)\n            connected = False\n            end_node = None\n            if other is not None:\n                if self._dist(new_node.position, other.position) <= self.connect_dist and self._segment_free(new_node.position, other.position):\n                    connected = True\n                    end_node = other\n                else:\n                    # Micro-bridge steps from the opposite tree\n                    head = other\n                    for _ in range(self.bridge_trials):\n                        step_p = self._steer_adaptive(head.position, new_node.position)\n                        if not self._in_bounds(step_p) or self._point_blocked(step_p):\n                            break\n                        if self._has_duplicate(Gopp, step_p, self.dupe_r):\n                            break\n                        if not self._segment_free(head.position, step_p):\n                            break\n                        q = Node(step_p, head, head.cost + self._dist(head.position, step_p))\n                        head.add_child(q)\n                        Topp.append(q)\n                        nodes.append(q)\n                        edges.append((head, q))\n                        self._grid_put(Gopp, q)\n                        self._ancestor_leap(q, edges)\n                        self._rewire_local(Gopp, q, edges)\n                        head = q\n                        if self._segment_free(new_node.position, head.position):\n                            connected = True\n                            end_node = head\n                            break\n\n            if connected and end_node is not None:\n                path = self._assemble(new_node, end_node, grow_a)\n                path = self._postprocess(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Maintain incumbent for informed sampling\n            if other is not None and self._segment_free(new_node.position, other.position):\n                tmp = self._assemble(new_node, other, grow_a)\n                L = self._path_len(tmp)\n                if L < best_len:\n                    best_len = L\n                    best_path = tmp\n\n        if best_path is not None:\n            best_path = self._postprocess(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            s = (s * 2654435761 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 13) * 1103515245\n        self._rng = s if s != 0 else 2463534242\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry and bounds\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer_adaptive(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        # Base step\n        step = self.step_size if d > self.step_size else d\n        # Estimate local clutter by obstacle index buckets overlapped by tentative step box\n        dirv = tuple((b[i] - a[i]) / d for i in range(self.dims))\n        trial = tuple(a[i] + dirv[i] * step for i in range(self.dims))\n        clutter = self._box_bucket_density(a, trial)\n        if clutter > 10 and step > 0.5 * self.step_size:\n            step *= 0.6\n            trial = tuple(a[i] + dirv[i] * step for i in range(self.dims))\n            clutter = self._box_bucket_density(a, trial)\n            if clutter > 14 and step > 0.3 * self.step_size:\n                step *= 0.6\n                trial = tuple(a[i] + dirv[i] * step for i in range(self.dims))\n        return self._clamp(trial)\n\n    # Sampling\n    def _sample_target(self, attractor, best_len):\n        for _ in range(16):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._sample_informed(best_len * 1.02)\n                if p is not None and not self._point_blocked(p):\n                    return p\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attractor\n            elif r < self.goal_bias + self.corridor_bias:\n                t = self._rand()\n                base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n                if self.dims == 3:\n                    p = (self._rand_range(base[0] - self.corridor_w, base[0] + self.corridor_w),\n                         self._rand_range(base[1] - self.corridor_w, base[1] + self.corridor_w),\n                         self._rand_range(base[2] - self.corridor_w, base[2] + self.corridor_w))\n                else:\n                    p = (self._rand_range(base[0] - self.corridor_w, base[0] + self.corridor_w),\n                         self._rand_range(base[1] - self.corridor_w, base[1] + self.corridor_w))\n            else:\n                if self.dims == 3:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n            p = self._clamp(p)\n            if not self._point_blocked(p):\n                return p\n        return None\n\n    def _sample_informed(self, max_sum):\n        c = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        # Axis-aligned rejection in prolate envelope\n        for _ in range(24):\n            if self.dims == 3:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half),\n                     self._rand_range(c[2] - half, c[2] + half))\n            else:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half))\n            if self._in_bounds(p) and (self._dist(p, self.start) + self._dist(p, self.goal)) <= max_sum:\n                return p\n        return None\n\n    # Node grid\n    def _cell_of(self, pos):\n        return tuple(int(pos[i] // self.cell) for i in range(self.dims))\n\n    def _grid_put(self, grid, node):\n        k = self._cell_of(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _ring_nodes(self, grid, key, r):\n        out = []\n        if self.dims == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos, tree):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        for r in range(0, 4):\n            cand = self._ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback limited scan\n        if not tree:\n            return None\n        step = max(1, len(tree) // 64)\n        for i in range(0, len(tree), step):\n            n = tree[i]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, cap):\n        key = self._cell_of(pos)\n        r = max(1, int(radius // self.cell) + 1)\n        cand = self._ring_nodes(grid, key, r)\n        out = []\n        rr = radius * radius\n        for n in cand:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= rr:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _has_duplicate(self, grid, pos, radius):\n        return len(self._neighbors(grid, pos, radius, self.neighbor_cap)) > 0\n\n    # Parent selection and optimization\n    def _choose_parent(self, grid, tree, new_pos):\n        n = max(1, len(tree))\n        # RRT* radius ~ (log(n)/n)^{1/d} scaled\n        base = (self.rewire_radius_mult * self.step_size)\n        dyn_r = max(self.step_size, base * ((1.0 + self._log1p(n)) / n) ** (1.0 / max(1, self.dims)))\n        neigh = self._neighbors(grid, new_pos, dyn_r, self.neighbor_cap)\n        if not neigh:\n            # fallback to nearest in tree\n            near = None\n            bestd = 1e100\n            for m in tree:\n                d = self._dist(m.position, new_pos)\n                if d < bestd:\n                    bestd = d\n                    near = m\n            neigh = [near] if near is not None else []\n        best_p = None\n        best_c = 1e100\n        for p in neigh:\n            d = self._dist(p.position, new_pos)\n            gc = p.cost + d\n            if gc + 1e-9 < best_c and self._segment_free(p.position, new_pos):\n                best_c = gc\n                best_p = p\n        if best_p is None:\n            return None, None\n        return best_p, best_c\n\n    def _log1p(self, x):\n        # simple series for small x; adequate for our integer n\n        return 0.5 if x <= 1.0 else self._fast_log(x + 1.0)\n\n    def _fast_log(self, x):\n        # crude monotonic approximation using change-of-base and piecewise\n        y = 0.0\n        t = x\n        while t > 2.718281828:\n            t *= 0.367879441  # divide by e\n            y += 1.0\n        # linear tail\n        return y + (t - 1.0) / 2.718281828\n\n    def _ancestor_leap(self, node, edges):\n        curp = node.parent\n        if curp is None:\n            return\n        bestp = curp\n        bestc = node.cost\n        anc = curp.parent\n        while anc is not None:\n            if self._segment_free(anc.position, node.position):\n                c = anc.cost + self._dist(anc.position, node.position)\n                if c + 1e-9 < bestc:\n                    bestc = c\n                    bestp = anc\n            anc = anc.parent\n        if bestp is not curp:\n            self._reparent(node, bestp, edges)\n\n    def _rewire_local(self, grid, node, edges):\n        radius = max(self.step_size, self.rewire_radius_mult * self.step_size)\n        neigh = self._neighbors(grid, node.position, radius, self.neighbor_cap)\n        improvements = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if node.cost + d + 1e-9 < nb.cost and self._segment_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n                improvements += 1\n                if improvements >= self.rewire_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        if child.parent is new_parent:\n            return\n        if not self._segment_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._remove_edge(edges, old, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        # propagate cost to subtree\n        stack = [child]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if abs(newc - ch.cost) > 1e-12:\n                    ch.cost = newc\n                    stack.append(ch)\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is p and e[1] is c:\n                edges.pop(i)\n                return\n\n    # Obstacles and collision\n    def _build_obs_index(self):\n        # Cell size for obstacle spatial index\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.dims == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obs_grid.get(key)\n                            if b is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obs_grid.get(key)\n                        if b is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_blocked(self, p):\n        if self.dims == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _segment_free(self, a, b):\n        return not self._segment_hits(a, b)\n\n    def _box_bucket_density(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            s = 0\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obs_grid.get((i, j, k))\n                        if bkt:\n                            s += len(bkt)\n            return s\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            s = 0\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obs_grid.get((i, j))\n                    if bkt:\n                        s += len(bkt)\n            return s\n\n    def _segment_hits(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obs_grid.get((i, j, k))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit3d(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obs_grid.get((i, j))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit2d(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit2d(self, p0, p1, bmin, bmax):\n        # Slab method\n        t0, t1 = 0.0, 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _seg_box_hit3d(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Path assembly and postprocess\n    def _assemble(self, u, v, a_side):\n        pu = u.path_from_root()\n        pv = v.path_from_root()\n        if a_side:\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _postprocess(self, path):\n        if len(path) < 2:\n            return path[:]\n        p = self._visibility_prune(path)\n        p = self._shortcut(p, self.shortcut_trials)\n        p = self._elastic_angle_smooth(p, self.smooth_iters)\n        return p\n\n    def _visibility_prune(self, path):\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._segment_free(out[-1], path[j]):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i + 1])\n                i += 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = list(path)\n        best = self._path_len(pts)\n        n = len(pts)\n        fail = 0\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1:\n                fail += 1\n                if fail > 24:\n                    break\n                continue\n            a, b = pts[i], pts[j - 1]\n            if self._segment_free(a, b):\n                cand = pts[:i + 1] + pts[j - 1:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    pts = cand\n                    best = L\n                    n = len(pts)\n                    fail = 0\n                else:\n                    fail += 1\n            else:\n                fail += 1\n            if fail > 48:\n                break\n        return pts\n\n    def _elastic_angle_smooth(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return path[:]\n        pts = list(path)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                b = pts[i]\n                c = pts[i + 1]\n                # Angle-aware midpoint pull\n                mid = tuple(0.25 * a[k] + 0.5 * b[k] + 0.25 * c[k] for k in range(self.dims))\n                if self._point_blocked(mid):\n                    continue\n                if self._segment_free(a, mid) and self._segment_free(mid, c):\n                    if mid != b:\n                        pts[i] = mid\n                        moved = True\n                # Try skip if possible\n                if self._segment_free(a, c):\n                    pts[i] = c  # will be removed next pass by neighbors\n                    moved = True\n            # Compact duplicates\n            comp = [pts[0]]\n            for p in pts[1:]:\n                if p != comp[-1]:\n                    comp.append(p)\n            pts = comp\n            if not moved:\n                break\n            if len(pts) < 3:\n                break\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        return pts",
          "objective": -39.0221,
          "time_improvement": 68.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1312.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009383320808410645,
                    "num_nodes_avg": 51.0,
                    "path_length_avg": 148.31907804876715,
                    "smoothness_avg": 0.03583382190014427,
                    "success_improvement": 0.0,
                    "time_improvement": 61.966642474939334,
                    "node_improvement": 87.15688743389575,
                    "length_improvement": 18.703963055278603,
                    "smoothness_improvement": 460.8771271269766,
                    "objective_score": 32.11675621128384
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.043584227561950684,
                    "num_nodes_avg": 172.0,
                    "path_length_avg": 228.72791182641134,
                    "smoothness_avg": 0.08818936081319215,
                    "success_improvement": 0.0,
                    "time_improvement": 73.9409183696743,
                    "node_improvement": 88.44319021702614,
                    "length_improvement": 23.644039464437803,
                    "smoothness_improvement": 2169.175773952521,
                    "objective_score": 47.21457805932758
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01668705940246582,
                    "num_nodes_avg": 82.0,
                    "path_length_avg": 122.67227871244054,
                    "smoothness_avg": 0.1106371606216832,
                    "success_improvement": 0.0,
                    "time_improvement": 66.9410768359495,
                    "node_improvement": 89.57406230133503,
                    "length_improvement": 18.526913505383728,
                    "smoothness_improvement": 1307.2965167220898,
                    "objective_score": 37.73495373762554
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "SPARK-Lite: an ultra-fast bi-directional RRT-Connect variant with quasi-random sampling, single-shot exact meeting, compact spatial hashing, and obstacle binning. It minimizes collision checks via direct-connect attempts only (no greedy multi-step linking), tight duplicate-spacing, and tiny-ring approximate nearest queries. Post-processing is a minimal visibility prune with a few shortcuts for near-zero overhead.",
          "planning_mechanism": "Alternate growing start/goal trees. Each iteration: draw a free sample from a Halton-guided sequence with a small goal bias; steer one step from the nearest node (approximate via a 1\u20132 ring spatial hash); if node and edge are collision-free and not too close to existing nodes, insert it. Immediately attempt a single direct connection to the opposite tree and to the goal via exact meeting nodes (with full node+edge checks). On success, stitch roots through the meeting point and apply a fast visibility prune and a few shortcuts, then return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=7.5,\n        goal_bias=0.08,\n        grid_cell_factor=1.0,\n        min_separation_mult=0.6,\n        smooth_shortcuts=12\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.min_sep_mult = float(min_separation_mult)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self._rng = 1\n        self._hidx = 1\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step * self.min_sep_mult)\n\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Direct path fast check\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize trees and grids\n        root_s = Node(self.start, None, 0.0)\n        root_g = Node(self.goal, None, 0.0)\n        Ta = [root_s]\n        Tb = [root_g]\n        Ga = {}\n        Gb = {}\n        self._grid_add(Ga, root_s)\n        self._grid_add(Gb, root_g)\n        nodes.extend([root_s, root_g])\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            T_src = Ta if active_start else Tb\n            T_dst = Tb if active_start else Ta\n            G_src = Ga if active_start else Gb\n            G_dst = Gb if active_start else Ga\n            attractor = self.goal if active_start else self.start\n\n            q_rand = self._sample_free(attractor)\n            if q_rand is None:\n                continue\n\n            n_near = self._nearest(G_src, q_rand, T_src)\n            if n_near is None:\n                continue\n\n            q_new = self._steer(n_near.position, q_rand, self.step)\n            if (not self._in_bounds(q_new)) or self._point_in_obstacles(q_new):\n                continue\n            if not self._edge_free(n_near.position, q_new):\n                continue\n            if self._too_close(G_src, q_new, self.min_sep):\n                continue\n\n            nn = self._insert_node(T_src, G_src, n_near, q_new, nodes, edges)\n            if nn is None:\n                continue\n\n            # Try direct connect to global goal from start side (and vice-versa symmetrically)\n            if active_start:\n                if self._in_bounds(self.goal) and (not self._point_in_obstacles(self.goal)):\n                    if self._edge_free(nn.position, self.goal):\n                        meet = self._insert_node(T_src, G_src, nn, self.goal, nodes, edges)\n                        if meet is not None:\n                            pa = self._trace_to_root(meet)\n                            pb = self._trace_to_root(root_g)\n                            path = pa + pb[-2::-1]\n                            path = self._finalize_path(path)\n                            return PlannerResult(True, path, nodes, edges)\n            else:\n                if self._in_bounds(self.start) and (not self._point_in_obstacles(self.start)):\n                    if self._edge_free(nn.position, self.start):\n                        meet = self._insert_node(T_src, G_src, nn, self.start, nodes, edges)\n                        if meet is not None:\n                            pa = self._trace_to_root(meet)\n                            pb = self._trace_to_root(root_s)\n                            path = pa + pb[-2::-1]\n                            path = self._finalize_path(path)\n                            return PlannerResult(True, path, nodes, edges)\n\n            # Single-shot exact meeting with opposite tree\n            n_other = self._nearest(G_dst, nn.position, T_dst)\n            if n_other is not None and self._edge_free(n_other.position, nn.position):\n                # Prefer inserting exact meeting in the opposite tree for a clean junction\n                if (not self._too_close(G_dst, nn.position, self.min_sep)) and (not self._point_in_obstacles(nn.position)):\n                    meetB = self._insert_node(T_dst, G_dst, n_other, nn.position, nodes, edges)\n                else:\n                    meetB = n_other\n                if meetB is not None:\n                    if active_start:\n                        pa = self._trace_to_root(nn)\n                        pb = self._trace_to_root(meetB)\n                        path = pa + pb[-2::-1]\n                    else:\n                        pa = self._trace_to_root(meetB)\n                        pb = self._trace_to_root(nn)\n                        path = pa + pb[-2::-1]\n                    path = self._finalize_path(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG and Halton\n    def _seed_rng(self):\n        s = 0xC0FFEE\n        for v in self.start + self.goal:\n            iv = int(v * 9973)\n            s ^= (iv * 110351) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 1\n        self._rng = s & 0xffffffff\n        self._hidx = 1\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _radical_inverse(self, base, i):\n        inv = 1.0 / base\n        f = inv\n        x = 0.0\n        n = i\n        while n > 0:\n            x += (n % base) * f\n            n //= base\n            f *= inv\n        return x\n\n    def _halton_point(self, idx):\n        if self.is3:\n            return (\n                self._radical_inverse(2, idx) * self.bounds[0],\n                self._radical_inverse(3, idx) * self.bounds[1],\n                self._radical_inverse(5, idx) * self.bounds[2],\n            )\n        else:\n            return (\n                self._radical_inverse(2, idx) * self.bounds[0],\n                self._radical_inverse(3, idx) * self.bounds[1],\n            )\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        out = []\n        for i in range(self.dim):\n            out.append(a[i] + (b[i] - a[i]) * r)\n        return self._clamp(tuple(out))\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # Spatial hash\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        else:\n            return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos, T_list):\n        key = self._cell_key(pos)\n        # Tiny rings for speed; fallback to small random sample from tree\n        for r in (0, 1, 2):\n            cand = self._collect_ring(grid, key, r)\n            if cand:\n                best = None\n                bestd = 1e100\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                return best\n        # Fallback: approximate NN by sampling a handful of nodes\n        if not T_list:\n            return None\n        m = min(32, len(T_list))\n        best = None\n        bestd = 1e100\n        for _ in range(m):\n            j = int(self._rand_range(0, len(T_list)))\n            if j >= len(T_list):\n                j = len(T_list) - 1\n            n = T_list[j]\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius, limit=None):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n                                if limit is not None and len(out) >= limit:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n                            if limit is not None and len(out) >= limit:\n                                return out\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        lst = self._neighbors_in_radius(grid, pos, radius, limit=1)\n        return len(lst) > 0\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            bucket = self.obin.get(key)\n                            if bucket is None:\n                                self.obin[key] = [idx]\n                            else:\n                                bucket.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        bucket = self.obin.get(key)\n                        if bucket is None:\n                            self.obin[key] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Sampling\n    def _sample_free(self, attractor):\n        # Try goal bias, then Halton, then random; attempt a few times to avoid obstacle samples\n        tries = 0\n        while tries < 12:\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attractor\n            else:\n                if r < 0.6:\n                    p = self._halton_point(self._hidx)\n                    self._hidx += 1\n                else:\n                    if self.is3:\n                        p = (\n                            self._rand_range(0.0, self.bounds[0]),\n                            self._rand_range(0.0, self.bounds[1]),\n                            self._rand_range(0.0, self.bounds[2]),\n                        )\n                    else:\n                        p = (\n                            self._rand_range(0.0, self.bounds[0]),\n                            self._rand_range(0.0, self.bounds[1]),\n                        )\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n            tries += 1\n        return None\n\n    # Insert node with checks already verified\n    def _insert_node(self, tree, grid, parent, pos, nodes, edges):\n        if (not self._in_bounds(pos)) or self._point_in_obstacles(pos):\n            return None\n        if not self._edge_free(parent.position, pos):\n            return None\n        if self._too_close(grid, pos, self.min_sep):\n            return None\n        new_cost = parent.cost + self._dist(parent.position, pos)\n        nn = Node(pos, parent, new_cost)\n        parent.add_child(nn)\n        tree.append(nn)\n        nodes.append(nn)\n        edges.append((parent, nn))\n        self._grid_add(grid, nn)\n        return nn\n\n    # Path utilities\n    def _trace_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        return out[::-1]\n\n    def _edge_simplify(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._edge_simplify(path)\n        p2 = self._shortcut(p1, self.smooth_shortcuts)\n        out = []\n        last = None\n        for p in p2:\n            if (last is None) or (p != last):\n                out.append(p)\n                last = p\n        return out",
          "objective": -38.98061,
          "time_improvement": 78.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 1939.0,
          "node_improvement": 91.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01192178726196289,
                    "num_nodes_avg": 58.0,
                    "path_length_avg": 190.28222135597667,
                    "smoothness_avg": 0.05947656957302187,
                    "success_improvement": 0.0,
                    "time_improvement": 51.67749173986195,
                    "node_improvement": 85.39410727776378,
                    "length_improvement": -4.296700739960651,
                    "smoothness_improvement": 830.9374692558246,
                    "objective_score": 17.079914424261318
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.016370940208435058,
                    "num_nodes_avg": 96.0,
                    "path_length_avg": 235.03136664902294,
                    "smoothness_avg": 0.11934863343125808,
                    "success_improvement": 0.0,
                    "time_improvement": 90.21178781589272,
                    "node_improvement": 93.54968756299134,
                    "length_improvement": 21.53976480976291,
                    "smoothness_improvement": 2970.9263015322663,
                    "objective_score": 54.84202673828689
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.003277277946472168,
                    "num_nodes_avg": 40.0,
                    "path_length_avg": 133.2685295932742,
                    "smoothness_avg": 0.1662596391706955,
                    "success_improvement": 0.0,
                    "time_improvement": 93.50734738778176,
                    "node_improvement": 94.91417673235854,
                    "length_improvement": 11.489388209578951,
                    "smoothness_improvement": 2014.8103382412316,
                    "objective_score": 45.01988883328806
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "RAPIDS-IRRT*: Rapid Adaptive Prolate Informed Dual-tree RRT* with Indexed Obstacles and Segment Cache. It combines two balanced RRT* trees, a coarse hash-grid for O(1)-ish neighbors, a large, quantized edge-collision cache over obstacle bins, dynamic radius best-parent selection and bounded rewiring. After the first solution, it switches to ellipsoidal informed sampling to shrink path length quickly. Fast LOS bridging, duplicate suppression, and early visibility postprocessing reduce expansions and time.",
          "planning_mechanism": "Alternating tree growth with goal/corridor/informed-biased sampling. For each sample, find a nearby anchor from the hash-grid, steer, pick the least-cost parent among local neighbors (dynamic radius), verify point and edge, insert and lightly rewire neighbors. Probe the opposite tree with direct LOS or a short micro-bridge; on success assemble, visibility-collapse, shortcut, and round, then return. Collision checks use binned AABBs and a coarse LRU segment cache; nearest/neighbor queries use a coarse spatial grid with ring expansion and frontier fallback for speed.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = None\n        self.cost = float(cost)\n        self.children = []\n        if parent is not None:\n            self.attach(parent)\n\n    def attach(self, parent):\n        # Ensure proper detachment and consistent child registration\n        if self.parent is parent:\n            if parent is not None:\n                found = False\n                for ch in parent.children:\n                    if ch is self:\n                        found = True\n                        break\n                if not found:\n                    parent.children.append(self)\n            return\n        if self.parent is not None:\n            old = self.parent\n            for i in range(len(old.children) - 1, -1, -1):\n                if old.children[i] is self:\n                    old.children.pop(i)\n                    break\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=4500,\n                 step_size=6.0,\n                 goal_bias=0.35,\n                 corridor_bias=0.30,\n                 informed_bias=0.55,\n                 grid_cell_factor=2.0,\n                 base_neighbor_radius=18.0,\n                 dupe_radius_ratio=0.30,\n                 k_parent_cap=24,\n                 k_rewire=10,\n                 connect_hops=3,\n                 smoothing_shortcuts=120,\n                 smoothing_rounds=4):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.cell_factor = float(grid_cell_factor)\n        self.base_nei = float(base_neighbor_radius)\n        self.dupe_ratio = float(dupe_radius_ratio)\n        self.k_parent_cap = int(max(6, k_parent_cap))\n        self.k_rewire = int(max(0, k_rewire))\n        self.connect_hops = int(max(1, connect_hops))\n        self.smoothing_shortcuts = int(max(0, smoothing_shortcuts))\n        self.smoothing_rounds = int(max(0, smoothing_rounds))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", [])) if getattr(map, \"obstacles\", None) is not None else []\n        nodes = []\n        edges = []\n        self._edge_idx = {}  # (id(p), id(c)) -> index\n        self._seed_rng()\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Build obstacle bins and segment cache\n        self._build_obs_bins()\n        self._seg_cache = {}\n        self._seg_tick = 0\n        self._seg_cap = 16384  # larger cache for reuse\n\n        # Endpoint validity\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight-line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            nodes.extend([n0, n1])\n            self._add_edge(edges, n0, n1)\n            path = [self.start, self.goal]\n            path = self._postprocess(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Spatial params\n        self.cell = max(1.0, self.step * self.cell_factor)\n        self.dupe_radius = max(0.5, self.step * self.dupe_ratio)\n\n        # Trees\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        A, B = [a_root], [b_root]\n        GA, GB = {}, {}\n        self._grid_add(GA, a_root)\n        self._grid_add(GB, b_root)\n        nodes.extend([a_root, b_root])\n        frontierA, frontierB = [a_root], [b_root]\n\n        # Informed sampling state\n        cmin = self._dist(self.start, self.goal)\n        best_path = None\n        best_len = 1e100\n\n        for it in range(self.max_iter):\n            # Alternate growth with slight bias toward smaller tree\n            if it % 3 == 2:\n                growA = (len(A) <= len(B))\n            else:\n                growA = (it % 2 == 0)\n            T = A if growA else B\n            O = B if growA else A\n            G = GA if growA else GB\n            GO = GB if growA else GA\n            frontier = frontierA if growA else frontierB\n            frontierO = frontierB if growA else frontierA\n            attract = self.goal if growA else self.start\n\n            # Dynamic neighbor radius (decreases with total nodes)\n            n_tot = max(2, len(A) + len(B))\n            r_nei = max(1.5 * self.step, self.base_nei / ((n_tot) ** (1.0 / (self.dim + 1.0))))\n\n            # Sampling\n            target = self._sample_target(attract, best_len, cmin)\n            if target is None:\n                continue\n\n            # Nearest anchor\n            qnear = self._nearest(G, frontier, target, max_rings=2)\n            if qnear is None:\n                qnear = T[-1]\n            qnew_pos = self._steer(qnear.position, target, self.step)\n            if (not self._in_bounds(qnew_pos)) or self._point_blocked(qnew_pos):\n                continue\n            if self._has_close(G, qnew_pos, self.dupe_radius):\n                continue\n\n            # Choose best parent among neighbors\n            parent, bestc = self._choose_parent(G, qnew_pos, qnear, r_nei)\n            if parent is None:\n                continue\n\n            # Mandatory checks before insertion\n            if self._point_blocked(qnew_pos):\n                continue\n            if not self._edge_free(parent.position, qnew_pos):\n                continue\n\n            # Insert node\n            qnode = Node(qnew_pos, parent, bestc)\n            T.append(qnode)\n            nodes.append(qnode)\n            self._grid_add(G, qnode)\n            self._add_edge(edges, parent, qnode)\n\n            frontier.append(qnode)\n            if len(frontier) > 160:\n                del frontier[:16]\n\n            # Local rewiring\n            if self.k_rewire > 0:\n                self._rewire_local(qnode, G, edges, r_nei, k=self.k_rewire)\n\n            # Try to connect to opposite tree\n            other_near = self._nearest(GO, frontierO, qnode.position, max_rings=2)\n            connected = False\n            meet = None\n            if other_near is not None:\n                if self._edge_free(qnode.position, other_near.position):\n                    connected = True\n                    meet = other_near\n                else:\n                    # Short micro-bridge on O toward qnode\n                    mb = self._micro_bridge(O, GO, other_near, qnode.position)\n                    if mb is not None and self._edge_free(qnode.position, mb.position):\n                        connected = True\n                        meet = mb\n\n            if connected and meet is not None:\n                path = self._assemble_path(qnode, meet, growA)\n                path = self._postprocess(path)\n                L = self._path_len(path)\n                if L < best_len:\n                    best_len = L\n                    best_path = path\n                # Return immediately to reduce planning time\n                return PlannerResult(True, best_path, nodes, edges)\n\n        # If loop ends without connection, return best if any\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            s ^= (int(v * 2654435761) & 0xffffffff)\n            s = (s * 1664525 + 1013904223) & 0xffffffff\n        s ^= len(self.obstacles) * 374761393\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        x = self._rng & 0xffffffff\n        x ^= (x << 13) & 0xffffffff\n        x ^= (x >> 17) & 0xffffffff\n        x ^= (x << 5) & 0xffffffff\n        self._rng = x & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Obstacles and collisions\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.8)\n        self._obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self._obin.get(key)\n                            if lst is None:\n                                self._obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self._obin.get(key)\n                        if lst is None:\n                            self._obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_bucket(self, p):\n        if self.is3:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell),\n                                   int(p[2] // self.obs_cell)))\n        else:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell)))\n\n    def _point_blocked(self, p):\n        bucket = self._point_bucket(p)\n        if not bucket:\n            return False\n        if self.is3:\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _seg_box_intersect(self, a, b, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(self.dim):\n            p = a[i]\n            d = b[i] - a[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _edge_cache_key(self, a, b):\n        s = self.obs_cell if self.obs_cell > 0 else 1.0\n        qa = []\n        qb = []\n        for i in range(self.dim):\n            qa.append(int(a[i] / s * 4.0))\n            qb.append(int(b[i] / s * 4.0))\n        ka = tuple(qa)\n        kb = tuple(qb)\n        if ka <= kb:\n            return (ka, kb)\n        else:\n            return (kb, ka)\n\n    def _cache_seg(self, key, val):\n        self._seg_cache[key] = val\n        self._seg_tick += 1\n        if self._seg_tick >= self._seg_cap:\n            self._seg_cache.clear()\n            self._seg_tick = 0\n\n    def _edge_free(self, a, b):\n        key = self._edge_cache_key(a, b)\n        hit = self._seg_cache.get(key)\n        if hit is not None:\n            return hit\n        if self.is3:\n            mn = (min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2]))\n            mx = (max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2]))\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            iz0 = int(max(0.0, mn[2]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mx[2]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self._obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if cand:\n                for idx in cand:\n                    ox, oy, oz, w, h, d = self.obstacles[idx]\n                    if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                        self._cache_seg(key, False)\n                        return False\n            self._cache_seg(key, True)\n            return True\n        else:\n            mn = (min(a[0], b[0]), min(a[1], b[1]))\n            mx = (max(a[0], b[0]), max(a[1], b[1]))\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self._obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if cand:\n                for idx in cand:\n                    ox, oy, w, h = self.obstacles[idx]\n                    if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                        self._cache_seg(key, False)\n                        return False\n            self._cache_seg(key, True)\n            return True\n\n    # Grid utilities\n    def _cell_key(self, pos):\n        if self.is3:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, frontier, pos, max_rings=2):\n        kk = self._cell_key(pos)\n        best = None\n        bd = 1e100\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring(grid, kk, r)\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bd:\n                        bd = d2\n                        best = n\n                if best is not None:\n                    return best\n        # fallback to recent frontier\n        if frontier:\n            lim = min(32, len(frontier))\n            for i in range(lim):\n                n = frontier[-1 - i]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bd:\n                    bd = d2\n                    best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, cap=None):\n        kk = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        limit = self.k_parent_cap if cap is None else int(cap)\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((kk[0] + dx, kk[1] + dy, kk[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n                                if len(out) >= limit:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((kk[0] + dx, kk[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n                            if len(out) >= limit:\n                                return out\n        return out\n\n    def _has_close(self, grid, pos, radius):\n        ns = self._neighbors(grid, pos, radius, cap=8)\n        return len(ns) > 0\n\n    # Parent selection (pure geometric cost)\n    def _choose_parent(self, grid, new_pos, fallback, radius):\n        cand = self._neighbors(grid, new_pos, radius, cap=self.k_parent_cap)\n        if fallback not in cand:\n            cand.append(fallback)\n        cand.sort(key=lambda n: self._dist2(n.position, new_pos))\n        best = None\n        best_cost = 1e100\n        for p in cand:\n            # Both checks for the candidate edge\n            if not self._edge_free(p.position, new_pos):\n                continue\n            d = self._dist(p.position, new_pos)\n            c = p.cost + d\n            if c < best_cost:\n                best_cost = c\n                best = p\n        return best, best_cost\n\n    # Rewiring with subtree cost updates\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _propagate_delta(self, node, delta):\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    def _rewire_local(self, new_node, grid, edges, radius, k=10):\n        neigh = self._neighbors(grid, new_node.position, radius, cap=48)\n        if not neigh:\n            return\n        neigh.sort(key=lambda n: self._dist2(n.position, new_node.position))\n        count = 0\n        for nb in neigh:\n            if count >= k:\n                break\n            if nb is new_node or nb is new_node.parent:\n                continue\n            if self._is_ancestor(nb, new_node):\n                continue\n            if self._point_blocked(nb.position):\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            cand_cost = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand_cost + 1e-9 < nb.cost:\n                oldp = nb.parent\n                old_cost = nb.cost\n                if oldp is not None:\n                    # detach from old parent\n                    for i in range(len(oldp.children) - 1, -1, -1):\n                        if oldp.children[i] is nb:\n                            oldp.children.pop(i)\n                            break\n                    self._remove_edge(edges, oldp, nb)\n                nb.attach(new_node)\n                nb.cost = cand_cost\n                self._add_edge(edges, new_node, nb)\n                self._propagate_delta(nb, cand_cost - old_cost)\n                count += 1\n\n    # Micro-bridge: create short chain in opposite tree, commit only if closure works\n    def _micro_bridge(self, tree, grid, near_node, target_pos):\n        cur = near_node.position\n        chain = []\n        last_ok = None\n        for _ in range(self.connect_hops):\n            nxt = self._steer(cur, target_pos, self.step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                return None\n            if self._has_close(grid, nxt, self.dupe_radius * 0.7):\n                return None\n            if not self._edge_free(cur, nxt):\n                return None\n            chain.append(nxt)\n            cur = nxt\n            last_ok = cur\n            if self._edge_free(cur, target_pos):\n                break\n        if last_ok is None:\n            return None\n        # Commit with checks\n        prev = near_node\n        for p in chain:\n            if self._point_blocked(p):\n                return None\n            if not self._edge_free(prev.position, p):\n                return None\n            nn = Node(p, prev, prev.cost + self._dist(prev.position, p))\n            tree.append(nn)\n            self._grid_add(grid, nn)\n            prev = nn\n        return prev\n\n    # Edge list maintenance\n    def _add_edge(self, edges, p, c):\n        edges.append((p, c))\n        self._edge_idx[(id(p), id(c))] = len(edges) - 1\n\n    def _remove_edge(self, edges, p, c):\n        key = (id(p), id(c))\n        idx = self._edge_idx.get(key)\n        if idx is None:\n            return\n        last_idx = len(edges) - 1\n        if idx != last_idx:\n            lp, lc = edges[last_idx]\n            edges[idx] = (lp, lc)\n            self._edge_idx[(id(lp), id(lc))] = idx\n        edges.pop()\n        del self._edge_idx[key]\n\n    # Sampling\n    def _sample_target(self, attract, c_best, c_min):\n        tries = 28\n        while tries > 0:\n            tries -= 1\n            r = self._rand()\n            if c_best < 1e99 and r < self.informed_bias:\n                p = self._sample_in_ellipse(c_best, c_min)\n            elif r < self.goal_bias + (0.0 if c_best < 1e99 else 0.0):\n                p = attract\n            elif r < self.goal_bias + self.corridor_bias:\n                p = self._corridor_point()\n            else:\n                p = self._uniform_point()\n            if p is not None and self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        return None\n\n    def _uniform_point(self):\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _corridor_point(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step, 0.10 * sg)\n        if self.is3:\n            return self._clamp((base[0] + self._rand_range(-w, w),\n                                base[1] + self._rand_range(-w, w),\n                                base[2] + self._rand_range(-w, w)))\n        else:\n            return self._clamp((base[0] + self._rand_range(-w, w),\n                                base[1] + self._rand_range(-w, w)))\n\n    def _sample_in_ellipse(self, c_best, c_min):\n        # Prolate hyperspheroid with foci at start and goal\n        if c_best < c_min + 1e-9:\n            return None\n        a = 0.5 * c_best  # major radius\n        if a <= 1e-9:\n            return None\n        if self.is3:\n            b_sq = a * a - (c_min * c_min) * 0.25\n            if b_sq <= 1e-9:\n                return None\n            b = b_sq ** 0.5\n            # Unit vector along start->goal\n            u = (self.goal[0] - self.start[0], self.goal[1] - self.start[1], self.goal[2] - self.start[2])\n            un = self._norm(u)\n            if un <= 1e-12:\n                return None\n            e1 = (u[0] / un, u[1] / un, u[2] / un)\n            # Build orthonormal basis\n            ref = (1.0, 0.0, 0.0) if abs(e1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            e2 = self._cross(e1, ref)\n            e2n = self._norm(e2)\n            if e2n <= 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                e2 = self._cross(e1, ref)\n                e2n = self._norm(e2)\n                if e2n <= 1e-12:\n                    return None\n            e2 = (e2[0] / e2n, e2[1] / e2n, e2[2] / e2n)\n            e3 = self._cross(e1, e2)\n            # Sample inside unit ball\n            for _ in range(10):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                z = self._rand_range(-1.0, 1.0)\n                if x * x + y * y + z * z <= 1.0:\n                    # scale\n                    rx = (self._rand() ** (1.0 / 3.0))\n                    x *= rx\n                    y *= rx\n                    z *= rx\n                    # transform to ellipse\n                    cx = a * x\n                    cy = b * y\n                    cz = b * z\n                    # rotate and translate to center\n                    center = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dim))\n                    vx = (e1[0] * cx + e2[0] * cy + e3[0] * cz)\n                    vy = (e1[1] * cx + e2[1] * cy + e3[1] * cz)\n                    vz = (e1[2] * cx + e2[2] * cy + e3[2] * cz)\n                    p = (center[0] + vx, center[1] + vy, center[2] + vz)\n                    if self._in_bounds(p):\n                        return p\n            return None\n        else:\n            b_sq = a * a - (c_min * c_min) * 0.25\n            if b_sq <= 1e-9:\n                return None\n            b = b_sq ** 0.5\n            dx = self.goal[0] - self.start[0]\n            dy = self.goal[1] - self.start[1]\n            un = (dx * dx + dy * dy) ** 0.5\n            if un <= 1e-12:\n                return None\n            cos_t = dx / un\n            sin_t = dy / un\n            center = ((self.start[0] + self.goal[0]) * 0.5,\n                      (self.start[1] + self.goal[1]) * 0.5)\n            # Sample inside unit disk\n            for _ in range(12):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                if x * x + y * y <= 1.0:\n                    r = (self._rand() ** 0.5)\n                    x *= r\n                    y *= r\n                    # scale\n                    ex = a * x\n                    ey = b * y\n                    # rotate\n                    rx = cos_t * ex - sin_t * ey\n                    ry = sin_t * ex + cos_t * ey\n                    p = (center[0] + rx, center[1] + ry)\n                    if self._in_bounds(p):\n                        return p\n            return None\n\n    def _norm(self, v):\n        s = 0.0\n        for i in range(len(v)):\n            s += v[i] * v[i]\n        return s ** 0.5\n\n    def _cross(self, a, b):\n        return (a[1] * b[2] - a[2] * b[1],\n                a[2] * b[0] - a[0] * b[2],\n                a[0] * b[1] - a[1] * b[0])\n\n    # Path utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _assemble_path(self, a_end, b_end, a_side_grew):\n        if a_side_grew:\n            pa = self._path_to_root(a_end)\n            pb = self._path_to_root(b_end)\n            if pa and pb and pa[0] == pb[-1]:\n                pb = pb[:-1]\n            return pa + pb[::-1]\n        else:\n            pa = self._path_to_root(a_end)\n            pb = self._path_to_root(b_end)\n            if pa and pb and pb[0] == pa[-1]:\n                pa = pa[:-1]\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _vis_collapse(self, pts, passes=2):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            i = 0\n            changed = False\n            while i < len(cur) - 2:\n                j = len(cur) - 1\n                while j > i + 1:\n                    if self._edge_free(cur[i], cur[j]):\n                        if j > i + 1:\n                            del cur[i + 1:j]\n                            changed = True\n                        break\n                    j -= 1\n                i += 1\n            if not changed:\n                break\n        return cur\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        stall = 0\n        while tries < attempts and len(cur) > 2:\n            n = len(cur)\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j > n - 1:\n                tries += 1\n                continue\n            a, b = cur[i], cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-12 <= bestL:\n                    cur = cand\n                    bestL = L\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            tries += 1\n            if stall > 28:\n                break\n        return cur\n\n    def _round_corners(self, pts, passes):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                c = cur[i + 1]\n                mid = tuple(0.5 * a[k] + 0.5 * c[k] for k in range(self.dim))\n                if (not self._in_bounds(mid)) or self._point_blocked(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if cur[i] != mid:\n                        cur[i] = mid\n                        moved = True\n            if not moved:\n                break\n        return cur\n\n    def _postprocess(self, path):\n        if len(path) < 3:\n            return path[:]\n        p = self._vis_collapse(path, passes=2)\n        p = self._shortcut(p, self.smoothing_shortcuts)\n        p = self._round_corners(p, self.smoothing_rounds)\n        return p",
          "objective": -38.81705,
          "time_improvement": 73.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1331.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007626032829284668,
                    "num_nodes_avg": 42.0,
                    "path_length_avg": 150.30466036531917,
                    "smoothness_avg": 0.042772972605090796,
                    "success_improvement": 0.0,
                    "time_improvement": 69.08944722064112,
                    "node_improvement": 89.42331906320827,
                    "length_improvement": 17.615633924011192,
                    "smoothness_improvement": 569.4899042663268,
                    "objective_score": 34.143664041930684
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04364337921142578,
                    "num_nodes_avg": 179.0,
                    "path_length_avg": 226.32721347498054,
                    "smoothness_avg": 0.08650527069846632,
                    "success_improvement": 0.0,
                    "time_improvement": 73.90555150077547,
                    "node_improvement": 87.97285493516092,
                    "length_improvement": 24.445461674416084,
                    "smoothness_improvement": 2125.842922299545,
                    "objective_score": 47.468157066380016
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01258089542388916,
                    "num_nodes_avg": 77.0,
                    "path_length_avg": 135.9262852877516,
                    "smoothness_avg": 0.10978088951272895,
                    "success_improvement": 0.0,
                    "time_improvement": 75.07584499328578,
                    "node_improvement": 90.20979020979021,
                    "length_improvement": 9.724233426033248,
                    "smoothness_improvement": 1296.4048114195507,
                    "objective_score": 34.83931761070344
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "FLASH-Connect: a fast, low-dispersion, edge-cached BiRRT-Connect with hash-grid nearest search, per-cell caps, and one-shot limited connection. It minimizes planning time by deterministic Halton sampling, bounded tree growth without rewiring, immediate bridge attempts, and lightweight post-shortcutting.",
          "planning_mechanism": "Alternate expansion from start and goal trees toward a Halton-guided target. Each step inserts only if both the node and edge are collision-free and not too close to existing nodes. After insertion, attempt a direct bridge to the opposite tree; if blocked, perform at most a couple of connect steps on the other tree, again validating both node and edge per step. An LRU-like edge-collision cache accelerates repeated checks. On success, return immediately after quick line-of-sight collapse and a few shortcut passes.",
          "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = tuple(position)\n        self.parent = parent\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=9.0,\n        goal_bias=0.2,\n        grid_cell_factor=1.25,\n        per_cell_cap=8,\n        dupe_radius_ratio=0.5,\n        connect_steps=2,\n        edge_cache_capacity=30000,\n        edge_cache_quant=1.0,\n        smoothing_iters=20\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.per_cell_cap = int(per_cell_cap)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.connect_steps = int(connect_steps)\n        self.edge_cache_capacity = int(edge_cache_capacity)\n        self.edge_cache_quant = float(edge_cache_quant)\n        self.smoothing_iters = int(smoothing_iters)\n        # internal states\n        self._rnd_state = 2463534242\n        self._hidx = 1\n\n    def plan(self, map):\n        # Scene setup\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # seed RNG deterministically from scene\n        self._seed_from_scene()\n\n        # build spatial indices\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self._build_obstacle_grid()\n\n        # quick endpoint checks\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # edge cache\n        self._tick = 0\n        self._ecache = {}\n        self._ecache_last_prune = 0\n\n        # early straight line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None)\n            n1 = Node(self.goal, n0)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # trees and grids\n        nodes = []\n        edges = []\n\n        root_a = Node(self.start, None)\n        root_b = Node(self.goal, None)\n        nodes.extend([root_a, root_b])\n\n        tree_a = [root_a]\n        tree_b = [root_b]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, root_a)\n        self._grid_insert(grid_b, root_b)\n\n        # main loop\n        for it in range(self.max_iter):\n            grow_from_a = (it % 2 == 0)\n            source_tree = tree_a if grow_from_a else tree_b\n            source_grid = grid_a if grow_from_a else grid_b\n            target_tree = tree_b if grow_from_a else tree_a\n            target_grid = grid_b if grow_from_a else grid_a\n            attractor = self.goal if grow_from_a else self.start\n\n            q_rand = self._sample(attractor)\n            if q_rand is None:\n                continue\n\n            near = self._nearest(source_grid, q_rand)\n            if near is None:\n                continue\n\n            q_new = self._steer_valid(near.position, q_rand)\n            if q_new is None:\n                continue\n            if self._has_nearby(source_grid, q_new, self.dupe_radius):\n                continue\n\n            # per-cell cap\n            ckey = self._cell_of(q_new)\n            bucket = source_grid.get(ckey)\n            if bucket and len(bucket) >= self.per_cell_cap:\n                continue\n\n            # Insertion (both node and edge already validated in _steer_valid)\n            new_node = Node(q_new, near)\n            source_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((near, new_node))\n            self._grid_insert(source_grid, new_node)\n\n            # Try to connect to opposite tree\n            other_near = self._nearest(target_grid, new_node.position)\n            if other_near is not None:\n                # direct bridge\n                if self._edge_free(new_node.position, other_near.position):\n                    path = self._assemble_path(new_node, other_near)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # limited connect steps\n                p = other_near\n                steps = 0\n                while steps < self.connect_steps:\n                    step_pos = self._steer_once(p.position, new_node.position)\n                    if step_pos is None:\n                        break\n                    if self._has_nearby(target_grid, step_pos, self.dupe_radius):\n                        break\n                    cell2 = self._cell_of(step_pos)\n                    buck2 = target_grid.get(cell2)\n                    if buck2 and len(buck2) >= self.per_cell_cap:\n                        break\n                    q2 = Node(step_pos, p)\n                    target_tree.append(q2)\n                    nodes.append(q2)\n                    edges.append((p, q2))\n                    self._grid_insert(target_grid, q2)\n                    if self._edge_free(new_node.position, q2.position):\n                        path = self._assemble_path(new_node, q2)\n                        path = self._postprocess(path)\n                        return PlannerResult(True, path, nodes, edges)\n                    p = q2\n                    steps += 1\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG and Halton\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= len(self.obstacles) * 2654435761\n        s ^= int(self.step_size * 1000) & 0xffffffff\n        self._rnd_state = (s ^ 0x9E3779B9) & 0xffffffff\n        if self._rnd_state == 0:\n            self._rnd_state = 2463534242\n        self._hidx = 1\n\n    def _rand(self):\n        self._rnd_state = (1664525 * self._rnd_state + 1013904223) & 0xffffffff\n        return self._rnd_state / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _vdc(self, n, base):\n        v = 0.0\n        denom = 1.0\n        while n > 0:\n            n, r = divmod(n, base)\n            denom *= base\n            v += r / denom\n        return v\n\n    def _halton_point(self, idx):\n        bases = (2, 3, 5)\n        if self.dims == 2:\n            x = self._vdc(idx, bases[0]) * self.bounds[0]\n            y = self._vdc(idx, bases[1]) * self.bounds[1]\n            return (x, y)\n        else:\n            x = self._vdc(idx, bases[0]) * self.bounds[0]\n            y = self._vdc(idx, bases[1]) * self.bounds[1]\n            z = self._vdc(idx, bases[2]) * self.bounds[2]\n            return (x, y, z)\n\n    # Sampling with goal bias and Halton fallback\n    def _sample(self, attractor):\n        for _ in range(24):\n            if self._rand() < self.goal_bias:\n                p = attractor\n            else:\n                # Halton with tiny jitter to avoid grid alignment with obstacles\n                p = self._halton_point(self._hidx)\n                self._hidx += 1\n                jitter = 0.001 * self.cell_size\n                if self.dims == 2:\n                    p = (min(max(p[0] + self._rand_range(-jitter, jitter), 0.0), self.bounds[0]),\n                         min(max(p[1] + self._rand_range(-jitter, jitter), 0.0), self.bounds[1]))\n                else:\n                    p = (min(max(p[0] + self._rand_range(-jitter, jitter), 0.0), self.bounds[0]),\n                         min(max(p[1] + self._rand_range(-jitter, jitter), 0.0), self.bounds[1]),\n                         min(max(p[2] + self._rand_range(-jitter, jitter), 0.0), self.bounds[2]))\n            if self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer_once(self, a, b):\n        # Try to step toward b by at most step_size\n        d = self._dist(a, b)\n        if d < 1e-12:\n            return None\n        r = min(1.0, self.step_size / d)\n        q = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n        if not self._within_bounds(q):\n            return None\n        if self._point_in_obstacles(q):\n            return None\n        if not self._edge_free(a, q):\n            return None\n        return q\n\n    def _steer_valid(self, a, b):\n        # Fast attempt: if target within 1.5*step and edge is free, go there; else single step\n        d = self._dist(a, b)\n        max_jump = 1.5 * self.step_size\n        if d <= max_jump:\n            q = b\n            # clamp to bounds\n            q = tuple(min(max(q[i], 0.0), self.bounds[i]) for i in range(self.dims))\n            if not self._point_in_obstacles(q) and self._edge_free(a, q):\n                return q\n        # try normal step\n        q = self._steer_once(a, b)\n        if q is not None:\n            return q\n        # last attempt: slightly shorter step to sneak around grazing edges\n        if d > 1e-9:\n            r = min(1.0, (0.6 * self.step_size) / d)\n            q2 = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n            if self._within_bounds(q2) and (not self._point_in_obstacles(q2)) and self._edge_free(a, q2):\n                return q2\n        return None\n\n    # Node grid utilities\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_of(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 4):\n            cand = self._grid_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback: scan grid buckets\n        for b in grid.values():\n            for n in b:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    # Obstacle grid\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 2.0)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            x0, y0, z0 = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= x0 <= x + w and y <= y0 <= y + h and z <= z0 <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            x0, y0 = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= x0 <= x + w and y <= y0 <= y + h:\n                    return True\n            return False\n\n    # Edge collision with cache\n    def _edge_key(self, a, b):\n        q = max(0.25, self.edge_cache_quant)\n        qa = tuple(int(a[i] / q) for i in range(self.dims))\n        qb = tuple(int(b[i] / q) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self._ecache.get(key)\n        if hit is not None:\n            # refresh LRU tick\n            self._tick += 1\n            self._ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self._ecache[key] = (free, self._tick)\n        if len(self._ecache) - self._ecache_last_prune > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self._ecache:\n            return\n        cutoff = self._tick - 4000\n        to_del = []\n        for k, v in self._ecache.items():\n            if v[1] < cutoff:\n                to_del.append(k)\n        if not to_del:\n            i = 0\n            for k in list(self._ecache.keys()):\n                if (i % 3) == 0:\n                    to_del.append(k)\n                i += 1\n        for k in to_del:\n            if k in self._ecache:\n                del self._ecache[k]\n        self._ecache_last_prune = len(self._ecache)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x0, y0, z0, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x0, y0, z0), (x0 + w, y0 + h, z0 + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x0, y0, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x0, y0), (x0 + w, y0 + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect(self, p0, p1, bmin, bmax):\n        # slab intersection for 2D/3D segment vs AABB\n        tmin = 0.0\n        tmax = 1.0\n        n = self.dims\n        for i in range(n):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Path assembly and postprocess\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _assemble_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return pa + pb[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _los_collapse(self, path):\n        if len(path) < 3:\n            return path[:]\n        out = [path[0]]\n        last = 0\n        k = 1\n        while k < len(path) - 1:\n            if self._edge_free(path[last], path[k + 1]):\n                k += 1\n                continue\n            out.append(path[k])\n            last = k\n            k += 1\n        out.append(path[-1])\n        return out\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best = self._path_len(pts)\n        n = len(pts)\n        iters = min(self.smoothing_iters, max(1, n - 2))\n        for t in range(iters):\n            i = (t % (n - 2))\n            j = min(n - 1, i + 2 + (t % max(1, (n - i - 1))))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= best + 1e-12:\n                    pts = new_pts\n                    best = L\n                    n = len(pts)\n        return pts\n\n    def _postprocess(self, path):\n        p = self._los_collapse(path)\n        p = self._shortcut(p)\n        return p",
          "objective": -38.51088,
          "time_improvement": 67.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1919.0,
          "node_improvement": 85.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01389298439025879,
                    "num_nodes_avg": 79.0,
                    "path_length_avg": 164.28407730787757,
                    "smoothness_avg": 0.04754812951617681,
                    "success_improvement": 0.0,
                    "time_improvement": 43.68765033257988,
                    "node_improvement": 80.10576680936792,
                    "length_improvement": 9.953293979757886,
                    "smoothness_improvement": 644.2314793440236,
                    "objective_score": 22.299428884348814
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.015888690948486328,
                    "num_nodes_avg": 96.0,
                    "path_length_avg": 256.1129773273841,
                    "smoothness_avg": 0.12192815124399099,
                    "success_improvement": 0.0,
                    "time_improvement": 90.5001254447587,
                    "node_improvement": 93.54968756299134,
                    "length_improvement": 14.502116364807549,
                    "smoothness_improvement": 3037.299152805466,
                    "objective_score": 51.03780321633946
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016379070281982423,
                    "num_nodes_avg": 140.0,
                    "path_length_avg": 121.59420940833631,
                    "smoothness_avg": 0.17113765919663135,
                    "success_improvement": 0.0,
                    "time_improvement": 67.55123758529757,
                    "node_improvement": 82.19961856325493,
                    "length_improvement": 19.24291580502608,
                    "smoothness_improvement": 2076.858392913151,
                    "objective_score": 42.195412723170676
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "RAPTOR-BiRRT*: Rapid Adaptive-Parenting Two-way RRT*-Connect with hashed k-nearest selection, cached collision checks, bounded rewiring, and seam-preserving join. It accelerates planning via a compact spatial hash and a lazy edge-collision cache, reduces detours with adaptive-radius parent choice and limited local rewiring, and finishes with visibility pruning plus shortcut smoothing for shorter, smoother paths.",
          "planning_mechanism": "Alternate expansions from start and goal. Each iteration: sample with goal/informed bias, steer one step, choose the lowest-cost visible parent among k nearest within an adaptive radius, verify node and edge collisions, add the node, and locally rewire cheaper neighbors. Attempt a one-shot line-of-sight connect to the opposite tree (falling back to a few greedy steps). On meeting, build a seam-preserving path, prune by visibility, and apply bounded shortcuts.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def detach_from_parent(self):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = None\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=6.0,\n        goal_bias=0.2,\n        grid_cell_factor=1.5,\n        k_near=10,\n        parent_radius_scale=2.4,\n        rewire_radius_scale=2.8,\n        rewire_cap=24,\n        connect_steps=8,\n        smooth_attempts=120\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.k_near = int(max(1, k_near))\n        self.parent_radius_scale = float(parent_radius_scale)\n        self.rewire_radius_scale = float(rewire_radius_scale)\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_steps = int(max(0, connect_steps))\n        self.smooth_attempts = int(max(0, smooth_attempts))\n\n        self._rng = 123456789\n        self.ecache = {}\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n\n        # Spatial grid for nodes\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_radius = max(0.5, 0.4 * self.step)\n\n        # Obstacle bins\n        self._build_obs_bins()\n\n        # Start/goal collision check\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Trivial straight path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize bidirectional trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        Ta = [start_root]\n        Tb = [goal_root]\n        Ga = {}\n        Gb = {}\n        self._grid_add(Ga, start_root)\n        self._grid_add(Gb, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_path = None\n        best_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            if active_start:\n                tree_grow, tree_other = Ta, Tb\n                grid_grow, grid_other = Ga, Gb\n                attractor = self.goal\n            else:\n                tree_grow, tree_other = Tb, Ta\n                grid_grow, grid_other = Gb, Ga\n                attractor = self.start\n\n            # Sample\n            sample = self._sample(attractor, best_len)\n            if sample is None:\n                continue\n\n            # Nearest\n            near = self._nearest(grid_grow, tree_grow, sample)\n            if near is None:\n                continue\n\n            # Steer\n            newp = self._steer(near.position, sample, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(grid_grow, newp, self.dup_radius):\n                continue\n\n            # Choose parent among k-nearest within adaptive radius\n            pradius = self._adaptive_radius(len(tree_grow), scale=self.parent_radius_scale)\n            knn = self._k_nearest(grid_grow, newp, self.k_near, pradius)\n            if near not in knn:\n                knn.append(near)\n            parent, pcost = self._choose_parent(newp, knn)\n            if parent is None:\n                continue\n\n            # Final node+edge collision checks before insertion\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            # Insert node\n            nn = Node(newp, parent, pcost)\n            parent.add_child(nn)\n            tree_grow.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(grid_grow, nn)\n\n            # Local rewiring (bounded)\n            if self.rewire_cap > 0:\n                rrad = self._adaptive_radius(len(tree_grow), scale=self.rewire_radius_scale)\n                neigh = self._grid_neighbors_within(grid_grow, newp, rrad)\n                self._rewire_from(nn, neigh, edges)\n\n            # Try to connect opposite tree\n            meet_node, reached = self._try_connect(tree_other, grid_other, nn.position, nodes, edges)\n            if reached:\n                # Build seam-preserving path (include meet once)\n                if active_start:\n                    path_a = self._trace_to_root(nn)\n                    path_b = self._trace_to_root(meet_node)\n                    if path_a[-1] == path_b[-1]:\n                        merged = path_a + path_b[-2::-1]\n                    else:\n                        merged = path_a + path_b[::-1]\n                else:\n                    path_a = self._trace_to_root(meet_node)\n                    path_b = self._trace_to_root(nn)\n                    if path_a[-1] == path_b[-1]:\n                        merged = path_a + path_b[-2::-1]\n                    else:\n                        merged = path_a + path_b[::-1]\n\n                merged = self._dedup(merged)\n                best_path = merged\n                best_len = self._path_len(merged)\n\n                # Finalize and return (fast and short)\n                final = self._finalize_path(best_path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0x9E3779B9 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= (q ^ (q >> 13) ^ ((q << 7) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 23) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(min(max(a[i], 0.0), self.bounds[i]) for i in range(self.dim))\n        if d2 <= step * step:\n            tgt = b\n        else:\n            d = d2 ** 0.5\n            r = step / d\n            tgt = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n        return tuple(min(max(tgt[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # Spatial hash grid\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, tree, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        # expand rings until found\n        for r in range(0, 6):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n            if best is not None:\n                return best\n        # fallback full scan\n        for n in tree:\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        return best\n\n    def _k_nearest(self, grid, pos, k, radius):\n        key = self._cell_key(pos)\n        cand = []\n        # gather rings until enough candidates\n        for r in range(0, 6):\n            cand.extend(self._grid_collect_ring(grid, key, r))\n            if len(cand) >= k:\n                break\n        # filter by radius and unique\n        seen = set()\n        scored = []\n        for n in cand:\n            if id(n) in seen:\n                continue\n            seen.add(id(n))\n            d2 = self._dist2(n.position, pos)\n            if d2 <= radius * radius:\n                scored.append((d2, n))\n        scored.sort(key=lambda x: x[0])\n        out = []\n        for i in range(min(k, len(scored))):\n            out.append(scored[i][1])\n        # if still empty, allow nearest from ring candidates\n        if not out and scored:\n            out.append(scored[0][1])\n        return out\n\n    def _grid_neighbors_within(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        out = []\n        span = max(1, int(radius // self.cell) + 1)\n        r2 = radius * radius\n        if self.is3:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        lst = self._grid_neighbors_within(grid, pos, radius)\n        return len(lst) > 0\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.2)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _edge_key(self, a, b):\n        # order-invariant rounded key\n        ra = tuple(int(round(x * 10.0)) for x in a)\n        rb = tuple(int(round(x * 10.0)) for x in b)\n        if ra <= rb:\n            return (ra, rb)\n        else:\n            return (rb, ra)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            return hit\n        ok = not self._segment_hits_any(a, b)\n        if len(self.ecache) > 40000:\n            self.ecache.clear()\n        self.ecache[key] = ok\n        return ok\n\n    # Parenting and rewiring\n    def _adaptive_radius(self, n_nodes, scale=2.4):\n        if n_nodes <= 1:\n            return self.step * scale\n        # RRT* style fade with log(n)/n\n        base = self.step * scale\n        decay = (self._log(n_nodes + 1) / (n_nodes + 1.0)) ** (1.0 / max(2, self.dim))\n        r = max(self.step * 1.25, base * (0.9 + 0.6 * decay))\n        return r\n\n    def _log(self, x):\n        # natural log via series around 1 for x>0; fallback to change-of-base using ln(1+y)\n        # For stability, use simple Newton iteration on exp; approximate ln using binary search between [0, max]\n        # Simpler: use change to base-2 via bit shifts approximation\n        # Here use a minimal iterative approach\n        if x <= 0:\n            return -1e9\n        y = 0.0\n        v = x\n        # normalize v to [1,2)\n        k = 0\n        while v >= 2.0:\n            v *= 0.5\n            k += 1\n        while v < 1.0:\n            v *= 2.0\n            k -= 1\n        # series ln(v) around 1: ln(v) ~ 2*(t + t^3/3 + t^5/5 + ...), t=(v-1)/(v+1)\n        t = (v - 1.0) / (v + 1.0)\n        t2 = t * t\n        s = 0.0\n        num = t\n        for n in range(1, 7, 2):\n            s += num / n\n            num *= t2\n        ln2 = 0.6931471805599453\n        return 2.0 * s + k * ln2\n\n    def _choose_parent(self, newp, candidates):\n        best = None\n        best_cost = 1e100\n        for n in candidates:\n            # edge check deferred to minimize calls\n            g = n.cost + self._dist(n.position, newp)\n            if g + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                best = n\n                best_cost = g\n        if best is None:\n            return None, 0.0\n        return best, best_cost\n\n    def _rewire_from(self, pivot, neighbors, edges):\n        if not neighbors:\n            return\n        rewired = 0\n        for nb in neighbors:\n            if rewired >= self.rewire_cap:\n                break\n            if nb is pivot or nb.parent is None:\n                continue\n            cand_cost = pivot.cost + self._dist(pivot.position, nb.position)\n            if cand_cost + 1e-12 < nb.cost and self._edge_free(pivot.position, nb.position):\n                oldp = nb.parent\n                nb.detach_from_parent()\n                pivot.add_child(nb)\n                try:\n                    idx = edges.index((oldp, nb))\n                    edges.pop(idx)\n                except:\n                    pass\n                edges.append((pivot, nb))\n                old_cost = nb.cost\n                nb.cost = cand_cost\n                self._propagate_cost(nb)\n                rewired += 1\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if newc + 1e-12 < ch.cost:\n                    ch.cost = newc\n                else:\n                    ch.cost = newc\n                stack.append(ch)\n\n    # Connect attempt\n    def _try_connect(self, tree, grid, target_pos, nodes, edges):\n        # Direct one-shot connect to nearest opposite node\n        nearest = self._nearest(grid, tree, target_pos)\n        if nearest and self._edge_free(nearest.position, target_pos):\n            # If target_pos too close to existing node, treat as meeting at that node\n            if self._dist(nearest.position, target_pos) <= self.dup_radius * 0.75:\n                return nearest, True\n            if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                meet = Node(target_pos, nearest, nearest.cost + self._dist(nearest.position, target_pos))\n                nearest.add_child(meet)\n                tree.append(meet)\n                nodes.append(meet)\n                edges.append((nearest, meet))\n                self._grid_add(grid, meet)\n                # light seam rewiring\n                rrad = self._adaptive_radius(len(tree), scale=self.rewire_radius_scale * 0.8)\n                neigh = self._grid_neighbors_within(grid, target_pos, rrad)\n                self._rewire_from(meet, neigh, edges)\n                return meet, True\n            return nearest, False\n\n        # Greedy bounded steps toward target\n        cur = nearest\n        steps = 0\n        while cur is not None and steps < self.connect_steps:\n            nxtp = self._steer(cur.position, target_pos, self.step)\n            if (not self._in_bounds(nxtp)) or self._point_in_obstacles(nxtp):\n                return cur, False\n            if not self._edge_free(cur.position, nxtp):\n                return cur, False\n            # choose parent locally (cur or neighbor within small radius)\n            pr = max(self.step * 1.25, self._adaptive_radius(len(tree), scale=self.parent_radius_scale * 0.6))\n            neigh = self._grid_neighbors_within(grid, nxtp, pr)\n            if cur not in neigh:\n                neigh.append(cur)\n            bestp, bestc = self._choose_parent(nxtp, neigh)\n            if bestp is None:\n                return cur, False\n            # final checks before add\n            if self._point_in_obstacles(nxtp) or (not self._edge_free(bestp.position, nxtp)):\n                return cur, False\n            nn = Node(nxtp, bestp, bestc)\n            bestp.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((bestp, nn))\n            self._grid_add(grid, nn)\n            # small local rewire\n            self._rewire_from(nn, neigh, edges)\n            cur = nn\n            steps += 1\n            if self._dist(cur.position, target_pos) <= self.step and self._edge_free(cur.position, target_pos):\n                if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                    final = Node(target_pos, cur, cur.cost + self._dist(cur.position, target_pos))\n                    cur.add_child(final)\n                    tree.append(final)\n                    nodes.append(final)\n                    edges.append((cur, final))\n                    self._grid_add(grid, final)\n                    return final, True\n                return cur, False\n        return cur, False\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.6:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            if self._in_bounds(attractor) and (not self._point_in_obstacles(attractor)):\n                return attractor\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(15):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Path utilities\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        # Greedy corner cull\n        k = 1\n        while k < len(cur) - 1:\n            if self._edge_free(cur[k - 1], cur[k + 1]):\n                cur.pop(k)\n            else:\n                k += 1\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._visibility_prune(path)\n        p2 = self._shortcut(p1, self.smooth_attempts)\n        return self._dedup(p2)",
          "objective": -38.45865,
          "time_improvement": 69.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1355.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.006320738792419433,
                    "num_nodes_avg": 40.0,
                    "path_length_avg": 153.28064096609592,
                    "smoothness_avg": 0.04475071007809341,
                    "success_improvement": 0.0,
                    "time_improvement": 74.38018765178215,
                    "node_improvement": 89.92697053638882,
                    "length_improvement": 15.984451799295094,
                    "smoothness_improvement": 600.4457904444797,
                    "objective_score": 34.9069563273341
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06322317123413086,
                    "num_nodes_avg": 229.0,
                    "path_length_avg": 234.02056344335762,
                    "smoothness_avg": 0.08682989071145224,
                    "success_improvement": 0.0,
                    "time_improvement": 62.198761518109656,
                    "node_improvement": 84.61331720755224,
                    "length_improvement": 21.877200014171095,
                    "smoothness_improvement": 2134.1956290480175,
                    "objective_score": 42.45692660917564
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014822864532470703,
                    "num_nodes_avg": 83.0,
                    "path_length_avg": 125.04636269503999,
                    "smoothness_avg": 0.11244887119936313,
                    "success_improvement": 0.0,
                    "time_improvement": 70.63425449437379,
                    "node_improvement": 89.446916719644,
                    "length_improvement": 16.950159965872018,
                    "smoothness_improvement": 1330.3413415436141,
                    "objective_score": 38.01207903555342
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "IBEX-Lite: Informed BiRRT* with Elastic Micro-Connect. It blends fast bidirectional growth, visibility-based best-parent insertion with light rewiring, obstacle-binned collision checks, and a commit-only micro-bridge to connect trees. After connection it runs multi-pass visibility compression, shortcutting, and safe corner rounding. The design targets high success, short and smooth paths with low planning time.",
          "planning_mechanism": "Alternate growing the two trees (balanced), sampling via goal/corridor-biased free points. For each sample: pick a nearby anchor with a hash grid, steer one step, and select the least-cost visible parent among local neighbors with a small turn-angle penalty; insert only after node and edge checks, then lightly rewire neighbors. Probe the opposite tree: first try direct LOS; else simulate a few greedy steps; if a connector exists, commit the whole micro-bridge and return the assembled, smoothed path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            # detach from old parent\n            i = 0\n            while i < len(self.parent.children):\n                if self.parent.children[i] is self:\n                    self.parent.children.pop(i)\n                    break\n                i += 1\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=6.0,\n                 goal_bias=0.3,\n                 corridor_bias=0.25,\n                 grid_cell_factor=1.8,\n                 neighbor_radius_factor=2.2,\n                 dupe_radius_ratio=0.3,\n                 k_rewire=4,\n                 connect_hops=3,\n                 edge_res=0.8,\n                 smooth_shortcuts=80,\n                 smooth_rounds=6):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.cell_factor = float(grid_cell_factor)\n        self.nei_factor = float(neighbor_radius_factor)\n        self.dupe_ratio = float(dupe_radius_ratio)\n        self.k_rewire = int(max(0, k_rewire))\n        self.connect_hops = int(max(1, connect_hops))\n        self.edge_res = float(edge_res)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self.smooth_rounds = int(max(0, smooth_rounds))\n        self._rng = 123456789\n\n    def plan(self, map):\n        # Setup\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", [])) if getattr(map, \"obstacles\", None) is not None else []\n\n        self._seed_rng()\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], [], [])\n        # Build obstacle bins before collision tests\n        self._build_obs_bins()\n\n        # Validate endpoints\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        nodes = []\n        edges = []\n\n        # Early straight-line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Derived spatial params\n        self.cell = max(1.0, self.step * self.cell_factor)\n        self.nei_radius = max(1.5 * self.step, self.step * self.nei_factor)\n        self.dupe_radius = max(0.35, self.step * self.dupe_ratio)\n\n        # Initialize two trees and grids\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        A, B = [a_root], [b_root]\n        nodes.extend([a_root, b_root])\n        GA, GB = {}, {}\n        self._grid_add(GA, a_root)\n        self._grid_add(GB, b_root)\n        frontierA, frontierB = [a_root], [b_root]\n\n        for it in range(self.max_iter):\n            # Balanced alternating\n            if it % 3 == 2:\n                growA = (len(A) <= len(B))\n            else:\n                growA = (it % 2 == 0)\n\n            T = A if growA else B\n            O = B if growA else A\n            G = GA if growA else GB\n            GO = GB if growA else GA\n            frontier = frontierA if growA else frontierB\n            frontierO = frontierB if growA else frontierA\n            attract = self.goal if growA else self.start\n\n            target = self._sample_target(attract)\n            if target is None:\n                continue\n\n            # nearest anchor\n            qnear = self._nearest(G, frontier, target, max_rings=2)\n            if qnear is None:\n                qnear = T[-1]\n\n            qnew_pos = self._steer(qnear.position, target, self.step)\n            if (not self._in_bounds(qnew_pos)) or self._point_blocked(qnew_pos):\n                continue\n            if self._has_close(G, qnew_pos, self.dupe_radius):\n                continue\n\n            parent, bestc = self._choose_parent(G, qnew_pos, qnear)\n            if parent is None:\n                continue\n\n            # Both checks before insertion\n            if self._point_blocked(qnew_pos):\n                continue\n            if not self._edge_free(parent.position, qnew_pos):\n                continue\n\n            qnode = Node(qnew_pos, parent, bestc)\n            qnode.attach(parent)\n            T.append(qnode)\n            nodes.append(qnode)\n            edges.append((parent, qnode))\n            self._grid_add(G, qnode)\n            frontier.append(qnode)\n            if len(frontier) > 160:\n                del frontier[:16]\n\n            # Local light rewiring\n            if self.k_rewire > 0:\n                self._rewire_local(qnode, G, edges, k=self.k_rewire)\n\n            # Try to connect to opposite tree\n            other_near = self._nearest(GO, frontierO, qnode.position, max_rings=2)\n            if other_near is not None:\n                # Direct bridge\n                if self._edge_free(qnode.position, other_near.position):\n                    path = self._assemble_path(qnode, other_near, growA)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # Elastic micro-bridge (commit only if it completes)\n                qlast = self._micro_bridge(O, GO, other_near, qnode.position)\n                if qlast is not None and self._edge_free(qnode.position, qlast.position):\n                    path = self._assemble_path(qnode, qlast, growA)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            s ^= (int(v * 2654435761) & 0xffffffff)\n            s = (s * 1664525 + 1013904223) & 0xffffffff\n        s ^= len(self.obstacles) * 374761393\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        # xorshift32\n        x = self._rng & 0xffffffff\n        x ^= (x << 13) & 0xffffffff\n        x ^= (x >> 17) & 0xffffffff\n        x ^= (x << 5) & 0xffffffff\n        self._rng = x & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Obstacle bins and collisions\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self._obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self._obin.get(key)\n                            if lst is None:\n                                self._obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self._obin.get(key)\n                        if lst is None:\n                            self._obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_bucket(self, p):\n        if self.is3:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell),\n                                   int(p[2] // self.obs_cell)))\n        else:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell)))\n\n    def _point_blocked(self, p):\n        bucket = self._point_bucket(p)\n        if not bucket:\n            return False\n        if self.is3:\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _seg_box_intersect(self, a, b, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(self.dim):\n            p = a[i]\n            d = b[i] - a[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _edge_free(self, a, b):\n        # Quickly reject with obstacle bin candidate list based on segment bbox coverage\n        if self.is3:\n            mn = (min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2]))\n            mx = (max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2]))\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            iz0 = int(max(0.0, mn[2]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mx[2]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self._obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return True\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            mn = (min(a[0], b[0]), min(a[1], b[1]))\n            mx = (max(a[0], b[0]), max(a[1], b[1]))\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self._obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return True\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    # Grid utilities\n    def _cell_key(self, pos):\n        if self.is3:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, frontier, pos, max_rings=2):\n        kk = self._cell_key(pos)\n        best = None\n        bd = 1e100\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring(grid, kk, r)\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bd:\n                        bd = d2\n                        best = n\n                if best is not None:\n                    return best\n        # fallback to recent frontier\n        if frontier:\n            lim = min(24, len(frontier))\n            for i in range(lim):\n                n = frontier[-1 - i]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bd:\n                    bd = d2\n                    best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, cap=20):\n        kk = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((kk[0] + dx, kk[1] + dy, kk[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n                                if len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((kk[0] + dx, kk[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n                            if len(out) >= cap:\n                                return out\n        return out\n\n    def _has_close(self, grid, pos, radius):\n        ns = self._neighbors(grid, pos, radius, cap=6)\n        return len(ns) > 0\n\n    # Parent selection with small turn penalty\n    def _choose_parent(self, grid, new_pos, fallback):\n        cand = self._neighbors(grid, new_pos, self.nei_radius, cap=24)\n        if fallback not in cand:\n            cand.append(fallback)\n        best = None\n        best_cost = 1e100\n        for p in cand:\n            d = self._dist(p.position, new_pos)\n            if d > 1.6 * self.step:\n                continue\n            if not self._edge_free(p.position, new_pos):\n                continue\n            c = p.cost + d\n            # Turn penalty: prefer smoother joins\n            if p.parent is not None:\n                u = tuple(p.position[i] - p.parent.position[i] for i in range(self.dim))\n                v = tuple(new_pos[i] - p.position[i] for i in range(self.dim))\n                nu = max(1e-12, self._dist((0.0,) * self.dim, u))\n                nv = max(1e-12, self._dist((0.0,) * self.dim, v))\n                dot = 0.0\n                for i in range(self.dim):\n                    dot += u[i] * v[i]\n                cosang = max(-1.0, min(1.0, dot / (nu * nv)))\n                # angle in [0, pi]; penalty scaled by step\n                ang = (1.0 - cosang)  # cheaper than acos, monotonic\n                c += 0.08 * self.step * ang\n            if c < best_cost:\n                best_cost = c\n                best = p\n        return best, best_cost\n\n    # Light rewiring around a new node\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                edges.pop(i)\n                return\n\n    def _propagate_delta(self, node, delta):\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    def _rewire_local(self, new_node, grid, edges, k=4):\n        neigh = self._neighbors(grid, new_node.position, self.nei_radius, cap=32)\n        if not neigh:\n            return\n        # Prefer closest neighbors\n        neigh.sort(key=lambda n: self._dist2(n.position, new_node.position))\n        count = 0\n        for nb in neigh:\n            if count >= k:\n                break\n            if nb is new_node or nb is new_node.parent:\n                continue\n            if self._is_ancestor(nb, new_node):\n                continue\n            # Both checks before adding new edge\n            if self._point_blocked(nb.position):\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            cand_cost = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand_cost + 1e-9 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    # detach from old parent\n                    i = 0\n                    while i < len(oldp.children):\n                        if oldp.children[i] is nb:\n                            oldp.children.pop(i)\n                            break\n                        i += 1\n                    self._remove_edge(edges, oldp, nb)\n                nb.attach(new_node)\n                edges.append((new_node, nb))\n                delta = cand_cost - nb.cost\n                nb.cost = cand_cost\n                self._propagate_delta(nb, delta)\n                count += 1\n\n    # Micro-bridge: simulate a few steps on opposite tree, commit only if connection completes\n    def _micro_bridge(self, tree, grid, near_node, target_pos):\n        cur = near_node.position\n        chain = []\n        success = False\n        last = None\n        for _ in range(self.connect_hops):\n            nxt = self._steer(cur, target_pos, self.step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                break\n            if self._has_close(grid, nxt, self.dupe_radius * 0.7):\n                break\n            if not self._edge_free(cur, nxt):\n                break\n            chain.append(nxt)\n            cur = nxt\n            # if we can close the final link to target, mark success\n            if self._edge_free(cur, target_pos):\n                success = True\n                last = cur\n                break\n        if not success or last is None:\n            return None\n        # Commit the chain to the opposite tree with both checks on each segment\n        prev = near_node\n        for p in chain:\n            if self._point_blocked(p):\n                return None\n            if not self._edge_free(prev.position, p):\n                return None\n            nn = Node(p, prev, prev.cost + self._dist(prev.position, p))\n            nn.attach(prev)\n            tree.append(nn)\n            self._grid_add(grid, nn)\n            prev = nn\n        return prev\n\n    # Sampling\n    def _sample_target(self, attract):\n        for _ in range(28):\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attract\n            elif r < self.goal_bias + self.corridor_bias:\n                p = self._corridor_point()\n            else:\n                if self.is3:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        return None\n\n    def _corridor_point(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step, 0.08 * sg)\n        if self.is3:\n            return self._clamp((base[0] + self._rand_range(-w, w),\n                                base[1] + self._rand_range(-w, w),\n                                base[2] + self._rand_range(-w, w)))\n        else:\n            return self._clamp((base[0] + self._rand_range(-w, w),\n                                base[1] + self._rand_range(-w, w)))\n\n    # Path assembly and utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _assemble_path(self, a_end, b_end, a_side_grew):\n        if a_side_grew:\n            pa = self._path_to_root(a_end)\n            pb = self._path_to_root(b_end)\n            if pa and pb and pa[0] == pb[-1]:\n                pb = pb[:-1]\n            return pa + pb[::-1]\n        else:\n            pa = self._path_to_root(a_end)\n            pb = self._path_to_root(b_end)\n            if pa and pb and pb[0] == pa[-1]:\n                pa = pa[:-1]\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # Smoothing\n    def _vis_collapse(self, pts, passes=2):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            i = 0\n            changed = False\n            while i < len(cur) - 2:\n                j = len(cur) - 1\n                while j > i + 1:\n                    if self._edge_free(cur[i], cur[j]):\n                        if j > i + 1:\n                            del cur[i + 1:j]\n                            changed = True\n                        break\n                    j -= 1\n                i += 1\n            if not changed:\n                break\n        return cur\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            n = len(cur)\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j > n - 1:\n                tries += 1\n                continue\n            a, b = cur[i], cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-12 <= bestL:\n                    cur = cand\n                    bestL = L\n            tries += 1\n        return cur\n\n    def _round_corners(self, pts, passes):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                c = cur[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                if (not self._in_bounds(mid)) or self._point_blocked(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if cur[i] != mid:\n                        cur[i] = mid\n                        moved = True\n            if not moved:\n                break\n        return cur\n\n    def _postprocess(self, path):\n        if len(path) < 3:\n            return path[:]\n        p = self._vis_collapse(path, passes=2)\n        p = self._shortcut(p, self.smooth_shortcuts)\n        p = self._round_corners(p, self.smooth_rounds)\n        return p",
          "objective": -37.68839,
          "time_improvement": 61.0,
          "length_improvement": 21.0,
          "smoothness_improvement": 1336.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011586189270019531,
                    "num_nodes_avg": 61.0,
                    "path_length_avg": 150.2550697876198,
                    "smoothness_avg": 0.041941448754662616,
                    "success_improvement": 0.0,
                    "time_improvement": 53.03776905243485,
                    "node_improvement": 84.63863006799295,
                    "length_improvement": 17.64281530546121,
                    "smoothness_improvement": 556.4747503241836,
                    "objective_score": 29.279393650628094
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03080716133117676,
                    "num_nodes_avg": 131.0,
                    "path_length_avg": 228.48646410685174,
                    "smoothness_avg": 0.08768701591384163,
                    "success_improvement": 0.0,
                    "time_improvement": 81.58034736794089,
                    "node_improvement": 91.19801115366526,
                    "length_improvement": 23.72464166291407,
                    "smoothness_improvement": 2156.250077867826,
                    "objective_score": 49.490139597469835
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026394367218017578,
                    "num_nodes_avg": 112.0,
                    "path_length_avg": 116.65576078031737,
                    "smoothness_avg": 0.10957624060714707,
                    "success_improvement": 0.0,
                    "time_improvement": 47.70981892140697,
                    "node_improvement": 85.75969485060394,
                    "length_improvement": 22.5227982401031,
                    "smoothness_improvement": 1293.8016924461601,
                    "objective_score": 34.29563308271475
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "BASIL-RRT: Bi-directional Adaptive Simplified Informed Lite with Rewire and Visibility. Two trees grow toward each other with simple grid-accelerated nearest search, duplicate suppression, best-parent selection, visibility jumps to higher ancestors, and light local rewiring. Guided sampling uses corridor and informed-ellipse biases to shorten routes. On connection, deterministic visibility compression, shortcutting, and elastic smoothing yield short, smooth paths efficiently.",
          "planning_mechanism": "Initialize bidirectional trees and spatial hashes. Repeat: sample a biased target (goal/corridor/informed/uniform), pick the nearest via grid, steer by a fixed step, and validate both node and edge. Choose the least-cost feasible parent from nearby nodes, insert, then visibility-jump to a visible ancestor and locally rewire cheaper neighbors. Probe the opposite tree for a direct or short bridge; if connected, assemble the path and postprocess with visibility compression, randomized shortcuts, and elastic smoothing. Maintain an incumbent best path for informed sampling.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=7.0,\n        goal_bias=0.15,\n        corridor_bias=0.45,\n        informed_bias=0.5,\n        cell_size_factor=1.2,\n        dupe_ratio=0.3,\n        connect_dist_factor=2.5,\n        rewire_mult=2.5,\n        neighbor_cap=32,\n        shortcuts=120,\n        elastic_iters=10\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.cell_size_factor = float(cell_size_factor)\n        self.dupe_ratio = float(dupe_ratio)\n        self.connect_dist_factor = float(connect_dist_factor)\n        self.rewire_mult = float(rewire_mult)\n        self.neighbor_cap = int(neighbor_cap)\n        self.shortcuts = int(max(0, shortcuts))\n        self.elastic_iters = int(max(0, elastic_iters))\n        self._rnd = 2463534242\n\n    # Public entry\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if getattr(map, \"obstacles\", None) else []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        self._seed_from_scene()\n        self._build_obstacle_grid()\n\n        # Endpoint validity\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Parameters\n        self.cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_ratio)\n        self.connect_dist = max(self.step_size, self.connect_dist_factor * self.step_size)\n        corridor_w = max(self.step_size, 0.2 * self._dist(self.start, self.goal))\n\n        # Trees and grids\n        nodes = []\n        edges = []\n\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_insert(Ga, a_root)\n        self._grid_insert(Gb, b_root)\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            T = Ta if side_a else Tb\n            G = Ga if side_a else Gb\n            T_opp = Tb if side_a else Ta\n            G_opp = Gb if side_a else Ga\n            attractor = self.goal if side_a else self.start\n\n            # Target sampling\n            target = self._sample_target(attractor, best_len, corridor_w)\n            if target is None:\n                continue\n\n            # Nearest and steer\n            near = self._nearest_grid(G, target)\n            if near is None:\n                continue\n            new_pos = self._steer(near.position, target)\n            if not self._within_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if self._has_nearby(G, new_pos, self.dupe_radius):\n                continue\n\n            # Best-parent selection with local neighbors\n            parent, new_cost = self._choose_parent(T, G, new_pos)\n            if parent is None:\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            # Insert node\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            T.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(G, new_node)\n\n            # Visibility jump to a cheaper visible ancestor\n            self._visibility_jump(new_node, edges)\n\n            # Local rewiring (length/cost reduction)\n            self._rewire_neighbors(G, new_node, edges)\n\n            # Try connect to opposite tree\n            other_near = self._nearest_grid(G_opp, new_node.position)\n            if other_near is not None:\n                dno = self._dist(new_node.position, other_near.position)\n                if dno <= self.connect_dist and self._edge_free(new_node.position, other_near.position):\n                    path = self._assemble_path(new_node, other_near, side_a)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # One-step probe from opposite tree\n                step_p = self._steer(other_near.position, new_node.position)\n                if self._within_bounds(step_p) and not self._point_in_obstacles(step_p):\n                    if not self._has_nearby(G_opp, step_p, self.dupe_radius):\n                        if self._edge_free(other_near.position, step_p):\n                            q = Node(step_p, other_near, other_near.cost + self._dist(other_near.position, step_p))\n                            other_near.add_child(q)\n                            T_opp.append(q)\n                            nodes.append(q)\n                            edges.append((other_near, q))\n                            self._grid_insert(G_opp, q)\n                            self._visibility_jump(q, edges)\n                            self._rewire_neighbors(G_opp, q, edges)\n                            if self._edge_free(new_node.position, q.position):\n                                path = self._assemble_path(new_node, q, side_a)\n                                path = self._postprocess(path)\n                                return PlannerResult(True, path, nodes, edges)\n\n            # Maintain incumbent best for informed sampling\n            if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                tmp = self._assemble_path(new_node, other_near, side_a)\n                L = self._path_len(tmp)\n                if L < best_len:\n                    best_len = L\n                    best_path = tmp\n\n        if best_path is not None:\n            best_path = self._postprocess(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 1) * 2654435761\n        self._rnd = (s ^ 0x9E3779B9) & 0xffffffff\n        if self._rnd == 0:\n            self._rnd = 2463534242\n\n    def _rand(self):\n        self._rnd = (1664525 * self._rnd + 1013904223) & 0xffffffff\n        return self._rnd / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= self.step_size:\n            return self._clamp(b)\n        r = self.step_size / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Sampling\n    def _sample_target(self, attractor, best_len, corridor_w):\n        for _ in range(16):\n            if best_len < float('inf') and self._rand() < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p is not None and not self._point_in_obstacles(p):\n                    return p\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attractor\n            elif r < self.goal_bias + self.corridor_bias:\n                t = self._rand()\n                base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n                if self.dims == 3:\n                    p = (self._rand_range(base[0] - corridor_w, base[0] + corridor_w),\n                         self._rand_range(base[1] - corridor_w, base[1] + corridor_w),\n                         self._rand_range(base[2] - corridor_w, base[2] + corridor_w))\n                else:\n                    p = (self._rand_range(base[0] - corridor_w, base[0] + corridor_w),\n                         self._rand_range(base[1] - corridor_w, base[1] + corridor_w))\n            else:\n                p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            p = self._clamp(p)\n            if not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if self._within_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Node spatial grid\n    def _cell_of(self, pos, cell=None):\n        cs = self.cell_size if cell is None else cell\n        if self.dims == 3:\n            return (int(pos[0] // cs), int(pos[1] // cs), int(pos[2] // cs))\n        return (int(pos[0] // cs), int(pos[1] // cs))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _nearest_grid(self, grid, pos):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        # Expand rings up to 3\n        for r in range(0, 4):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback: scan all buckets\n        for b in grid.values():\n            for n in b:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.dims == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _neighbors_within_radius(self, grid, pos, radius, cap):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        out = []\n        rr = radius * radius\n        for n in cand:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= rr:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _has_nearby(self, grid, pos, radius):\n        neigh = self._neighbors_within_radius(grid, pos, radius, self.neighbor_cap)\n        return len(neigh) > 0\n\n    # Parent selection and optimization\n    def _choose_parent(self, tree, grid, new_pos):\n        n = len(tree)\n        # Dynamic radius ~ n^{-1/d}\n        dyn_r = max(self.step_size, self.rewire_mult * self.step_size * (1.0 / (1.0 + n)) ** (1.0 / max(1, self.dims)))\n        neigh = self._neighbors_within_radius(grid, new_pos, dyn_r, self.neighbor_cap)\n        if not neigh:\n            near = None\n            bestd = 1e100\n            for m in tree:\n                d = self._dist(m.position, new_pos)\n                if d < bestd:\n                    bestd = d\n                    near = m\n            neigh = [near] if near is not None else []\n        best_parent = None\n        best_cost = 1e100\n        for p in neigh:\n            d = self._dist(p.position, new_pos)\n            if d > dyn_r + 1e-9:\n                continue\n            if not self._edge_free(p.position, new_pos):\n                continue\n            gc = p.cost + d\n            if gc < best_cost:\n                best_cost = gc\n                best_parent = p\n        if best_parent is None:\n            return None, None\n        return best_parent, best_cost\n\n    def _visibility_jump(self, node, edges):\n        cur_parent = node.parent\n        if cur_parent is None:\n            return\n        best_parent = cur_parent\n        best_cost = node.cost\n        anc = cur_parent.parent\n        while anc is not None:\n            if self._edge_free(anc.position, node.position):\n                c = anc.cost + self._dist(anc.position, node.position)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best_parent = anc\n            anc = anc.parent\n        if best_parent is not cur_parent:\n            self._reparent(node, best_parent, edges)\n\n    def _rewire_neighbors(self, grid, node, edges):\n        # Use same dynamic radius as parent selection from this node's tree size (approx via node.cost order not needed)\n        radius = max(self.step_size, self.rewire_mult * self.step_size * 0.9)\n        neigh = self._neighbors_within_radius(grid, node.position, radius, self.neighbor_cap)\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if node.cost + d + 1e-9 < nb.cost and self._edge_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        if child.parent is new_parent:\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old_parent = child.parent\n        if old_parent is not None:\n            old_parent.remove_child(child)\n            self._edges_remove(edges, old_parent, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        self._propagate_costs(child)\n\n    def _edges_remove(self, edges, parent, child):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is parent and e[1] is child:\n                edges.pop(i)\n                break\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if abs(newc - ch.cost) > 1e-12:\n                    ch.cost = newc\n                    stack.append(ch)\n\n    # Obstacles\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.dims == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.dims == 3:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Path assembly and post-process\n    def _assemble_path(self, u, v, side_a):\n        # u in current tree, v in opposite\n        pu = u.path_from_root()\n        pv = v.path_from_root()\n        if side_a:\n            # start -> u then v -> goal\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _postprocess(self, path):\n        if len(path) < 2:\n            return path[:]\n        p = self._visibility_compress(path)\n        p = self._shortcut(p, self.shortcuts)\n        p = self._elastic(p, self.elastic_iters)\n        return p\n\n    def _visibility_compress(self, path):\n        out = [path[0]]\n        anchor = path[0]\n        i = 1\n        while i < len(path):\n            far = i\n            j = i\n            while j < len(path):\n                if self._edge_free(anchor, path[j]):\n                    far = j\n                    j += 1\n                else:\n                    break\n            out.append(path[far])\n            anchor = path[far]\n            i = far + 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = path[:]\n        best = self._path_len(pts)\n        n = len(pts)\n        noimp = 0\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j > n:\n                noimp += 1\n                if noimp > 16:\n                    break\n                continue\n            a, b = pts[i], pts[j - 1]\n            if self._edge_free(a, b):\n                candidate = pts[:i + 1] + pts[j - 1:]\n                L = self._path_len(candidate)\n                if L <= best + 1e-12:\n                    pts = candidate\n                    best = L\n                    n = len(pts)\n                    noimp = 0\n                else:\n                    noimp += 1\n            else:\n                noimp += 1\n            if noimp > 24:\n                break\n        return pts\n\n    def _elastic(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return path[:]\n        pts = list(path)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dims))\n                if self._point_in_obstacles(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if mid != pts[i]:\n                        pts[i] = mid\n                        moved = True\n            if not moved:\n                break\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        return pts",
          "objective": -37.60553,
          "time_improvement": 63.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1737.0,
          "node_improvement": 84.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01027677059173584,
                    "num_nodes_avg": 56.0,
                    "path_length_avg": 152.97087548687767,
                    "smoothness_avg": 0.05880624031240139,
                    "success_improvement": 0.0,
                    "time_improvement": 58.34522786771023,
                    "node_improvement": 85.89775875094435,
                    "length_improvement": 16.154239167002743,
                    "smoothness_improvement": 820.4453606838263,
                    "objective_score": 31.298338663933844
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.048004674911499026,
                    "num_nodes_avg": 233.0,
                    "path_length_avg": 260.1076340388263,
                    "smoothness_avg": 0.1240816945243068,
                    "success_improvement": 0.0,
                    "time_improvement": 71.29792559985403,
                    "node_improvement": 84.34455418934354,
                    "length_improvement": 13.168584974709937,
                    "smoothness_improvement": 3092.7113725425193,
                    "objective_score": 44.754085527494766
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021122431755065917,
                    "num_nodes_avg": 136.0,
                    "path_length_avg": 118.36585536678952,
                    "smoothness_avg": 0.1098386556019516,
                    "success_improvement": 0.0,
                    "time_improvement": 58.154110224750575,
                    "node_improvement": 82.70820089001907,
                    "length_improvement": 21.38703484172179,
                    "smoothness_improvement": 1297.1395918106139,
                    "objective_score": 36.764151931511314
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "ABLE-RRT: Adaptive Best-Parent Light Elastic Bidirectional RRT-Connect. Two grids grow start/goal trees with mixture-biased sampling. Each extension selects a locally optimal parent within one-step radius to reduce path cost, enforces strict node/edge collision checks, and performs greedy connect to the opposite tree. AABB-pruned edge checks accelerate collision tests. Upon connection, a light two-stage smoother (visibility compression + shortcutting + optional rubber-band) improves length and smoothness while keeping runtime low.",
          "planning_mechanism": "Initialize bidirectional trees and coarse grids. Each iteration: sample (goal/corridor/uniform), find a near node via grid, propose a one-step point, choose the best parent among nearby nodes that can reach it collision-free, then insert. Greedily connect the other tree toward the new node; if a short, collision-free bridge closes the gap, assemble the path and apply lightweight smoothing.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=7.0,\n        goal_bias=0.20,\n        corridor_bias=0.40,\n        cell_size_factor=2.0,\n        edge_resolution=1.0,\n        dupe_radius_ratio=0.40,\n        neighbor_radius_ratio=1.25,\n        smooth_shortcuts=80,\n        rubber_iters=6\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.cell_size_factor = float(cell_size_factor)\n        self.edge_resolution = float(edge_resolution)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.neighbor_radius_ratio = float(neighbor_radius_ratio)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self.rubber_iters = int(max(0, rubber_iters))\n\n    def plan(self, map):\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        obstacles = list(map.obstacles)\n\n        # Validate start/goal\n        if not self._within_bounds(start, bounds) or not self._within_bounds(goal, bounds):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight line\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_resolution):\n            n0 = Node(start, None, 0.0)\n            n1 = Node(goal, n0, self._distance(start, goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [start, goal], [n0, n1], [(n0, n1)])\n\n        # Init trees and grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n        cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        grid_start, grid_goal = {}, {}\n        self._grid_insert(grid_start, start_root.position, start_root, cell_size, dim)\n        self._grid_insert(grid_goal, goal_root.position, goal_root, cell_size, dim)\n\n        dsg = self._distance(start, goal)\n        corridor_w = max(self.step_size, 0.18 * dsg)\n        dupe_radius = max(0.5, self.dupe_radius_ratio * self.step_size)\n        neighbor_radius = max(self.step_size, self.neighbor_radius_ratio * self.step_size)\n\n        for it in range(self.max_iter):\n            # Alternate growth\n            if it % 2 == 0:\n                grow_tree, grow_grid, grow_root = start_tree, grid_start, start_root\n                other_tree, other_grid, other_root = goal_tree, grid_goal, goal_root\n                other_root_pos = goal\n                a_is_start_side = True\n            else:\n                grow_tree, grow_grid, grow_root = goal_tree, grid_goal, goal_root\n                other_tree, other_grid, other_root = start_tree, grid_start, start_root\n                other_root_pos = start\n                a_is_start_side = False\n\n            target = self._sample_target(bounds, obstacles, is_3d, start, goal, corridor_w, other_root_pos)\n            a_near = self._nearest_from_grid(grow_tree, grow_grid, target, cell_size, dim)\n\n            # Propose a one-step point\n            proposed = self._steer(a_near.position, target, self.step_size)\n            if not self._within_bounds(proposed, bounds):\n                continue\n            if self._is_in_obstacle(proposed, obstacles, is_3d):\n                continue\n            if self._exists_close(grow_grid, proposed, dupe_radius, cell_size, dim):\n                continue\n\n            # Choose best parent among neighbors that can reach proposed within one step\n            candidates = self._neighbors_within_radius(grow_grid, proposed, neighbor_radius, cell_size, dim)\n            if a_near not in candidates:\n                candidates.append(a_near)\n            best_parent = None\n            best_cost = float('inf')\n            for cand in candidates:\n                dcp = self._distance(cand.position, proposed)\n                if dcp > self.step_size + 1e-9:\n                    continue\n                if self._is_edge_in_obstacle(cand.position, proposed, obstacles, is_3d, self.edge_resolution):\n                    continue\n                cost = cand.cost + dcp\n                if cost < best_cost:\n                    best_cost = cost\n                    best_parent = cand\n            if best_parent is None:\n                continue\n\n            # Commit new node (both node and edge already validated)\n            new_node = Node(proposed, best_parent, best_cost)\n            best_parent.add_child(new_node)\n            grow_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            self._grid_insert(grow_grid, new_node.position, new_node, cell_size, dim)\n\n            # Greedy connect from the other tree toward new_node\n            b_near = self._nearest_from_grid(other_tree, other_grid, new_node.position, cell_size, dim)\n            b_last = self._greedy_extend(other_tree, other_grid, b_near, new_node.position,\n                                         nodes, edges, obstacles, is_3d, bounds, cell_size, dim)\n            if b_last is None:\n                continue\n\n            # Try final short bridge\n            if self._distance(b_last.position, new_node.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(b_last.position, new_node.position, obstacles, is_3d, self.edge_resolution):\n                    edges.append((b_last, new_node))\n                    # Assemble path\n                    if a_is_start_side:\n                        pa = new_node.path_from_root()\n                        pb = b_last.path_from_root()\n                        raw_path = pa + pb[::-1]\n                    else:\n                        pa = new_node.path_from_root()\n                        pb = b_last.path_from_root()\n                        raw_path = pb + pa[::-1]\n                    # Smooth\n                    path = self._compress_visibility(raw_path, obstacles, is_3d)\n                    path = self._shortcut_path(path, obstacles, is_3d, bounds, self.smooth_shortcuts)\n                    path = self._rubber_band(path, obstacles, is_3d, self.rubber_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---- Geometry utilities ----\n    def _distance(self, a, b):\n        s = 0.0\n        for i in range(len(a)):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p, bounds):\n        for i in range(len(bounds)):\n            if p[i] < 0.0 or p[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._distance(from_pos, to_pos)\n        if d <= step:\n            return tuple(to_pos[i] for i in range(len(to_pos)))\n        r = step / (d + 1e-12)\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    # ---- Sampling ----\n    def _sample_target(self, bounds, obstacles, is_3d, start, goal, corridor_w, other_root_pos):\n        import random  # Local import to avoid global requirement; acceptable inline\n        r = random.random()\n        if r < self.goal_bias:\n            return other_root_pos\n        elif r < self.goal_bias + self.corridor_bias:\n            t = random.random()\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(len(bounds)))\n            if len(bounds) == 3:\n                return (\n                    self._clamp(base[0] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[0]),\n                    self._clamp(base[1] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[1]),\n                    self._clamp(base[2] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[2]),\n                )\n            else:\n                return (\n                    self._clamp(base[0] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[0]),\n                    self._clamp(base[1] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[1]),\n                )\n        else:\n            # rejection sample in free space\n            for _ in range(32):\n                if len(bounds) == 3:\n                    p = (random.uniform(0.0, bounds[0]),\n                         random.uniform(0.0, bounds[1]),\n                         random.uniform(0.0, bounds[2]))\n                else:\n                    p = (random.uniform(0.0, bounds[0]),\n                         random.uniform(0.0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback (may be occupied; extension will reject)\n            if len(bounds) == 3:\n                return (random.uniform(0.0, bounds[0]),\n                        random.uniform(0.0, bounds[1]),\n                        random.uniform(0.0, bounds[2]))\n            else:\n                return (random.uniform(0.0, bounds[0]),\n                        random.uniform(0.0, bounds[1]))\n\n    def _clamp(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # ---- Collision utilities ----\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for x, y, z, w, h, d in obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for x, y, w, h in obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _seg_aabb_overlap(self, a, b, obs, is_3d):\n        if is_3d:\n            x, y, z, w, h, d = obs\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            if maxx < x or minx > x + w or maxy < y or miny > y + h or maxz < z or minz > z + d:\n                return False\n            return True\n        else:\n            x, y, w, h = obs\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            if maxx < x or minx > x + w or maxy < y or miny > y + h:\n                return False\n            return True\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._distance(a, b)\n        steps = int(max(1, d / max(1e-9, resolution)))\n        # Pre-filter obstacles by segment AABB overlap\n        relevant = []\n        for obs in obstacles:\n            if self._seg_aabb_overlap(a, b, obs, is_3d):\n                relevant.append(obs)\n        if not relevant:\n            return False\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(len(a)))\n            if self._is_in_obstacle(p, relevant, is_3d):\n                return True\n        return False\n\n    # ---- Grid NN and neighborhood ----\n    def _cell_index(self, pos, cell_size, dim):\n        if dim == 2:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size))\n        else:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size), int(pos[2] // cell_size))\n\n    def _grid_insert(self, grid, pos, node, cell_size, dim):\n        idx = self._cell_index(pos, cell_size, dim)\n        bucket = grid.get(idx)\n        if bucket is None:\n            grid[idx] = [node]\n        else:\n            bucket.append(node)\n\n    def _nearest_from_grid(self, tree, grid, point, cell_size, dim, max_rings=3):\n        if len(tree) < 32:\n            best = None\n            bestd = float('inf')\n            for n in tree:\n                d = self._distance(n.position, point)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            return best\n        center = self._cell_index(point, cell_size, dim)\n        best = None\n        bestd = float('inf')\n        found = False\n        for r in range(0, max_rings + 1):\n            cand = []\n            if dim == 2:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        idx = (center[0] + dx, center[1] + dy)\n                        if idx in grid:\n                            cand.extend(grid[idx])\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            idx = (center[0] + dx, center[1] + dy, center[2] + dz)\n                            if idx in grid:\n                                cand.extend(grid[idx])\n            if cand:\n                for n in cand:\n                    d = self._distance(n.position, point)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                        found = True\n            if found:\n                break\n        if best is None:\n            # fallback linear\n            best = tree[0]\n            bestd = self._distance(best.position, point)\n            for n in tree:\n                d = self._distance(n.position, point)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors_within_radius(self, grid, point, radius, cell_size, dim):\n        cells = int(radius / max(1e-9, cell_size)) + 1\n        center = self._cell_index(point, cell_size, dim)\n        out = []\n        if dim == 2:\n            for dx in range(-cells, cells + 1):\n                for dy in range(-cells, cells + 1):\n                    idx = (center[0] + dx, center[1] + dy)\n                    if idx in grid:\n                        out.extend(grid[idx])\n        else:\n            for dx in range(-cells, cells + 1):\n                for dy in range(-cells, cells + 1):\n                    for dz in range(-cells, cells + 1):\n                        idx = (center[0] + dx, center[1] + dy, center[2] + dz)\n                        if idx in grid:\n                            out.extend(grid[idx])\n        # filter by true distance\n        rr = radius * radius\n        fil = []\n        for n in out:\n            s = 0.0\n            p = n.position\n            for i in range(dim):\n                d = p[i] - point[i]\n                s += d * d\n            if s <= rr:\n                fil.append(n)\n        return fil\n\n    def _exists_close(self, grid, pos, radius, cell_size, dim):\n        neigh = self._neighbors_within_radius(grid, pos, radius, cell_size, dim)\n        return len(neigh) > 0\n\n    # ---- Extend/connect ----\n    def _greedy_extend(self, tree, grid, from_node, target_pos, nodes, edges, obstacles, is_3d, bounds, cell_size, dim):\n        current = from_node\n        last_new = None\n        while True:\n            step_pos = self._steer(current.position, target_pos, self.step_size)\n            if not self._within_bounds(step_pos, bounds):\n                break\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                break\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d, self.edge_resolution):\n                break\n            new_node = Node(step_pos, current, current.cost + self._distance(current.position, step_pos))\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node.position, new_node, cell_size, dim)\n            last_new = new_node\n            current = new_node\n            if self._distance(current.position, target_pos) <= self.step_size:\n                break\n        return last_new\n\n    # ---- Smoothing ----\n    def _compress_visibility(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        last = path[0]\n        i = 1\n        while i < len(path):\n            far = i\n            j = i\n            while j < len(path):\n                if self._is_edge_in_obstacle(last, path[j], obstacles, is_3d, self.edge_resolution):\n                    break\n                far = j\n                j += 1\n            out.append(path[far])\n            last = path[far]\n            i = far + 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds, attempts):\n        if len(path) < 3:\n            return list(path)\n        import random\n        pts = list(path)\n        n = len(pts)\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_resolution):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts\n\n    def _rubber_band(self, path, obstacles, is_3d, iters):\n        if len(path) < 3 or iters <= 0:\n            return list(path)\n        pts = list(path)\n        for _ in range(iters):\n            changed = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(len(a)))\n                if self._is_in_obstacle(mid, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(a, mid, obstacles, is_3d, self.edge_resolution):\n                    continue\n                if self._is_edge_in_obstacle(mid, c, obstacles, is_3d, self.edge_resolution):\n                    continue\n                if mid != pts[i]:\n                    pts[i] = mid\n                    changed = True\n            if not changed:\n                break\n        return pts",
          "objective": -37.59775,
          "time_improvement": 66.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1905.0,
          "node_improvement": 85.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009185576438903808,
                    "num_nodes_avg": 64.4,
                    "path_length_avg": 170.56202690395023,
                    "smoothness_avg": 0.04785735504538155,
                    "success_improvement": 0.0,
                    "time_improvement": 62.768158532802346,
                    "node_improvement": 83.782422563586,
                    "length_improvement": 6.512250325673065,
                    "smoothness_improvement": 649.0715303700621,
                    "objective_score": 25.983155407094852
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027295637130737304,
                    "num_nodes_avg": 154.6,
                    "path_length_avg": 240.5028644826979,
                    "smoothness_avg": 0.12901280114279629,
                    "success_improvement": 0.0,
                    "time_improvement": 83.67989348599582,
                    "node_improvement": 89.61230934623397,
                    "length_improvement": 19.713221344549247,
                    "smoothness_improvement": 3219.5922975687886,
                    "objective_score": 53.02986234037223
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02437562942504883,
                    "num_nodes_avg": 141.5,
                    "path_length_avg": 127.88160399822759,
                    "smoothness_avg": 0.15294445433893913,
                    "success_improvement": 0.0,
                    "time_improvement": 51.70916332215004,
                    "node_improvement": 82.00890019071836,
                    "length_improvement": 15.067127691977475,
                    "smoothness_improvement": 1845.4421700060007,
                    "objective_score": 33.7802364618615
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "FLASH-Connect-Lite: Fast Lattice-Hashed Spatially-Indexed BiRRT-Connect. It accelerates planning with a uniform spatial hash for obstacles and nodes, greedy multi-step RRT-Connect extensions, bounded per-cell admissions, near-duplicate suppression, and collision-check caching. The spatial hash prunes obstacle checks to local bins, drastically reducing segment and point collision costs; greedy connect minimizes iterations and edge tests; and early visibility pruning plus bounded shortcutting quickly yields usable, smooth paths.",
          "planning_mechanism": "Alternate extending start/goal trees: sample with goal bias, find a near node via lattice-hash rings, and greedily extend multiple steps toward the sample while enforcing in-bounds, node-collision, and edge-collision checks and skipping near-duplicates/excess cells. After each insertion, attempt a greedy connect from the opposite tree toward the new node; on first line-of-sight bridge, extract the path, visibility-prune, and shortcut-smooth, then stop. Obstacle and node queries use a spatial hash; edge checks use cached segment results.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        goal_bias=0.35,\n        grid_cell_factor=1.8,\n        max_per_cell=6,\n        min_sep_factor=0.6,\n        ring_max=3,\n        min_nn_candidates=16,\n        connect_max_steps=48,\n        smoothing_iters=40\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.max_per_cell = max_per_cell\n        self.min_sep_factor = min_sep_factor\n        self.ring_max = ring_max\n        self.min_nn_candidates = min_nn_candidates\n        self.connect_max_steps = connect_max_steps\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        self._lcg_state = 2463534242\n\n        # Spatial indices and caches\n        self._obs_grid = {}\n        self._obs_cell = 4.0\n        self._edge_cache = {}\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        self.is_3d = is_3d\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Parameters derived from map/step\n        self.edge_res = max(0.5, min(1.0, self.step_size * 0.5))\n        self.nn_cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.3, self.step_size * self.min_sep_factor)\n        self._obs_cell = max(2.0, self.step_size)  # coarse but effective for pruning\n\n        # Reset RNG and caches\n        self._lcg_state = 2463534242\n        self._edge_cache = {}\n\n        # Build obstacle spatial hash\n        self._build_obs_grid(obstacles, is_3d)\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start) or self._is_in_obstacle(goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line attempt\n        if not self._edge_blocked(start, goal):\n            path = [start, goal]\n            path = self._visibility_prune(path)\n            path = self._shortcut_smooth(path, min(10, self.smoothing_iters))\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Initialize trees and their spatial hashes\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n\n        self._grid_add(grid_start, counts_start, start_root)\n        self._grid_add(grid_goal, counts_goal, goal_root)\n\n        # Main planning loop\n        for it in range(self.max_iter):\n            a_is_start = (it % 2 == 0)\n            tree_a = start_tree if a_is_start else goal_tree\n            tree_b = goal_tree if a_is_start else start_tree\n            grid_a = grid_start if a_is_start else grid_goal\n            grid_b = grid_goal if a_is_start else grid_start\n            counts_a = counts_start if a_is_start else counts_goal\n            counts_b = counts_goal if a_is_start else counts_start\n            attractor = goal if a_is_start else start\n\n            # Sample target with goal bias\n            target = self._guided_sample(attractor)\n\n            # Greedy extend Tree A toward target (multi-step RRT-Connect style)\n            new_node = self._extend_greedy(tree_a, grid_a, counts_a, nodes, edges, target)\n            if new_node is None:\n                continue\n\n            # Attempt fast direct bridge to Tree B\n            other_near = self._nearest_hashed(grid_b, tree_b, new_node.position)\n            if other_near is not None and not self._edge_blocked(new_node.position, other_near.position):\n                path = self._extract_path(new_node, other_near, a_is_start)\n                path = self._visibility_prune(path)\n                path = self._shortcut_smooth(path, self.smoothing_iters)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Otherwise greedy-connect Tree B toward new_node\n            hit_node = self._connect_greedy(tree_b, grid_b, counts_b, nodes, edges, new_node.position)\n            if hit_node is not None:\n                # Final LOS check between the connection endpoints\n                if not self._edge_blocked(new_node.position, hit_node.position):\n                    path = self._extract_path(new_node, hit_node, a_is_start)\n                    path = self._visibility_prune(path)\n                    path = self._shortcut_smooth(path, self.smoothing_iters)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG utilities\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry helpers\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer_step(self, from_pos, to_pos):\n        d = self._dist(from_pos, to_pos)\n        if d <= 1e-9:\n            return self._clamp(from_pos)\n        if d <= self.step_size:\n            return self._clamp(to_pos)\n        r = self.step_size / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Obstacle spatial hash\n    def _obs_key(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self._obs_cell), int(pos[1] // self._obs_cell), int(pos[2] // self._obs_cell))\n        else:\n            return (int(pos[0] // self._obs_cell), int(pos[1] // self._obs_cell))\n\n    def _build_obs_grid(self, obstacles, is_3d):\n        self._obs_grid = {}\n        if is_3d:\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                x2, y2, z2 = x + w, y + h, z + d\n                ix0 = int(x // self._obs_cell)\n                iy0 = int(y // self._obs_cell)\n                iz0 = int(z // self._obs_cell)\n                ix1 = int(x2 // self._obs_cell)\n                iy1 = int(y2 // self._obs_cell)\n                iz1 = int(z2 // self._obs_cell)\n                for ix in range(ix0, ix1 + 1):\n                    for iy in range(iy0, iy1 + 1):\n                        for iz in range(iz0, iz1 + 1):\n                            key = (ix, iy, iz)\n                            bucket = self._obs_grid.get(key)\n                            if bucket is None:\n                                self._obs_grid[key] = [obs]\n                            else:\n                                bucket.append(obs)\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                x2, y2 = x + w, y + h\n                ix0 = int(x // self._obs_cell)\n                iy0 = int(y // self._obs_cell)\n                ix1 = int(x2 // self._obs_cell)\n                iy1 = int(y2 // self._obs_cell)\n                for ix in range(ix0, ix1 + 1):\n                    for iy in range(iy0, iy1 + 1):\n                        key = (ix, iy)\n                        bucket = self._obs_grid.get(key)\n                        if bucket is None:\n                            self._obs_grid[key] = [obs]\n                        else:\n                            bucket.append(obs)\n\n    def _is_in_obstacle(self, pos):\n        if self.is_3d:\n            px, py, pz = pos\n            key = self._obs_key(pos)\n            bucket = self._obs_grid.get(key)\n            if not bucket:\n                return False\n            for obs in bucket:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            key = self._obs_key(pos)\n            bucket = self._obs_grid.get(key)\n            if not bucket:\n                return False\n            for obs in bucket:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_hits(self, a, b):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p):\n                return True\n        return False\n\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked(self, a, b):\n        k = self._edge_key(a, b)\n        cached = self._edge_cache.get(k)\n        if cached is not None:\n            return cached\n        blocked = self._segment_hits(a, b)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    # Node spatial hash (for NN and duplicate suppression)\n    def _grid_key(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.nn_cell), int(pos[1] // self.nn_cell), int(pos[2] // self.nn_cell))\n        else:\n            return (int(pos[0] // self.nn_cell), int(pos[1] // self.nn_cell))\n\n    def _grid_add(self, grid, counts, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n\n    def _grid_ring_cells(self, key, r):\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        yield (key[0] + dx, key[1] + dy, key[2] + dz)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    yield (key[0] + dx, key[1] + dy)\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        seen = set()\n        total = 0\n        for r in range(0, self.ring_max + 1):\n            for cell in self._grid_ring_cells(key, r):\n                bucket = grid.get(cell)\n                if not bucket:\n                    continue\n                for n in bucket:\n                    if id(n) in seen:\n                        continue\n                    seen.add(id(n))\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                    total += 1\n            if total >= self.min_nn_candidates and best is not None:\n                break\n        if best is not None:\n            return best\n        # Fallback random subset if grid empty\n        if not tree:\n            return None\n        trials = min(48, len(tree))\n        for _ in range(trials):\n            idx = int(self._uniform(0, len(tree)))\n            n = tree[idx]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r = max(1, int(radius // self.nn_cell) + 1)\n        rr = radius\n        for rad in range(0, r + 1):\n            for cell in self._grid_ring_cells(key, rad):\n                bucket = grid.get(cell)\n                if not bucket:\n                    continue\n                for n in bucket:\n                    if self._dist(n.position, pos) <= rr:\n                        return True\n        return False\n\n    # Sampling\n    def _sample_free(self):\n        while True:\n            if self.is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p):\n                return p\n\n    def _guided_sample(self, attractor):\n        if self._rand() < self.goal_bias:\n            if not self._is_in_obstacle(attractor):\n                return attractor\n        # Blend toward attractor\n        alpha = 0.25\n        if self.is_3d:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]),\n                   self._uniform(0.0, self.bounds[2]))\n            p = tuple(alpha * attractor[i] + (1.0 - alpha) * rnd[i] for i in range(3))\n        else:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]))\n            p = tuple(alpha * attractor[i] + (1.0 - alpha) * rnd[i] for i in range(2))\n        if self._in_bounds(p) and not self._is_in_obstacle(p):\n            return p\n        return self._sample_free()\n\n    # Greedy extend for active tree (multi-step)\n    def _extend_greedy(self, tree, grid, counts, nodes_all, edges_all, target):\n        nearest = self._nearest_hashed(grid, tree, target)\n        if nearest is None:\n            return None\n        cur = nearest\n        last_added = None\n        for _ in range(self.connect_max_steps):\n            new_pos = self._steer_step(cur.position, target)\n            if not self._in_bounds(new_pos):\n                break\n            if self._is_in_obstacle(new_pos):\n                break\n            if self._edge_blocked(cur.position, new_pos):\n                break\n            # Per-cell capacity and near-duplicate suppression\n            key = self._grid_key(new_pos)\n            if counts.get(key, 0) >= self.max_per_cell:\n                # Try to step further without adding\n                if self._dist(new_pos, target) <= 1e-6:\n                    break\n                # advance origin for next attempt to same cur to see if farther step is viable\n                # but keep cur to avoid skipping collision guarantee; attempt another step\n                # however, to prevent infinite loops if target within step, break\n                cur_to_target = self._dist(cur.position, target)\n                if cur_to_target <= self.step_size + 1e-9:\n                    break\n                # Try to leap one more step ahead\n                leap_pos = self._steer_step(new_pos, target)\n                if not self._in_bounds(leap_pos) or self._is_in_obstacle(leap_pos) or self._edge_blocked(cur.position, leap_pos):\n                    break\n                new_pos = leap_pos  # accept leap if valid\n                key = self._grid_key(new_pos)\n                if counts.get(key, 0) >= self.max_per_cell:\n                    # still crowded; skip insertion this round\n                    if self._dist(new_pos, target) <= self.step_size:\n                        break\n                    continue\n            if self._near_duplicate(grid, new_pos, self.min_sep):\n                if self._dist(new_pos, target) <= self.step_size:\n                    break\n                # continue stepping without adding\n                cur_to_target = self._dist(cur.position, target)\n                if cur_to_target <= self.step_size + 1e-9:\n                    break\n                continue\n\n            # Insert node\n            new_cost = cur.cost + self._dist(cur.position, new_pos)\n            new_node = Node(new_pos, parent=cur, cost=new_cost)\n            cur.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_all.append((cur, new_node))\n            self._grid_add(grid, counts, new_node)\n            last_added = new_node\n            cur = new_node\n\n            # Stop if we got close enough to target\n            if self._dist(new_pos, target) <= self.step_size * 0.5:\n                break\n        return last_added\n\n    # Greedy connect from the opposite tree toward a target point; return last added if progressed\n    def _connect_greedy(self, tree, grid, counts, nodes_all, edges_all, target):\n        nearest = self._nearest_hashed(grid, tree, target)\n        if nearest is None:\n            return None\n        cur = nearest\n        last_added = None\n        for _ in range(self.connect_max_steps):\n            new_pos = self._steer_step(cur.position, target)\n            if not self._in_bounds(new_pos):\n                break\n            if self._is_in_obstacle(new_pos):\n                break\n            if self._edge_blocked(cur.position, new_pos):\n                break\n            key = self._grid_key(new_pos)\n            if counts.get(key, 0) >= self.max_per_cell:\n                cur_to_target = self._dist(cur.position, target)\n                if cur_to_target <= self.step_size + 1e-9:\n                    break\n                # attempt to continue without adding\n                continue\n            if self._near_duplicate(grid, new_pos, self.min_sep):\n                cur_to_target = self._dist(cur.position, target)\n                if cur_to_target <= self.step_size + 1e-9:\n                    break\n                continue\n            # Insert node\n            new_cost = cur.cost + self._dist(cur.position, new_pos)\n            new_node = Node(new_pos, parent=cur, cost=new_cost)\n            cur.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_all.append((cur, new_node))\n            self._grid_add(grid, counts, new_node)\n            last_added = new_node\n            cur = new_node\n\n            # If close enough to target, stop\n            if self._dist(new_pos, target) <= self.step_size * 0.5:\n                break\n        return last_added\n\n    # Path extraction and post-processing\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j]):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -37.29529,
          "time_improvement": 53.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 2507.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015715956687927246,
                    "num_nodes_avg": 50.0,
                    "path_length_avg": 159.74438521735743,
                    "smoothness_avg": 0.04853181796198822,
                    "success_improvement": 0.0,
                    "time_improvement": 36.29860773549004,
                    "node_improvement": 87.40871317048602,
                    "length_improvement": 12.441571150596545,
                    "smoothness_improvement": 659.628339634622,
                    "objective_score": 21.65266670917805
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07348463535308838,
                    "num_nodes_avg": 114.0,
                    "path_length_avg": 256.59359164084896,
                    "smoothness_avg": 0.19309266417859872,
                    "success_improvement": 0.0,
                    "time_improvement": 56.06341517653498,
                    "node_improvement": 92.34025398105221,
                    "length_improvement": 14.341673473257,
                    "smoothness_improvement": 4868.413328339737,
                    "objective_score": 49.76609527861338
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016176486015319826,
                    "num_nodes_avg": 81.0,
                    "path_length_avg": 125.19551263187705,
                    "smoothness_avg": 0.1646340240175897,
                    "success_improvement": 0.0,
                    "time_improvement": 67.95257957997248,
                    "node_improvement": 89.70120788302607,
                    "length_improvement": 16.851101679581618,
                    "smoothness_improvement": 1994.132633484155,
                    "objective_score": 40.467098049161486
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "AERO-Connect-R*: Adaptive Elliptic Rewired Connect BiRRT with Hash-Grids. It couples bidirectional RRT-Connect growth (greedy multi-step connect) with lightweight RRT* local optimization (best-parent selection and bounded rewiring), uses adaptive informed sampling (goal/corridor \u2192 ellipse after first incumbent), and fast slab-based collision via obstacle bins. A two-stage path refiner (visibility + shortcut + corner-round) improves length and smoothness at negligible cost.",
          "planning_mechanism": "Mechanism: Alternate expanding start/goal trees. Each iteration: draw a guided sample (goal/corridor/uniform; switch to ellipse once a path is known), pick an anchor via multi-ring hash-grid nearest, steer one step, validate node/edge, choose cheapest parent among nearby anchors, insert and locally rewire. Then greedily connect the opposite tree toward the new node with multiple validated steps; on meeting, extract the path and run refinements, then return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.25,\n                 corridor_bias=0.35,\n                 ellipse_bias=0.55,\n                 grid_cell_factor=1.7,\n                 neighbor_radius_factor=2.4,\n                 min_sep_ratio=0.4,\n                 k_parent=6,\n                 k_rewire=6,\n                 connect_mult=1.8,\n                 smoothing_attempts=120):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.ellipse_bias = float(ellipse_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neigh_factor = float(neighbor_radius_factor)\n        self.min_sep_ratio = float(min_sep_ratio)\n        self.k_parent = int(max(1, k_parent))\n        self.k_rewire = int(max(0, k_rewire))\n        self.connect_mult = float(connect_mult)\n        self.smoothing_attempts = int(max(0, smoothing_attempts))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self._is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Spatial parameters\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.neigh_radius = max(self.step * 1.2, self.step * self.neigh_factor)\n        self.min_sep = max(0.5, self.step * self.min_sep_ratio)\n        self.connect_step = max(self.step, self.step * self.connect_mult)\n\n        # Initialize RNG seed\n        self._seed()\n\n        # Build obstacle bins before any collision checks\n        self._build_obs_bins()\n\n        # Validate start/goal\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Trivial straight-line solution\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._smooth_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize two trees and their grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = self.goal if active_start else self.start\n\n            # Guided sampling with informed ellipse once best path exists\n            sp = self._guided_sample(root_other, best_len)\n            if sp is None:\n                continue\n\n            # Nearest anchor in active tree\n            anchor = self._nearest_grid(grid_a, sp)\n            if anchor is None:\n                anchor = tree_a[-1]\n\n            # Steer one step toward sample\n            newp = self._steer(anchor.position, sp, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(grid_a, newp, self.min_sep):\n                continue\n            if not self._edge_free(anchor.position, newp):\n                continue\n\n            # Best-parent selection (local RRT*)\n            neigh = self._neighbors(grid_a, newp, self.neigh_radius)\n            if not neigh:\n                neigh = [anchor]\n            # Sort few closest anchors\n            neigh = sorted(neigh, key=lambda n: self._dist2(n.position, newp))[:self.k_parent]\n            parent = anchor\n            bestc = anchor.cost + self._dist(anchor.position, newp)\n            for nb in neigh:\n                gc = nb.cost + self._dist(nb.position, newp)\n                if gc + 1e-12 < bestc and self._edge_free(nb.position, newp):\n                    parent = nb\n                    bestc = gc\n\n            # Final checks before adding node/edge\n            if self._point_in_obstacles(newp) or (not self._edge_free(parent.position, newp)):\n                continue\n\n            nn = Node(newp, parent, bestc)\n            parent.add_child(nn)\n            tree_a.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(grid_a, nn)\n\n            # Bounded local rewiring\n            if self.k_rewire > 0:\n                self._rewire_lite(nn, grid_a, edges)\n\n            # Greedy multi-step connect from the opposite tree toward nn\n            other_near = self._nearest_grid(grid_b, nn.position)\n            meet_b = other_near\n            connected = False\n            cur = other_near\n            if cur is not None:\n                while True:\n                    # If we are close and direct edge is free, consider connected\n                    if self._dist(cur.position, nn.position) <= self.connect_step and self._edge_free(cur.position, nn.position):\n                        connected = True\n                        meet_b = cur\n                        break\n                    # Otherwise extend the other tree by a connect step\n                    nxtp = self._steer(cur.position, nn.position, self.connect_step)\n                    if (not self._in_bounds(nxtp)) or self._point_in_obstacles(nxtp):\n                        break\n                    if not self._edge_free(cur.position, nxtp):\n                        break\n                    # Add the node to the opposite tree (both checks already passed)\n                    cn = Node(nxtp, cur, cur.cost + self._dist(cur.position, nxtp))\n                    cur.add_child(cn)\n                    tree_b.append(cn)\n                    nodes.append(cn)\n                    edges.append((cur, cn))\n                    self._grid_add(grid_b, cn)\n                    cur = cn\n                    meet_b = cur\n                    # Loop continues until blocked or within direct reach\n\n            if connected:\n                # Extract full path (do not insert a cross-edge to preserve tree structures)\n                path = self._extract_path(nn, meet_b)\n                L = self._path_len(path)\n                if best_len is None or L + 1e-9 < best_len:\n                    best_len = L\n                path = self._smooth_path(path)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- RNG ----------\n    def _seed(self):\n        s = 0x9E3779B97F4A7C15 & 0xffffffff\n        for v in self.start + self.goal:\n            zv = int(v * 1315423911) & 0xffffffff\n            s ^= ((zv ^ (zv << 13) ^ (zv >> 17)) & 0xffffffff)\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # ---------- Spatial hash for nodes ----------\n    def _cell_key(self, p):\n        if self._is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self._is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            cand.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        cand.extend(lst)\n        return cand\n\n    def _nearest_grid(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback scan\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self._is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors(grid, pos, radius)) > 0\n\n    # ---------- Obstacles: binning and collision ----------\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self._is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obin.get(key)\n                            if b is None:\n                                self.obin[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obin.get(key)\n                        if b is None:\n                            self.obin[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self._is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self._is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # ---------- Rewiring ----------\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _erase_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                del edges[i]\n                break\n\n    def _propagate_cost(self, node, delta):\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    def _rewire_lite(self, new_node, grid, edges):\n        neigh = self._neighbors(grid, new_node.position, self.neigh_radius)\n        if not neigh:\n            return\n        neigh = sorted(neigh, key=lambda n: self._dist2(n.position, new_node.position))[:self.k_rewire]\n        for nb in neigh:\n            if nb is new_node or nb is new_node.parent:\n                continue\n            if self._is_ancestor(nb, new_node):\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            cand = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand + 1e-9 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._erase_edge(edges, oldp, nb)\n                new_node.add_child(nb)\n                edges.append((new_node, nb))\n                delta = cand - nb.cost\n                nb.cost = cand\n                self._propagate_cost(nb, delta)\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, target_root, incumbent_len):\n        tries = 20\n        while tries > 0:\n            tries -= 1\n            r = self._rand()\n            if incumbent_len is not None and r < self.ellipse_bias:\n                p = self._sample_in_ellipse(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                r2 = self._rand()\n                if r2 < self.goal_bias:\n                    p = target_root\n                elif r2 < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_point()\n                else:\n                    if self._is3:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]),\n                             self._rand_range(0.0, self.bounds[2]))\n                    else:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _corridor_point(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step, 0.07 * sg)\n        if self._is3:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            oz = self._rand_range(-w, w)\n            return self._clamp((base[0] + ox, base[1] + oy, base[2] + oz))\n        else:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            return self._clamp((base[0] + ox, base[1] + oy))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(16):\n            if self._is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if not self._in_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # ---------- Paths and smoothing ----------\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, meet_a, meet_b):\n        # meet_a is in active tree; meet_b is in the opposite tree\n        path_a = self._trace_to_root(meet_a)\n        # path_b: from meet_b up to its root\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # Concatenate without adding a cross edge to preserve structures\n        return path_a + path_b\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _prune_collinear(self, pts, cos_eps=0.999):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        for i in range(1, len(pts) - 1):\n            a = out[-1]\n            b = pts[i]\n            c = pts[i + 1]\n            v1 = tuple(b[j] - a[j] for j in range(self.dim))\n            v2 = tuple(c[j] - b[j] for j in range(self.dim))\n            n1 = sum(v1[j] * v1[j] for j in range(self.dim)) ** 0.5\n            n2 = sum(v2[j] * v2[j] for j in range(self.dim)) ** 0.5\n            if n1 < 1e-9 or n2 < 1e-9:\n                continue\n            cosang = sum(v1[j] * v2[j] for j in range(self.dim)) / (n1 * n2)\n            if cosang < cos_eps:\n                out.append(b)\n        out.append(pts[-1])\n        return out\n\n    def _vis_collapse(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = pts[:]\n        i = 0\n        while i < len(out) - 2:\n            j = len(out) - 1\n            collapsed = False\n            while j > i + 1:\n                if self._edge_free(out[i], out[j]):\n                    del out[i + 1:j]\n                    collapsed = True\n                    break\n                j -= 1\n            if not collapsed:\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        stall = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 1, len(cur) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-9 <= bestL:\n                    cur = cand\n                    bestL = L\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            tries += 1\n            if stall > 24:\n                break\n        return cur\n\n    def _round_corners(self, pts, passes=2):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            i = 1\n            while i < len(cur) - 1:\n                a = cur[i - 1]\n                c = cur[i + 1]\n                # propose midpoint between a and c\n                mid = tuple(0.5 * (a[j] + c[j]) for j in range(self.dim))\n                if self._in_bounds(mid) and (not self._point_in_obstacles(mid)):\n                    if self._edge_free(a, mid) and self._edge_free(mid, c):\n                        cur[i] = mid\n                i += 1\n        return cur\n\n    def _smooth_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._prune_collinear(path)\n        p1 = self._vis_collapse(p0)\n        p2 = self._shortcut(p1, self.smoothing_attempts)\n        p3 = self._round_corners(p2, passes=2)\n        return p3",
          "objective": -37.18079,
          "time_improvement": 73.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1385.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009148359298706055,
                    "num_nodes_avg": 41.0,
                    "path_length_avg": 160.05130696013703,
                    "smoothness_avg": 0.047923416631070685,
                    "success_improvement": 0.0,
                    "time_improvement": 62.919010542245815,
                    "node_improvement": 89.67514479979855,
                    "length_improvement": 12.273342479892806,
                    "smoothness_improvement": 650.1055376411265,
                    "objective_score": 29.490236338815063
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.039803075790405276,
                    "num_nodes_avg": 172.0,
                    "path_length_avg": 240.87765654308606,
                    "smoothness_avg": 0.0896202009366,
                    "success_improvement": 0.0,
                    "time_improvement": 76.20167525773196,
                    "node_improvement": 88.44319021702614,
                    "length_improvement": 19.588104967000366,
                    "smoothness_improvement": 2205.992320920289,
                    "objective_score": 45.64332716212125
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.00955343246459961,
                    "num_nodes_avg": 74.0,
                    "path_length_avg": 136.5410158564313,
                    "smoothness_avg": 0.11001885368701667,
                    "success_improvement": 0.0,
                    "time_improvement": 81.07358629325219,
                    "node_improvement": 90.59122695486332,
                    "length_improvement": 9.315958652640234,
                    "smoothness_improvement": 1299.4316981518023,
                    "objective_score": 36.40880957031881
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SIBiRRT-Connect-Lite: A streamlined balanced informed BiRRT-Connect with light neighbor parent selection, grid-accelerated proximity/collision, and two-phase shortcut refinement for faster search, shorter paths, and improved smoothness.",
          "planning_mechanism": "Per iteration, expand the smaller tree: sample from a mixed distribution (uniform/corridor/goal; ellipse after a first solution), steer one bounded step, validate node and edge, pick the cheapest feasible parent among the nearest few neighbors, insert, then greedily connect the opposite tree toward it until blocked. On connection, extract and shortcut the path and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=6.0,\n        goal_bias=0.25,\n        corridor_bias=0.35,\n        grid_cell_factor=1.0,\n        min_sep_ratio=0.3,\n        neighbor_radius_factor=2.0,\n        neighbor_cap=6,\n        connect_steps=32,\n        shortcut_attempts=80\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.min_sep_ratio = min_sep_ratio\n        self.neighbor_radius_factor = neighbor_radius_factor\n        self.neighbor_cap = neighbor_cap\n        self.connect_steps = connect_steps\n        self.shortcut_attempts = shortcut_attempts\n        self._rnd_state = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step_size * self.min_sep_ratio)\n        self.neighbor_radius = max(self.step_size * 1.2, self.step_size * self.neighbor_radius_factor)\n\n        self._seed_from_scene()\n\n        nodes = []\n        edges = []\n\n        if (not self._within_bounds(self.start)) or (not self._within_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._build_obstacle_grid()\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        incumbent_len = None\n\n        for _ in range(self.max_iter):\n            if len(tree_a) <= len(tree_b):\n                active_tree, active_grid = tree_a, grid_a\n                passive_tree, passive_grid = tree_b, grid_b\n                attractor = self.goal\n            else:\n                active_tree, active_grid = tree_b, grid_b\n                passive_tree, passive_grid = tree_a, grid_a\n                attractor = self.start\n\n            s = self._sample(attractor, incumbent_len)\n            if s is None:\n                continue\n\n            nearest = self._nearest_in_grid(active_grid, s)\n            if nearest is None:\n                continue\n\n            new_pos = self._steer(nearest.position, s, self.step_size)\n            if not self._within_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if self._has_nearby(active_grid, new_pos, self.min_sep):\n                continue\n\n            parent, new_cost = self._choose_parent_light(active_grid, nearest, new_pos)\n            if parent is None:\n                continue\n\n            if self._point_in_obstacles(new_pos):\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(active_grid, new_node)\n\n            meet = self._connect_toward(passive_tree, passive_grid, new_node.position, nodes, edges)\n            if meet is not None and self._edge_free(meet.position, new_node.position):\n                path = self._extract_path(new_node, meet)\n                incumbent_len = self._path_len(path)\n                path = self._shortcut(path)\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0x7fffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0x7fffffff\n        self._rnd_state = (s ^ 0x9E3779B9) & 0x7fffffff\n        if self._rnd_state == 0:\n            self._rnd_state = 123456789\n\n    def _rand(self):\n        self._rnd_state = (1103515245 * self._rnd_state + 12345) & 0x7fffffff\n        return self._rnd_state / 2147483647.0\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            q = []\n            for i in range(self.dims):\n                q.append(self._clamp_val(b[i], 0.0, self.bounds[i]))\n            return tuple(q)\n        d = d2 ** 0.5\n        r = step / d\n        q = []\n        for i in range(self.dims):\n            v = a[i] + (b[i] - a[i]) * r\n            q.append(self._clamp_val(v, 0.0, self.bounds[i]))\n        return tuple(q)\n\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_in_grid(self, grid, pos, max_ring=4):\n        key = self._cell_of(pos)\n        best = None\n        bestd2 = 1e100\n        for r in range(0, max_ring + 1):\n            cand = self._ring_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            if best is not None:\n                return best\n        buckets = list(grid.values())\n        if not buckets:\n            return None\n        trials = 0\n        while trials < 24:\n            b = buckets[int(self._rand() * len(buckets)) % max(1, len(buckets))]\n            if b:\n                n = b[int(self._rand() * len(b)) % max(1, len(b))]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            trials += 1\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        rc = int(radius // self.cell_size) + 1\n        r2 = radius * radius\n        for n in self._ring_collect(grid, key, rc):\n            if self._dist2(n.position, pos) <= r2:\n                return True\n        return False\n\n    def _nearby_nodes(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        rc = int(radius // self.cell_size) + 1\n        r2 = radius * radius\n        out = []\n        for n in self._ring_collect(grid, key, rc):\n            if self._dist2(n.position, pos) <= r2:\n                out.append(n)\n        return out\n\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            b = self.obs_grid.get((cx, cy, cz))\n            if not b:\n                return False\n            px, py, pz = p\n            for idx in b:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            b = self.obs_grid.get((cx, cy))\n            if not b:\n                return False\n            px, py = p\n            for idx in b:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _choose_parent_light(self, grid, nearest, new_pos):\n        neigh = self._nearby_nodes(grid, new_pos, self.neighbor_radius)\n        if nearest not in neigh:\n            neigh.append(nearest)\n        neigh.sort(key=lambda n: self._dist2(n.position, new_pos))\n        cand = neigh[:max(1, self.neighbor_cap)]\n        best_parent = None\n        best_cost = 1e100\n        for n in cand:\n            if not self._edge_free(n.position, new_pos):\n                continue\n            c = n.cost + self._dist(n.position, new_pos)\n            if c + 1e-9 < best_cost:\n                best_cost = c\n                best_parent = n\n        if best_parent is None:\n            return None, None\n        return best_parent, best_cost\n\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        near = self._nearest_in_grid(grid, target_pos)\n        if near is None:\n            return None\n        cur = near\n        steps = 0\n        while steps < self.connect_steps:\n            nxt = self._steer(cur.position, target_pos, self.step_size)\n            if self._dist2(cur.position, nxt) < (self.min_sep * self.min_sep * 0.25):\n                break\n            if not self._within_bounds(nxt):\n                break\n            if self._point_in_obstacles(nxt):\n                break\n            if self._has_nearby(grid, nxt, self.min_sep):\n                break\n            if not self._edge_free(cur.position, nxt):\n                break\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            q = Node(nxt, cur, new_cost)\n            cur.add_child(q)\n            tree.append(q)\n            nodes.append(q)\n            edges.append((cur, q))\n            self._grid_insert(grid, q)\n            cur = q\n            steps += 1\n            if self._dist2(cur.position, target_pos) <= (self.step_size * self.step_size) and self._edge_free(cur.position, target_pos):\n                return cur\n        return None\n\n    def _sample(self, attractor, incumbent_len):\n        for _ in range(20):\n            r = self._rand()\n            if incumbent_len is not None and r < 0.55:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                elif r < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_sample()\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            if p is not None and self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        if self._within_bounds(attractor) and not self._point_in_obstacles(attractor):\n            return attractor\n        return None\n\n    def _corridor_sample(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n        dsg = self._dist(self.start, self.goal)\n        width = max(self.step_size, 0.08 * dsg)\n        if self.is_3d:\n            return (\n                self._clamp_val(base[0] + self._rand_range(-width, width), 0.0, self.bounds[0]),\n                self._clamp_val(base[1] + self._rand_range(-width, width), 0.0, self.bounds[1]),\n                self._clamp_val(base[2] + self._rand_range(-width, width), 0.0, self.bounds[2]),\n            )\n        else:\n            return (\n                self._clamp_val(base[0] + self._rand_range(-width, width), 0.0, self.bounds[0]),\n                self._clamp_val(base[1] + self._rand_range(-width, width), 0.0, self.bounds[1]),\n            )\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum_dist\n        ext = [max(self.step_size, half)] * self.dims\n        for _ in range(18):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._within_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum_dist and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        pb.reverse()\n        if pa and pb and pa[-1] == pb[0]:\n            pb = pb[1:]\n        return pa + pb\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        i = 0\n        while i < len(pts) - 2:\n            j = len(pts) - 1\n            improved = False\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    del pts[i + 1:j]\n                    improved = True\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n        attempts = 0\n        while attempts < self.shortcut_attempts and len(pts) > 2:\n            i = int(self._rand_range(0, len(pts) - 2))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                attempts += 1\n                continue\n            if self._edge_free(pts[i], pts[j]):\n                pts = pts[:i + 1] + pts[j:]\n            attempts += 1\n        return pts",
          "objective": -37.09124,
          "time_improvement": 61.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1377.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011144709587097169,
                    "num_nodes_avg": 49.0,
                    "path_length_avg": 150.61019244127573,
                    "smoothness_avg": 0.04827733550563596,
                    "success_improvement": 0.0,
                    "time_improvement": 54.82721598316178,
                    "node_improvement": 87.6605389070763,
                    "length_improvement": 17.448166951713837,
                    "smoothness_improvement": 655.6451365752101,
                    "objective_score": 30.195290648852886
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04703662395477295,
                    "num_nodes_avg": 160.0,
                    "path_length_avg": 222.69131300634007,
                    "smoothness_avg": 0.08728289130799861,
                    "success_improvement": 0.0,
                    "time_improvement": 71.87672486543198,
                    "node_improvement": 89.24947927165222,
                    "length_improvement": 25.65922990444059,
                    "smoothness_improvement": 2145.851660680297,
                    "objective_score": 47.68781370569543
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02253601551055908,
                    "num_nodes_avg": 116.0,
                    "path_length_avg": 125.1119046359757,
                    "smoothness_avg": 0.11227318427452833,
                    "success_improvement": 0.0,
                    "time_improvement": 55.35364337006359,
                    "node_improvement": 85.2511125238398,
                    "length_improvement": 16.906630129474358,
                    "smoothness_improvement": 1328.1066168275754,
                    "objective_score": 33.39060417284157
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "FLASH-IBiRRT: A fast, informed bidirectional RRT-Connect with bounded parenting and zero-cost rewiring. It grows two trees with large-step greedy connections, uses a compact spatial hash and obstacle bins for O(1)-like queries, schedules goal/segment-biased sampling, and returns on the first valid connection. Post-processing applies a single shortcut pass and visibility pruning for quick, smooth paths.",
          "planning_mechanism": "Alternate expansions from start/goal: sample (goal/line/uniform), steer one step from the active tree, insert only if node- and edge-free, then greedily connect the opposite tree with larger steps, inserting the exact meeting point when visible. No global rewiring; a small, local best-parent choice near the extension reduces cost at negligible overhead. Early exit upon connection, followed by fast shortcut and visibility prune.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=7.5,\n        connect_factor=2.6,\n        goal_bias=0.18,\n        line_bias=0.22,\n        grid_cell_factor=2.0,\n        k_parent=6,\n        smooth_attempts=60\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_step = self.step * float(connect_factor)\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.k_parent = int(max(1, k_parent))\n        self.smooth_attempts = int(max(0, smooth_attempts))\n        self._rng = 246813579\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_radius = max(0.4, 0.35 * self.step)\n\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            final = self._finalize_path(path)\n            return PlannerResult(True, final, nodes, edges)\n\n        # Initialize trees\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        Ta, Tb = [start_root], [goal_root]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, start_root)\n        self._grid_add(Gb, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        for it in range(self.max_iter):\n            # Two fast passes per iteration: grow both sides toward a single sample\n            attract_a = self.goal\n            attract_b = self.start\n            sample = self._sample(attract_a, attract_b)\n            if sample is None:\n                continue\n\n            # pass 1: start tree\n            res = self._expand_and_connect(Ta, Ga, Tb, Gb, sample, nodes, edges, active_is_start=True)\n            if res is not None:\n                path = res\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n            # pass 2: goal tree\n            res = self._expand_and_connect(Tb, Gb, Ta, Ga, sample, nodes, edges, active_is_start=False)\n            if res is not None:\n                path = res\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # Core expansion + connection\n    def _expand_and_connect(self, Ta, Ga, Tb, Gb, sample, nodes, edges, active_is_start):\n        na = self._nearest(Ga, sample)\n        if na is None:\n            return None\n\n        # Choose a lightweight best parent among k nearest in the grid ring\n        target = self._steer(na.position, sample, self.step)\n        if (not self._in_bounds(target)) or self._point_in_obstacles(target):\n            return None\n\n        parent = self._best_parent(Ga, target, na, self.k_parent)\n        if parent is None:\n            return None\n\n        if (not self._edge_free(parent.position, target)):\n            return None\n\n        if self._too_close(Ga, target, self.dup_radius):\n            return None\n\n        new_cost = parent.cost + self._dist(parent.position, target)\n        nn = Node(target, parent, new_cost)\n        parent.add_child(nn)\n        Ta.append(nn)\n        nodes.append(nn)\n        edges.append((parent, nn))\n        self._grid_add(Ga, nn)\n\n        meet_node, reached = self._connect_toward(Tb, Gb, nn.position, nodes, edges)\n        if reached:\n            pa = self._trace_to_root(nn)\n            pb = self._trace_to_root(meet_node)\n            if active_is_start:\n                # pa goes start->...->nn, pb goes goal->...->meet\n                # Join paths; include meet if different from nn\n                if pa[-1] != pb[-1]:\n                    path = pa + [pb[-1]] + pb[-2::-1]\n                else:\n                    path = pa + pb[-2::-1]\n            else:\n                # pa goes goal->...->nn, pb goes start->...->meet\n                if pa[-1] != pb[-1]:\n                    path = pb + [pa[-1]] + pa[-2::-1]\n                else:\n                    path = pb + pa[-2::-1]\n            return self._dedup(path)\n        return None\n\n    # RNG and sampling\n    def _seed_from_scene(self):\n        s = 0xA341316C & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 11400714819323198485 & 0xffffffff)\n            s ^= (q ^ (q >> 15) ^ ((q << 9) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 29) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 246813579\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _sample(self, attract_a, attract_b):\n        r = self._rand()\n        # Goal bias\n        if r < self.goal_bias:\n            return attract_a\n        # Segment (start-goal) bias\n        if r < self.goal_bias + self.line_bias:\n            t = self._rand()\n            if self.is3:\n                return (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                        self.start[1] + (self.goal[1] - self.start[1]) * t,\n                        self.start[2] + (self.goal[2] - self.start[2]) * t)\n            else:\n                return (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                        self.start[1] + (self.goal[1] - self.start[1]) * t)\n        # Uniform\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial hash for nodes\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        for r in range(0, 3):\n            cand = self._grid_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found = True\n            if found:\n                return best\n        # fallback scan\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _k_nearest(self, grid, pos, kmax):\n        key = self._cell_key(pos)\n        heap = []\n        # simple partial selection without imports\n        cand = []\n        for r in range(0, 2):\n            cand.extend(self._grid_collect(grid, key, r))\n        if not cand:\n            for lst in grid.values():\n                cand.extend(lst)\n        # unique nodes (avoid tiny overhead of set by ID)\n        seen = {}\n        out = []\n        for n in cand:\n            if id(n) in seen:\n                continue\n            seen[id(n)] = True\n            out.append((self._dist2(n.position, pos), n))\n        out.sort(key=lambda x: x[0])\n        return [n for (_, n) in out[:kmax]]\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Local best parent (bounded k-NN)\n    def _best_parent(self, grid, newp, fallback, kmax):\n        best = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        kn = self._k_nearest(grid, newp, kmax)\n        for n in kn:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                best = n\n                best_cost = c\n        return best\n\n    # Greedy connect from the other tree toward a target position\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < 48:\n            if self._edge_free(cur.position, target_pos):\n                # Insert exact meeting point if sufficiently far/unique\n                if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                    if not self._too_close(grid, target_pos, 0.75 * self.dup_radius):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        cur.add_child(nn)\n                        tree.append(nn)\n                        nodes.append(nn)\n                        edges.append((cur, nn))\n                        self._grid_add(grid, nn)\n                        return nn, True\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            if self._too_close(grid, nxt, 0.75 * self.dup_radius):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n        # Last visibility try\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                if not self._too_close(grid, target_pos, 0.75 * self.dup_radius):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    cur.add_child(nn)\n                    tree.append(nn)\n                    nodes.append(nn)\n                    edges.append((cur, nn))\n                    self._grid_add(grid, nn)\n                    return nn, True\n            return cur, True\n        return cur, False\n\n    # Utilities\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        nbr = self._neighbors_in_radius(grid, pos, radius)\n        return len(nbr) > 0\n\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    # Fast, light smoothing\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._shortcut(path, self.smooth_attempts)\n        p2 = self._visibility_prune(p1)\n        return self._dedup(p2)",
          "objective": -37.07801,
          "time_improvement": 75.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1629.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014019584655761719,
                    "num_nodes_avg": 83.0,
                    "path_length_avg": 188.21860119077922,
                    "smoothness_avg": 0.04147767672480912,
                    "success_improvement": 0.0,
                    "time_improvement": 43.17450224151976,
                    "node_improvement": 79.0984638630068,
                    "length_improvement": -3.1655978272618333,
                    "smoothness_improvement": 549.2157109598944,
                    "objective_score": 13.799070530898302
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009280896186828614,
                    "num_nodes_avg": 72.0,
                    "path_length_avg": 247.55425918283944,
                    "smoothness_avg": 0.12140082327282926,
                    "success_improvement": 0.0,
                    "time_improvement": 94.45093684426602,
                    "node_improvement": 95.16226567224349,
                    "length_improvement": 17.35926283049915,
                    "smoothness_improvement": 3023.7306242884893,
                    "objective_score": 53.869491873021744
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.005894255638122558,
                    "num_nodes_avg": 52.0,
                    "path_length_avg": 124.23642750462632,
                    "smoothness_avg": 0.11125496209005074,
                    "success_improvement": 0.0,
                    "time_improvement": 88.32282311998175,
                    "node_improvement": 93.38842975206612,
                    "length_improvement": 17.48808035437552,
                    "smoothness_improvement": 1315.154905798364,
                    "objective_score": 43.56546967761165
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "INSTAR-BiRRT*: Informed-Indexed Star-Rewire Bidirectional Planner. A bidirectional, obstacle-indexed RRT with local best-parent selection, limited RRT*-style rewiring, cached edge checks, and informed corridor sampling that tightens after the first solution. It enforces strict node and edge collision checks before any insertion, caps connect steps, and maintains coherent trees/edges. On connection, it performs visibility compression, endpoint-inclusive shortcutting, and elastic smoothing for shorter, smoother paths while keeping runtime low.",
          "planning_mechanism": "Mechanism: Build start/goal trees with a spatial node grid and an obstacle cell index. Each iteration alternates trees, samples goal/corridor/informed/uniform targets using LCG RNG, gathers near candidates from grid rings, selects the cheapest collision-free parent, and inserts a single node after both node and edge checks. It then locally rewires cheaper neighbors (edge-checked) and attempts a bounded greedy connect on the opposite tree with commit-per-step checks. A cached, AABB-prefiltered edge tester accelerates validation. Upon bridge closure, it assembles the path and applies visibility compression, endpoint-inclusive random shortcuts, and elastic smoothing.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=7000,\n        step_size=6.0,\n        goal_bias=0.22,\n        corridor_bias=0.40,\n        grid_cell_factor=1.3,\n        neighbor_radius_ratio=1.5,\n        rewire_radius_ratio=1.8,\n        dupe_radius_ratio=0.30,\n        connect_hops=6,\n        edge_resolution=0.9,\n        shortcut_attempts=120,\n        elastic_iters=8\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neighbor_radius_ratio = float(neighbor_radius_ratio)\n        self.rewire_radius_ratio = float(rewire_radius_ratio)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.connect_hops = int(connect_hops)\n        self.edge_resolution = float(edge_resolution)\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.elastic_iters = int(max(0, elastic_iters))\n        # runtime fields\n        self.bounds = None\n        self.dim = 2\n        self.is_3d = False\n        self.start = None\n        self.goal = None\n        self.obstacles = None\n        self.grid_cell = 1.0\n        self.obs_cell = 4.0\n        self.edge_res = 1.0\n        self.cache_bin = 1.0\n        self._free_edge_cache = None\n        self._blocked_edge_cache = None\n        self.obs_index = None\n\n    # ---- Public API ----\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles)\n\n        # Parameterize\n        self.grid_cell = max(1.0, self.grid_cell_factor * self.step_size)\n        self.obs_cell = max(4.0, 1.2 * self.step_size)\n        self.edge_res = max(0.5, min(self.edge_resolution, self.step_size))\n        self.cache_bin = max(1.0, self.edge_res)\n\n        # Validate start/goal\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._build_obstacle_index()\n        if self._is_point_blocked_indexed(self.start) or self._is_point_blocked_indexed(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct LOS\n        self._free_edge_cache, self._blocked_edge_cache = set(), set()\n        if not self._is_edge_blocked_cached(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._distance(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Initialize trees, grids, edges\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree, goal_tree = [start_root], [goal_root]\n        grid_start, grid_goal = {}, {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n        edges = []\n\n        # RNG init\n        self._lcg_state = 2463534242\n\n        # Sampling parameters\n        dsg = self._distance(self.start, self.goal)\n        corridor_w = max(self.step_size, 0.2 * dsg)\n        dupe_radius = max(0.5, self.dupe_radius_ratio * self.step_size)\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            # Alternate sides\n            if it % 2 == 0:\n                grow_tree, grow_grid, grow_root_pos = start_tree, grid_start, self.start\n                other_tree, other_grid, other_root_pos = goal_tree, grid_goal, self.goal\n                start_side_active = True\n            else:\n                grow_tree, grow_grid, grow_root_pos = goal_tree, grid_goal, self.goal\n                other_tree, other_grid, other_root_pos = start_tree, grid_start, self.start\n                start_side_active = False\n\n            # Dynamic radii (light dependence on current tree size)\n            nA = max(1, len(grow_tree))\n            neighbor_radius = max(self.step_size, self.neighbor_radius_ratio * self.step_size * (1.0 + 0.15 * (1.0 / (1.0 + nA / 300.0))))\n            rewire_radius = max(self.step_size, self.rewire_radius_ratio * self.step_size * (1.0 + 0.10 * (1.0 / (1.0 + nA / 300.0))))\n\n            # Target sampling (goal / informed corridor / uniform)\n            r = self._rand()\n            if r < self.goal_bias:\n                target = other_root_pos\n            else:\n                # informed corridor tightens once a path exists\n                use_informed = best_len < float('inf') and self._rand() < self.corridor_bias\n                if use_informed:\n                    width = max(self.step_size, 0.25 * (best_len - dsg) + 0.15 * dsg)\n                    target = self._sample_corridor(self.start, self.goal, width)\n                elif self._rand() < self.corridor_bias:\n                    target = self._sample_corridor(self.start, self.goal, corridor_w)\n                else:\n                    target = self._sample_free()\n\n            # Choose near set and best parent\n            near_candidates = self._nearest_candidates(grow_tree, grow_grid, target, min_k=16, max_rings=4)\n            if not near_candidates:\n                near_candidates = [self._nearest_linear(grow_tree, target)]\n            base_parent = self._best_near(near_candidates, target)\n            proposed = self._steer(base_parent.position, target, self.step_size)\n            if not self._within_bounds(proposed):\n                continue\n            if self._is_point_blocked_indexed(proposed):\n                continue\n            if self._exists_close(grow_grid, proposed, dupe_radius):\n                continue\n\n            # Best-parent selection within neighbor radius (strict node+edge checks)\n            neighbors = self._neighbors_within_radius(grow_grid, proposed, neighbor_radius)\n            if base_parent not in neighbors:\n                neighbors.append(base_parent)\n            best_parent = None\n            best_cost = float('inf')\n            for cand in neighbors:\n                dcp = self._distance(cand.position, proposed)\n                if dcp > self.step_size + 1e-9:\n                    continue\n                if self._is_edge_blocked_cached(cand.position, proposed):\n                    continue\n                cost = cand.cost + dcp\n                if cost < best_cost:\n                    best_cost = cost\n                    best_parent = cand\n            if best_parent is None:\n                continue\n\n            # Commit new node (both checks enforced)\n            new_node = self._commit_node(grow_tree, grow_grid, edges, best_parent, proposed, best_cost)\n            if new_node is None:\n                continue\n\n            # Local rewiring (limited) with strict edge checks\n            self._local_rewire(new_node, grow_grid, edges, rewire_radius, max_rewires=16)\n\n            # Attempt immediate direct bridge to nearest of other tree\n            other_near = self._nearest_from_grid(other_tree, other_grid, new_node.position, max_rings=3)\n            if other_near is not None and not self._is_edge_blocked_cached(new_node.position, other_near.position):\n                # Bridge and finish\n                edges.append((other_near, new_node))\n                raw_path = self._assemble_path(start_root, goal_root, new_node, other_near, start_side_active)\n                best_len = self._path_length(raw_path)\n                path = self._postprocess(raw_path)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Greedy bounded connect on the other tree toward new_node\n            if other_near is None:\n                other_near = self._nearest_linear(other_tree, new_node.position)\n            last_b = self._bounded_connect(other_tree, other_grid, other_near, new_node.position, edges, self.connect_hops)\n            if last_b is not None:\n                # Try final bridge\n                if not self._is_edge_blocked_cached(last_b.position, new_node.position):\n                    edges.append((last_b, new_node))\n                    raw_path = self._assemble_path(start_root, goal_root, new_node, last_b, start_side_active)\n                    best_len = self._path_length(raw_path)\n                    path = self._postprocess(raw_path)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---- RNG ----\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---- Geometry ----\n    def _distance(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_pos(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._distance(from_pos, to_pos)\n        if d <= step:\n            return self._clamp_pos(to_pos)\n        r = step / (d + 1e-12)\n        return self._clamp_pos(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---- Obstacle index and collision ----\n    def _build_obstacle_index(self):\n        self.obs_index = {}\n        if self.is_3d:\n            for oi, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                minx = int(x // self.obs_cell)\n                maxx = int((x + w) // self.obs_cell)\n                miny = int(y // self.obs_cell)\n                maxy = int((y + h) // self.obs_cell)\n                minz = int(z // self.obs_cell)\n                maxz = int((z + d) // self.obs_cell)\n                for cx in range(minx, maxx + 1):\n                    for cy in range(miny, maxy + 1):\n                        for cz in range(minz, maxz + 1):\n                            key = (cx, cy, cz)\n                            bucket = self.obs_index.get(key)\n                            if bucket is None:\n                                self.obs_index[key] = [oi]\n                            else:\n                                bucket.append(oi)\n        else:\n            for oi, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                minx = int(x // self.obs_cell)\n                maxx = int((x + w) // self.obs_cell)\n                miny = int(y // self.obs_cell)\n                maxy = int((y + h) // self.obs_cell)\n                for cx in range(minx, maxx + 1):\n                    for cy in range(miny, maxy + 1):\n                        key = (cx, cy)\n                        bucket = self.obs_index.get(key)\n                        if bucket is None:\n                            self.obs_index[key] = [oi]\n                        else:\n                            bucket.append(oi)\n\n    def _obs_cell_key(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.obs_cell), int(pos[1] // self.obs_cell), int(pos[2] // self.obs_cell))\n        else:\n            return (int(pos[0] // self.obs_cell), int(pos[1] // self.obs_cell))\n\n    def _obs_candidates_for_segment(self, a, b, pad):\n        if self.is_3d:\n            mins = (min(a[0], b[0]) - pad, min(a[1], b[1]) - pad, min(a[2], b[2]) - pad)\n            maxs = (max(a[0], b[0]) + pad, max(a[1], b[1]) + pad, max(a[2], b[2]) + pad)\n            minc = (int(mins[0] // self.obs_cell), int(mins[1] // self.obs_cell), int(mins[2] // self.obs_cell))\n            maxc = (int(maxs[0] // self.obs_cell), int(maxs[1] // self.obs_cell), int(maxs[2] // self.obs_cell))\n            seen = set()\n            cand = []\n            for cx in range(minc[0], maxc[0] + 1):\n                for cy in range(minc[1], maxc[1] + 1):\n                    for cz in range(minc[2], maxc[2] + 1):\n                        bucket = self.obs_index.get((cx, cy, cz))\n                        if bucket:\n                            for oi in bucket:\n                                if oi not in seen:\n                                    seen.add(oi)\n                                    cand.append(oi)\n            return cand\n        else:\n            mins = (min(a[0], b[0]) - pad, min(a[1], b[1]) - pad)\n            maxs = (max(a[0], b[0]) + pad, max(a[1], b[1]) + pad)\n            minc = (int(mins[0] // self.obs_cell), int(mins[1] // self.obs_cell))\n            maxc = (int(maxs[0] // self.obs_cell), int(maxs[1] // self.obs_cell))\n            seen = set()\n            cand = []\n            for cx in range(minc[0], maxc[0] + 1):\n                for cy in range(minc[1], maxc[1] + 1):\n                    bucket = self.obs_index.get((cx, cy))\n                    if bucket:\n                        for oi in bucket:\n                            if oi not in seen:\n                                seen.add(oi)\n                                cand.append(oi)\n            return cand\n\n    def _is_point_blocked_indexed(self, pos):\n        key = self._obs_cell_key(pos)\n        bucket = self.obs_index.get(key)\n        if not bucket:\n            return False\n        if self.is_3d:\n            px, py, pz = pos\n            for oi in bucket:\n                x, y, z, w, h, d = self.obstacles[oi]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for oi in bucket:\n                x, y, w, h = self.obstacles[oi]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_blocked_cached(self, a, b):\n        key = self._edge_key_q(a, b)\n        if key in self._blocked_edge_cache:\n            return True\n        if key in self._free_edge_cache:\n            return False\n        blocked = self._is_edge_blocked_filtered(a, b)\n        if blocked:\n            self._blocked_edge_cache.add(key)\n            return True\n        else:\n            self._free_edge_cache.add(key)\n            return False\n\n    def _is_edge_blocked_filtered(self, a, b):\n        d = self._distance(a, b)\n        steps = int(max(1, d / max(1e-9, self.edge_res)))\n        cand = self._obs_candidates_for_segment(a, b, pad=self.edge_res)\n        if not cand:\n            return False\n        if steps <= 1:\n            mid = tuple((a[i] + b[i]) * 0.5 for i in range(self.dim))\n            return self._is_point_blocked_in_list(mid, cand) or self._is_point_blocked_in_list(a, cand) or self._is_point_blocked_in_list(b, cand)\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_point_blocked_in_list(p, cand):\n                return True\n        return False\n\n    def _is_point_blocked_in_list(self, pos, cand_idx):\n        if not cand_idx:\n            return False\n        if self.is_3d:\n            px, py, pz = pos\n            for oi in cand_idx:\n                x, y, z, w, h, d = self.obstacles[oi]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for oi in cand_idx:\n                x, y, w, h = self.obstacles[oi]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    # ---- Sampling ----\n    def _sample_free(self):\n        for _ in range(64):\n            if self.is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_point_blocked_indexed(p):\n                return p\n        # fallback within bounds (may be blocked; extension will reject)\n        if self.is_3d:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]),\n                    self._uniform(0.0, self.bounds[2]))\n        else:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]))\n\n    def _sample_corridor(self, a, b, width):\n        t = self._rand()\n        base = tuple(a[i] + t * (b[i] - a[i]) for i in range(self.dim))\n        if self.is_3d:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_point_blocked_indexed(p):\n            return p\n        return self._sample_free()\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # ---- Node grid and nearest ----\n    def _grid_key(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell), int(pos[2] // self.grid_cell))\n        else:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _nearest_from_grid(self, tree, grid, point, max_rings=4):\n        # ring search with early exit only if enough candidates seen; else fallback\n        cand = self._collect_ring(grid, point, max_rings)\n        if cand:\n            best = cand[0]\n            bestd = self._distance(best.position, point)\n            for n in cand:\n                d = self._distance(n.position, point)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            return best\n        return self._nearest_linear(tree, point)\n\n    def _nearest_linear(self, tree, point):\n        best = tree[0]\n        bestd = self._distance(best.position, point)\n        for n in tree:\n            d = self._distance(n.position, point)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _collect_ring(self, grid, point, max_rings):\n        center = self._grid_key(point)\n        out = []\n        # grow rings\n        for r in range(0, max_rings + 1):\n            if self.is_3d:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            k = (center[0] + dx, center[1] + dy, center[2] + dz)\n                            if k in grid:\n                                out.extend(grid[k])\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        k = (center[0] + dx, center[1] + dy)\n                        if k in grid:\n                            out.extend(grid[k])\n        return out\n\n    def _nearest_candidates(self, tree, grid, point, min_k=16, max_rings=4):\n        cand = []\n        center = self._grid_key(point)\n        for r in range(0, max_rings + 1):\n            if self.is_3d:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            k = (center[0] + dx, center[1] + dy, center[2] + dz)\n                            if k in grid:\n                                cand.extend(grid[k])\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        k = (center[0] + dx, center[1] + dy)\n                        if k in grid:\n                            cand.extend(grid[k])\n            if len(cand) >= min_k:\n                break\n        if not cand and tree:\n            cand = tree[:min(min_k, len(tree))]\n        return cand\n\n    def _neighbors_within_radius(self, grid, point, radius):\n        cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        center = self._grid_key(point)\n        out = []\n        if self.is_3d:\n            for dx in range(-cells, cells + 1):\n                for dy in range(-cells, cells + 1):\n                    for dz in range(-cells, cells + 1):\n                        k = (center[0] + dx, center[1] + dy, center[2] + dz)\n                        if k in grid:\n                            out.extend(grid[k])\n        else:\n            for dx in range(-cells, cells + 1):\n                for dy in range(-cells, cells + 1):\n                    k = (center[0] + dx, center[1] + dy)\n                    if k in grid:\n                        out.extend(grid[k])\n        # distance filter\n        rr = radius * radius\n        fil = []\n        for n in out:\n            s = 0.0\n            p = n.position\n            for i in range(self.dim):\n                d = p[i] - point[i]\n                s += d * d\n            if s <= rr:\n                fil.append(n)\n        return fil\n\n    def _exists_close(self, grid, pos, radius):\n        return len(self._neighbors_within_radius(grid, pos, radius)) > 0\n\n    def _best_near(self, nodes, target):\n        best = nodes[0]\n        bestd = self._distance(best.position, target)\n        for n in nodes:\n            d = self._distance(n.position, target)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    # ---- Commit/rewire/connect ----\n    def _commit_node(self, tree, grid, edges, parent, pos, cost):\n        if not self._within_bounds(pos):\n            return None\n        if self._is_point_blocked_indexed(pos):\n            return None\n        if self._is_edge_blocked_cached(parent.position, pos):\n            return None\n        new_node = Node(pos, parent, cost)\n        parent.add_child(new_node)\n        tree.append(new_node)\n        self._grid_add(grid, new_node)\n        edges.append((parent, new_node))\n        return new_node\n\n    def _local_rewire(self, new_node, grid, edges, radius, max_rewires=16):\n        # try to improve nearby neighbors' costs via new_node\n        neigh = self._neighbors_within_radius(grid, new_node.position, radius)\n        count = 0\n        for nb in neigh:\n            if nb is new_node or nb is new_node.parent:\n                continue\n            d = self._distance(new_node.position, nb.position)\n            if d <= 1e-9 or d > radius + 1e-9:\n                continue\n            new_cost = new_node.cost + d\n            if new_cost + 1e-9 < nb.cost:\n                # enforce both checks\n                if self._is_edge_blocked_cached(new_node.position, nb.position):\n                    continue\n                if self._is_point_blocked_indexed(nb.position):  # redundant but explicit\n                    continue\n                old_parent = nb.parent\n                if old_parent is None:\n                    continue\n                # apply rewire\n                self._remove_child(old_parent, nb)\n                self._remove_edge(edges, old_parent, nb)\n                new_node.add_child(nb)\n                nb.parent = new_node\n                delta = new_cost - nb.cost\n                nb.cost = new_cost\n                self._propagate_cost(nb, delta)\n                edges.append((new_node, nb))\n                count += 1\n                if count >= max_rewires:\n                    break\n\n    def _remove_child(self, parent, child):\n        if child in parent.children:\n            parent.children.remove(child)\n\n    def _remove_edge(self, edges, parent, child):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is parent and e[1] is child:\n                del edges[i]\n                return\n\n    def _propagate_cost(self, node, delta):\n        # BFS propagate cost changes to subtree\n        q = [node]\n        while q:\n            cur = q.pop()\n            for ch in cur.children:\n                ch.cost += delta\n                q.append(ch)\n\n    def _bounded_connect(self, tree, grid, from_node, target_pos, edges, max_hops):\n        current = from_node\n        last_new = None\n        hops = 0\n        while hops < max_hops:\n            step_pos = self._steer(current.position, target_pos, self.step_size)\n            if not self._within_bounds(step_pos):\n                break\n            if self._is_point_blocked_indexed(step_pos):\n                break\n            if self._is_edge_blocked_cached(current.position, step_pos):\n                break\n            # commit (strict checks already done)\n            new_cost = current.cost + self._distance(current.position, step_pos)\n            nxt = Node(step_pos, current, new_cost)\n            current.add_child(nxt)\n            tree.append(nxt)\n            self._grid_add(grid, nxt)\n            edges.append((current, nxt))\n            last_new = nxt\n            current = nxt\n            hops += 1\n            if self._distance(current.position, target_pos) <= self.step_size:\n                break\n        return last_new\n\n    # ---- Path assembly and post-processing ----\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _assemble_path(self, start_root, goal_root, a_node, b_node, a_is_start_side):\n        if a_is_start_side:\n            pa = self._path_to_root(a_node)  # start -> a_node\n            pb = self._path_to_root(b_node)  # goal -> b_node\n            return pa + pb[::-1]\n        else:\n            pa = self._path_to_root(a_node)  # goal-side growth\n            pb = self._path_to_root(b_node)\n            return pb + pa[::-1]\n\n    def _path_length(self, path):\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._distance(path[i - 1], path[i])\n        return total\n\n    def _visibility_compress(self, path):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            jumped = False\n            while j > i + 1:\n                if not self._is_edge_blocked_cached(path[i], path[j]):\n                    out.append(path[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(path[i + 1])\n                i += 1\n        if out[-1] != path[-1]:\n            out.append(path[-1])\n        # de-dup\n        ded = [out[0]]\n        for k in range(1, len(out)):\n            if self._distance(ded[-1], out[k]) > 1e-9:\n                ded.append(out[k])\n        return ded\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return list(path)\n        pts = list(path)\n        for _ in range(attempts):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_blocked_cached(a, b):\n                pts = pts[:i + 1] + pts[j:]\n        return pts\n\n    def _elastic(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return list(path)\n        pts = list(path)\n        for _ in range(iters):\n            changed = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                if self._is_point_blocked_indexed(mid):\n                    continue\n                if self._is_edge_blocked_cached(a, mid):\n                    continue\n                if self._is_edge_blocked_cached(mid, c):\n                    continue\n                if self._distance(pts[i], mid) > 1e-9:\n                    pts[i] = mid\n                    changed = True\n            if not changed:\n                break\n        return pts\n\n    def _postprocess(self, raw_path):\n        p = self._visibility_compress(raw_path)\n        p = self._shortcut(p, self.shortcut_attempts)\n        p = self._elastic(p, self.elastic_iters)\n        return p",
          "objective": -36.94679,
          "time_improvement": 62.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1876.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01455528736114502,
                    "num_nodes_avg": 56.0,
                    "path_length_avg": 153.05488117915178,
                    "smoothness_avg": 0.04323917072604063,
                    "success_improvement": 0.0,
                    "time_improvement": 41.00314170328443,
                    "node_improvement": 85.89775875094435,
                    "length_improvement": 16.108194315911927,
                    "smoothness_improvement": 576.7869172246149,
                    "objective_score": 24.84979368665556
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04361860752105713,
                    "num_nodes_avg": 170.0,
                    "path_length_avg": 244.2123677023688,
                    "smoothness_avg": 0.12207511882177972,
                    "success_improvement": 0.0,
                    "time_improvement": 73.92036253535261,
                    "node_improvement": 88.57757172613049,
                    "length_improvement": 18.474882397693065,
                    "smoothness_improvement": 3041.0807344384375,
                    "objective_score": 48.466441871413814
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014497733116149903,
                    "num_nodes_avg": 74.0,
                    "path_length_avg": 135.28177456457792,
                    "smoothness_avg": 0.16586943691668363,
                    "success_improvement": 0.0,
                    "time_improvement": 71.27837604096456,
                    "node_improvement": 90.59122695486332,
                    "length_improvement": 10.15228676006259,
                    "smoothness_improvement": 2009.8469943719351,
                    "objective_score": 37.5241198401866
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SAGE-BRRT: Simple Adaptive Grid-Enhanced BiRRT with Local Rewire and On-the-fly Visibility. Two trees grow toward each other using grid-accelerated nearest search and informed/corridor-biased sampling. Each insertion selects the least-cost feasible parent among nearby nodes, performs ancestor visibility compression, and locally rewires neighbors. A probe-then-commit connect adds at most one node on the opposite tree per iteration and bridges if a short direct link is free. Obstacle checks use a spatial hash for fast node and edge validation. On success, a lightweight visibility pass, shortcutting, and elastic smoothing return a short, smooth path quickly.",
          "planning_mechanism": "Initialize bidirectional trees, node-grid, and obstacle-grid. Iterate: sample a target (goal/corridor/informed/uniform), find a near node via grid rings, steer by a fixed step, and validate node (inside-bounds, not in obstacles) and edge (segment-obstacle free). Choose the best feasible parent within a local radius; insert the node, then optionally compress to a visible ancestor and rewire nearby nodes if cheaper. Probe the other tree: try a direct bridge; else simulate one feasible step toward the new node and commit at most one opposite-node; if the short bridge becomes free, assemble the path. Maintain an incumbent path for informed sampling. After connection, run visibility compression, shortcutting, and elastic smoothing, then return the result.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=7.0,\n        goal_bias=0.18,\n        corridor_bias=0.35,\n        informed_bias=0.55,\n        cell_size_factor=1.6,\n        dupe_radius_ratio=0.45,\n        rewire_radius_factor=2.0,\n        neighbor_cap=24,\n        connect_steps=1,\n        smooth_shortcuts=80,\n        rubber_iters=8\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.cell_size_factor = float(cell_size_factor)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.rewire_radius_factor = float(rewire_radius_factor)\n        self.neighbor_cap = int(neighbor_cap)\n        self.connect_steps = int(connect_steps)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self.rubber_iters = int(max(0, rubber_iters))\n\n        self._rnd = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_from_scene()\n\n        # Build obstacle spatial hash\n        self._build_obstacle_grid()\n\n        # Validate endpoints\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Setup structures\n        self.cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.rewire_radius = max(self.step_size * 1.25, self.rewire_radius_factor * self.step_size)\n\n        nodes = []\n        edges = []\n\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        tree_a, tree_b = [a_root], [b_root]\n        grid_a, grid_b = {}, {}\n        anchors_a, anchors_b = [a_root], [b_root]\n        self._grid_insert(grid_a, a_root)\n        self._grid_insert(grid_b, b_root)\n\n        best_path = None\n        best_len = float('inf')\n\n        # Corridor width for biased sampling\n        sg = self._dist(self.start, self.goal)\n        corridor_w = max(self.step_size, 0.2 * sg)\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            tree1 = tree_a if side_a else tree_b\n            grid1 = grid_a if side_a else grid_b\n            anchors1 = anchors_a if side_a else anchors_b\n\n            tree2 = tree_b if side_a else tree_a\n            grid2 = grid_b if side_a else grid_a\n            anchors2 = anchors_b if side_a else anchors_a\n\n            attractor = self.goal if side_a else self.start\n\n            # Sample a target\n            target = self._sample_target(attractor, best_len, corridor_w)\n            if target is None:\n                continue\n\n            # Find near node and steer\n            near = self._nearest_hashed(grid1, anchors1, target, 3)\n            if near is None:\n                continue\n            new_pos = self._steer(near.position, target)\n\n            # Validity checks for node and edge\n            if not self._within_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if self._has_nearby(grid1, new_pos, self.dupe_radius):\n                continue\n\n            # Select best parent among local candidates\n            parent, new_cost = self._choose_parent(grid1, anchors1, tree1, new_pos)\n            if parent is None:\n                continue\n\n            # Node collision already checked; ensure edge is free\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            # Insert node\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(grid1, new_node)\n            if (len(tree1) % 24) == 0:\n                anchors1.append(new_node)\n\n            # Optional: compress to visible ancestor (one hop)\n            gp = parent.parent\n            if gp is not None:\n                if self._edge_free(gp.position, new_node.position):\n                    self._reparent(new_node, gp, edges)\n\n            # Local rewiring\n            self._rewire_neighbors(grid1, new_node, self.rewire_radius, edges)\n\n            # Try to connect the other tree\n            other_near = self._nearest_hashed(grid2, anchors2, new_node.position, 3)\n            if other_near is not None:\n                # Direct bridge\n                if self._edge_free(new_node.position, other_near.position):\n                    path = self._assemble_path(new_node, other_near, side_a)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # Probe-then-commit: at most one step on the other tree\n                committed = None\n                steps = 0\n                probe_from = other_near\n                while steps < self.connect_steps:\n                    step_p = self._steer(probe_from.position, new_node.position)\n                    if not self._within_bounds(step_p):\n                        break\n                    if self._point_in_obstacles(step_p):\n                        break\n                    if self._has_nearby(grid2, step_p, self.dupe_radius):\n                        break\n                    if not self._edge_free(probe_from.position, step_p):\n                        break\n                    # Commit this single step\n                    q = Node(step_p, probe_from, probe_from.cost + self._dist(probe_from.position, step_p))\n                    probe_from.add_child(q)\n                    tree2.append(q)\n                    nodes.append(q)\n                    edges.append((probe_from, q))\n                    self._grid_insert(grid2, q)\n                    if (len(tree2) % 24) == 0:\n                        anchors2.append(q)\n                    # Light local optimize\n                    self._compress_one(q, edges)\n                    self._rewire_neighbors(grid2, q, self.rewire_radius, edges)\n                    committed = q\n                    break\n                # If committed, try short bridge\n                if committed is not None:\n                    if self._edge_free(new_node.position, committed.position):\n                        path = self._assemble_path(new_node, committed, side_a)\n                        path = self._postprocess(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n            # Maintain best incumbent (for informed sampling)\n            if best_path is None:\n                # Try a temporary connection via NN if possible (no commit)\n                if other_near is not None:\n                    if self._edge_free(new_node.position, other_near.position):\n                        tmp = self._assemble_path(new_node, other_near, side_a)\n                        L = self._path_len(tmp)\n                        if L < best_len:\n                            best_len = L\n                            best_path = tmp\n\n        if best_path is not None:\n            best_path = self._postprocess(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG utilities\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 1) * 2654435761\n        self._rnd = (s ^ 0x9E3779B9) & 0xffffffff\n        if self._rnd == 0:\n            self._rnd = 2463534242\n\n    def _rand(self):\n        self._rnd = (1664525 * self._rnd + 1013904223) & 0xffffffff\n        return self._rnd / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= self.step_size:\n            return self._clamp(b)\n        r = self.step_size / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Sampling\n    def _sample_target(self, attractor, best_len, corridor_w):\n        for _ in range(24):\n            if best_len < float('inf') and self._rand() < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p is not None and not self._point_in_obstacles(p):\n                    return p\n            else:\n                r = self._rand()\n                if r < self.goal_bias:\n                    p = attractor\n                elif r < self.goal_bias + self.corridor_bias:\n                    t = self._rand()\n                    base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n                    if self.is_3d:\n                        p = (\n                            self._clamp((base[0] + self._rand_range(-corridor_w, corridor_w),\n                                         base[1] + self._rand_range(-corridor_w, corridor_w),\n                                         base[2] + self._rand_range(-corridor_w, corridor_w)))[0],\n                            self._clamp((base[0] + self._rand_range(-corridor_w, corridor_w),\n                                         base[1] + self._rand_range(-corridor_w, corridor_w),\n                                         base[2] + self._rand_range(-corridor_w, corridor_w)))[1],\n                            self._clamp((base[0] + self._rand_range(-corridor_w, corridor_w),\n                                         base[1] + self._rand_range(-corridor_w, corridor_w),\n                                         base[2] + self._rand_range(-corridor_w, corridor_w)))[2]\n                        )\n                        p = (min(max(base[0] + self._rand_range(-corridor_w, corridor_w), 0.0), self.bounds[0]),\n                             min(max(base[1] + self._rand_range(-corridor_w, corridor_w), 0.0), self.bounds[1]),\n                             min(max(base[2] + self._rand_range(-corridor_w, corridor_w), 0.0), self.bounds[2]))\n                    else:\n                        p = (min(max(base[0] + self._rand_range(-corridor_w, corridor_w), 0.0), self.bounds[0]),\n                             min(max(base[1] + self._rand_range(-corridor_w, corridor_w), 0.0), self.bounds[1]))\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n                if self._within_bounds(p) and not self._point_in_obstacles(p):\n                    return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._within_bounds(p):\n                return p\n        return None\n\n    # Node grid\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, anchors, pos, max_rings=3):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # Fallback: scan grid buckets\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors_within_radius(self, grid, pos, radius, cap):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        # Filter and cap\n        out = []\n        rr = radius * radius\n        for n in cand:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= rr:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _has_nearby(self, grid, pos, radius):\n        neigh = self._neighbors_within_radius(grid, pos, radius, self.neighbor_cap)\n        return len(neigh) > 0\n\n    # Parent selection\n    def _choose_parent(self, grid, anchors, tree, new_pos):\n        neigh = self._neighbors_within_radius(grid, new_pos, self.rewire_radius, self.neighbor_cap)\n        if not neigh:\n            # include a nearest fallback\n            near = None\n            bestd = 1e100\n            for n in tree:\n                d = self._dist(n.position, new_pos)\n                if d < bestd:\n                    bestd = d\n                    near = n\n            if near is None:\n                return None, None\n            neigh = [near]\n        best_parent = None\n        best_cost = 1e100\n        for p in neigh:\n            d = self._dist(p.position, new_pos)\n            if d > self.step_size + 1e-9:\n                continue\n            if not self._edge_free(p.position, new_pos):\n                continue\n            gc = p.cost + d\n            if gc < best_cost:\n                best_cost = gc\n                best_parent = p\n        if best_parent is None:\n            return None, None\n        return best_parent, best_cost\n\n    # Obstacle spatial hash\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Local optimization helpers\n    def _compress_one(self, node, edges):\n        p = node.parent\n        if p is None or p.parent is None:\n            return\n        gp = p.parent\n        if self._edge_free(gp.position, node.position):\n            self._reparent(node, gp, edges)\n\n    def _rewire_neighbors(self, grid, node, radius, edges):\n        neigh = self._neighbors_within_radius(grid, node.position, radius, self.neighbor_cap)\n        count = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            new_cost = node.cost + d\n            if new_cost + 1e-9 < nb.cost and self._edge_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n                count += 1\n                if count >= self.neighbor_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        old_parent = child.parent\n        if old_parent is new_parent:\n            return\n        if old_parent is not None:\n            old_parent.remove_child(child)\n            self._edges_remove(edges, old_parent, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        self._propagate_costs(child)\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                old = ch.cost\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                if abs(ch.cost - old) > 1e-12:\n                    stack.append(ch)\n\n    # Path assembly and post-processing\n    def _assemble_path(self, new_node, other_node, side_a):\n        if side_a:\n            pa = new_node.path_from_root()\n            pb = other_node.path_from_root()\n            if pa and pb and pa[0] == pb[-1]:\n                pb = pb[:-1]\n            return pa + pb[::-1]\n        else:\n            pa = new_node.path_from_root()\n            pb = other_node.path_from_root()\n            if pa and pb and pb[0] == pa[-1]:\n                pa = pa[:-1]\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _postprocess(self, path):\n        if len(path) < 3:\n            return path[:]\n        p = self._visibility_compress(path)\n        p = self._shortcut(p, self.smooth_shortcuts)\n        p = self._rubber_band(p, self.rubber_iters)\n        return p\n\n    def _visibility_compress(self, path):\n        out = [path[0]]\n        last = path[0]\n        i = 1\n        while i < len(path):\n            far = i\n            j = i\n            while j < len(path):\n                if self._edge_free(last, path[j]):\n                    far = j\n                    j += 1\n                else:\n                    break\n            out.append(path[far])\n            last = path[far]\n            i = far + 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = path[:]\n        best_len = self._path_len(pts)\n        n = len(pts)\n        tries = 0\n        noimp = 0\n        stop = 12\n        while tries < attempts and n >= 3:\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j > n:\n                tries += 1\n                continue\n            a, b = pts[i], pts[j - 1]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j - 1:]\n                L = self._path_len(new_pts)\n                if L <= best_len + 1e-12:\n                    pts = new_pts\n                    best_len = L\n                    n = len(pts)\n                    noimp = 0\n                else:\n                    noimp += 1\n            else:\n                noimp += 1\n            tries += 1\n            if noimp >= stop:\n                break\n        return pts\n\n    def _rubber_band(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return path[:]\n        pts = list(path)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dims))\n                if self._point_in_obstacles(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if mid != pts[i]:\n                        pts[i] = mid\n                        moved = True\n            if not moved:\n                break\n        return pts",
          "objective": -36.91755,
          "time_improvement": 60.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 2316.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016495347023010254,
                    "num_nodes_avg": 71.0,
                    "path_length_avg": 170.6218692301367,
                    "smoothness_avg": 0.05965294648609013,
                    "success_improvement": 0.0,
                    "time_improvement": 33.13950960050793,
                    "node_improvement": 82.12037270209015,
                    "length_improvement": 6.479449798427921,
                    "smoothness_improvement": 833.6981509539397,
                    "objective_score": 17.99801351397883
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03120548725128174,
                    "num_nodes_avg": 138.0,
                    "path_length_avg": 245.4887822432574,
                    "smoothness_avg": 0.18956585497977163,
                    "success_improvement": 0.0,
                    "time_improvement": 81.34218764255085,
                    "node_improvement": 90.72767587180005,
                    "length_improvement": 18.048778484388976,
                    "smoothness_improvement": 4777.665987395928,
                    "objective_score": 59.12025332037828
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01702072620391846,
                    "num_nodes_avg": 92.0,
                    "path_length_avg": 132.8506469498789,
                    "smoothness_avg": 0.1130542551758292,
                    "success_improvement": 0.0,
                    "time_improvement": 66.28004574080119,
                    "node_improvement": 88.30260648442466,
                    "length_improvement": 11.766925963888978,
                    "smoothness_improvement": 1338.0417810394658,
                    "objective_score": 33.63437820577107
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Mini-BiRRT Connect-Lite: a simplified, robust bi-directional RRT-Connect with strict node/edge collision checks, lightweight grid-accelerated nearest/duplicate queries, and fast post-processing (visibility prune + random shortcut). It favors generalization by avoiding heavy rewiring or complex heuristics while delivering short, smooth paths quickly.",
          "planning_mechanism": "Alternate expansions from start and goal: sample with modest goal bias, steer a fixed step to a collision-free node, add only if unique, then attempt a greedy, strictly-validated connect to the opposite tree (no partial commits on failure). On success, merge roots-to-meet path, prune by line-of-sight, and shortcut to reduce length and kinks.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=3500,\n                 step_size=6.0,\n                 goal_bias=0.2,\n                 grid_scale=1.0,\n                 dupe_radius_ratio=0.5,\n                 connect_steps=14,\n                 shortcut_attempts=64):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_scale = float(grid_scale)\n        self.dupe_ratio = float(dupe_radius_ratio)\n        self.connect_steps = int(max(1, connect_steps))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self._rng = 1469598103934665603  # 64-bit state\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if getattr(map, 'obstacles', None) else []\n\n        nodes, edges = [], []\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._build_obs_grid()\n\n        if self._point_in_obs(self.start) or self._point_in_obs(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        self.node_cell = max(1.0, self.step * self.grid_scale)\n        self.dupe_radius = max(0.4 * self.step, self.step * self.dupe_ratio)\n\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        tree_a, tree_b = [a_root], [b_root]\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, a_root)\n        self._grid_add(grid_b, b_root)\n        nodes.extend([a_root, b_root])\n\n        for it in range(self.max_iter):\n            expand_a = (it % 2 == 0)\n            tree = tree_a if expand_a else tree_b\n            other_tree = tree_b if expand_a else tree_a\n            grid = grid_a if expand_a else grid_b\n            other_grid = grid_b if expand_a else grid_a\n            attractor = self.goal if expand_a else self.start\n\n            q_rand = self._sample(attractor)\n            if q_rand is None:\n                continue\n\n            parent = self._nearest(grid, q_rand, tree)\n            if parent is None:\n                continue\n\n            q_new = self._steer(parent.position, q_rand, self.step)\n            if (not self._in_bounds(q_new)) or self._point_in_obs(q_new):\n                continue\n            if self._exists_close(grid, q_new, self.dupe_radius):\n                continue\n            if not self._edge_free(parent.position, q_new):\n                continue\n\n            new_node = Node(q_new, parent, parent.cost + self._dist(parent.position, q_new))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(grid, new_node)\n\n            other_near = self._nearest(other_grid, new_node.position, other_tree)\n\n            if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                path = self._merge_path(new_node, other_near, expand_a)\n                path = self._finalize_path(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            if other_near is not None:\n                ok, commit_pts, last = self._simulate_connect(other_near.position, new_node.position, self.connect_steps)\n                if ok:\n                    prev = other_near\n                    commit_ok = True\n                    for p in commit_pts:\n                        if (not self._in_bounds(p)) or self._point_in_obs(p):\n                            commit_ok = False\n                            break\n                        if not self._edge_free(prev.position, p):\n                            commit_ok = False\n                            break\n                        n2 = Node(p, prev, prev.cost + self._dist(prev.position, p))\n                        prev.add_child(n2)\n                        other_tree.append(n2)\n                        nodes.append(n2)\n                        edges.append((prev, n2))\n                        self._grid_add(other_grid, n2)\n                        prev = n2\n                    if commit_ok and self._edge_free(prev.position, new_node.position):\n                        path = self._merge_path(new_node, prev, expand_a)\n                        path = self._finalize_path(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._rng ^= (self._rng << 13) & ((1 << 64) - 1)\n        self._rng ^= (self._rng >> 7)\n        self._rng ^= (self._rng << 17) & ((1 << 64) - 1)\n        return ((self._rng & ((1 << 53) - 1)) / float(1 << 53))\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-16:\n            return tuple(a)\n        if d2 <= step * step:\n            tgt = b\n        else:\n            d = d2 ** 0.5\n            r = step / d\n            tgt = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n        return tuple(min(max(tgt[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # Node grid\n    def _grid_key(self, pos):\n        if self.is3:\n            return (int(pos[0] // self.node_cell), int(pos[1] // self.node_cell), int(pos[2] // self.node_cell))\n        else:\n            return (int(pos[0] // self.node_cell), int(pos[1] // self.node_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos, fallback_list):\n        key = self._grid_key(pos)\n        best, bestd = None, 1e100\n        for r in range(0, 3):\n            cand = self._ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd, best = d2, n\n                if best is not None:\n                    return best\n        for n in fallback_list:\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd, best = d2, n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius // self.node_cell) + 1\n        r2 = radius * radius\n        cand = self._ring_collect(grid, key, r_cells)\n        out = []\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                out.append(n)\n        return out\n\n    def _exists_close(self, grid, pos, radius):\n        return len(self._neighbors_in_radius(grid, pos, radius)) > 0\n\n    # Obstacles\n    def _build_obs_grid(self):\n        self.og_cell = max(3.0, self.step * 1.5)\n        self.ogrid = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.og_cell)\n                cy0 = int(max(0.0, y) // self.og_cell)\n                cz0 = int(max(0.0, z) // self.og_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.og_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.og_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.og_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.ogrid.get(k)\n                            if b is None:\n                                self.ogrid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.og_cell)\n                cy0 = int(max(0.0, y) // self.og_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.og_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.og_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.ogrid.get(k)\n                        if b is None:\n                            self.ogrid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _bucket_candidates(self, a, b):\n        if self.is3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.og_cell)\n            cy0 = int(max(0.0, miny) // self.og_cell)\n            cz0 = int(max(0.0, minz) // self.og_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.og_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.og_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.og_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.ogrid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            return cand\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.og_cell)\n            cy0 = int(max(0.0, miny) // self.og_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.og_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.og_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.ogrid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            return cand\n\n    def _point_in_obs(self, p):\n        if self.is3:\n            cx = int(p[0] // self.og_cell)\n            cy = int(p[1] // self.og_cell)\n            cz = int(p[2] // self.og_cell)\n            bucket = self.ogrid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if (ox <= x <= ox + w) and (oy <= y <= oy + h) and (oz <= z <= oz + d):\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.og_cell)\n            cy = int(p[1] // self.og_cell)\n            bucket = self.ogrid.get((cx, cy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if (ox <= x <= ox + w) and (oy <= y <= oy + h):\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        cand = self._bucket_candidates(a, b)\n        if not cand:\n            return False\n        if self.is3:\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(self.dim):\n            d = p1[i] - p0[i]\n            if abs(d) < 1e-12:\n                if p0[i] < bmin[i] or p0[i] > bmax[i]:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (bmin[i] - p0[i]) * inv\n                tB = (bmax[i] - p0[i]) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Sampling\n    def _sample(self, attractor):\n        for _ in range(12):\n            if self._rand() < self.goal_bias:\n                p = attractor\n            else:\n                if self.is3:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(p) and (not self._point_in_obs(p)):\n                return p\n        return None\n\n    # Connect and path utilities\n    def _simulate_connect(self, start_pos, target_pos, steps):\n        pts = []\n        cur = start_pos\n        for _ in range(steps):\n            nxt = self._steer(cur, target_pos, self.step)\n            if (not self._in_bounds(nxt)) or self._point_in_obs(nxt):\n                return False, [], cur\n            if not self._edge_free(cur, nxt):\n                return False, [], cur\n            pts.append(nxt)\n            cur = nxt\n            if self._edge_free(cur, target_pos):\n                return True, pts, cur\n        if self._edge_free(cur, target_pos):\n            return True, pts, cur\n        return False, pts, cur\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_path(self, a_end, b_end, a_forward):\n        pa = self._path_to_root(a_end)\n        pb = self._path_to_root(b_end)\n        if a_forward:\n            return pa + pb[::-1]\n        else:\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _vis_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-12 <= bestL:\n                    cur = cand\n                    bestL = L\n            tries += 1\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._vis_prune(path)\n        p1 = self._shortcut(p0, self.shortcut_attempts)\n        p2 = self._vis_prune(p1)\n        return p2",
          "objective": -36.76802,
          "time_improvement": 65.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1882.0,
          "node_improvement": 83.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013627099990844726,
                    "num_nodes_avg": 84.7,
                    "path_length_avg": 174.56569007096033,
                    "smoothness_avg": 0.048326840248883916,
                    "success_improvement": 0.0,
                    "time_improvement": 44.76535796186469,
                    "node_improvement": 78.67036011080333,
                    "length_improvement": 4.317779101732099,
                    "smoothness_improvement": 656.4199933083113,
                    "objective_score": 19.302374816140222
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0202009916305542,
                    "num_nodes_avg": 136.8,
                    "path_length_avg": 237.0938391096177,
                    "smoothness_avg": 0.1283977633324745,
                    "success_improvement": 0.0,
                    "time_improvement": 87.92179374600857,
                    "node_improvement": 90.80830477726265,
                    "length_improvement": 20.851252137438184,
                    "smoothness_improvement": 3203.76693171538,
                    "objective_score": 54.90612406484238
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018436336517333986,
                    "num_nodes_avg": 164.0,
                    "path_length_avg": 130.18358877739544,
                    "smoothness_avg": 0.1482704890864588,
                    "success_improvement": 0.0,
                    "time_improvement": 63.47556404916617,
                    "node_improvement": 79.14812460267005,
                    "length_improvement": 13.538259010389897,
                    "smoothness_improvement": 1785.9896769906786,
                    "objective_score": 36.09557300593718
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "AURORA-IBiRRT* (Adaptive Unified Rewire-Connect Optimal Bi-directional RRT with Elastic Smoothing): A bidirectional, informed, grid-accelerated RRT* variant that symmetrically guides samples toward the opposite root, selects best parents by accumulated cost with ancestor compression, performs bounded local rewiring, and attempts multi-neighbor lazy connects with short validated chains. It uses obstacle-binned collision checks and maintains coherent trees. The resulting path is refined by visibility collapse and an elastic-band smoother that can accept tiny length increases for large curvature reductions, followed by opportunistic shortcutting.",
          "planning_mechanism": "Alternate expanding start and goal trees. Each iteration: draw a guided sample (goal/corridor/uniform, switch to informed ellipse after an incumbent), gated by a symmetric cone using the active root-to-target direction; steer; pick a best-cost parent from k-near via spatial hash, compress to a visible ancestor, validate node and edge, insert, then locally rewire neighbors. Try to connect to k near nodes in the opposite tree by direct line-of-sight or a short, validated step chain; on success, extract a bi-tree path, visibility-collapse, apply elastic smoothing with curvature-aware acceptance, shortcut, re-smooth, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children) - 1, -1, -1):\n            if self.children[i] is child:\n                del self.children[i]\n                break\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=6.5,\n                 goal_bias=0.22,\n                 corridor_bias=0.28,\n                 ellipse_bias=0.55,\n                 grid_cell_factor=1.6,\n                 neighbor_radius_factor=2.2,\n                 k_parent=8,\n                 k_rewire=8,\n                 connect_radius_factor=2.8,\n                 connect_steps=4,\n                 smoothing_attempts=80,\n                 elastic_iters=24,\n                 min_sep_ratio=0.22):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.ellipse_bias = float(ellipse_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neigh_factor = float(neighbor_radius_factor)\n        self.k_parent = int(max(1, k_parent))\n        self.k_rewire = int(max(0, k_rewire))\n        self.connect_radius_factor = float(connect_radius_factor)\n        self.connect_steps = int(max(1, connect_steps))\n        self.smoothing_attempts = int(max(0, smoothing_attempts))\n        self.elastic_iters = int(max(0, elastic_iters))\n        self.min_sep_ratio = float(min_sep_ratio)\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self._is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if hasattr(map, \"obstacles\") and map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n\n        # Spatial parameters\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.neigh_radius = max(self.step * 1.2, self.step * self.neigh_factor)\n        self.min_sep = max(0.25, self.step * self.min_sep_ratio)\n        self.cstep = max(self.step, 1.5 * self.step)\n        self.connect_radius = max(self.step, self.connect_radius_factor * self.step)\n\n        # Build obstacle bins for fast collision lookups\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early trivial solution\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize trees and spatial grids\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        Ta, Tb = [a_root], [b_root]\n        nodes.extend([a_root, b_root])\n        GA, GB = {}, {}\n\n        self._grid_add(GA, a_root)\n        self._grid_add(GB, b_root)\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            # Choose active/other trees\n            if (it & 1) == 0:\n                A, B = Ta, Tb\n                GAct, GOth = GA, GB\n                root_act, root_oth = self.start, self.goal\n            else:\n                A, B = Tb, Ta\n                GAct, GOth = GB, GA\n                root_act, root_oth = self.goal, self.start\n\n            # Sample with symmetric cone gating\n            sp = self._guided_sample(root_act, root_oth, best_len)\n            if sp is None:\n                continue\n\n            # Nearest and steering\n            anchor = self._nearest(GAct, sp)\n            newp = self._steer(anchor.position, sp, self.step)\n\n            # Prechecks\n            if (not self._in_bounds(newp)) or self._point_blocked(newp):\n                continue\n            if self._too_close(GAct, newp, self.min_sep):\n                continue\n\n            # Best parent among k nearest\n            neigh = self._neighbors(GAct, newp, self.neigh_radius)\n            cands = self._k_nearest(neigh if neigh else [anchor], newp, self.k_parent)\n            parent, gbest = None, 1e100\n            for nb in cands:\n                if not self._edge_free(nb.position, newp):\n                    continue\n                gc = nb.cost + self._dist(nb.position, newp)\n                if gc < gbest:\n                    parent, gbest = nb, gc\n\n            if parent is None:\n                continue\n\n            # Ancestor compression (up to 4 hops) if visible and cheaper\n            hops = 0\n            anc = parent\n            while anc is not None and anc.parent is not None and hops < 4:\n                up = anc.parent\n                if self._edge_free(up.position, newp):\n                    gc = up.cost + self._dist(up.position, newp)\n                    if gc + 1e-12 < gbest:\n                        parent, gbest = up, gc\n                anc = up\n                hops += 1\n\n            # Both checks before adding\n            if self._point_blocked(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, gbest)\n            parent.add_child(nn)\n            A.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(GAct, nn)\n\n            # Lite local rewiring\n            if self.k_rewire > 0:\n                self._rewire_local(nn, GAct, edges)\n\n            # Multi-neighbor lazy connect to other tree\n            meet_node = None\n            near_o = self._neighbors(GOth, nn.position, self.connect_radius)\n            if not near_o:\n                near_o = [self._nearest(GOth, nn.position)]\n\n            # Evaluate multiple meet candidates and pick the best path length\n            best_meet = None\n            best_meet_len = 1e100\n            best_chain = None\n\n            for cand in self._k_nearest(near_o, nn.position, min(6, max(1, len(near_o)))):\n                if cand is None:\n                    continue\n                # Direct line of sight\n                if self._edge_free(cand.position, nn.position):\n                    # estimate length\n                    L = self._estimate_bipath_len(nn, cand)\n                    if L < best_meet_len:\n                        best_meet_len = L\n                        best_meet = cand\n                        best_chain = None\n                    continue\n                # Short validated chain from cand towards nn (do not bloat if fails)\n                ok, chain_positions = self._ghost_chain_positions(cand.position, nn.position, self.connect_steps, self.cstep)\n                if ok:\n                    # If last in chain connects to nn, this is a candidate; we will later commit it\n                    lastp = chain_positions[-1] if chain_positions else cand.position\n                    if self._edge_free(lastp, nn.position):\n                        # Estimate using chain\n                        L = self._estimate_bipath_len(nn, cand)  # rough estimate; acceptable\n                        if L < best_meet_len:\n                            best_meet_len = L\n                            best_meet = cand\n                            best_chain = chain_positions\n\n            if best_meet is not None:\n                # If a chain was proposed, commit it with both checks at each step\n                commit_target = best_meet\n                if best_chain:\n                    prev = best_meet\n                    okc = True\n                    for p in best_chain:\n                        if (not self._in_bounds(p)) or self._point_blocked(p):\n                            okc = False\n                            break\n                        if not self._edge_free(prev.position, p):\n                            okc = False\n                            break\n                        # Add node into B\n                        nb = Node(p, prev, prev.cost + self._dist(prev.position, p))\n                        prev.add_child(nb)\n                        B.append(nb)\n                        nodes.append(nb)\n                        edges.append((prev, nb))\n                        self._grid_add(GOth, nb)\n                        prev = nb\n                    if okc:\n                        commit_target = prev\n                    else:\n                        commit_target = best_meet\n\n                # Final snap check (do not add cross-edge; we only use it for path extraction)\n                if self._edge_free(commit_target.position, nn.position):\n                    path = self._extract_path(nn, commit_target, forward_from_a=(root_act == self.start))\n                    rawL = self._path_len(path)\n                    if best_len is None or rawL < best_len:\n                        best_len = rawL\n                    path = self._finalize_path(path)\n                    return PlannerResult(True, path, Ta + Tb, edges)\n\n        return PlannerResult(False, [], Ta + Tb, edges)\n\n    # ---------- RNG ----------\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            iv = int((v + 0.5) * 1103515245) & 0xffffffff\n            s ^= (iv + 0x9E3779B9 + ((s << 6) & 0xffffffff) + (s >> 2))\n            s &= 0xffffffff\n        s ^= (len(self.obstacles) + 1) * 2654435761 & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _randu(self):\n        # xorshift32\n        x = self._rng\n        x ^= (x << 13) & 0xffffffff\n        x ^= (x >> 17) & 0xffffffff\n        x ^= (x << 5) & 0xffffffff\n        self._rng = x & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._randu()\n\n    # ---------- Geometry ----------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # ---------- Spatial hashing ----------\n    def _cell_key(self, p):\n        if self._is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _neighbors(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        span = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self._is3:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        # expanding rings up to 3; fallback scan\n        for r in range(0, 4):\n            cand = []\n            if self._is3:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                            if lst:\n                                cand += lst\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy))\n                        if lst:\n                            cand += lst\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                if best is not None:\n                    return best\n        # fallback\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _k_nearest(self, nodes, pos, k):\n        # Partial selection by squared distance\n        if not nodes:\n            return []\n        buf = []\n        for nd in nodes:\n            buf.append((self._dist2(nd.position, pos), nd))\n        buf.sort(key=lambda t: t[0])\n        out = []\n        m = min(k, len(buf))\n        for i in range(m):\n            out.append(buf[i][1])\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        neigh = self._neighbors(grid, pos, radius)\n        return len(neigh) > 0\n\n    # ---------- Obstacles & collision ----------\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.6)\n        self.obin = {}\n        if self._is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            self._obin_add((i, j, k), idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        self._obin_add((i, j), idx)\n\n    def _obin_add(self, key, idx):\n        lst = self.obin.get(key)\n        if lst is None:\n            self.obin[key] = [idx]\n        else:\n            lst.append(idx)\n\n    def _bucket_candidates(self, a, b):\n        if self._is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self.obin.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            return cand\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self.obin.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            return cand\n\n    def _point_blocked(self, p):\n        if self._is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            lst = self.obin.get((ix, iy, iz))\n            if not lst:\n                return False\n            x, y, z = p\n            for idx in lst:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            lst = self.obin.get((ix, iy))\n            if not lst:\n                return False\n            x, y = p\n            for idx in lst:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        cand = self._bucket_candidates(a, b)\n        if not cand:\n            return True\n        if self._is3:\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            q = p1[i]\n            d = q - p\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # ---------- Rewiring ----------\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                del edges[i]\n                break\n\n    def _propagate_cost(self, node, delta):\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    def _rewire_local(self, new_node, grid, edges):\n        neigh = self._neighbors(grid, new_node.position, self.neigh_radius)\n        if not neigh:\n            return\n        cands = self._k_nearest(neigh, new_node.position, self.k_rewire)\n        for nb in cands:\n            if nb is new_node or nb is new_node.parent:\n                continue\n            # avoid cycles\n            cur = new_node\n            cyc = False\n            while cur is not None:\n                if cur is nb:\n                    cyc = True\n                    break\n                cur = cur.parent\n            if cyc:\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            cand_cost = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand_cost + 1e-9 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, oldp, nb)\n                new_node.add_child(nb)\n                edges.append((new_node, nb))\n                delta = cand_cost - nb.cost\n                nb.cost = cand_cost\n                self._propagate_cost(nb, delta)\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, root_act, root_oth, incumbent_len):\n        tries = 20\n        while tries > 0:\n            tries -= 1\n            r = self._randu()\n            if incumbent_len is not None and r < self.ellipse_bias:\n                p = self._sample_in_ellipse(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                r2 = self._randu()\n                if r2 < self.goal_bias:\n                    p = root_oth\n                elif r2 < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_point()\n                else:\n                    if self._is3:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]),\n                             self._rand_range(0.0, self.bounds[2]))\n                    else:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]))\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            # Symmetric cone gating: gate by direction from active root toward opposite root\n            v_to_p = tuple(p[i] - root_act[i] for i in range(self.dim))\n            v_to_oth = tuple(root_oth[i] - root_act[i] for i in range(self.dim))\n            if self._cos_align(v_to_p, v_to_oth) < -0.1 and self._randu() < 0.5:\n                continue\n            return p\n        return None\n\n    def _cos_align(self, a, b):\n        na, nb, dp = 0.0, 0.0, 0.0\n        for i in range(self.dim):\n            na += a[i] * a[i]\n            nb += b[i] * b[i]\n            dp += a[i] * b[i]\n        if na <= 1e-18 or nb <= 1e-18:\n            return 1.0\n        return dp / ((na ** 0.5) * (nb ** 0.5))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(20):\n            if self._is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            if self._dist(p, f1) + self._dist(p, f2) <= max_sum + 1e-9:\n                return p\n        return None\n\n    def _corridor_point(self):\n        t = self._randu()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step, 0.06 * sg)\n        if self._is3:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            oz = self._rand_range(-w, w)\n            p = (base[0] + ox, base[1] + oy, base[2] + oz)\n        else:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            p = (base[0] + ox, base[1] + oy)\n        return self._clamp(p)\n\n    # ---------- Connect helpers ----------\n    def _ghost_chain_positions(self, from_pos, to_pos, steps, step_len):\n        chain = []\n        cur = from_pos\n        for _ in range(steps):\n            nxt = self._steer(cur, to_pos, step_len)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                return False, None\n            if not self._edge_free(cur, nxt):\n                return False, None\n            chain.append(nxt)\n            cur = nxt\n            if self._edge_free(cur, to_pos):\n                break\n        if not chain:\n            return False, None\n        return True, chain\n\n    def _estimate_bipath_len(self, a_node, b_node):\n        # rough: cost to a_node + cost from b_node to its root + distance between\n        L = a_node.cost + b_node.cost + self._dist(a_node.position, b_node.position)\n        return L\n\n    # ---------- Paths and smoothing ----------\n    def _trace(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, a_node, b_node, forward_from_a=True):\n        pa = self._trace(a_node)\n        # b_node toward its root\n        pb = []\n        cur = b_node\n        while cur is not None:\n            pb.append(cur.position)\n            cur = cur.parent\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return (pa + pb) if forward_from_a else (pb[::-1] + pa[::-1])\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_collapse(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            progressed = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    progressed = True\n                    break\n                j -= 1\n            if not progressed:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _elastic_smooth(self, pts, iters=24, w=0.5, max_len_increase=0.005):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(iters):\n            changed = False\n            for k in range(1, len(cur) - 1):\n                a = cur[k - 1]\n                b = cur[k]\n                c = cur[k + 1]\n                mid = tuple(0.5 * (a[i] + c[i]) for i in range(self.dim))\n                q = tuple((1.0 - w) * b[i] + w * mid[i] for i in range(self.dim))\n                if (not self._in_bounds(q)) or self._point_blocked(q):\n                    continue\n                # Check edges\n                if not (self._edge_free(a, q) and self._edge_free(q, c)):\n                    continue\n                # Length and curvature criteria\n                oldL = self._dist(a, b) + self._dist(b, c)\n                newL = self._dist(a, q) + self._dist(q, c)\n                len_ok = (newL <= oldL * (1.0 + max_len_increase) + 1e-12)\n\n                curv_old = self._corner_cost(a, b, c)\n                curv_new = self._corner_cost(a, q, c)\n                # Accept if not longer, or tiny increase buys meaningful curvature reduction\n                if len_ok and (newL <= oldL + 1e-12 or curv_new + 1e-12 < 0.85 * curv_old):\n                    cur[k] = q\n                    changed = True\n            if not changed:\n                break\n        return cur\n\n    def _corner_cost(self, a, b, c):\n        # 1 - cosine of angle at b, scaled by segment lengths to de-emphasize tiny edges\n        v1 = tuple(b[i] - a[i] for i in range(self.dim))\n        v2 = tuple(c[i] - b[i] for i in range(self.dim))\n        n1 = (sum(v1[i] * v1[i] for i in range(self.dim))) ** 0.5\n        n2 = (sum(v2[i] * v2[i] for i in range(self.dim))) ** 0.5\n        if n1 < 1e-9 or n2 < 1e-9:\n            return 0.0\n        cosang = sum(v1[i] * v2[i] for i in range(self.dim)) / (n1 * n2)\n        if cosang > 1.0:\n            cosang = 1.0\n        if cosang < -1.0:\n            cosang = -1.0\n        return 1.0 - cosang\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a, b = cur[i], cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-9 <= bestL:\n                    cur = cand\n                    bestL = L\n            tries += 1\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path[:]\n        p1 = self._visibility_collapse(path)\n        p2 = self._elastic_smooth(p1, iters=self.elastic_iters, w=0.55, max_len_increase=0.006)\n        p3 = self._shortcut(p2, self.smoothing_attempts)\n        p4 = self._elastic_smooth(p3, iters=max(8, self.elastic_iters // 2), w=0.5, max_len_increase=0.004)\n        return p4",
          "objective": -36.64471,
          "time_improvement": 59.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1360.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011651158332824707,
                    "num_nodes_avg": 58.0,
                    "path_length_avg": 156.0637914065294,
                    "smoothness_avg": 0.04615392285067924,
                    "success_improvement": 0.0,
                    "time_improvement": 52.77443034280418,
                    "node_improvement": 85.39410727776378,
                    "length_improvement": 14.458962941052569,
                    "smoothness_improvement": 622.4091174607547,
                    "objective_score": 27.619752454776567
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022267484664916994,
                    "num_nodes_avg": 102.0,
                    "path_length_avg": 225.72102057026777,
                    "smoothness_avg": 0.08695574697277104,
                    "success_improvement": 0.0,
                    "time_improvement": 86.68623414834413,
                    "node_improvement": 93.14654303567829,
                    "length_improvement": 24.64782631430452,
                    "smoothness_improvement": 2137.434001302351,
                    "objective_score": 51.481736039597706
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03081855773925781,
                    "num_nodes_avg": 127.0,
                    "path_length_avg": 119.0787979417283,
                    "smoothness_avg": 0.11165176730825668,
                    "success_improvement": 0.0,
                    "time_improvement": 38.94500476348596,
                    "node_improvement": 83.8525111252384,
                    "length_improvement": 20.913532330124678,
                    "smoothness_improvement": 1320.2022388848293,
                    "objective_score": 30.83263202154474
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "LITE-BiRRT*: Lightweight Informed Two-Tree RRT* with grid NN, ancestor line-of-sight compression, capped local rewiring, and safe lazy-bridge connection. It emphasizes simple, general mechanisms: uniform+goal+ellipse sampling, adaptive RRT* neighbor radius, duplicate suppression, and minimal smoothing (LOS+shortcuts) for fast, short, smooth paths.",
          "planning_mechanism": "Alternate expanding the start/goal trees. For each guided sample, steer a fixed step, pick a cheapest parent among neighbors (cost plus mild turn penalty), validate node and edge, insert, then compress to any visible ancestor and rewire nearby nodes within an adaptive radius. Try to connect to the opposite tree directly or via a lazy simulated bridge (commit only on success). On success, merge, visibility-prune, and shortcut the path, then return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=3500,\n                 step_size=7.0,\n                 goal_bias=0.2,\n                 informed_bias=0.6,\n                 node_grid_factor=1.0,\n                 dupe_radius_ratio=0.4,\n                 neighbor_gamma=2.1,\n                 rewire_cap=18,\n                 connect_steps=7,\n                 shortcut_attempts=90,\n                 angle_weight=0.12):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.node_grid_factor = float(node_grid_factor)\n        self.dupe_ratio = float(dupe_radius_ratio)\n        self.gamma = float(neighbor_gamma)\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_steps = int(max(1, connect_steps))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.angle_w = float(angle_weight)\n        self._rng = 123456789\n\n    # ------------- Planning -------------\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        # Basic validation\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Build obstacle grid\n        self._build_obs_grid()\n\n        # Start/goal must be free\n        if self._point_in_obs(self.start) or self._point_in_obs(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early direct\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Node grid and dupes\n        self.node_cell = max(1.0, self.step * self.node_grid_factor)\n        self.dupe_radius = max(0.5, self.step * self.dupe_ratio)\n\n        # Init trees\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_len = float('inf')\n        sg = self._dist(self.start, self.goal)\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            tree = tree_a if side_a else tree_b\n            other_tree = tree_b if side_a else tree_a\n            grid = grid_a if side_a else grid_b\n            other_grid = grid_b if side_a else grid_a\n            attractor = self.goal if side_a else self.start\n\n            # Sample\n            q_rand = self._sample(best_len, sg, attractor)\n            if q_rand is None:\n                continue\n\n            # Nearest\n            parent0 = self._nearest_grid(grid, q_rand, tree)\n            if parent0 is None:\n                continue\n\n            # Steer\n            q_new = self._steer(parent0.position, q_rand, self.step)\n            if (not self._in_bounds(q_new)) or self._point_in_obs(q_new):\n                continue\n            if self._exists_close(grid, q_new, self.dupe_radius):\n                continue\n\n            # Choose parent among neighbors within adaptive radius\n            radius = self._rewire_radius(len(nodes))\n            nb = self._neighbors_in_radius(grid, q_new, radius)\n            parent, new_cost = self._choose_parent(nb, q_new)\n            if parent is None:\n                # fallback to nearest if edge is free\n                if self._edge_free(parent0.position, q_new):\n                    parent = parent0\n                    new_cost = parent.cost + self._dist(parent.position, q_new)\n                else:\n                    continue\n\n            # Final checks before node/edge add\n            if self._point_in_obs(q_new) or (not self._edge_free(parent.position, q_new)):\n                continue\n\n            # Insert node\n            nn = Node(q_new, parent, new_cost)\n            parent.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(grid, nn)\n\n            # Ancestor LOS compression\n            self._compress_to_visible_ancestor(nn, edges)\n\n            # Local rewiring\n            if self.rewire_cap > 0:\n                self._rewire_neighbors(grid, nn, radius, edges, self.rewire_cap)\n\n            # Try direct connect to nearest in other tree\n            other_near = self._nearest_grid(other_grid, nn.position, other_tree)\n            if other_near is not None and self._edge_free(nn.position, other_near.position):\n                path = self._merge_nodes_to_path(nn, other_near, side_a)\n                best_len = self._path_len(path)\n                path = self._finalize_path(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Lazy bridge (simulate first, commit on success)\n            if other_near is not None:\n                ok, pts = self._lazy_bridge_sim(other_near.position, nn.position, self.connect_steps)\n                if ok and pts:\n                    prev = other_near\n                    # Commit nodes on other tree side; validate each step (both checks)\n                    commit_ok = True\n                    for p in pts:\n                        if self._point_in_obs(p) or (not self._edge_free(prev.position, p)):\n                            commit_ok = False\n                            break\n                        q = Node(p, prev, prev.cost + self._dist(prev.position, p))\n                        prev.add_child(q)\n                        other_tree.append(q)\n                        nodes.append(q)\n                        edges.append((prev, q))\n                        self._grid_add(other_grid, q)\n                        prev = q\n                    if commit_ok and self._edge_free(prev.position, nn.position):\n                        path = self._merge_nodes_to_path(nn, prev, side_a)\n                        best_len = self._path_len(path)\n                        path = self._finalize_path(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # ------------- RNG -------------\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------- Geometry -------------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _vec(self, a, b):\n        return tuple(b[i] - a[i] for i in range(self.dim))\n\n    def _cos(self, u, v):\n        du = 0.0\n        dv = 0.0\n        dot = 0.0\n        for i in range(self.dim):\n            ui = u[i]\n            vi = v[i]\n            dot += ui * vi\n            du += ui * ui\n            dv += vi * vi\n        if du <= 1e-18 or dv <= 1e-18:\n            return 1.0\n        c = dot / ((du ** 0.5) * (dv ** 0.5))\n        if c < -1.0:\n            return -1.0\n        if c > 1.0:\n            return 1.0\n        return c\n\n    # ------------- Node grid (NN, neighbors, dupes) -------------\n    def _grid_key(self, pos):\n        if self.is3:\n            return (int(pos[0] // self.node_cell), int(pos[1] // self.node_cell), int(pos[2] // self.node_cell))\n        return (int(pos[0] // self.node_cell), int(pos[1] // self.node_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _ring_nodes(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_grid(self, grid, pos, tree_fallback=None):\n        key = self._grid_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 4):\n            cand = self._ring_nodes(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n            if best is not None:\n                return best\n        if tree_fallback:\n            for n in tree_fallback:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius // self.node_cell) + 1\n        r2 = radius * radius\n        out = []\n        cand = self._ring_nodes(grid, key, r_cells)\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                out.append(n)\n        return out\n\n    def _exists_close(self, grid, pos, radius):\n        nb = self._neighbors_in_radius(grid, pos, radius)\n        return len(nb) > 0\n\n    # ------------- Obstacles and collisions -------------\n    def _build_obs_grid(self):\n        self.obs_cell = max(3.0, self.step * 1.5)\n        self.ogrid = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.ogrid.get(k)\n                            if b is None:\n                                self.ogrid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.ogrid.get(k)\n                        if b is None:\n                            self.ogrid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obs(self, p):\n        if self.is3:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.ogrid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.ogrid.get((cx, cy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.ogrid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.ogrid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # ------------- Parent selection, compression, rewiring -------------\n    def _choose_parent(self, neighbors, q_new):\n        best = None\n        best_cost = 1e100\n        for n in neighbors:\n            # edge check for candidate parent\n            if not self._edge_free(n.position, q_new):\n                continue\n            base = n.cost + self._dist(n.position, q_new)\n            pen = 0.0\n            if n.parent is not None:\n                u = self._vec(n.parent.position, n.position)\n                v = self._vec(n.position, q_new)\n                c = self._cos(u, v)\n                pen = self.angle_w * self.step * max(0.0, 1.0 - c)\n            cst = base + pen\n            if cst < best_cost:\n                best_cost = cst\n                best = n\n        if best is None:\n            return None, None\n        return best, best_cost\n\n    def _reparent(self, child, new_parent, edges):\n        if child is new_parent or child.parent is new_parent:\n            return\n        # Both checks before edge change\n        if self._point_in_obs(child.position) or self._point_in_obs(new_parent.position):\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            try:\n                old.children.remove(child)\n            except:\n                pass\n            self._edges_remove(edges, old, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        # propagate\n        stack = list(child.children)\n        while stack:\n            n = stack.pop()\n            n.cost = n.parent.cost + self._dist(n.parent.position, n.position)\n            if n.children:\n                for c in n.children:\n                    stack.append(c)\n\n    def _compress_to_visible_ancestor(self, node, edges):\n        curp = node.parent\n        if curp is None:\n            return\n        anc = curp.parent\n        best = curp\n        bestc = node.cost\n        while anc is not None:\n            if self._edge_free(anc.position, node.position):\n                c = anc.cost + self._dist(anc.position, node.position)\n                if c + 1e-12 < bestc:\n                    bestc = c\n                    best = anc\n            anc = anc.parent\n        if best is not curp:\n            self._reparent(node, best, edges)\n\n    def _rewire_neighbors(self, grid, node, radius, edges, cap):\n        neigh = self._neighbors_in_radius(grid, node.position, radius)\n        cnt = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            # avoid cycles\n            if self._is_ancestor(nb, node):\n                continue\n            if not self._edge_free(node.position, nb.position):\n                continue\n            new_cost = node.cost + self._dist(node.position, nb.position)\n            if new_cost + 1e-12 < nb.cost:\n                self._reparent(nb, node, edges)\n                cnt += 1\n                if cnt >= cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _rewire_radius(self, n_nodes):\n        if n_nodes <= 2:\n            return 3.0 * self.step\n        ln = self._ln(max(2.0, float(n_nodes)))\n        r_star = self.gamma * ((ln / float(n_nodes)) ** (1.0 / float(self.dim)))\n        r = r_star * self.step\n        if r < 1.2 * self.step:\n            r = 1.2 * self.step\n        if r > 4.0 * self.step:\n            r = 4.0 * self.step\n        return r\n\n    def _ln(self, x):\n        # stable approximation: ln(x) \u2248 2 * atanh((x-1)/(x+1)) with truncated series\n        y = (x - 1.0) / (x + 1.0)\n        y2 = y * y\n        s = y\n        p = y\n        for k in range(1, 7):\n            p *= y2\n            s += p / (2 * k + 1)\n        return 2.0 * s\n\n    # ------------- Sampling -------------\n    def _sample(self, best_len, sg, attractor):\n        for _ in range(24):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.01)\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                else:\n                    if self.is3:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]),\n                             self._rand_range(0.0, self.bounds[2]))\n                    else:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]))\n            if p is not None and self._in_bounds(p) and (not self._point_in_obs(p)):\n                return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if self._in_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and (not self._point_in_obs(p)):\n                return p\n        return None\n\n    # ------------- Bridge and path utilities -------------\n    def _lazy_bridge_sim(self, a_from, b_to, steps):\n        curr = a_from\n        pts = []\n        for _ in range(steps):\n            nxt = self._steer(curr, b_to, self.step)\n            if self._point_in_obs(nxt) or (not self._edge_free(curr, nxt)):\n                return False, []\n            pts.append(nxt)\n            curr = nxt\n            if self._edge_free(curr, b_to):\n                return True, pts\n        return False, []\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_nodes_to_path(self, a_end, b_end, a_forward):\n        pa = self._path_to_root(a_end)\n        pb = self._path_to_root(b_end)\n        # pa: from its root to a_end, pb: from its root to b_end\n        # We want: path from start to goal\n        if a_forward:\n            # pa starts at start, pb starts at goal; go pa + reversed(pb)\n            return pa + pb[::-1]\n        else:\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        stall = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-12 <= bestL:\n                    cur = cand\n                    bestL = L\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            tries += 1\n            if stall > 64:\n                break\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._visibility_prune(path)\n        p1 = self._shortcut(p0, self.shortcut_attempts)\n        p2 = self._visibility_prune(p1)\n        return p2",
          "objective": -36.35153,
          "time_improvement": 69.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1656.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01191093921661377,
                    "num_nodes_avg": 62.1,
                    "path_length_avg": 169.98648258417646,
                    "smoothness_avg": 0.051656131335479825,
                    "success_improvement": 0.0,
                    "time_improvement": 51.72146205651587,
                    "node_improvement": 84.36162175774363,
                    "length_improvement": 6.827715287424435,
                    "smoothness_improvement": 708.5306284848467,
                    "objective_score": 23.155720931833656
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02790379524230957,
                    "num_nodes_avg": 145.0,
                    "path_length_avg": 245.55157959153934,
                    "smoothness_avg": 0.11152056945517788,
                    "success_improvement": 0.0,
                    "time_improvement": 83.31627474682966,
                    "node_improvement": 90.25734058993481,
                    "length_improvement": 18.02781492201101,
                    "smoothness_improvement": 2769.5045771011437,
                    "objective_score": 49.65909426276122
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014263558387756347,
                    "num_nodes_avg": 99.0,
                    "path_length_avg": 132.33636885589763,
                    "smoothness_avg": 0.12503219506376403,
                    "success_improvement": 0.0,
                    "time_improvement": 71.7423022586528,
                    "node_improvement": 87.41258741258741,
                    "length_improvement": 12.108484986620105,
                    "smoothness_improvement": 1490.4002922944414,
                    "objective_score": 36.23978313104011
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "LEXI-BiRRT: Lazy-Elastic Indexed BiRRT with multi-ancestor visibility and dual indexing. It grows two trees with early-stopping hashed nearest search and obstacle-bin filtered collision checks, inserts only well-separated nodes, performs bounded multi-ancestor line-of-sight compression to shorten edges, and attempts k-nearest bridging to the opposite tree with a lazy short connect. On success it runs a fast, collision-aware elastic-band refinement (visibility prune + shortcut + midpoint relaxation) to reduce length and sharp turns while preserving clearance. The dual spatial indices (node grid + obstacle bins) and early exits improve speed and success, while the visibility compression and elastic refinement improve path length and smoothness.",
          "planning_mechanism": "Mechanism: Build obstacle bins and node grids; alternate growing start/goal trees. Each iteration: sample from goal/corridor/informed/uniform; find nearest via hashed rings with early stop; steer one step; if node and edge are collision-free and not a near-duplicate, add it; then try multi-ancestor visibility to relink to the farthest visible ancestor; attempt direct bridges to k nearest in the other tree or a short lazy connect; upon connection, extract path, run visibility prune, randomized shortcuts, and elastic midpoint relaxation with continuous collision checks, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=4500,\n                 step_size=7.5,\n                 goal_bias=0.18,\n                 corridor_bias=0.45,\n                 informed_bias=0.35,\n                 min_sep_ratio=0.28,\n                 dupe_radius_ratio=0.45,\n                 k_bridge=3,\n                 connect_steps=6,\n                 smoothing_shortcuts=50,\n                 elastic_passes=2):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.min_sep_ratio = float(min_sep_ratio)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.k_bridge = int(k_bridge)\n        self.connect_steps = int(connect_steps)\n        self.smoothing_shortcuts = int(smoothing_shortcuts)\n        self.elastic_passes = int(elastic_passes)\n\n        self.dim = 2\n        self.bounds = None\n        self.start = None\n        self.goal = None\n\n        self.grid_cell = None\n        self.dupe_radius = None\n\n        self._rng = 2463534242\n\n        # Obstacle bins\n        self._bins_cell = None\n        self._bins_n = None\n        self._bins = None\n        self._obstacles = None\n\n    # ---------------- Planning ----------------\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self._obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        is_3d = (self.dim == 3)\n\n        self.grid_cell = max(1.0, 0.9 * self.step_size)\n        self.dupe_radius = max(0.25, self.dupe_radius_ratio * self.step_size)\n\n        self._build_obstacle_bins(is_3d)\n\n        if self._point_in_obstacle(self.start, is_3d) or self._point_in_obstacle(self.goal, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if not self._edge_blocked(self.start, self.goal, is_3d):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Trees\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        base_corridor = max(self.step_size, 0.15 * self._dist(self.start, self.goal))\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            attractor = self.goal if active_start else self.start\n\n            # Sample\n            s = self._sample_target(attractor, base_corridor, best_len, is_3d)\n            if s is None:\n                continue\n\n            # Nearest via hashed rings (early stop)\n            parent = self._nearest_grid(grid_a, tree_a, s, max_rings=2)\n            if parent is None:\n                continue\n\n            new_pos = self._steer(parent.position, s, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._point_in_obstacle(new_pos, is_3d):\n                continue\n            if self._edge_blocked(parent.position, new_pos, is_3d):\n                continue\n            if self._dist2(parent.position, new_pos) < (self.min_sep_ratio * self.step_size) ** 2:\n                continue\n            if self._exists_close(grid_a, new_pos, self.dupe_radius):\n                continue\n\n            # Insert node\n            new_node = Node(new_pos, parent, parent.cost + self._dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(grid_a, new_node)\n\n            # Bounded multi-ancestor visibility compression (up to 3 ancestors)\n            new_parent = self._visible_ancestor(parent, new_node.position, is_3d, max_up=3)\n            if new_parent is not None and new_parent is not parent:\n                # Update edges coherently\n                parent.remove_child(new_node)\n                self._remove_edge(edges, (parent, new_node))\n                new_parent.add_child(new_node)\n                new_node.cost = new_parent.cost + self._dist(new_parent.position, new_node.position)\n                edges.append((new_parent, new_node))\n                parent = new_parent  # for potential subsequent logic\n\n            # Try k-nearest direct bridges\n            cand = self._k_nearest_grid(grid_b, tree_b, new_node.position, self.k_bridge, max_rings=2)\n            bridged = False\n            for other in cand:\n                if not self._edge_blocked(new_node.position, other.position, is_3d):\n                    path = self._extract_path(new_node, other)\n                    L = self._path_len(path)\n                    if L < best_len:\n                        best_len = L\n                    path = self._finalize_path(path, is_3d)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n            if not bridged and cand:\n                # Lazy short connect from nearest candidate towards new_node\n                seed = cand[0]\n                last = seed\n                steps = 0\n                while steps < self.connect_steps:\n                    nxt_pos = self._steer(last.position, new_node.position, self.step_size)\n                    if not self._in_bounds(nxt_pos):\n                        break\n                    if self._point_in_obstacle(nxt_pos, is_3d):\n                        break\n                    if self._edge_blocked(last.position, nxt_pos, is_3d):\n                        break\n                    if self._exists_close(grid_b, nxt_pos, self.dupe_radius):\n                        break\n                    q = Node(nxt_pos, last, last.cost + self._dist(last.position, nxt_pos))\n                    last.add_child(q)\n                    tree_b.append(q)\n                    edges.append((last, q))\n                    self._grid_add(grid_b, q)\n                    last = q\n                    steps += 1\n                    if not self._edge_blocked(last.position, new_node.position, is_3d):\n                        path = self._extract_path(new_node, last)\n                        L = self._path_len(path)\n                        if L < best_len:\n                            best_len = L\n                        path = self._finalize_path(path, is_3d)\n                        return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------------- RNG ----------------\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) % (1 << 32)\n        return self._rng / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------------- Geometry ----------------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        if d <= 1e-12:\n            return tuple(from_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------------- Obstacle bins ----------------\n    def _build_obstacle_bins(self, is_3d):\n        nobs = len(self._obstacles)\n        if nobs <= 0:\n            self._bins_cell = self.bounds if not is_3d else self.bounds\n            self._bins_n = (1, 1) if not is_3d else (1, 1, 1)\n            self._bins = { (0, 0) if not is_3d else (0, 0, 0): [] }\n            return\n\n        # Resolution based on obstacle count\n        base = int((nobs ** 0.5) * 2.0) + 6\n        g = max(8, min(64, base))\n        if not is_3d:\n            cx = max(self.bounds[0] / g, 1.0)\n            cy = max(self.bounds[1] / g, 1.0)\n            nx = max(int(self.bounds[0] / cx), 1)\n            ny = max(int(self.bounds[1] / cy), 1)\n            self._bins_cell = (cx, cy)\n            self._bins_n = (nx, ny)\n            self._bins = {}\n            for obs in self._obstacles:\n                x, y, w, h = obs\n                i0 = int(x / cx); j0 = int(y / cy)\n                i1 = int((x + w) / cx); j1 = int((y + h) / cy)\n                if i0 < 0: i0 = 0\n                if j0 < 0: j0 = 0\n                if i1 >= nx: i1 = nx - 1\n                if j1 >= ny: j1 = ny - 1\n                for i in range(i0, i1 + 1):\n                    for j in range(j0, j1 + 1):\n                        k = (i, j)\n                        b = self._bins.get(k)\n                        if b is None:\n                            self._bins[k] = [obs]\n                        else:\n                            b.append(obs)\n        else:\n            cx = max(self.bounds[0] / g, 1.0)\n            cy = max(self.bounds[1] / g, 1.0)\n            cz = max(self.bounds[2] / max(int(g * 0.75), 1), 1.0)\n            nx = max(int(self.bounds[0] / cx), 1)\n            ny = max(int(self.bounds[1] / cy), 1)\n            nz = max(int(self.bounds[2] / cz), 1)\n            self._bins_cell = (cx, cy, cz)\n            self._bins_n = (nx, ny, nz)\n            self._bins = {}\n            for obs in self._obstacles:\n                x, y, z, w, h, d = obs\n                i0 = int(x / cx); j0 = int(y / cy); k0 = int(z / cz)\n                i1 = int((x + w) / cx); j1 = int((y + h) / cy); k1 = int((z + d) / cz)\n                if i0 < 0: i0 = 0\n                if j0 < 0: j0 = 0\n                if k0 < 0: k0 = 0\n                if i1 >= nx: i1 = nx - 1\n                if j1 >= ny: j1 = ny - 1\n                if k1 >= nz: k1 = nz - 1\n                for i in range(i0, i1 + 1):\n                    for j in range(j0, j1 + 1):\n                        for k in range(k0, k1 + 1):\n                            key = (i, j, k)\n                            b = self._bins.get(key)\n                            if b is None:\n                                self._bins[key] = [obs]\n                            else:\n                                b.append(obs)\n\n    def _bin_key(self, pos):\n        if self.dim == 2:\n            cx, cy = self._bins_cell\n            i = int(pos[0] / cx); j = int(pos[1] / cy)\n            nx, ny = self._bins_n\n            if i < 0: i = 0\n            if j < 0: j = 0\n            if i >= nx: i = nx - 1\n            if j >= ny: j = ny - 1\n            return (i, j)\n        else:\n            cx, cy, cz = self._bins_cell\n            i = int(pos[0] / cx); j = int(pos[1] / cy); k = int(pos[2] / cz)\n            nx, ny, nz = self._bins_n\n            if i < 0: i = 0\n            if j < 0: j = 0\n            if k < 0: k = 0\n            if i >= nx: i = nx - 1\n            if j >= ny: j = ny - 1\n            if k >= nz: k = nz - 1\n            return (i, j, k)\n\n    def _bin_range_for_bbox(self, bmin, bmax):\n        if self.dim == 2:\n            cx, cy = self._bins_cell\n            nx, ny = self._bins_n\n            i0 = int(bmin[0] / cx); j0 = int(bmin[1] / cy)\n            i1 = int(bmax[0] / cx); j1 = int(bmax[1] / cy)\n            if i0 < 0: i0 = 0\n            if j0 < 0: j0 = 0\n            if i1 >= nx: i1 = nx - 1\n            if j1 >= ny: j1 = ny - 1\n            for i in range(i0, i1 + 1):\n                for j in range(j0, j1 + 1):\n                    yield (i, j)\n        else:\n            cx, cy, cz = self._bins_cell\n            nx, ny, nz = self._bins_n\n            i0 = int(bmin[0] / cx); j0 = int(bmin[1] / cy); k0 = int(bmin[2] / cz)\n            i1 = int(bmax[0] / cx); j1 = int(bmax[1] / cy); k1 = int(bmax[2] / cz)\n            if i0 < 0: i0 = 0\n            if j0 < 0: j0 = 0\n            if k0 < 0: k0 = 0\n            if i1 >= nx: i1 = nx - 1\n            if j1 >= ny: j1 = ny - 1\n            if k1 >= nz: k1 = nz - 1\n            for i in range(i0, i1 + 1):\n                for j in range(j0, j1 + 1):\n                    for k in range(k0, k1 + 1):\n                        yield (i, j, k)\n\n    def _point_in_obstacle(self, pos, is_3d):\n        key = self._bin_key(pos)\n        bucket = self._bins.get(key)\n        if not bucket:\n            return False\n        if not is_3d:\n            px, py = pos\n            for obs in bucket:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        else:\n            px, py, pz = pos\n            for obs in bucket:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        return False\n\n    def _edge_blocked(self, a, b, is_3d):\n        if self.dim == 2:\n            bmin = (min(a[0], b[0]), min(a[1], b[1]))\n            bmax = (max(a[0], b[0]), max(a[1], b[1]))\n        else:\n            bmin = (min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2]))\n            bmax = (max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2]))\n        seen = {}\n        for key in self._bin_range_for_bbox(bmin, bmax):\n            bucket = self._bins.get(key)\n            if not bucket:\n                continue\n            for obs in bucket:\n                oid = id(obs)\n                if seen.get(oid):\n                    continue\n                seen[oid] = True\n                if self._segment_intersects_box(a, b, obs, is_3d):\n                    return True\n        return False\n\n    def _segment_intersects_box(self, a, b, obs, is_3d):\n        tmin = 0.0\n        tmax = 1.0\n        eps = 1e-12\n        if not is_3d:\n            x, y, w, h = obs\n            mn = (x, y)\n            mx = (x + w, y + h)\n            for i in range(2):\n                p0 = a[i]; p1 = b[i]\n                d = p1 - p0\n                lo = mn[i]; hi = mx[i]\n                if abs(d) < eps:\n                    if p0 < lo or p0 > hi:\n                        return False\n                else:\n                    inv = 1.0 / d\n                    t1 = (lo - p0) * inv\n                    t2 = (hi - p0) * inv\n                    if t1 > t2: t1, t2 = t2, t1\n                    if t1 > tmin: tmin = t1\n                    if t2 < tmax: tmax = t2\n                    if tmin > tmax: return False\n            return True\n        else:\n            x, y, z, w, h, dlen = obs\n            mn = (x, y, z)\n            mx = (x + w, y + h, z + dlen)\n            for i in range(3):\n                p0 = a[i]; p1 = b[i]\n                d = p1 - p0\n                lo = mn[i]; hi = mx[i]\n                if abs(d) < eps:\n                    if p0 < lo or p0 > hi:\n                        return False\n                else:\n                    inv = 1.0 / d\n                    t1 = (lo - p0) * inv\n                    t2 = (hi - p0) * inv\n                    if t1 > t2: t1, t2 = t2, t1\n                    if t1 > tmin: tmin = t1\n                    if t2 < tmax: tmax = t2\n                    if tmin > tmax: return False\n            return True\n\n    # ---------------- Sampling ----------------\n    def _sample_target(self, attractor, corridor_w, best_len, is_3d):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._ellipse_sample(self.start, self.goal, best_len * 1.02, is_3d)\n            if p is not None:\n                return p\n        r2 = self._rand()\n        if r2 < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and not self._point_in_obstacle(p, is_3d):\n                return p\n        elif r2 < self.goal_bias + self.corridor_bias:\n            t = self._rand()\n            base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n            jitter = tuple(self._uniform(-corridor_w, corridor_w) for _ in range(self.dim))\n            p = tuple(min(max(base[i] + jitter[i], 0.0), self.bounds[i]) for i in range(self.dim))\n            if not self._point_in_obstacle(p, is_3d):\n                return p\n        # Uniform fallback\n        if self.dim == 2:\n            for _ in range(32):\n                p = (self._uniform(0.0, self.bounds[0]), self._uniform(0.0, self.bounds[1]))\n                if not self._point_in_obstacle(p, is_3d):\n                    return p\n        else:\n            for _ in range(32):\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n                if not self._point_in_obstacle(p, is_3d):\n                    return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum, is_3d):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [half] * self.dim\n        for _ in range(36):\n            p = tuple(c[i] + (self._uniform(-ext[i], ext[i])) for i in range(self.dim))\n            if self._in_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and not self._point_in_obstacle(p, is_3d):\n                return p\n        return None\n\n    # ---------------- Node grid ----------------\n    def _grid_key(self, pos):\n        if self.dim == 2:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell))\n        else:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell), int(pos[2] // self.grid_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        return out\n\n    def _nearest_grid(self, grid, tree, pos, max_rings=2):\n        key = self._grid_key(pos)\n        best = None\n        bestd2 = float('inf')\n        for r in range(0, max_rings + 1):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            if best is not None:\n                return best\n        # fallback linear scan (rare)\n        for n in tree:\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd2:\n                bestd2 = d2\n                best = n\n        return best\n\n    def _k_nearest_grid(self, grid, tree, pos, k, max_rings=2):\n        key = self._grid_key(pos)\n        cand_nodes = []\n        seen = set()\n        for r in range(0, max_rings + 1):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                if n in seen:\n                    continue\n                seen.add(n)\n                cand_nodes.append((self._dist2(n.position, pos), n))\n            if len(cand_nodes) >= k:\n                break\n        if not cand_nodes:\n            # Fallback: scan a bit of the tree (first min(k*5, len(tree)) nodes)\n            limit = min(len(tree), k * 5)\n            for i in range(limit):\n                n = tree[i]\n                cand_nodes.append((self._dist2(n.position, pos), n))\n        cand_nodes.sort(key=lambda t: t[0])\n        return [n for (_, n) in cand_nodes[:k]]\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_collect_ring(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                return True\n        return False\n\n    # ---------------- Ancestor visibility ----------------\n    def _visible_ancestor(self, node, new_pos, is_3d, max_up=3):\n        cur = node\n        best = cur\n        steps = 0\n        while cur is not None and steps < max_up:\n            if not self._edge_blocked(cur.position, new_pos, is_3d):\n                best = cur\n            else:\n                break\n            cur = cur.parent\n            steps += 1\n        return best\n\n    def _remove_edge(self, edges, e):\n        # Remove the first match from the end to amortize cost\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is e[0] and edges[i][1] is e[1]:\n                edges.pop(i)\n                return\n\n    # ---------------- Paths and smoothing ----------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a, b):\n        pa = self._path_to_root(a)      # start -> a\n        pb = self._path_to_root(b)      # goal -> b (or goal tree root)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return pa + pb[::-1]\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, path, is_3d):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            jumped = False\n            while j > i + 1:\n                if not self._edge_blocked(out[-1], path[j], is_3d):\n                    out.append(path[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(path[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, path, is_3d):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        bestL = self._path_len(pts)\n        for _ in range(self.smoothing_shortcuts):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                continue\n            a = pts[i]; b = pts[j]\n            if not self._edge_blocked(a, b, self.dim == 3):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= bestL + 1e-12:\n                    pts = new_pts\n                    bestL = L\n        return pts\n\n    def _elastic_relax(self, path, is_3d):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        for _ in range(self.elastic_passes):\n            for i in range(1, len(pts) - 1):\n                prevp = pts[i - 1]\n                nextp = pts[i + 1]\n                mid = tuple(0.5 * (prevp[d] + nextp[d]) for d in range(self.dim))\n                if not self._in_bounds(mid):\n                    continue\n                if self._point_in_obstacle(mid, is_3d):\n                    continue\n                if self._edge_blocked(prevp, mid, is_3d):\n                    continue\n                if self._edge_blocked(mid, nextp, is_3d):\n                    continue\n                pts[i] = mid\n        return pts\n\n    def _finalize_path(self, path, is_3d):\n        p = self._visibility_prune(path, is_3d)\n        p = self._shortcut(p, is_3d)\n        p = self._elastic_relax(p, is_3d)\n        return p",
          "objective": -36.30959,
          "time_improvement": 70.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1781.0,
          "node_improvement": 86.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007480740547180176,
                    "num_nodes_avg": 53.3,
                    "path_length_avg": 168.98698854267826,
                    "smoothness_avg": 0.043924256976246044,
                    "success_improvement": 0.0,
                    "time_improvement": 69.67835954962798,
                    "node_improvement": 86.57768823973811,
                    "length_improvement": 7.3755538095662025,
                    "smoothness_improvement": 587.5100047289332,
                    "objective_score": 28.26639017427278
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.024790167808532715,
                    "num_nodes_avg": 139.4,
                    "path_length_avg": 244.006334012553,
                    "smoothness_avg": 0.12083465068115114,
                    "success_improvement": 0.0,
                    "time_improvement": 85.17791773104643,
                    "node_improvement": 90.633608815427,
                    "length_improvement": 18.54366237370452,
                    "smoothness_improvement": 3009.1625957069764,
                    "objective_score": 51.72538572207152
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02339780330657959,
                    "num_nodes_avg": 145.8,
                    "path_length_avg": 140.25127890109354,
                    "smoothness_avg": 0.14515848164505177,
                    "success_improvement": 0.0,
                    "time_improvement": 53.64634576625997,
                    "node_improvement": 81.46217418944693,
                    "length_improvement": 6.851778602115996,
                    "smoothness_improvement": 1746.4051720404764,
                    "objective_score": 28.936996751349973
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "HASTE-BiRRT: Hashed, Anytime, Saturation\u2011Throttled, Efficient BiRRT-Connect. It accelerates bidirectional RRT with cached collision tests, hashed nearest search with leader fallbacks, per-cell growth throttling, and duplicate-suppressed commit-only connections. A light visibility prune plus brief shortcutting refines the path while keeping postprocessing costs low.",
          "planning_mechanism": "Alternate expanding start/goal trees with goal-biased sampling; find nearest via grid rings, else leader-guided buckets; steer one step and validate with cached edge checks; suppress inserts in saturated/duplicate cells; attempt a single, commit-only direct bridge to the opposite tree, skipping known-blocked cell pairs; upon success, extract start-to-goal path, visibility-prune, then run a few shortcuts; terminate on success or iteration cap.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=7.0,\n                 goal_bias=0.25,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=40,\n                 max_per_cell=6,\n                 search_r_max=2,\n                 leader_stride=25):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n        self.max_per_cell = max_per_cell\n        self.search_r_max = search_r_max\n        self.leader_stride = leader_stride\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        # Caches\n        self._edge_blocked_cache = set()   # quantized blocked segments (safe to reuse only for blocked)\n        self._edge_exact_cache = {}        # exact endpoint pairs -> bool\n        self._connect_blocked_cells = set()  # (cellA, cellB) pairs known to fail direct connect\n\n    # ------------- Public API -------------\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Parameters derived\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size * 2.5)\n        self.edge_res = max(0.5, self.collision_step)\n\n        # Reset caches\n        self._edge_blocked_cache = set()\n        self._edge_exact_cache = {}\n        self._connect_blocked_cells = set()\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            path = [start, goal]\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Initialize trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Grids and counts\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n        self._grid_add(grid_start, counts_start, start_root)\n        self._grid_add(grid_goal, counts_goal, goal_root)\n\n        # Leaders\n        leaders_start = [start_root]\n        leaders_goal = [goal_root]\n        inserted_since_leader_start = 0\n        inserted_since_leader_goal = 0\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            grid_a = grid_start if active_start else grid_goal\n            counts_a = counts_start if active_start else counts_goal\n            leaders_a = leaders_start if active_start else leaders_goal\n\n            tree_b = goal_tree if active_start else start_tree\n            grid_b = grid_goal if active_start else grid_start\n            counts_b = counts_goal if active_start else counts_start\n            leaders_b = leaders_goal if active_start else leaders_start\n\n            root_other = goal if active_start else start\n\n            # Sample with goal/opposite-root bias\n            if self._rand() < self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest lookup\n            nearest = self._nearest_hashed(grid_a, leaders_a, tree_a, x_rand)\n            if nearest is None:\n                continue\n\n            # Steer\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Per-cell throttling and duplicate suppression\n            key_new = self._grid_key(new_pos)\n            if self._cell_count(counts_a, key_new) >= self.max_per_cell:\n                continue\n            if self._near_duplicate(grid_a, new_pos, dup_radius=0.7 * self.step_size):\n                continue\n\n            # Insert node and edge\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, counts_a, new_node)\n\n            # Leader sampling\n            if active_start:\n                inserted_since_leader_start += 1\n                if inserted_since_leader_start >= self.leader_stride:\n                    leaders_start.append(new_node)\n                    inserted_since_leader_start = 0\n            else:\n                inserted_since_leader_goal += 1\n                if inserted_since_leader_goal >= self.leader_stride:\n                    leaders_goal.append(new_node)\n                    inserted_since_leader_goal = 0\n\n            # Try commit-only direct connection to the other tree (with cell-pair de-dup)\n            other_near = self._nearest_hashed(grid_b, leaders_b, tree_b, new_node.position)\n            if other_near is not None:\n                pair_key = (self._grid_key(new_node.position), self._grid_key(other_near.position))\n                if pair_key not in self._connect_blocked_cells:\n                    if not self._edge_blocked(new_node.position, other_near.position, obstacles, is_3d):\n                        path = self._extract_path(new_node, other_near, a_is_start_tree=active_start)\n                        path = self._visibility_prune(path, obstacles, is_3d)\n                        path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                        return PlannerResult(True, path, start_tree + goal_tree, edges)\n                    else:\n                        # cache blocked cell pair to avoid repeating futile checks\n                        self._connect_blocked_cells.add(pair_key)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ------------- Random -------------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------- Geometry -------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ------------- Collision & caches -------------\n    def _quant(self, p, q=1.5):\n        # Quantize for blocked-segment cache; coarse to avoid false frees; safe for blocked reuse only\n        if self.dim == 3:\n            return (int(p[0] // q), int(p[1] // q), int(p[2] // q))\n        else:\n            return (int(p[0] // q), int(p[1] // q))\n\n    def _seg_key_exact(self, a, b):\n        # Canonicalize order for undirected segment\n        if a <= b:\n            return (a, b)\n        else:\n            return (b, a)\n\n    def _seg_key_quant_blocked(self, a, b):\n        qa = self._quant(a)\n        qb = self._quant(b)\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        # Exact cache check\n        k_exact = self._seg_key_exact(a, b)\n        cached = self._edge_exact_cache.get(k_exact)\n        if cached is not None:\n            return cached\n        # Blocked quantized cache\n        kq = self._seg_key_quant_blocked(a, b)\n        if kq in self._edge_blocked_cache:\n            self._edge_exact_cache[k_exact] = True\n            return True\n        # Compute\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res)\n        # Update caches\n        self._edge_exact_cache[k_exact] = blocked\n        if blocked:\n            self._edge_blocked_cache.add(kq)\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ------------- Sampling -------------\n    def _sample_free(self, obstacles, is_3d):\n        # Rejection sampling within bounds until a free point is found\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ------------- Grid / NN -------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n\n    def _cell_count(self, counts, key):\n        return counts.get(key, 0)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, leaders, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Local rings\n        for r in range(0, self.search_r_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Leader fallback\n        if leaders:\n            lead_best = None\n            lead_bestd = float('inf')\n            for n in leaders:\n                d = self._dist(n.position, pos)\n                if d < lead_bestd:\n                    lead_bestd = d\n                    lead_best = n\n            if lead_best is not None:\n                # Search around leader cell for neighbors\n                lk = self._grid_key(lead_best.position)\n                for r in range(0, min(2, self.search_r_max) + 1):\n                    cand = self._grid_ring_collect(grid, lk, r)\n                    for n in cand:\n                        d = self._dist(n.position, pos)\n                        if d < bestd:\n                            bestd = d\n                            best = n\n                if best is not None:\n                    return best\n        # Sparse random subset fallback (avoid full scan)\n        if tree:\n            trials = min(64, len(tree))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(tree)))\n                n = tree[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            if best is not None:\n                return best\n        return None\n\n    def _near_duplicate(self, grid, pos, dup_radius):\n        key = self._grid_key(pos)\n        r = 1\n        cand = self._grid_ring_collect(grid, key, r)\n        rr = dup_radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # ------------- Path -------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            # start-tree path to meet, then meet->goal via reversed goal-tree path\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -35.78786,
          "time_improvement": 66.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1772.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016536712646484375,
                    "num_nodes_avg": 67.3,
                    "path_length_avg": 176.25078259592178,
                    "smoothness_avg": 0.05067539409595988,
                    "success_improvement": 0.0,
                    "time_improvement": 35.1470831615236,
                    "node_improvement": 83.05212792747419,
                    "length_improvement": 3.3941531868009323,
                    "smoothness_improvement": 693.1799609813568,
                    "objective_score": 16.046516665444422
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023010659217834472,
                    "num_nodes_avg": 105.2,
                    "path_length_avg": 247.25890321415372,
                    "smoothness_avg": 0.1191098532602342,
                    "success_improvement": 0.0,
                    "time_improvement": 85.63605318102866,
                    "node_improvement": 92.93153262111133,
                    "length_improvement": 17.45786115419664,
                    "smoothness_improvement": 2964.7823157454163,
                    "objective_score": 50.989444225553655
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.011754655838012695,
                    "num_nodes_avg": 94.4,
                    "path_length_avg": 127.41557160345823,
                    "smoothness_avg": 0.13822063405561777,
                    "success_improvement": 0.0,
                    "time_improvement": 76.0361625858193,
                    "node_improvement": 87.99745708836618,
                    "length_improvement": 15.376644218505373,
                    "smoothness_improvement": 1658.156262801516,
                    "objective_score": 40.327616620856595
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "SwiftLD-Bridge BiRRT*: A low-discrepancy, informed, lazy-bridge bidirectional RRT* with ring-grid nearest neighbors and unsorted, bounded rewiring. It uses Halton sampling to reduce wasted samples, obstacle binning for fast collision tests, early direct/ midpoint bridging before short connect, and a light two-stage refinement (visibility collapse, bounded shortcuts with elastic relaxation) for shorter, smoother paths with lower planning time.",
          "planning_mechanism": "Alternate expanding start/goal trees. Each iteration: draw a Halton-biased sample (goal/corridor/uniform; switch to ellipse after an incumbent), find nearest via ring-grid, steer and validate, pick cheapest parent from local neighbors without sorting, insert and locally rewire within a bounded radius. Try direct connect to the other tree; if blocked, attempt a midpoint bridge, else a short, duplicate-suppressed connect. On meeting, assemble and lightly refine the path and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        i = 0\n        while i < len(self.children):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n            i += 1\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=6.0,\n                 connect_factor=1.8,\n                 grid_cell_factor=1.3,\n                 neighbor_factor=2.2,\n                 min_sep_ratio=0.35,\n                 k_rewire=8,\n                 goal_bias=0.18,\n                 corridor_bias=0.36,\n                 informed_bias=0.6,\n                 vis_rounds=1,\n                 shortcut_attempts=90,\n                 elastic_passes=8,\n                 elastic_alpha=0.42):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_factor = float(connect_factor)\n        self.cell_factor = float(grid_cell_factor)\n        self.neigh_factor = float(neighbor_factor)\n        self.min_sep_ratio = float(min_sep_ratio)\n        self.k_rewire = int(max(0, k_rewire))\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.vis_rounds = int(max(0, vis_rounds))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.elastic_passes = int(max(0, elastic_passes))\n        self.elastic_alpha = float(elastic_alpha)\n        self._rng = 2463534242\n        self._hidx = 1\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self._is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", [])) if getattr(map, \"obstacles\", None) else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed()\n        if not self._build_obs_bins():\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Parameters derived\n        self.cell = max(1.0, self.step * self.cell_factor)\n        self.min_sep = max(0.5, self.step * self.min_sep_ratio)\n        self.connect_step = max(self.step, self.step * self.connect_factor)\n        self.base_neigh = max(self.step * 1.2, self.step * self.neigh_factor)\n\n        # Early direct check\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._refine(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize trees and grids\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        tree_a = [a_root]\n        tree_b = [b_root]\n        nodes.extend([a_root, b_root])\n        grid_a = {}\n        grid_b = {}\n        self._grid_add(grid_a, a_root)\n        self._grid_add(grid_b, b_root)\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            grow_a = (it & 1) == 0\n            T = tree_a if grow_a else tree_b\n            O = tree_b if grow_a else tree_a\n            G = grid_a if grow_a else grid_b\n            GO = grid_b if grow_a else grid_a\n            attractor = self.goal if grow_a else self.start\n\n            sp = self._sample(attractor, best_len)\n            if sp is None:\n                continue\n\n            anchor = self._nearest(G, sp)\n            if anchor is None:\n                anchor = T[-1]\n\n            newp = self._steer(anchor.position, sp, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(G, newp, self.min_sep):\n                continue\n            if not self._edge_free(anchor.position, newp):\n                continue\n\n            # Choose parent from local neighbors without sorting\n            neigh_r = self._neigh_radius(len(T))\n            neigh = self._neighbors(G, newp, neigh_r)\n            parent = anchor\n            bestc = anchor.cost + self._dist(anchor.position, newp)\n            for nb in neigh:\n                if nb is anchor:\n                    continue\n                gc = nb.cost + self._dist(nb.position, newp)\n                if gc + 1e-12 < bestc and self._edge_free(nb.position, newp):\n                    parent = nb\n                    bestc = gc\n\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, bestc)\n            parent.add_child(nn)\n            T.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(G, nn)\n\n            # Local bounded rewiring\n            if self.k_rewire > 0:\n                self._rewire_local(nn, G, edges, neigh_r)\n\n            # Try direct connect to opposite tree\n            op_near = self._nearest(GO, nn.position)\n            if op_near is not None and self._edge_free(nn.position, op_near.position):\n                path = self._assemble(nn, op_near, grow_a)\n                best_len = self._path_len(path)\n                path = self._refine(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Lazy midpoint bridge(s)\n            if op_near is not None:\n                m1 = self._midpoint(nn.position, op_near.position)\n                if (self._in_bounds(m1) and\n                    (not self._point_in_obstacles(m1)) and\n                    self._edge_free(nn.position, m1) and\n                    self._edge_free(op_near.position, m1)):\n                    ma = Node(m1, nn, nn.cost + self._dist(nn.position, m1))\n                    nn.add_child(ma)\n                    T.append(ma)\n                    nodes.append(ma)\n                    edges.append((nn, ma))\n                    self._grid_add(G, ma)\n\n                    mb = Node(m1, op_near, op_near.cost + self._dist(op_near.position, m1))\n                    op_near.add_child(mb)\n                    O.append(mb)\n                    nodes.append(mb)\n                    edges.append((op_near, mb))\n                    self._grid_add(GO, mb)\n\n                    path = self._assemble(ma, mb, grow_a)\n                    best_len = self._path_len(path)\n                    path = self._refine(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n                # Second chance with biased trisection points\n                t1 = 1.0 / 3.0\n                t2 = 2.0 / 3.0\n                p1 = tuple(nn.position[i] * (1 - t1) + op_near.position[i] * t1 for i in range(self.dim))\n                p2 = tuple(nn.position[i] * (1 - t2) + op_near.position[i] * t2 for i in range(self.dim))\n                if (self._in_bounds(p1) and self._in_bounds(p2) and\n                    (not self._point_in_obstacles(p1)) and (not self._point_in_obstacles(p2)) and\n                    self._edge_free(nn.position, p1) and\n                    self._edge_free(p1, p2) and\n                    self._edge_free(p2, op_near.position)):\n                    a1 = Node(p1, nn, nn.cost + self._dist(nn.position, p1))\n                    nn.add_child(a1)\n                    T.append(a1)\n                    nodes.append(a1)\n                    edges.append((nn, a1))\n                    self._grid_add(G, a1)\n\n                    b2 = Node(p2, op_near, op_near.cost + self._dist(op_near.position, p2))\n                    op_near.add_child(b2)\n                    O.append(b2)\n                    nodes.append(b2)\n                    edges.append((op_near, b2))\n                    self._grid_add(GO, b2)\n\n                    path = self._assemble(a1, b2, grow_a)\n                    best_len = self._path_len(path)\n                    path = self._refine(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n            # Short greedy connect\n            if op_near is not None:\n                meet = self._short_connect(O, GO, op_near, nn.position, edges)\n                if meet is not None:\n                    path = self._assemble(nn, meet, grow_a)\n                    best_len = self._path_len(path)\n                    path = self._refine(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed(self):\n        s = 0x9E3779B9 & 0xffffffff\n        for v in self.start + self.goal:\n            u = int(v * 2654435761) & 0xffffffff\n            s ^= (u ^ (u << 13) ^ (u >> 7)) & 0xffffffff\n            s = (1103515245 * s + 12345) & 0xffffffff\n        s ^= (len(self.obstacles) * 374761393) & 0xffffffff\n        if s == 0:\n            s = 2463534242\n        self._rng = s\n        self._hidx = (s % 10007) + 1\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Halton sequence\n    def _radical_inverse(self, i, base):\n        f = 1.0\n        r = 0.0\n        while i > 0:\n            f = f / base\n            r += f * (i % base)\n            i //= base\n        return r\n\n    def _halton_nd(self, idx):\n        if self._is3:\n            return (self._radical_inverse(idx, 2),\n                    self._radical_inverse(idx, 3),\n                    self._radical_inverse(idx, 5))\n        else:\n            return (self._radical_inverse(idx, 2),\n                    self._radical_inverse(idx, 3))\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _midpoint(self, a, b):\n        return tuple(0.5 * (a[i] + b[i]) for i in range(self.dim))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial hash for nodes\n    def _cell_key(self, p):\n        if self._is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self._is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        r = 0\n        while True:\n            cand = self._ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                if best is not None:\n                    return best\n            r += 1\n            if r > 8:\n                break\n        # fallback linear scan (rare)\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self._is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors(grid, pos, radius)) > 0\n\n    def _neigh_radius(self, ncount):\n        if ncount <= 1:\n            return self.base_neigh\n        n = float(ncount + 1)\n        gamma = self.base_neigh\n        # Mildly shrinking radius with n^(-1/d)\n        return max(self.step * 1.05, gamma * (n ** (-1.0 / max(2.0, float(self.dim)))))\n\n    # Obstacles and collision bins\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.4)\n        self.obin = {}\n        if self._is3:\n            for idx, o in enumerate(self.obstacles):\n                if len(o) != 6:\n                    continue\n                x, y, z, w, h, d = o\n                if w <= 0 or h <= 0 or d <= 0:\n                    continue\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n            return True\n        else:\n            for idx, o in enumerate(self.obstacles):\n                if len(o) != 4:\n                    continue\n                x, y, w, h = o\n                if w <= 0 or h <= 0:\n                    continue\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n            return True\n\n    def _point_in_obstacles(self, p):\n        if self._is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self._is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = []\n            seen = {}\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                if idx not in seen:\n                                    seen[idx] = True\n                                    cand.append(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = []\n            seen = {}\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            if idx not in seen:\n                                seen[idx] = True\n                                cand.append(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Rewiring\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _erase_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                del edges[i]\n                break\n\n    def _propagate(self, node, delta):\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    def _rewire_local(self, new_node, grid, edges, radius):\n        neigh = self._neighbors(grid, new_node.position, radius)\n        if not neigh:\n            return\n        count = 0\n        for nb in neigh:\n            if count >= self.k_rewire:\n                break\n            if nb is new_node or nb is new_node.parent:\n                continue\n            if self._is_ancestor(nb, new_node):\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            cand = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand + 1e-9 < nb.cost:\n                op = nb.parent\n                if op is not None:\n                    op.remove_child(nb)\n                    self._erase_edge(edges, op, nb)\n                new_node.add_child(nb)\n                edges.append((new_node, nb))\n                delta = cand - nb.cost\n                nb.cost = cand\n                self._propagate(nb, delta)\n                count += 1\n\n    # Sampling\n    def _sample(self, attractor, incumbent_len):\n        tries = 20\n        while tries > 0:\n            tries -= 1\n            r = self._rand()\n            if incumbent_len is not None and r < self.informed_bias:\n                p = self._sample_in_ellipse(self.start, self.goal, incumbent_len * 1.01)\n                if p is None:\n                    continue\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                elif r < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_point()\n                else:\n                    hv = self._halton_nd(self._hidx)\n                    self._hidx += 1\n                    if self._is3:\n                        p = (hv[0] * self.bounds[0], hv[1] * self.bounds[1], hv[2] * self.bounds[2])\n                    else:\n                        p = (hv[0] * self.bounds[0], hv[1] * self.bounds[1])\n            if self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _corridor_point(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step, 0.05 * sg)\n        if self._is3:\n            return self._clamp((base[0] + self._rand_range(-w, w),\n                                base[1] + self._rand_range(-w, w),\n                                base[2] + self._rand_range(-w, w)))\n        else:\n            return self._clamp((base[0] + self._rand_range(-w, w),\n                                base[1] + self._rand_range(-w, w)))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(18):\n            if self._is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if not self._in_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # Connect side\n    def _short_connect(self, tree, grid, from_node, target_pos, edges):\n        cur = from_node\n        steps = 0\n        max_steps = max(3, min(10, int(self._dist(cur.position, target_pos) / max(1.0, self.connect_step)) + 2))\n        while steps < max_steps:\n            if self._dist(cur.position, target_pos) <= self.connect_step and self._edge_free(cur.position, target_pos):\n                return cur\n            nxtp = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxtp)) or self._point_in_obstacles(nxtp):\n                return None\n            if self._too_close(grid, nxtp, self.min_sep):\n                return None\n            if not self._edge_free(cur.position, nxtp):\n                return None\n            nn = Node(nxtp, cur, cur.cost + self._dist(cur.position, nxtp))\n            cur.add_child(nn)\n            tree.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n        if self._edge_free(cur.position, target_pos):\n            return cur\n        return None\n\n    # Path extraction\n    def _to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _assemble(self, a_end, b_end, a_side_grew):\n        if a_side_grew:\n            pa = self._to_root(a_end)\n            pb = self._to_root(b_end)\n            if pa and pb and pa[-1] == pb[-1]:\n                pb = pb[:-1]\n            return pa + pb[::-1]\n        else:\n            pa = self._to_root(a_end)\n            pb = self._to_root(b_end)\n            if pa and pb and pb[-1] == pa[-1]:\n                pa = pa[:-1]\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    # Refinement pipeline\n    def _refine(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._vis_collapse(path, self.vis_rounds)\n        p1 = self._shortcut(p0, self.shortcut_attempts)\n        p2 = self._elastic(p1, self.elastic_passes, self.elastic_alpha)\n        return p2\n\n    def _vis_collapse(self, pts, rounds):\n        if len(pts) < 3 or rounds <= 0:\n            return pts[:]\n        cur = pts[:]\n        k = 0\n        while k < rounds:\n            out = [cur[0]]\n            i = 0\n            n = len(cur)\n            while i < n - 1:\n                j = n - 1\n                collapsed = False\n                while j > i + 1:\n                    if self._edge_free(out[-1], cur[j]):\n                        out.append(cur[j])\n                        i = j\n                        collapsed = True\n                        break\n                    j -= 1\n                if not collapsed:\n                    out.append(cur[i + 1])\n                    i += 1\n            if len(out) == len(cur):\n                cur = out\n                break\n            cur = out\n            k += 1\n        return cur\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3 or attempts <= 0:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j <= i + 1 or j >= len(cur):\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-12 <= bestL:\n                    cur = cand\n                    bestL = L\n            tries += 1\n        return cur\n\n    def _elastic(self, pts, passes, alpha):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = [tuple(p) for p in pts]\n        for _ in range(passes):\n            changed = False\n            i = 1\n            while i < len(cur) - 1:\n                a = cur[i - 1]\n                b = cur[i]\n                c = cur[i + 1]\n                tgt = tuple((a[k] + c[k]) * 0.5 for k in range(self.dim))\n                newp = tuple(b[k] + alpha * (tgt[k] - b[k]) for k in range(self.dim))\n                if (self._in_bounds(newp) and\n                    (not self._point_in_obstacles(newp)) and\n                    self._edge_free(a, newp) and\n                    self._edge_free(newp, c)):\n                    old_len = self._dist(a, b) + self._dist(b, c)\n                    new_len = self._dist(a, newp) + self._dist(newp, c)\n                    if new_len <= old_len + 1e-9:\n                        cur[i] = newp\n                        changed = True\n                i += 1\n            if not changed:\n                break\n        return cur",
          "objective": -35.73473,
          "time_improvement": 64.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1363.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011209535598754882,
                    "num_nodes_avg": 30.0,
                    "path_length_avg": 151.81793455890218,
                    "smoothness_avg": 0.04809570465023027,
                    "success_improvement": 0.0,
                    "time_improvement": 54.5644571018826,
                    "node_improvement": 92.44522790229162,
                    "length_improvement": 16.786184359144237,
                    "smoothness_improvement": 652.8022192703957,
                    "objective_score": 29.7050588424033
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.051754188537597653,
                    "num_nodes_avg": 167.0,
                    "path_length_avg": 239.31364021195412,
                    "smoothness_avg": 0.08741228791537975,
                    "success_improvement": 0.0,
                    "time_improvement": 69.05608521120335,
                    "node_improvement": 88.779143989787,
                    "length_improvement": 20.110218636046223,
                    "smoothness_improvement": 2149.181128588823,
                    "objective_score": 43.528862387932854
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.015206575393676758,
                    "num_nodes_avg": 85.0,
                    "path_length_avg": 134.05878342120369,
                    "smoothness_avg": 0.10895225286116442,
                    "success_improvement": 0.0,
                    "time_improvement": 69.87408054329718,
                    "node_improvement": 89.19262555626192,
                    "length_improvement": 10.964539244911666,
                    "smoothness_improvement": 1285.8646143752453,
                    "objective_score": 33.97027078181238
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SAGE-Connect*: Simplified Adaptive Grid-Enhanced RRT*-Connect with lazy visibility reparenting and cache-accelerated collisions. It uses a sparse grid for sublinear nearest/neighbor lookups, obstacle bins and segment caches to speed collision checks, informed-biased sampling for focus, best-parent selection within a shrinking radius, bounded local rewiring, and a restrained greedy connect. A minimal, robust smoothing stack (visibility prune + shortcut + elastic relax) refines the final path.",
          "planning_mechanism": "Alternate expanding start/goal trees. Each iteration: informed/goal/uniform sample; find nearest via grid rings; steer one step; choose the cheapest feasible parent among nearby nodes; insert only if both node and edge are collision-free; locally rewire cheaper neighbors; then greedily extend the opposite tree toward the new point, inserting an exact meeting node when visible. On connection, extract and run visibility prune, randomized shortcuts, and elastic relaxation, then return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=4800,\n                 step_size=5.0,\n                 connect_factor=2.3,\n                 goal_bias=0.12,\n                 neighbor_radius_factor=2.4,\n                 neighbor_cap=12,\n                 dup_radius_factor=0.40,\n                 shortcut_attempts=180,\n                 relax_passes=6):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_step = float(connect_factor) * self.step\n        self.goal_bias = float(goal_bias)\n        self.neighbor_radius_factor = float(neighbor_radius_factor)\n        self.neighbor_cap = int(neighbor_cap)\n        self.dup_radius_factor = float(dup_radius_factor)\n        self.shortcut_attempts = int(shortcut_attempts)\n        self.relax_passes = int(relax_passes)\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Seed RNG from scene\n        self._seed_from_scene()\n\n        # Spatial hash/grid parameters\n        self.grid_cell = max(1.0, 0.9 * self.step)\n        self.dup_radius = max(0.35 * self.step, self.dup_radius_factor * self.step)\n\n        # Build obstacle bins and caches\n        self._build_obs_bins()\n        self._edge_free_cache = {}  # (canon(a,b)) -> bool (True if free)\n        self._edge_block_cache = {} # (canon(a,b)) -> bool (True if blocked)\n\n        # Validate start/goal free\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            final = self._finalize_path(path)\n            return PlannerResult(True, final, nodes, edges)\n\n        # Initialize trees and grids\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        Ta, Tb = [root_a], [root_b]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, root_a)\n        self._grid_add(Gb, root_b)\n        nodes.extend([root_a, root_b])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = Ta if active_start else Tb\n            tree_b = Tb if active_start else Ta\n            grid_a = Ga if active_start else Gb\n            grid_b = Gb if active_start else Ga\n            attractor = self.goal if active_start else self.start\n\n            # Sample\n            s = self._sample(attractor, best_len)\n            if s is None:\n                continue\n\n            # Nearest and nominal steer\n            na = self._nearest(grid_a, s)\n            if na is None:\n                continue\n            q_new = self._steer(na.position, s, self.step)\n            if (not self._in_bounds(q_new)) or self._point_in_obstacles(q_new):\n                continue\n            if self._exists_close(grid_a, q_new, self.dup_radius):\n                continue\n\n            # Cost-aware parent choice within adaptive radius\n            rad = self._adaptive_radius(len(tree_a))\n            parent, new_cost = self._choose_parent(grid_a, q_new, na, rad)\n\n            # Final both-checks before adding the node/edge\n            if not self._in_bounds(q_new):\n                continue\n            if self._point_in_obstacles(q_new):\n                continue\n            if not self._edge_free(parent.position, q_new):\n                continue\n\n            # Insert node\n            nn = Node(q_new, parent, new_cost)\n            parent.add_child(nn)\n            tree_a.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(grid_a, nn)\n\n            # Lazy visibility reparenting (bounded up-ancestor)\n            up = parent\n            steps_up = 0\n            while up is not None and steps_up < 4:\n                if self._edge_free(up.position, nn.position):\n                    if up is not nn.parent:\n                        # Both checks before edge commit\n                        if self._in_bounds(nn.position) and (not self._point_in_obstacles(nn.position)) and self._edge_free(up.position, nn.position):\n                            oldp = nn.parent\n                            if oldp is not None:\n                                oldp.remove_child(nn)\n                                self._remove_edge(edges, (oldp, nn))\n                            up.add_child(nn)\n                            nn.cost = up.cost + self._dist(up.position, nn.position)\n                            edges.append((up, nn))\n                            parent = up\n                    break\n                up = up.parent\n                steps_up += 1\n\n            # Local bounded rewiring\n            self._local_rewire(grid_a, nn, rad, edges, cap=self.neighbor_cap)\n\n            # Greedy connect toward new point from opposite tree\n            meet, reached = self._connect_toward(tree_b, grid_b, nn.position, nodes, edges)\n            if reached:\n                # Build full path including exact meeting node if inserted\n                pa = self._trace_to_root(nn)\n                pb = self._trace_to_root(meet)\n                if pa and pb and pa[0] == pb[0]:\n                    # same root; join at meeting\n                    if pa[-1] == pb[-1]:\n                        full = pa\n                    else:\n                        full = pa + pb[-2::-1]\n                else:\n                    full = pa + pb[-2::-1]\n                full = self._dedup(full)\n                best_len = self._path_len(full)\n                final = self._finalize_path(full)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG and helpers\n    def _seed_from_scene(self):\n        s = 0x9E3779B9 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= (q ^ (q >> 13) ^ ((q << 7) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 23) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial hash for nodes\n    def _grid_key(self, pos):\n        if self.is3:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell), int(pos[2] // self.grid_cell))\n        else:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 4):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n            if best is not None:\n                return best\n        # fallback scan over grid buckets\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius, cap=None):\n        key = self._grid_key(pos)\n        rc = int(radius // self.grid_cell) + 1\n        r2 = radius * radius\n        out = []\n        cand = self._grid_collect_ring(grid, key, rc)\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                out.append(n)\n                if cap is not None and len(out) >= cap:\n                    break\n        return out\n\n    def _exists_close(self, grid, pos, radius):\n        nb = self._neighbors_in_radius(grid, pos, radius, cap=1)\n        return len(nb) > 0\n\n    # Obstacles and collisions\n    def _build_obs_bins(self):\n        # Bin size based on step and scene size\n        cell = max(4.0, self.step * 1.3)\n        self.obs_cell = cell\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // cell)\n                iy0 = int(max(0.0, y) // cell)\n                iz0 = int(max(0.0, z) // cell)\n                ix1 = int(min(self.bounds[0], x + w) // cell)\n                iy1 = int(min(self.bounds[1], y + h) // cell)\n                iz1 = int(min(self.bounds[2], z + d) // cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // cell)\n                iy0 = int(max(0.0, y) // cell)\n                ix1 = int(min(self.bounds[0], x + w) // cell)\n                iy1 = int(min(self.bounds[1], y + h) // cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        key = self._canon_seg(a, b)\n        v = self._edge_free_cache.get(key)\n        if v is not None:\n            return v\n        blocked = self._edge_blocked(a, b)\n        res = not blocked\n        self._edge_free_cache[key] = res\n        self._edge_block_cache[key] = blocked\n        return res\n\n    def _edge_blocked(self, a, b):\n        key = self._canon_seg(a, b)\n        v = self._edge_block_cache.get(key)\n        if v is not None:\n            return v\n        hit = self._edge_hits_any(a, b)\n        self._edge_block_cache[key] = hit\n        self._edge_free_cache[key] = not hit\n        return hit\n\n    def _edge_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _canon_seg(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Parenting / rewiring\n    def _adaptive_radius(self, n_nodes):\n        # Smoothly shrink with growth; keep a floor tied to step\n        shrink = 0.55 ** (n_nodes / 2000.0)\n        return max(self.step * 1.2, self.neighbor_radius_factor * self.step * shrink)\n\n    def _choose_parent(self, grid, newp, fallback, radius):\n        parent = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        neigh = self._neighbors_in_radius(grid, newp, radius, cap=self.neighbor_cap * 2)\n        for n in neigh:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                parent = n\n                best_cost = c\n        return parent, best_cost\n\n    def _local_rewire(self, grid, nn, radius, edges, cap=12):\n        neigh = self._neighbors_in_radius(grid, nn.position, radius, cap=cap)\n        for nb in neigh:\n            if nb is nn or nb is nn.parent:\n                continue\n            # prevent cycles: don't reparent an ancestor\n            cur = nn\n            cyc = False\n            while cur is not None:\n                if cur is nb:\n                    cyc = True\n                    break\n                cur = cur.parent\n            if cyc:\n                continue\n            cand = nn.cost + self._dist(nn.position, nb.position)\n            if cand + 1e-12 < nb.cost and self._edge_free(nn.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, (oldp, nb))\n                nn.add_child(nb)\n                nb.cost = cand\n                edges.append((nn, nb))\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _remove_edge(self, edges, e):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is e[0] and edges[i][1] is e[1]:\n                edges.pop(i)\n                return\n\n    # Greedy connect (BiRRT-Connect style)\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < 48:\n            # If straight visible, insert exact meeting node if safe\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                    if not self._exists_close(grid, target_pos, self.dup_radius * 0.75):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        # Both checks before adding\n                        if (not self._point_in_obstacles(nn.position)) and self._edge_free(cur.position, nn.position):\n                            cur.add_child(nn)\n                            tree.append(nn)\n                            nodes.append(nn)\n                            edges.append((cur, nn))\n                            self._grid_add(grid, nn)\n                            return nn, True\n                # If we cannot insert the exact node due to dup or bounds, still call it connected\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if self._exists_close(grid, nxt, self.dup_radius * 0.75):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            # Both checks before adding (redundant-safety)\n            if self._point_in_obstacles(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                return cur, False\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n        # Final attempt at exact meeting\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                if not self._exists_close(grid, target_pos, self.dup_radius * 0.75):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    if (not self._point_in_obstacles(nn.position)) and self._edge_free(cur.position, nn.position):\n                        cur.add_child(nn)\n                        tree.append(nn)\n                        nodes.append(nn)\n                        edges.append((cur, nn))\n                        self._grid_add(grid, nn)\n                        return nn, True\n            return cur, True\n        return cur, False\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.6:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.01)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n        # Uniform rejection sampling\n        if self.is3:\n            for _ in range(32):\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n                if not self._point_in_obstacles(p):\n                    return p\n        else:\n            for _ in range(32):\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n                if not self._point_in_obstacles(p):\n                    return p\n        return None\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(28):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Path utilities and smoothing\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        # backward pass for extra collapse\n        if len(out) >= 3:\n            rev = list(reversed(out))\n            rev2 = [rev[0]]\n            i = 0\n            m = len(rev)\n            while i < m - 1:\n                j = m - 1\n                while j > i + 1:\n                    if self._edge_free(rev2[-1], rev[j]):\n                        rev2.append(rev[j]); i = j; break\n                    j -= 1\n                else:\n                    rev2.append(rev[i + 1]); i += 1\n            out = list(reversed(rev2))\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            n = len(cur)\n            i = int(self._rand_range(0, max(1, n - 2)))\n            jmin = i + 2\n            if jmin >= n:\n                tries += 1\n                continue\n            j = int(self._rand_range(jmin, n))\n            if j >= n:\n                j = n - 1\n            a = cur[i]; b = cur[j]\n            if self._edge_free(a, b):\n                newp = cur[:i + 1] + cur[j:]\n                L = self._path_len(newp)\n                if L <= bestL + 1e-12:\n                    cur = newp\n                    bestL = L\n            tries += 1\n        return cur\n\n    def _elastic_relax(self, pts, passes):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        alpha = 0.55\n        for _ in range(passes):\n            changed = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                b = cur[i + 1]\n                target = tuple((1.0 - alpha) * cur[i][d] + alpha * 0.5 * (a[d] + b[d]) for d in range(self.dim))\n                if (not self._in_bounds(target)) or self._point_in_obstacles(target):\n                    continue\n                if self._edge_free(a, target) and self._edge_free(target, b):\n                    cur[i] = target\n                    changed = True\n            if not changed:\n                break\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p = self._visibility_prune(path)\n        p = self._shortcut(p, self.shortcut_attempts)\n        p = self._elastic_relax(p, self.relax_passes)\n        p = self._visibility_prune(p)\n        return self._dedup(p)",
          "objective": -35.54656,
          "time_improvement": 58.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1530.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013083529472351075,
                    "num_nodes_avg": 71.0,
                    "path_length_avg": 159.32104211285744,
                    "smoothness_avg": 0.03477356444157408,
                    "success_improvement": 0.0,
                    "time_improvement": 46.96860905943143,
                    "node_improvement": 82.12037270209015,
                    "length_improvement": 12.673612214473765,
                    "smoothness_improvement": 444.2817955144308,
                    "objective_score": 23.916159024085843
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03406612873077393,
                    "num_nodes_avg": 179.0,
                    "path_length_avg": 245.01780223509877,
                    "smoothness_avg": 0.12888246701044975,
                    "success_improvement": 0.0,
                    "time_improvement": 79.63180537815894,
                    "node_improvement": 87.97285493516092,
                    "length_improvement": 18.2060051675202,
                    "smoothness_improvement": 3216.238706467631,
                    "objective_score": 50.894338246297956
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026839089393615723,
                    "num_nodes_avg": 187.0,
                    "path_length_avg": 117.60547760156143,
                    "smoothness_avg": 0.0809019241494561,
                    "success_improvement": 0.0,
                    "time_improvement": 46.82877476150688,
                    "node_improvement": 76.22377622377621,
                    "length_improvement": 21.892041548088027,
                    "smoothness_improvement": 929.0665036222092,
                    "objective_score": 31.829189875415928
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Bounded BiRRT-Connect with Grid-Accelerated Nearest and Lightweight Shortcutting: a time-capped, bidirectional RRT-Connect that uses a coarse spatial grid for fast nearest-neighbor queries, commits only validated steps, attempts a single greedy bridge per iteration, and applies a brief shortcut smoother to the first found path for quality without heavy rewiring or anytime overhead.",
          "planning_mechanism": "Mechanism: Alternate growing start/goal trees with one extend loop toward a biased sample; each successful extension triggers a greedy extend from the opposite tree toward the new node. Both node and edge collisions are strictly checked before every insertion and the final bridge. Nearest queries use a bucket grid with limited ring expansion and linear fallback. On success, a bounded-time shortcut pass improves path length/smoothness; the planner enforces a hard time limit and returns the best (first) feasible path promptly.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=6.0,\n        goal_sample_rate=0.15,\n        bridge_bias_rate=0.30,\n        cell_size_factor=2.0,\n        time_limit_sec=12.0,\n        edge_resolution=1.0,\n        smooth_attempts=80,\n        smooth_time_frac=0.2\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.bridge_bias_rate = bridge_bias_rate\n        self.cell_size_factor = cell_size_factor\n        self.time_limit_sec = time_limit_sec\n        self.edge_resolution = edge_resolution\n        self.smooth_attempts = smooth_attempts\n        self.smooth_time_frac = smooth_time_frac\n\n    def plan(self, map):\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Validate start/goal feasibility\n        if self._is_in_obstacle(start_position, obstacles, is_3d) or self._is_in_obstacle(goal_position, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Initialize trees and spatial grids\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root = Node(goal_position, parent=None, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        grid_start = {}\n        grid_goal = {}\n        self._grid_insert(grid_start, start_root.position, start_root, cell_size, dim)\n        self._grid_insert(grid_goal, goal_root.position, goal_root, cell_size, dim)\n\n        start_time = time.time()\n\n        # Early straight-line check\n        if not self._is_edge_in_obstacle(start_position, goal_position, obstacles, is_3d, self.edge_resolution):\n            edges.append((start_root, goal_root))\n            direct_path = [start_position, goal_position]\n            return PlannerResult(True, direct_path, start_tree + goal_tree, edges)\n\n        # Main loop\n        for it in range(self.max_iter):\n            if time.time() - start_time >= self.time_limit_sec:\n                return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n            # Alternate tree growth\n            if it % 2 == 0:\n                grow_tree, grow_grid = start_tree, grid_start\n                other_tree, other_grid = goal_tree, grid_goal\n                a_is_start_side = True\n                other_root_pos = goal_root.position\n            else:\n                grow_tree, grow_grid = goal_tree, grid_goal\n                other_tree, other_grid = start_tree, grid_start\n                a_is_start_side = False\n                other_root_pos = start_root.position\n\n            sample = self._sample(bounds, obstacles, is_3d, other_root_pos)\n\n            # Extend grow_tree toward sample\n            a_near = self._nearest_from_grid(grow_tree, grow_grid, sample, cell_size, dim)\n            a_last = self._extend(grow_tree, grow_grid, a_near, sample, nodes, edges, obstacles, is_3d, bounds, cell_size, dim)\n            if a_last is None:\n                continue\n\n            # Greedy connect: extend other_tree toward the new node\n            b_near = self._nearest_from_grid(other_tree, other_grid, a_last.position, cell_size, dim)\n            b_last = self._extend(other_tree, other_grid, b_near, a_last.position, nodes, edges, obstacles, is_3d, bounds, cell_size, dim)\n            if b_last is None:\n                continue\n\n            # Attempt final short bridge\n            if self._distance(b_last.position, a_last.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(b_last.position, a_last.position, obstacles, is_3d, self.edge_resolution):\n                    edges.append((b_last, a_last))\n                    # Extract and smooth path\n                    final_path = self._assemble_path(a_last, b_last, a_is_start_side)\n                    remaining = max(0.0, self.time_limit_sec - (time.time() - start_time))\n                    budget = min(remaining, self.time_limit_sec * self.smooth_time_frac)\n                    final_path = self._shortcut_path(final_path, obstacles, is_3d, bounds, budget, self.smooth_attempts)\n                    return PlannerResult(True, final_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---- Utilities ----\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _within_bounds(self, p, bounds):\n        for i in range(len(bounds)):\n            if p[i] < 0.0 or p[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step_size):\n        d = self._distance(from_pos, to_pos)\n        if d <= step_size:\n            return to_pos\n        r = step_size / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    def _sample(self, bounds, obstacles, is_3d, other_root_pos):\n        # Bias toward the opposite root\n        if random.random() < self.bridge_bias_rate:\n            return other_root_pos\n        # Mild goal bias to encourage meeting/goal attraction\n        if random.random() < self.goal_sample_rate:\n            return other_root_pos\n        # Uniform rejection sampling in free space\n        dim = len(bounds)\n        for _ in range(30):\n            pt = tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n        # Fallback: last sample even if occupied (extend will reject)\n        return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n\n    def _extend(self, tree, grid, nearest_node, target_pos, nodes, edges, obstacles, is_3d, bounds, cell_size, dim):\n        current = nearest_node\n        last_new = None\n        while True:\n            step_pos = self._steer(current.position, target_pos, self.step_size)\n            if not self._within_bounds(step_pos, bounds):\n                break\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                break\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d, self.edge_resolution):\n                break\n            # Both node and edge are valid \u2192 commit\n            new_node = Node(step_pos)\n            new_node.cost = current.cost + self._distance(current.position, step_pos)\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node.position, new_node, cell_size, dim)\n            last_new = new_node\n            current = new_node\n            # Stop if reached target (within one step)\n            if self._distance(current.position, target_pos) <= self.step_size:\n                break\n        return last_new\n\n    def _assemble_path(self, a_node, b_node, a_is_start_side):\n        if a_is_start_side:\n            pa = a_node.path_from_root()   # start -> ... -> a\n            pb = b_node.path_from_root()   # goal  -> ... -> b\n            return pa + pb[::-1]           # start ... a, b ... goal\n        else:\n            pa = a_node.path_from_root()   # goal  -> ... -> a\n            pb = b_node.path_from_root()   # start -> ... -> b\n            return pb + pa[::-1]           # start ... b, a ... goal\n\n    # ---- Spatial grid for approximate nearest ----\n    def _cell_index(self, pos, cell_size, dim):\n        if dim == 2:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size))\n        else:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size), int(pos[2] // cell_size))\n\n    def _grid_insert(self, grid, pos, node, cell_size, dim):\n        idx = self._cell_index(pos, cell_size, dim)\n        if idx in grid:\n            grid[idx].append(node)\n        else:\n            grid[idx] = [node]\n\n    def _nearest_from_grid(self, tree, grid, point, cell_size, dim, max_rings=3):\n        # For small trees, just do linear scan\n        if len(tree) < 32:\n            return min(tree, key=lambda n: self._distance(n.position, point))\n\n        center = self._cell_index(point, cell_size, dim)\n        best = None\n        # Expand rings until some candidates found, then pick nearest among them\n        for r in range(0, max_rings + 1):\n            candidates = []\n            if dim == 2:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        idx = (center[0] + dx, center[1] + dy)\n                        if idx in grid:\n                            candidates.extend(grid[idx])\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            idx = (center[0] + dx, center[1] + dy, center[2] + dz)\n                            if idx in grid:\n                                candidates.extend(grid[idx])\n            if candidates:\n                best = min(candidates, key=lambda n: self._distance(n.position, point))\n                break\n\n        if best is None:\n            # Fallback to linear scan if grid empty nearby\n            best = min(tree, key=lambda n: self._distance(n.position, point))\n        return best\n\n    # ---- Collision utilities ----\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist / max(1e-6, resolution)))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    # ---- Path shortcutting ----\n    def _shortcut_path(self, path, obstacles, is_3d, bounds, time_budget, attempts):\n        if len(path) < 3:\n            return path\n        start_t = time.time()\n        pts = list(path)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and (time.time() - start_t) <= time_budget:\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            # Keep within bounds and collision-free\n            if not self._segment_within_bounds(a, b, bounds):\n                tries += 1\n                continue\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_resolution):\n                # Apply shortcut\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n            tries += 1\n        return pts\n\n    def _segment_within_bounds(self, a, b, bounds):\n        # The interpolated segment is within bounds if endpoints are; checks along the way via edge collision\n        for d in range(len(bounds)):\n            if a[d] < 0.0 or a[d] > bounds[d]:\n                return False\n            if b[d] < 0.0 or b[d] > bounds[d]:\n                return False\n        return True",
          "objective": -35.38986,
          "time_improvement": 79.0,
          "length_improvement": 6.0,
          "smoothness_improvement": 1571.0,
          "node_improvement": 81.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009288859367370606,
                    "num_nodes_avg": 87.5,
                    "path_length_avg": 179.7819366813108,
                    "smoothness_avg": 0.041891929272141075,
                    "success_improvement": 0.0,
                    "time_improvement": 63.57137981686718,
                    "node_improvement": 77.96524804835055,
                    "length_improvement": 1.4586716778820132,
                    "smoothness_improvement": 555.6996628894441,
                    "objective_score": 22.725115266236582
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009074711799621582,
                    "num_nodes_avg": 124.9,
                    "path_length_avg": 251.58839597257443,
                    "smoothness_avg": 0.10077141463831178,
                    "success_improvement": 0.0,
                    "time_improvement": 94.3352914641303,
                    "node_improvement": 91.6078747564335,
                    "length_improvement": 16.01255185389636,
                    "smoothness_improvement": 2492.9210813599107,
                    "objective_score": 50.372723958376454
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01003124713897705,
                    "num_nodes_avg": 215.4,
                    "path_length_avg": 148.33090891427284,
                    "smoothness_avg": 0.13860849885025553,
                    "success_improvement": 0.0,
                    "time_improvement": 79.54962026854608,
                    "node_improvement": 72.6128417037508,
                    "length_improvement": 1.4856730579993105,
                    "smoothness_improvement": 1663.0898743601072,
                    "objective_score": 33.07173928716395
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SWIFT-IRRT*: Simple Weighted Informed Rapidly-exploring bi-Trees with capped rewiring and ancestor compression. It grows two coherent trees with ring-hash nearest search, informed/corridor sampling after the first path, adaptive LOS-extended steering, bounded cost-aware parent choice, and tiny local rewiring. Every insertion performs multi-hop visible-ancestor compression and then attempts a short greedy bridge to the opposite tree. A minimal post-processor applies visibility pruning, shortcuts, and elastic averaging for smoothness. Mandatory node and edge collision checks are enforced before any insertion or reparenting for robustness.",
          "planning_mechanism": "Alternate start/goal expansions. Each step: sample (goal/informed/corridor/uniform), find near via hashed rings, steer with LOS-long step, validate node and parent edge, admit via per-cell gate, insert, compress to a visible ancestor, lightly rewire neighbors, then try a direct/greedy bridge to the other tree. On connection, assemble by parents and refine, then return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        pts.reverse()\n        return pts\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step=6.0,\n        long_step_factor=2.0,\n        goal_bias=0.15,\n        corridor_bias=0.35,\n        informed_bias=0.5,\n        grid_cell_factor=1.6,\n        cell_cap=8,\n        ring_max=3,\n        neighbor_radius_factor=3.0,\n        rewire_cap=16,\n        connect_attempts=4,\n        shortcut_attempts=80,\n        smooth_passes=6\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step)\n        self.long_step = float(step * long_step_factor)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.cell_cap = int(cell_cap)\n        self.ring_max = int(ring_max)\n        self.neighbor_radius_factor = float(neighbor_radius_factor)\n        self.rewire_cap = int(rewire_cap)\n        self.connect_attempts = int(connect_attempts)\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.smooth_passes = int(max(0, smooth_passes))\n        self._rng = 1234567\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed()\n        self._build_obs_index()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        if self.start == self.goal:\n            n0 = Node(self.start, None, 0.0)\n            return PlannerResult(True, [self.start], [n0], [])\n\n        # Early straight path\n        if self._edge_free(self.start, self.goal):\n            a = Node(self.start, None, 0.0)\n            b = Node(self.goal, a, self._dist(self.start, self.goal))\n            a.add_child(b)\n            return PlannerResult(True, [self.start, self.goal], [a, b], [(a, b)])\n\n        # Structures\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        nodes = []\n        edges = []\n\n        ra = Node(self.start, None, 0.0)\n        rb = Node(self.goal, None, 0.0)\n        nodes.extend([ra, rb])\n\n        tree_a, tree_b = [ra], [rb]\n        grid_a, grid_b = {}, {}\n        count_a, count_b = {}, {}\n        bestcost_a, bestcost_b = {}, {}\n\n        self._grid_add(grid_a, count_a, bestcost_a, ra)\n        self._grid_add(grid_b, count_b, bestcost_b, rb)\n\n        c_best = float('inf')\n        sg = self._dist(self.start, self.goal)\n        corridor_w = max(self.step, 0.2 * sg)\n\n        for it in range(self.max_iter):\n            forward = (it % 2 == 0)\n            tree = tree_a if forward else tree_b\n            other_tree = tree_b if forward else tree_a\n            grid = grid_a if forward else grid_b\n            other_grid = grid_b if forward else grid_a\n            counts = count_a if forward else count_b\n            bestcost = bestcost_a if forward else bestcost_b\n            attractor = self.goal if forward else self.start\n\n            target = self._sample_target(attractor, c_best, corridor_w)\n            if target is None:\n                continue\n\n            nearest = self._nearest(grid, tree, target)\n            if nearest is None:\n                continue\n\n            new_pos = self._steer_extended(nearest.position, target)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._point_blocked(new_pos):\n                continue\n            if not self._edge_free(nearest.position, new_pos):\n                continue\n\n            # Parent selection among local LOS neighbors\n            ncount = len(tree)\n            r_near = self._adaptive_radius(ncount)\n            parent = self._choose_parent(grid, new_pos, nearest, r_near)\n            if parent is None:\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            new_cost = parent.cost + self._dist(parent.position, new_pos)\n\n            # Per-cell gate: admit if cell under cap or improves best cost in cell\n            key = self._cell_of(new_pos)\n            cc = counts.get(key, 0)\n            bc = bestcost.get(key, float('inf'))\n            if cc >= self.cell_cap and not (new_cost + 1e-9 < bc):\n                continue\n\n            # Insert after mandatory checks\n            q = Node(new_pos, parent, new_cost)\n            parent.add_child(q)\n            tree.append(q)\n            nodes.append(q)\n            edges.append((parent, q))\n            self._grid_add(grid, counts, bestcost, q)\n\n            # Multi-hop visible ancestor compression (bounded)\n            self._compress_ancestor(q, edges, 3)\n\n            # Lightweight local rewiring\n            self._rewire_lite(grid, q, r_near, edges)\n\n            # Attempt connection\n            other_near = self._nearest(other_grid, other_tree, q.position)\n            if other_near is not None:\n                if self._edge_free(q.position, other_near.position):\n                    path = self._assemble_path(q, other_near, forward)\n                    path = self._refine(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # Greedy short chain from other tree toward q\n                prev = other_near\n                steps = 0\n                while steps < self.connect_attempts:\n                    steps += 1\n                    step_to = self._steer(prev.position, q.position)\n                    if not self._in_bounds(step_to) or self._point_blocked(step_to):\n                        break\n                    if not self._edge_free(prev.position, step_to):\n                        break\n                    # parent choice in other tree for the step\n                    b_parent = self._choose_parent(other_grid, step_to, prev, r_near)\n                    if b_parent is None:\n                        break\n                    if not self._edge_free(b_parent.position, step_to):\n                        break\n                    b_new = Node(step_to, b_parent, b_parent.cost + self._dist(b_parent.position, step_to))\n                    b_parent.add_child(b_new)\n                    other_tree.append(b_new)\n                    nodes.append(b_new)\n                    edges.append((b_parent, b_new))\n                    self._grid_add(other_grid, count_b if forward else count_a, bestcost_b if forward else bestcost_a, b_new)\n                    self._compress_ancestor(b_new, edges, 2)\n                    self._rewire_lite(other_grid, b_new, r_near, edges)\n                    prev = b_new\n                    if self._edge_free(prev.position, q.position):\n                        path = self._assemble_path(q, prev, forward)\n                        L = self._path_len(path)\n                        if L < c_best:\n                            c_best = L\n                        path = self._refine(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n            # Update incumbent bound via provisional visible link if any\n            if other_near is not None and self._edge_free(q.position, other_near.position):\n                tmp = self._assemble_path(q, other_near, forward)\n                L = self._path_len(tmp)\n                if L < c_best:\n                    c_best = L\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed(self):\n        v = 2166136261\n        for t in self.start + self.goal:\n            v ^= int(t * 10007 + 0.5) & 0xffffffff\n            v *= 16777619\n            v &= 0xffffffff\n        v ^= (len(self.obstacles) + 1) * 2654435761 & 0xffffffff\n        self._rng = (v ^ 0x9E3779B9) & 0xffffffff\n        if self._rng == 0:\n            self._rng = 1234567\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= self.step:\n            return tuple(self._clamp_all(b))\n        r = self.step / d\n        return tuple(self._clamp_all(self._lerp(a, b, r)))\n\n    def _steer_extended(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        # If within long step and segment is free, jump to target\n        if d <= self.long_step and self._edge_free(a, b):\n            return tuple(self._clamp_all(b))\n        return self._steer(a, b)\n\n    def _clamp_all(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # Sampling\n    def _sample_target(self, attractor, c_best, corridor_w):\n        for _ in range(24):\n            r = self._rand()\n            if c_best < float('inf') and r < self.informed_bias:\n                p = self._sample_ellipse(self.start, self.goal, c_best * 1.01)\n                if p and not self._point_blocked(p):\n                    return p\n            elif r < self.goal_bias:\n                if not self._point_blocked(attractor):\n                    return attractor\n            elif r < self.goal_bias + self.corridor_bias:\n                t = self._rand()\n                base = self._lerp(self.start, self.goal, t)\n                w = corridor_w\n                if self.is_3d:\n                    q = (self._rand_range(base[0] - w, base[0] + w),\n                         self._rand_range(base[1] - w, base[1] + w),\n                         self._rand_range(base[2] - w, base[2] + w))\n                else:\n                    q = (self._rand_range(base[0] - w, base[0] + w),\n                         self._rand_range(base[1] - w, base[1] + w))\n                q = self._clamp_all(q)\n                if not self._point_blocked(q):\n                    return q\n            else:\n                q = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n                if not self._point_blocked(q):\n                    return q\n        return None\n\n    def _sample_ellipse(self, f1, f2, max_sum):\n        center = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        for _ in range(28):\n            if self.is_3d:\n                p = (center[0] + self._rand_range(-half, half),\n                     center[1] + self._rand_range(-half, half),\n                     center[2] + self._rand_range(-half, half))\n            else:\n                p = (center[0] + self._rand_range(-half, half),\n                     center[1] + self._rand_range(-half, half))\n            if not self._in_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and not self._point_blocked(p):\n                return p\n        return None\n\n    # Node grid\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, counts, bestcost, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n        counts[key] = counts.get(key, 0) + 1\n        bc = bestcost.get(key)\n        if bc is None or node.cost < bc:\n            bestcost[key] = node.cost\n\n    def _ring_cells(self, key, r):\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        yield (key[0] + dx, key[1] + dy, key[2] + dz)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    yield (key[0] + dx, key[1] + dy)\n\n    def _nearest(self, grid, tree, pos):\n        key = self._cell_of(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, self.ring_max + 1):\n            cand = []\n            seen = set()\n            for cell in self._ring_cells(key, r):\n                b = grid.get(cell)\n                if b:\n                    for n in b:\n                        nid = id(n)\n                        if nid not in seen:\n                            seen.add(nid)\n                            cand.append(n)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan if grid sparse\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _neighbors_within(self, grid, pos, radius, cap):\n        key = self._cell_of(pos)\n        r_cells = int(max(1, radius // self.cell) + 1)\n        cand = []\n        seen = set()\n        for cell in self._ring_cells(key, r_cells):\n            b = grid.get(cell)\n            if b:\n                for n in b:\n                    nid = id(n)\n                    if nid in seen:\n                        continue\n                    seen.add(nid)\n                    # filter by metric radius\n                    d2 = 0.0\n                    p = n.position\n                    for i in range(self.dim):\n                        di = p[i] - pos[i]\n                        d2 += di * di\n                    if d2 <= radius * radius:\n                        cand.append(n)\n                        if len(cand) >= cap:\n                            return cand\n        return cand\n\n    def _choose_parent(self, grid, new_pos, fallback_near, radius):\n        best = fallback_near\n        best_cost = fallback_near.cost + self._dist(fallback_near.position, new_pos)\n        neigh = self._neighbors_within(grid, new_pos, radius, 48)\n        for n in neigh:\n            if n is fallback_near:\n                continue\n            if not self._edge_free(n.position, new_pos):\n                continue\n            c = n.cost + self._dist(n.position, new_pos)\n            if c + 1e-12 < best_cost:\n                best_cost = c\n                best = n\n        return best\n\n    def _adaptive_radius(self, ncount):\n        r_min = 1.25 * self.step\n        r_max = self.neighbor_radius_factor * self.step\n        t = ncount / (ncount + 200.0)\n        return r_max * (1.0 - t) + r_min * t\n\n    # Obstacles and collision\n    def _build_obs_index(self):\n        self.obs_cell = max(4.0, self.step * 2.0)\n        self.obs_grid = {}\n        if self.is_3d:\n            for i, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            lst = self.obs_grid.get(k)\n                            if lst is None:\n                                self.obs_grid[k] = [i]\n                            else:\n                                lst.append(i)\n        else:\n            for i, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        lst = self.obs_grid.get(k)\n                        if lst is None:\n                            self.obs_grid[k] = [i]\n                        else:\n                            lst.append(i)\n\n    def _point_blocked(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            lst = self.obs_grid.get((cx, cy, cz))\n            if not lst:\n                return False\n            x, y, z = p\n            for idx in lst:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            lst = self.obs_grid.get((cx, cy))\n            if not lst:\n                return False\n            x, y = p\n            for idx in lst:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        # Collect candidate obstacle cells overlapping the segment AABB\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        lst = self.obs_grid.get((cx, cy, cz))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    lst = self.obs_grid.get((cx, cy))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        # Slab method\n        t0 = 0.0\n        t1 = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tmin = (mn - p) * inv\n                tmax = (mx - p) * inv\n                if tmin > tmax:\n                    tmin, tmax = tmax, tmin\n                if tmin > t0:\n                    t0 = tmin\n                if tmax < t1:\n                    t1 = tmax\n                if t0 > t1:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        t0 = 0.0\n        t1 = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tmin = (mn - p) * inv\n                tmax = (mx - p) * inv\n                if tmin > tmax:\n                    tmin, tmax = tmax, tmin\n                if tmin > t0:\n                    t0 = tmin\n                if tmax < t1:\n                    t1 = tmax\n                if t0 > t1:\n                    return False\n        return True\n\n    # Optimization and rewiring\n    def _compress_ancestor(self, node, edges, hop_limit):\n        hops = 0\n        curp = node.parent\n        while hops < hop_limit and curp is not None and curp.parent is not None:\n            anc = curp.parent\n            if self._edge_free(anc.position, node.position):\n                newc = anc.cost + self._dist(anc.position, node.position)\n                if newc + 1e-9 < node.cost:\n                    self._reparent(node, anc, edges)\n                    curp = anc\n                    hops += 1\n                    continue\n            break\n\n    def _rewire_lite(self, grid, pivot, radius, edges):\n        neigh = self._neighbors_within(grid, pivot.position, radius, 64)\n        changed = 0\n        for nb in neigh:\n            if nb is pivot or nb.parent is pivot:\n                continue\n            # Avoid cycles\n            if self._is_ancestor(nb, pivot):\n                continue\n            if not self._edge_free(pivot.position, nb.position):\n                continue\n            newc = pivot.cost + self._dist(pivot.position, nb.position)\n            if newc + 1e-9 < nb.cost:\n                self._reparent(nb, pivot, edges)\n                changed += 1\n                if changed >= self.rewire_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        old = child.parent\n        if old is new_parent:\n            return\n        if old is not None:\n            old.remove_child(child)\n            self._remove_edge(edges, old, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        # propagate to subtree\n        stack = [child]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if abs(newc - ch.cost) > 1e-12:\n                    ch.cost = newc\n                    stack.append(ch)\n\n    def _remove_edge(self, edges, parent, child):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is parent and e[1] is child:\n                edges.pop(i)\n                return\n\n    # Path ops\n    def _assemble_path(self, a_leaf, b_leaf, a_forward):\n        pa = a_leaf.path_to_root()\n        pb = b_leaf.path_to_root()\n        if a_forward:\n            # pa: start->a, pb: goal->b\n            return pa + list(reversed(pb))\n        else:\n            return pb + list(reversed(pa))\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _refine(self, path):\n        if len(path) < 2:\n            return path[:]\n        p = self._vis_prune(path)\n        p = self._shortcuts(p, self.shortcut_attempts)\n        p = self._elastic(p, self.smooth_passes)\n        return p\n\n    def _vis_prune(self, path):\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], path[j]):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i + 1])\n                i += 1\n        return out\n\n    def _shortcuts(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return list(path)\n        pts = list(path)\n        for _ in range(attempts):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                continue\n            a, b = pts[i], pts[j]\n            if self._edge_free(a, b):\n                pts = pts[:i + 1] + pts[j:]\n        return pts\n\n    def _elastic(self, path, passes):\n        if len(path) < 3 or passes <= 0:\n            return list(path)\n        pts = list(path)\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                if self._point_blocked(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if pts[i] != mid:\n                        pts[i] = mid\n                        moved = True\n            if not moved:\n                break\n        return pts",
          "objective": -35.31946,
          "time_improvement": 61.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1602.0,
          "node_improvement": 84.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013038015365600586,
                    "num_nodes_avg": 73.0,
                    "path_length_avg": 178.87796007012008,
                    "smoothness_avg": 0.06096979653695013,
                    "success_improvement": 0.0,
                    "time_improvement": 47.153091113260764,
                    "node_improvement": 81.6167212289096,
                    "length_improvement": 1.954155582901718,
                    "smoothness_improvement": 854.3097138355535,
                    "objective_score": 19.589969252897028
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.061648321151733396,
                    "num_nodes_avg": 274.0,
                    "path_length_avg": 238.88305888509913,
                    "smoothness_avg": 0.12088627621200972,
                    "success_improvement": 0.0,
                    "time_improvement": 63.14036698293951,
                    "node_improvement": 81.58973325270443,
                    "length_improvement": 20.25395907654673,
                    "smoothness_improvement": 3010.490957800335,
                    "objective_score": 46.146940329811564
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014161467552185059,
                    "num_nodes_avg": 93.0,
                    "path_length_avg": 115.61722002198334,
                    "smoothness_avg": 0.08192767618050695,
                    "success_improvement": 0.0,
                    "time_improvement": 71.94455557408153,
                    "node_improvement": 88.17546090273363,
                    "length_improvement": 23.212547561791958,
                    "smoothness_improvement": 942.1139937440369,
                    "objective_score": 40.22146517801982
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "FIBER-Connect*: Fast Informed Bidirectional RRT*-Connect with Cached Collisions and Local Rewiring \u2014 a bidirectional planner that blends informed sampling, grid-accelerated near/nearest, per-cell cost gating, limited RRT* rewiring, and multi-step connect-extend bridging; it maintains an edge-collision cache and applies visibility pruning plus shortcuts for short, smooth paths with low planning time.",
          "planning_mechanism": "Alternate expanding the two trees; sample with goal/line bias and informed-ellipsoid once a path exists; find nearest via grid rings, steer, and validate; select the lowest-cost parent among radius neighbors (LOS) and insert under per-cell cost gates; locally rewire a few neighbors to reduce path cost; then attempt multi-step connect from the opposite tree toward the new node and bridge on first free LOS; upon success, extract start\u2192meetA + meetB\u2192goal, visibility-prune and shortcut, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.22,\n                 line_bias=0.30,\n                 informed_tries=80,\n                 grid_cell_factor=1.5,\n                 max_per_cell=6,\n                 duplicate_radius_factor=0.5,\n                 rewire_k=10,\n                 rewire_depth=5,\n                 neighbor_radius_factor=3.0,\n                 connect_steps=6,\n                 smoothing_iters=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.informed_tries = informed_tries\n        self.grid_cell_factor = grid_cell_factor\n        self.max_per_cell = max_per_cell\n        self.duplicate_radius_factor = duplicate_radius_factor\n        self.rewire_k = rewire_k\n        self.rewire_depth = rewire_depth\n        self.neighbor_radius_factor = neighbor_radius_factor\n        self.connect_steps = connect_steps\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        self.edge_res = max(0.5, min(1.0, 0.5 * self.step_size))\n        self.cell_size = max(1.0, self.grid_cell_factor * self.step_size)\n        self.min_sep = max(0.3, self.duplicate_radius_factor * self.step_size)\n\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.append(g)\n            return PlannerResult(True, [start, goal], [s, g], [(s, g)])\n\n        s_root = Node(start, None, 0.0)\n        g_root = Node(goal, None, 0.0)\n\n        start_tree = [s_root]\n        goal_tree = [g_root]\n        nodes = [s_root, g_root]\n        edges = []\n\n        grid_s = {}\n        grid_g = {}\n        counts_s = {}\n        counts_g = {}\n        bestcost_s = {}\n        bestcost_g = {}\n\n        self._grid_add(grid_s, counts_s, bestcost_s, s_root)\n        self._grid_add(grid_g, counts_g, bestcost_g, g_root)\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_s if active_start else grid_g\n            grid_b = grid_g if active_start else grid_s\n            counts_a = counts_s if active_start else counts_g\n            counts_b = counts_g if active_start else counts_s\n            bestcost_a = bestcost_s if active_start else bestcost_g\n            bestcost_b = bestcost_g if active_start else bestcost_s\n            root_other = goal if active_start else start\n\n            x_rand = self._sample(obstacles, is_3d, start, goal, best_len, root_other)\n\n            n_near = self._nearest(grid_a, tree_a, x_rand)\n            x_new = self._steer(n_near.position, x_rand)\n            if not self._in_bounds(x_new):\n                continue\n            if self._is_in_obstacle(x_new, obstacles, is_3d):\n                continue\n            if self._edge_blocked(n_near.position, x_new, obstacles, is_3d):\n                continue\n            if self._near_duplicate(grid_a, x_new, self.min_sep):\n                continue\n\n            r_near = max(self.neighbor_radius_factor * self.step_size, self.step_size)\n            neigh = self._near(grid_a, x_new, r_near)\n            parent, new_cost = self._choose_parent(neigh, n_near, x_new, obstacles, is_3d)\n\n            key_new = self._grid_key(x_new)\n            ccount = counts_a.get(key_new, 0)\n            bestc = bestcost_a.get(key_new, float('inf'))\n            if ccount >= self.max_per_cell and not (new_cost + 1e-12 < bestc):\n                continue\n\n            new_node = Node(x_new, None, new_cost)\n            new_node.attach(parent)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(grid_a, counts_a, bestcost_a, new_node)\n\n            if neigh:\n                self._rewire(new_node, neigh, obstacles, is_3d, edges)\n\n            meet_b, bridged = self._connect_toward(tree_b, grid_b, counts_b, bestcost_b, new_node.position, obstacles, is_3d)\n            if meet_b is None:\n                meet_candidate = self._nearest(grid_b, tree_b, new_node.position)\n                if meet_candidate is not None and not self._edge_blocked(new_node.position, meet_candidate.position, obstacles, is_3d):\n                    meet_b = meet_candidate\n                    bridged = True\n\n            if bridged and meet_b is not None:\n                if active_start:\n                    a = new_node\n                    b = meet_b\n                else:\n                    a = meet_b\n                    b = new_node\n                if not self._edge_blocked(a.position, b.position, obstacles, is_3d):\n                    edges.append((a, b))\n                    path = self._extract_path(a, b)\n                    path = self._visibility_prune(path, obstacles, is_3d)\n                    path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _uniform_point(self):\n        if self.dim == 3:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]),\n                    self._uniform(0.0, self.bounds[2]))\n        else:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]))\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos):\n        d = self._dist(from_pos, to_pos)\n        if d <= 1e-12:\n            return self._clamp(from_pos)\n        if d <= self.step_size:\n            return self._clamp(to_pos)\n        r = self.step_size / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _segment_hits(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        if k in self._edge_cache:\n            return self._edge_cache[k]\n        blocked = self._segment_hits(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, bestcost, node):\n        k = self._grid_key(node.position)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n        counts[k] = counts.get(k, 0) + 1\n        prev = bestcost.get(k, None)\n        if prev is None or node.cost < prev:\n            bestcost[k] = node.cost\n\n    def _grid_collect_ring(self, grid, key, r):\n        cand = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        return cand\n\n    def _nearest(self, grid, nodes, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        cand_total = []\n        r = 0\n        max_r = 4\n        while r <= max_r and len(cand_total) < 12:\n            cand_total.extend(self._grid_collect_ring(grid, key, r))\n            r += 1\n        if cand_total:\n            for n in cand_total:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            return best\n        if nodes:\n            trials = min(64, len(nodes))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(nodes)))\n                n = nodes[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _near(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        rng = int(max(1, radius // self.cell_size)) + 1\n        cand = []\n        if self.dim == 3:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        cand = self._grid_collect_ring(grid, key, 1)\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                return True\n        return False\n\n    def _choose_parent(self, neighbors, fallback_near, new_pos, obstacles, is_3d):\n        best_parent = fallback_near\n        best_cost = fallback_near.cost + self._dist(fallback_near.position, new_pos)\n        for n in neighbors:\n            if n is fallback_near:\n                continue\n            if not self._edge_blocked(n.position, new_pos, obstacles, is_3d):\n                c = n.cost + self._dist(n.position, new_pos)\n                if c + 1e-12 < best_cost:\n                    best_cost = c\n                    best_parent = n\n        return best_parent, best_cost\n\n    def _can_rewire(self, node, new_parent):\n        cur = new_parent\n        while cur is not None:\n            if cur is node:\n                return False\n            cur = cur.parent\n        return True\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                edges.pop(i)\n                break\n\n    def _propagate_cost(self, node, edges, depth):\n        if depth <= 0:\n            return\n        for ch in node.children:\n            old = ch.cost\n            ch.cost = node.cost + self._dist(node.position, ch.position)\n            if abs(ch.cost - old) > 1e-12:\n                self._propagate_cost(ch, edges, depth - 1)\n\n    def _rewire(self, new_node, neighbors, obstacles, is_3d, edges):\n        if not neighbors:\n            return\n        cand = []\n        for n in neighbors:\n            if n is new_node or n is new_node.parent:\n                continue\n            cand.append((self._dist(n.position, new_node.position), n))\n        cand.sort(key=lambda t: t[0])\n        limit = min(self.rewire_k, len(cand))\n        for i in range(limit):\n            n = cand[i][1]\n            if not self._can_rewire(n, new_node):\n                continue\n            if self._edge_blocked(new_node.position, n.position, obstacles, is_3d):\n                continue\n            new_cost = new_node.cost + self._dist(new_node.position, n.position)\n            if new_cost + 1e-12 < n.cost:\n                old_parent = n.parent\n                n.attach(new_node)\n                n.cost = new_cost\n                if old_parent is not None:\n                    self._remove_edge(edges, old_parent, n)\n                edges.append((new_node, n))\n                self._propagate_cost(n, edges, self.rewire_depth)\n\n    def _extend_toward(self, tree, grid, counts, bestcost, target_pos, obstacles, is_3d):\n        current = self._nearest(grid, tree, target_pos)\n        last = current\n        for _ in range(self.connect_steps):\n            nxt = self._steer(current.position, target_pos)\n            if not self._in_bounds(nxt):\n                break\n            if self._is_in_obstacle(nxt, obstacles, is_3d):\n                break\n            if self._edge_blocked(current.position, nxt, obstacles, is_3d):\n                break\n            if self._near_duplicate(grid, nxt, self.min_sep):\n                break\n            r_near = max(self.neighbor_radius_factor * self.step_size, self.step_size)\n            neigh = self._near(grid, nxt, r_near)\n            parent, new_cost = self._choose_parent(neigh, current, nxt, obstacles, is_3d)\n            key_new = self._grid_key(nxt)\n            ccount = counts.get(key_new, 0)\n            bestc = bestcost.get(key_new, float('inf'))\n            if ccount >= self.max_per_cell and not (new_cost + 1e-12 < bestc):\n                break\n            newn = Node(nxt, None, new_cost)\n            newn.attach(parent)\n            tree.append(newn)\n            self._grid_add(grid, counts, bestcost, newn)\n            last = newn\n            current = newn\n            if self._dist(nxt, target_pos) <= self.step_size:\n                break\n        return last\n\n    def _connect_toward(self, tree_b, grid_b, counts_b, bestcost_b, a_pos, obstacles, is_3d):\n        last = self._extend_toward(tree_b, grid_b, counts_b, bestcost_b, a_pos, obstacles, is_3d)\n        if last is None:\n            return None, False\n        if not self._edge_blocked(last.position, a_pos, obstacles, is_3d):\n            return last, True\n        return last, False\n\n    def _path_to_root(self, node):\n        seq = []\n        cur = node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _extract_path(self, meet_a, meet_b):\n        pa = self._path_to_root(meet_a)\n        pb = []\n        cur = meet_b\n        while cur is not None:\n            pb.append(cur.position)\n            cur = cur.parent\n        return pa + pb\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        n = len(path)\n        i = 0\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts\n\n    def _sample(self, obstacles, is_3d, start, goal, best_len, attractor):\n        r = self._rand()\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        if best_len < float('inf'):\n            for _ in range(self.informed_tries):\n                p = self._uniform_point()\n                if self._dist(p, start) + self._dist(p, goal) <= best_len and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jit = 0.5 * self.step_size\n            if self.dim == 3:\n                p = (self._clamp((base[0] + self._uniform(-jit, jit), base[1] + self._uniform(-jit, jit), base[2] + self._uniform(-jit, jit))))\n            else:\n                p = (min(max(base[0] + self._uniform(-jit, jit), 0.0), self.bounds[0]),\n                     min(max(base[1] + self._uniform(-jit, jit), 0.0), self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        while True:\n            p = self._uniform_point()\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p",
          "objective": -35.01262,
          "time_improvement": 55.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1329.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016425013542175293,
                    "num_nodes_avg": 47.0,
                    "path_length_avg": 154.62508050902176,
                    "smoothness_avg": 0.04071980109549708,
                    "success_improvement": 0.0,
                    "time_improvement": 33.4245918733191,
                    "node_improvement": 88.16419038025687,
                    "length_improvement": 15.247543181809576,
                    "smoothness_improvement": 537.3533116078908,
                    "objective_score": 21.86267002912093
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04094517230987549,
                    "num_nodes_avg": 124.0,
                    "path_length_avg": 229.46535757937585,
                    "smoothness_avg": 0.08684323820145955,
                    "success_improvement": 0.0,
                    "time_improvement": 75.51881386278623,
                    "node_improvement": 91.66834643553047,
                    "length_improvement": 23.397858845899172,
                    "smoothness_improvement": 2134.539069579714,
                    "objective_score": 47.36705481427394
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022255563735961915,
                    "num_nodes_avg": 88.0,
                    "path_length_avg": 119.3089523489693,
                    "smoothness_avg": 0.11130492356865981,
                    "success_improvement": 0.0,
                    "time_improvement": 55.909249570294364,
                    "node_improvement": 88.81118881118881,
                    "length_improvement": 20.760674731610354,
                    "smoothness_improvement": 1315.790412118499,
                    "objective_score": 35.80813177064702
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "FlashLink-Connect BiRRT: a time-optimized bidirectional planner that couples greedy multi-step extensions, tight obstacle prefiltering, hashed-nearest lookup with compact anchors fallback, and a safe blocked-only LRU edge cache. It prioritizes fast connection attempts with RRT-Connect-style growth while enforcing strict node and edge collision checks, then exits early upon the first feasible bridge and lightly post-processes the path.",
          "planning_mechanism": "Mechanism: Alternate trees expand. Each iteration samples goal/corridor/uniform, finds a near node via grid hashing, and greedily extends multiple step-size hops while validating node and edge collisions at every hop. After growth, the opposite tree performs a greedy connect toward the last new node. A blocked-only memo cache accelerates repeated edge checks without risking false frees. On a successful bridge, extract, visibility-collapse, and lightly shortcut the path, returning immediately.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=12.0,\n        extend_steps=6,\n        connect_steps=64,\n        goal_bias=0.25,\n        corridor_bias=0.5,\n        informed_bias=0.6,\n        nn_cell_factor=0.9,\n        min_sep_ratio=0.3,\n        anchors_stride=20,\n        obs_cell_factor=0.5,\n        edge_cache_max=20000,\n        edge_cache_bin_factor=0.2,\n        smooth_shortcuts=8\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.extend_steps = extend_steps\n        self.connect_steps = connect_steps\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.informed_bias = informed_bias\n        self.nn_cell_factor = nn_cell_factor\n        self.min_sep_ratio = min_sep_ratio\n        self.anchors_stride = max(1, int(anchors_stride))\n        self.obs_cell_factor = obs_cell_factor\n        self.edge_cache_max = edge_cache_max\n        self.edge_cache_bin_factor = edge_cache_bin_factor\n        self.smooth_shortcuts = smooth_shortcuts\n\n        # Runtime\n        self.dim = 2\n        self.bounds = None\n        self.start = None\n        self.goal = None\n        self.obstacles = None\n        self.is_3d = False\n\n        # Spatial hashing for nodes\n        self.nn_cell = 1.0\n        self.min_sep = 1.0\n\n        # Obstacle index\n        self.obs_cell = 4.0\n        self.obs_index = None  # dict[cell_key] -> list of obstacles\n\n        # Blocked-only edge memoization (safe)\n        self.cache_bin = 1.0\n        self.edge_blocked_cache = None  # dict[key] -> True\n        self.edge_cache_order = None  # list of keys for aging\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        self.obstacles = list(map.obstacles)\n        self.is_3d = (self.dim == 3)\n\n        # Derived params\n        self.nn_cell = max(1.0, self.step_size * self.nn_cell_factor)\n        self.min_sep = max(0.5, self.step_size * self.min_sep_ratio)\n        self.obs_cell = max(2.0, self.step_size * self.obs_cell_factor)\n        self.cache_bin = max(0.25, self.step_size * self.edge_cache_bin_factor)\n        self.edge_blocked_cache = {}\n        self.edge_cache_order = []\n\n        # Validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._build_obstacle_index()\n        if self._point_in_obstacle(self.start) or self._point_in_obstacle(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if not self._edge_blocked(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Initialize trees\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        anchors_a, anchors_b = [start_root], [goal_root]\n\n        d_sg = self._dist(self.start, self.goal)\n        base_corridor_w = max(self.step_size, 0.25 * d_sg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            anchors1 = anchors_a if active_start else anchors_b\n            anchors2 = anchors_b if active_start else anchors_a\n            other_root = self.goal if active_start else self.start\n\n            # Sampling\n            r = self._rand()\n            if r < self.goal_bias:\n                x_rand = other_root\n            else:\n                r2 = self._rand()\n                if r2 < self.corridor_bias:\n                    x_rand = self._sample_corridor(base_corridor_w)\n                else:\n                    x_rand = self._sample_free()\n\n            # Greedy extend from active tree\n            new_last = self._extend_toward(tree1, grid1, anchors1, x_rand, self.extend_steps, nodes, edges)\n            if new_last is None:\n                continue\n\n            # Attempt immediate bridge to nearest in the other tree\n            other_near = self._nearest_hashed(grid2, anchors2, new_last.position)\n            if other_near is not None and not self._edge_blocked(new_last.position, other_near.position):\n                path = self._extract_path_bridge(new_last, other_near, active_start)\n                path = self._post_process_path(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Greedy connect from the other tree toward the new point\n            connected_last = self._extend_toward(tree2, grid2, anchors2, new_last.position, self.connect_steps, nodes, edges)\n            if connected_last is not None:\n                if not self._edge_blocked(new_last.position, connected_last.position):\n                    path = self._extract_path_bridge(new_last, connected_last, active_start)\n                    path = self._post_process_path(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry and basic ops\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Obstacle indexing\n    def _obs_cell_key(self, p):\n        return tuple(int(p[i] // self.obs_cell) for i in range(self.dim))\n\n    def _build_obstacle_index(self):\n        self.obs_index = {}\n        if self.is_3d:\n            for obs in self.obstacles:\n                x, y, z, w, h, d = obs\n                gx0 = int(x // self.obs_cell)\n                gy0 = int(y // self.obs_cell)\n                gz0 = int(z // self.obs_cell)\n                gx1 = int((x + w) // self.obs_cell)\n                gy1 = int((y + h) // self.obs_cell)\n                gz1 = int((z + d) // self.obs_cell)\n                for gx in range(gx0, gx1 + 1):\n                    for gy in range(gy0, gy1 + 1):\n                        for gz in range(gz0, gz1 + 1):\n                            key = (gx, gy, gz)\n                            lst = self.obs_index.get(key)\n                            if lst is None:\n                                self.obs_index[key] = [obs]\n                            else:\n                                lst.append(obs)\n        else:\n            for obs in self.obstacles:\n                x, y, w, h = obs\n                gx0 = int(x // self.obs_cell)\n                gy0 = int(y // self.obs_cell)\n                gx1 = int((x + w) // self.obs_cell)\n                gy1 = int((y + h) // self.obs_cell)\n                for gx in range(gx0, gx1 + 1):\n                    for gy in range(gy0, gy1 + 1):\n                        key = (gx, gy)\n                        lst = self.obs_index.get(key)\n                        if lst is None:\n                            self.obs_index[key] = [obs]\n                        else:\n                            lst.append(obs)\n\n    def _point_in_obstacle(self, pos):\n        key = self._obs_cell_key(pos)\n        lst = self.obs_index.get(key)\n        if lst is None:\n            return False\n        if self.is_3d:\n            px, py, pz = pos\n            for x, y, z, w, h, d in lst:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for x, y, w, h in lst:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    # Segment vs AABB (slab method), generic for 2D/3D\n    def _seg_intersects_aabb(self, a, b, mins, maxs):\n        t0 = 0.0\n        t1 = 1.0\n        eps = 1e-12\n        for i in range(self.dim):\n            p0 = a[i]\n            p1 = b[i]\n            d = p1 - p0\n            mn = mins[i]\n            mx = maxs[i]\n            if abs(d) < eps:\n                if p0 < mn or p0 > mx:\n                    return False\n                else:\n                    continue\n            inv = 1.0 / d\n            tmin = (mn - p0) * inv\n            tmax = (mx - p0) * inv\n            if tmin > tmax:\n                tmin, tmax = tmax, tmin\n            if tmax < t0 or tmin > t1:\n                return False\n            if tmin > t0:\n                t0 = tmin\n            if tmax < t1:\n                t1 = tmax\n            if t0 > t1:\n                return False\n        return True\n\n    def _edge_blocked_core(self, a, b):\n        mins = tuple(min(a[i], b[i]) for i in range(self.dim))\n        maxs = tuple(max(a[i], b[i]) for i in range(self.dim))\n        if self.is_3d:\n            gx0 = int(mins[0] // self.obs_cell)\n            gy0 = int(mins[1] // self.obs_cell)\n            gz0 = int(mins[2] // self.obs_cell)\n            gx1 = int(maxs[0] // self.obs_cell)\n            gy1 = int(maxs[1] // self.obs_cell)\n            gz1 = int(maxs[2] // self.obs_cell)\n            uniq = {}\n            for gx in range(gx0, gx1 + 1):\n                for gy in range(gy0, gy1 + 1):\n                    for gz in range(gz0, gz1 + 1):\n                        lst = self.obs_index.get((gx, gy, gz))\n                        if lst:\n                            for o in lst:\n                                uniq[id(o)] = o\n            if not uniq:\n                return False\n            for x, y, z, w, h, d in uniq.values():\n                if self._seg_intersects_aabb(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            gx0 = int(mins[0] // self.obs_cell)\n            gy0 = int(mins[1] // self.obs_cell)\n            gx1 = int(maxs[0] // self.obs_cell)\n            gy1 = int(maxs[1] // self.obs_cell)\n            uniq = {}\n            for gx in range(gx0, gx1 + 1):\n                for gy in range(gy0, gy1 + 1):\n                    lst = self.obs_index.get((gx, gy))\n                    if lst:\n                        for o in lst:\n                            uniq[id(o)] = o\n            if not uniq:\n                return False\n            for x, y, w, h in uniq.values():\n                if self._seg_intersects_aabb(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    # Safe blocked-only cache\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] / self.cache_bin + 0.5) for i in range(self.dim))\n        qb = tuple(int(b[i] / self.cache_bin + 0.5) for i in range(self.dim))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_blocked(self, a, b):\n        key = self._edge_key_q(a, b)\n        if key in self.edge_blocked_cache:\n            return True\n        blocked = self._edge_blocked_core(a, b)\n        if blocked:\n            self.edge_blocked_cache[key] = True\n            self.edge_cache_order.append(key)\n            if len(self.edge_cache_order) > self.edge_cache_max:\n                # Evict oldest 10%\n                k = max(1, self.edge_cache_max // 10)\n                for _ in range(k):\n                    old = self.edge_cache_order.pop(0)\n                    if old in self.edge_blocked_cache:\n                        del self.edge_blocked_cache[old]\n        return blocked\n\n    # Sampling\n    def _sample_free(self):\n        while True:\n            if self.is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._point_in_obstacle(p):\n                return p\n\n    def _sample_corridor(self, width):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.is_3d:\n            for _ in range(12):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp((base[0] + ox, base[1] + oy, base[2] + oz))\n                    if not self._point_in_obstacle(p):\n                        return p\n        else:\n            for _ in range(12):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp((base[0] + ox, base[1] + oy))\n                    if not self._point_in_obstacle(p):\n                        return p\n        return self._sample_free()\n\n    # Node grid hashing\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.nn_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, anchors, pos):\n        k = self._grid_key(pos)\n        best = None\n        bestd = float(\"inf\")\n        for r in range(0, 3):\n            cand = self._grid_ring_collect(grid, k, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback: anchors\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # Last resort: any node in grid\n        for bucket in grid.values():\n            if bucket:\n                return bucket[0]\n        return None\n\n    def _exists_close(self, grid, pos, radius):\n        k = self._grid_key(pos)\n        r_cells = int(radius / max(1e-9, self.nn_cell)) + 1\n        cand = self._grid_ring_collect(grid, k, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # Greedy extension toward a target with strict node+edge checks\n    def _extend_toward(self, tree, grid, anchors, target_pos, max_steps, nodes, edges):\n        nearest = self._nearest_hashed(grid, anchors, target_pos)\n        if nearest is None:\n            return None\n        cur = nearest\n        added = None\n        steps = 0\n        while steps < max_steps:\n            nxt_pos = self._steer(cur.position, target_pos, self.step_size)\n            if not self._in_bounds(nxt_pos):\n                break\n            if self._point_in_obstacle(nxt_pos):\n                break\n            if self._exists_close(grid, nxt_pos, self.min_sep):\n                break\n            if self._edge_blocked(cur.position, nxt_pos):\n                break\n            new_cost = cur.cost + self._dist(cur.position, nxt_pos)\n            new_node = Node(nxt_pos, cur, new_cost)\n            cur.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((cur, new_node))\n            self._grid_add(grid, new_node)\n            if len(tree) % self.anchors_stride == 0:\n                anchors.append(new_node)\n            added = new_node\n            cur = new_node\n            steps += 1\n            # Stop if close enough to target\n            if self._dist(cur.position, target_pos) <= self.step_size * 0.5:\n                break\n        return added\n\n    # Path utilities and smoothing\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path_bridge(self, a_leaf, b_leaf, a_from_start):\n        if a_from_start:\n            left = self._path_to_root(a_leaf)\n            right = []\n            cur = b_leaf\n            while cur is not None:\n                right.append(cur.position)\n                cur = cur.parent\n            return left + right\n        else:\n            left = self._path_to_root(b_leaf)\n            right = []\n            cur = a_leaf\n            while cur is not None:\n                right.append(cur.position)\n                cur = cur.parent\n            return left + right\n\n    def _visibility_collapse(self, path):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        anchor = path[0]\n        i = 1\n        while i < len(path) - 1:\n            if self._edge_blocked(anchor, path[i + 1]):\n                out.append(path[i])\n                anchor = path[i]\n            i += 1\n        out.append(path[-1])\n        return out\n\n    def _shortcut(self, path, attempts):\n        pts = list(path)\n        if len(pts) < 3:\n            return pts\n        tries = 0\n        while tries < attempts and len(pts) >= 3:\n            i = int(self._uniform(0, len(pts) - 2))\n            j = int(self._uniform(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b):\n                pts = pts[:i + 1] + pts[j:]\n            tries += 1\n        return pts\n\n    def _post_process_path(self, path):\n        path = self._visibility_collapse(path)\n        path = self._shortcut(path, self.smooth_shortcuts)\n        return path",
          "objective": -34.70595,
          "time_improvement": 73.0,
          "length_improvement": 4.0,
          "smoothness_improvement": 2047.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011841702461242675,
                    "num_nodes_avg": 80.4,
                    "path_length_avg": 183.39408874434636,
                    "smoothness_avg": 0.08304705292189839,
                    "success_improvement": 0.0,
                    "time_improvement": 52.00209897863236,
                    "node_improvement": 79.75321077814154,
                    "length_improvement": -0.5212061060800529,
                    "smoothness_improvement": 1199.8667177895645,
                    "objective_score": 21.2872396188895
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.015815162658691408,
                    "num_nodes_avg": 114.9,
                    "path_length_avg": 259.7967118682781,
                    "smoothness_avg": 0.12339660675530258,
                    "success_improvement": 0.0,
                    "time_improvement": 90.54408813064502,
                    "node_improvement": 92.27978230195525,
                    "length_improvement": 13.272379744637384,
                    "smoothness_improvement": 3075.0835707972656,
                    "objective_score": 50.50207213996226
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.011373257637023926,
                    "num_nodes_avg": 94.2,
                    "path_length_avg": 151.1663116243918,
                    "smoothness_avg": 0.15450600267509548,
                    "success_improvement": 0.0,
                    "time_improvement": 77.46830994730173,
                    "node_improvement": 88.02288620470438,
                    "length_improvement": -0.39746641469366556,
                    "smoothness_improvement": 1865.304949580401,
                    "objective_score": 32.328537883276326
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SGB-RRT* Connect: A simplified, robust bi-directional RRT with grid-based nearest neighbors, strict collision checks before any add, safe simulated bridge connection, shallow line-of-sight compression, and capped local rewiring. It targets fast planning, strong success rate, and improved path length/smoothness via minimal, general mechanisms.",
          "planning_mechanism": "Alternate expanding start/goal trees: sample with goal bias, steer a fixed step, validate node and edge, insert if collision-free and not a duplicate, compress to grandparent if visible, and locally rewire cheaper neighbors. Attempt a safe simulated greedy connect to the opposite tree; on success, merge the trees and finalize the path with visibility prune and lightweight shortcutting.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=6.0,\n                 goal_bias=0.25,\n                 grid_scale=1.0,\n                 dupe_radius_ratio=0.5,\n                 neighbor_radius_ratio=2.5,\n                 rewire_cap=8,\n                 connect_steps=12,\n                 shortcut_attempts=60):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_scale = float(grid_scale)\n        self.dupe_ratio = float(dupe_radius_ratio)\n        self.neigh_ratio = float(neighbor_radius_ratio)\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_steps = int(max(1, connect_steps))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self._rng = 88172645463393265  # 64-bit LCG seed\n\n    # -------------------- Main planning --------------------\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes, edges = [], []\n\n        # basic validation\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._build_obs_grid()\n\n        if self._point_in_obs(self.start) or self._point_in_obs(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # early straight-line path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        self.cell = max(1.0, self.step * self.grid_scale)\n        self.dupe_radius = max(0.5, self.step * self.dupe_ratio)\n        self.neigh_radius = max(1.2 * self.step, self.step * self.neigh_ratio)\n\n        # initialize two trees and their grids\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        tree_a, tree_b = [a_root], [b_root]\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, a_root)\n        self._grid_add(grid_b, b_root)\n        nodes.extend([a_root, b_root])\n\n        for it in range(self.max_iter):\n            expand_a = (it % 2 == 0)\n            tree = tree_a if expand_a else tree_b\n            other_tree = tree_b if expand_a else tree_a\n            grid = grid_a if expand_a else grid_b\n            other_grid = grid_b if expand_a else grid_a\n            attractor = self.goal if expand_a else self.start\n\n            q_rand = self._sample(attractor)\n            if q_rand is None:\n                continue\n\n            parent = self._nearest(grid, q_rand, tree)\n            if parent is None:\n                continue\n\n            q_new = self._steer(parent.position, q_rand, self.step)\n            if (not self._in_bounds(q_new)) or self._point_in_obs(q_new):\n                continue\n            if self._exists_close(grid, q_new, self.dupe_radius):\n                continue\n            if not self._edge_free(parent.position, q_new):\n                continue\n\n            # insert node with strict checks\n            new_node = Node(q_new, parent, parent.cost + self._dist(parent.position, q_new))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(grid, new_node)\n\n            # shallow LOS compression to grandparent if visible\n            gp = parent.parent\n            if gp is not None:\n                if (not self._point_in_obs(new_node.position)) and (not self._point_in_obs(gp.position)):\n                    if self._edge_free(gp.position, new_node.position):\n                        self._reparent(new_node, gp, edges)\n\n            # local rewiring (capped)\n            if self.rewire_cap > 0:\n                self._rewire_around(grid, new_node, edges, self.neigh_radius, self.rewire_cap)\n\n            # try direct edge to nearest in other tree\n            other_near = self._nearest(other_grid, new_node.position, other_tree)\n            if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                path = self._merge_path(new_node, other_near, expand_a)\n                path = self._finalize_path(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # safe simulated greedy connect to other tree (no partial commits)\n            if other_near is not None:\n                ok, sim_pts, last_pt = self._simulate_connect(other_near.position, new_node.position, self.connect_steps)\n                if ok:\n                    # commit simulated nodes on other tree\n                    prev = other_near\n                    commit_ok = True\n                    for p in sim_pts:\n                        # strict checks before add\n                        if (not self._in_bounds(p)) or self._point_in_obs(p):\n                            commit_ok = False\n                            break\n                        if not self._edge_free(prev.position, p):\n                            commit_ok = False\n                            break\n                        n2 = Node(p, prev, prev.cost + self._dist(prev.position, p))\n                        prev.add_child(n2)\n                        other_tree.append(n2)\n                        nodes.append(n2)\n                        edges.append((prev, n2))\n                        self._grid_add(other_grid, n2)\n                        prev = n2\n                    # final link to new_node must be collision-free\n                    if commit_ok and self._edge_free(prev.position, new_node.position):\n                        path = self._merge_path(new_node, prev, expand_a)\n                        path = self._finalize_path(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # -------------------- RNG --------------------\n    def _rand(self):\n        # 64-bit LCG\n        self._rng = (6364136223846793005 * self._rng + 1) & ((1 << 64) - 1)\n        return (self._rng >> 11) / float(1 << 53)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # -------------------- Geometry --------------------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-16:\n            return tuple(a)\n        if d2 <= step * step:\n            tgt = b\n        else:\n            d = d2 ** 0.5\n            r = step / d\n            tgt = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n        # clamp to bounds\n        return tuple(min(max(tgt[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # -------------------- Grid for nodes --------------------\n    def _grid_key(self, pos):\n        if self.is3:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        else:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos, fallback=None):\n        key = self._grid_key(pos)\n        best, bestd = None, 1e100\n        for r in range(0, 3):\n            cand = self._ring_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd, best = d2, n\n            if best is not None:\n                return best\n        if fallback:\n            for n in fallback:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd, best = d2, n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        cand = self._ring_collect(grid, key, r_cells)\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                out.append(n)\n        return out\n\n    def _exists_close(self, grid, pos, radius):\n        return len(self._neighbors_in_radius(grid, pos, radius)) > 0\n\n    # -------------------- Obstacles & collisions --------------------\n    def _build_obs_grid(self):\n        self.og_cell = max(3.0, self.step * 1.5)\n        self.ogrid = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.og_cell)\n                cy0 = int(max(0.0, y) // self.og_cell)\n                cz0 = int(max(0.0, z) // self.og_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.og_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.og_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.og_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            if k not in self.ogrid:\n                                self.ogrid[k] = [idx]\n                            else:\n                                self.ogrid[k].append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.og_cell)\n                cy0 = int(max(0.0, y) // self.og_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.og_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.og_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        if k not in self.ogrid:\n                            self.ogrid[k] = [idx]\n                        else:\n                            self.ogrid[k].append(idx)\n\n    def _bucket_candidates(self, a, b):\n        if self.is3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.og_cell)\n            cy0 = int(max(0.0, miny) // self.og_cell)\n            cz0 = int(max(0.0, minz) // self.og_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.og_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.og_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.og_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.ogrid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            return cand\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.og_cell)\n            cy0 = int(max(0.0, miny) // self.og_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.og_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.og_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.ogrid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            return cand\n\n    def _point_in_obs(self, p):\n        if self.is3:\n            cx = int(p[0] // self.og_cell)\n            cy = int(p[1] // self.og_cell)\n            cz = int(p[2] // self.og_cell)\n            bucket = self.ogrid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if (ox <= x <= ox + w) and (oy <= y <= oy + h) and (oz <= z <= oz + d):\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.og_cell)\n            cy = int(p[1] // self.og_cell)\n            bucket = self.ogrid.get((cx, cy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if (ox <= x <= ox + w) and (oy <= y <= oy + h):\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        cand = self._bucket_candidates(a, b)\n        if not cand:\n            return False\n        if self.is3:\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        # Liang-Barsky in 2D\n        t0, t1 = 0.0, 1.0\n        dx = p1[0] - p0[0]\n        dy = p1[1] - p0[1]\n        for p, q in [(-dx, p0[0] - bmin[0]),\n                     ( dx, bmax[0] - p0[0]),\n                     (-dy, p0[1] - bmin[1]),\n                     ( dy, bmax[1] - p0[1])]:\n            if abs(p) < 1e-12:\n                if q < 0.0:\n                    return False\n            else:\n                t = q / p\n                if p < 0:\n                    if t > t1: return False\n                    if t > t0: t0 = t\n                else:\n                    if t < t0: return False\n                    if t < t1: t1 = t\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        # Liang-Barsky generalized to 3D\n        t0, t1 = 0.0, 1.0\n        for i in range(3):\n            d = p1[i] - p0[i]\n            for s, bound in [(-1.0, bmin[i]), (1.0, bmax[i])]:\n                p = s * d\n                q = s * (p0[i] - bound)\n                if abs(p) < 1e-12:\n                    if q < 0.0:\n                        return False\n                else:\n                    t = q / p\n                    if p < 0:\n                        if t > t1: return False\n                        if t > t0: t0 = t\n                    else:\n                        if t < t0: return False\n                        if t < t1: t1 = t\n        return True\n\n    # -------------------- Sampling --------------------\n    def _sample(self, attractor):\n        for _ in range(16):\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attractor\n            else:\n                if self.is3:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(p) and (not self._point_in_obs(p)):\n                return p\n        return None\n\n    # -------------------- Reparent/rewire --------------------\n    def _reparent(self, child, new_parent, edges):\n        if child is new_parent or child.parent is new_parent:\n            return\n        if self._point_in_obs(child.position) or self._point_in_obs(new_parent.position):\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            try:\n                old.children.remove(child)\n            except:\n                pass\n            self._remove_edge(edges, old, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        # propagate costs down\n        stack = list(child.children)\n        while stack:\n            n = stack.pop()\n            n.cost = n.parent.cost + self._dist(n.parent.position, n.position)\n            if n.children:\n                for c in n.children:\n                    stack.append(c)\n\n    def _rewire_around(self, grid, node, edges, radius, cap):\n        neigh = self._neighbors_in_radius(grid, node.position, radius)\n        cnt = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            # avoid cycles\n            cur = node\n            cyc = False\n            while cur is not None:\n                if cur is nb:\n                    cyc = True\n                    break\n                cur = cur.parent\n            if cyc:\n                continue\n            if self._point_in_obs(nb.position) or self._point_in_obs(node.position):\n                continue\n            if not self._edge_free(node.position, nb.position):\n                continue\n            ncost = node.cost + self._dist(node.position, nb.position)\n            if ncost + 1e-12 < nb.cost:\n                self._reparent(nb, node, edges)\n                cnt += 1\n                if cnt >= cap:\n                    break\n\n    def _remove_edge(self, edges, parent, child):\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                edges.pop(i)\n                return\n\n    # -------------------- Connect & path utilities --------------------\n    def _simulate_connect(self, start_pos, target_pos, steps):\n        pts = []\n        cur = start_pos\n        for _ in range(steps):\n            nxt = self._steer(cur, target_pos, self.step)\n            if self._point_in_obs(nxt) or (not self._edge_free(cur, nxt)):\n                return False, [], cur\n            pts.append(nxt)\n            cur = nxt\n            if self._edge_free(cur, target_pos):\n                # final segment check later by caller\n                return True, pts, cur\n        # ensure last check to target helps early exit decisions\n        if self._edge_free(cur, target_pos):\n            return True, pts, cur\n        return False, pts, cur\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_path(self, a_end, b_end, a_forward):\n        pa = self._path_to_root(a_end)\n        pb = self._path_to_root(b_end)\n        if a_forward:\n            return pa + pb[::-1]\n        else:\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _vis_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-12 <= bestL:\n                    cur = cand\n                    bestL = L\n            tries += 1\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._vis_prune(path)\n        p1 = self._shortcut(p0, self.shortcut_attempts)\n        p2 = self._vis_prune(p1)\n        return p2",
          "objective": -34.6993,
          "time_improvement": 61.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1729.0,
          "node_improvement": 85.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016133785247802734,
                    "num_nodes_avg": 81.8,
                    "path_length_avg": 171.93416133127897,
                    "smoothness_avg": 0.04800154406384858,
                    "success_improvement": 0.0,
                    "time_improvement": 34.60502575887451,
                    "node_improvement": 79.40065474691514,
                    "length_improvement": 5.7601617031927885,
                    "smoothness_improvement": 651.3284016205362,
                    "objective_score": 17.094246757680708
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.026781320571899414,
                    "num_nodes_avg": 138.6,
                    "path_length_avg": 239.09045233639964,
                    "smoothness_avg": 0.11363406057020475,
                    "success_improvement": 0.0,
                    "time_improvement": 83.98740420582064,
                    "node_improvement": 90.68736141906875,
                    "length_improvement": 20.184725173013117,
                    "smoothness_improvement": 2823.8862257769038,
                    "objective_score": 51.42648749443858
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018439054489135742,
                    "num_nodes_avg": 129.9,
                    "path_length_avg": 130.56172756377174,
                    "smoothness_avg": 0.1425140883988898,
                    "success_improvement": 0.0,
                    "time_improvement": 63.470179444318234,
                    "node_improvement": 83.48378893833438,
                    "length_improvement": 13.287117233512797,
                    "smoothness_improvement": 1712.7686851381018,
                    "objective_score": 35.577167599093656
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "GLIDE-Connect: a simplified, robust BiRRT-Connect with grid-based proximity, duplicate suppression, and greedy opposite-tree connection. It prioritizes generalization by using uniform goal-biased sampling, lightweight spatial hashing, and strict node+edge validation before commitment. After a first solution, it applies fast line-of-sight collapse, randomized shortcuts, and collision-aware corner rounding for shorter, smoother paths.",
          "planning_mechanism": "Alternate growing start/goal trees. For a sampled target, extend the active tree by several validated steps toward it, inserting nodes only if the point is free and the incoming edge is collision-free. After each successful step, greedily extend the opposite tree toward the new node (multi-step connect); on reach or direct visibility, assemble and smooth the path. Uniform sampling with goal bias and a dupe-radius gate maintains coverage and avoids near-duplicates; a coarse obstacle grid accelerates collision checks.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            i = 0\n            while i < len(self.parent.children):\n                if self.parent.children[i] is self:\n                    self.parent.children.pop(i)\n                    break\n                i += 1\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=6.0,\n                 goal_bias=0.28,\n                 cell_factor=1.6,\n                 dupe_radius_ratio=0.4,\n                 connect_limit=16,\n                 smooth_shortcuts=80,\n                 smooth_rounds=6):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.cell_factor = float(cell_factor)\n        self.dupe_ratio = float(dupe_radius_ratio)\n        self.connect_limit = int(connect_limit)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self.smooth_rounds = int(max(0, smooth_rounds))\n        self._rng = 123456789\n\n    def plan(self, map):\n        # Scene\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n\n        # Basic checks\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        # Build obstacle grid early to use for point checks\n        self._build_obs_grid()\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Parameters derived\n        self.cell = max(1.0, self.step * self.cell_factor)\n        self.dupe_radius = max(0.4, self.dupe_ratio * self.step)\n\n        # Data holders\n        self._nodes = []\n        self._edges = []\n\n        # Trees and grids\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        self._nodes.extend([a_root, b_root])\n        A, B = [a_root], [b_root]\n        GA, GB = {}, {}\n        self._grid_add(GA, a_root)\n        self._grid_add(GB, b_root)\n\n        # Main loop\n        for it in range(self.max_iter):\n            growA = (it % 2 == 0)\n            T = A if growA else B\n            O = B if growA else A\n            G = GA if growA else GB\n            GO = GB if growA else GA\n            attractor = self.goal if growA else self.start\n\n            target = self._sample_target(attractor)\n            if target is None:\n                continue\n\n            qnear = self._nearest(G, target)\n            if qnear is None:\n                qnear = T[-1]\n\n            new_end = self._extend(T, G, qnear, target, self.connect_limit)\n            if new_end is None:\n                continue\n\n            # Try to greedily connect the opposite tree toward the new node\n            other_near = self._nearest(GO, new_end.position)\n            if other_near is None:\n                other_near = O[-1]\n\n            # Direct bridge\n            if self._edge_free(new_end.position, other_near.position):\n                path = self._assemble_path(new_end, other_near, growA)\n                path = self._postprocess(path)\n                return PlannerResult(True, path, self._nodes, self._edges)\n\n            # Greedy connect\n            reach_end = self._extend(O, GO, other_near, new_end.position, self.connect_limit)\n            if reach_end is not None:\n                # If reached exactly or last hop can see the new node, accept\n                if self._same_pos(reach_end.position, new_end.position) or self._edge_free(reach_end.position, new_end.position):\n                    path = self._assemble_path(new_end, reach_end, growA)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, self._nodes, self._edges)\n\n        return PlannerResult(False, [], self._nodes, self._edges)\n\n    # RNG\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry and bounds\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _same_pos(self, a, b, eps=1e-9):\n        for i in range(self.dims):\n            if abs(a[i] - b[i]) > eps:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Obstacle grid\n    def _build_obs_grid(self):\n        self.obs_cell = max(4.0, self.step * 2.0)\n        self._ogrid = {}\n        if self.is3d:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self._ogrid.get(k)\n                            if b is None:\n                                self._ogrid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self._ogrid.get(k)\n                        if b is None:\n                            self._ogrid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _cell_candidates(self, a, b):\n        # Collect obstacle indices in bounding box of the segment\n        if self.is3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        lst = self._ogrid.get((cx, cy, cz))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            return cand\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    lst = self._ogrid.get((cx, cy))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            return cand\n\n    def _point_blocked(self, p):\n        if self.is3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self._ogrid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            x0, y0, z0 = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= x0 <= x + w and y <= y0 <= y + h and z <= z0 <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self._ogrid.get((cx, cy))\n            if not bucket:\n                return False\n            x0, y0 = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= x0 <= x + w and y <= y0 <= y + h:\n                    return True\n            return False\n\n    def _seg_aabb_hit(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(self.dims):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _edge_free(self, a, b):\n        cand = self._cell_candidates(a, b)\n        if not cand:\n            return True\n        if self.is3d:\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_hit(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return False\n            return True\n        else:\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_hit(a, b, (x, y), (x + w, y + h)):\n                    return False\n            return True\n\n    # Node grid for proximity queries\n    def _cell_key(self, pos):\n        if self.is3d:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos):\n        k = self._cell_key(pos)\n        best = None\n        bd = 1e100\n        for r in range(0, 3):\n            cand = self._grid_ring(grid, k, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bd:\n                        bd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback scan\n        for b in grid.values():\n            for n in b:\n                d = self._dist(n.position, pos)\n                if d < bd:\n                    bd = d\n                    best = n\n        return best\n\n    def _has_close(self, grid, pos, radius):\n        k = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell) + 1)\n        lst = self._grid_ring(grid, k, rc)\n        r2 = radius * radius\n        for n in lst:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # Extension (RRT-Connect style, limited steps). Ensures node+edge checks before adding.\n    def _extend(self, T, G, from_node, toward_pos, max_steps):\n        cur = from_node\n        advanced = False\n        steps = 0\n        while steps < max_steps:\n            nxt = self._steer(cur.position, toward_pos, self.step)\n            if self._same_pos(nxt, cur.position):\n                break\n            if not self._in_bounds(nxt):\n                break\n            if self._point_blocked(nxt):\n                break\n            if self._has_close(G, nxt, self.dupe_radius):\n                break\n            if not self._edge_free(cur.position, nxt):\n                break\n            d = self._dist(cur.position, nxt)\n            q = Node(nxt, cur, cur.cost + d)\n            q.attach(cur)\n            T.append(q)\n            self._nodes.append(q)\n            self._edges.append((cur, q))\n            self._grid_add(G, q)\n            cur = q\n            advanced = True\n            steps += 1\n            # If we reached the target exactly, stop\n            if self._same_pos(cur.position, toward_pos):\n                break\n        return cur if advanced else None\n\n    # Sampling\n    def _sample_target(self, attractor):\n        if self._rand() < self.goal_bias:\n            return attractor\n        return self._random_free()\n\n    def _random_free(self):\n        for _ in range(64):\n            if self.is3d:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n            else:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n            if not self._point_blocked(p):\n                return p\n        # As a last resort, return center clamped\n        if self.is3d:\n            return (min(max(self.bounds[0] * 0.5, 0.0), self.bounds[0]),\n                    min(max(self.bounds[1] * 0.5, 0.0), self.bounds[1]),\n                    min(max(self.bounds[2] * 0.5, 0.0), self.bounds[2]))\n        else:\n            return (min(max(self.bounds[0] * 0.5, 0.0), self.bounds[0]),\n                    min(max(self.bounds[1] * 0.5, 0.0), self.bounds[1]))\n\n    # Path utilities\n    def _to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _assemble_path(self, a_end, b_end, a_side_grew):\n        if a_side_grew:\n            pa = self._to_root(a_end)\n            pb = self._to_root(b_end)\n            if pa and pb and pa[0] == pb[-1]:\n                pb = pb[:-1]\n            return pa + pb[::-1]\n        else:\n            pa = self._to_root(a_end)\n            pb = self._to_root(b_end)\n            if pa and pb and pb[0] == pa[-1]:\n                pa = pa[:-1]\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    # Smoothing\n    def _los_collapse(self, path, rounds=3):\n        if len(path) < 3:\n            return path[:]\n        cur = path[:]\n        for _ in range(rounds):\n            out = [cur[0]]\n            anchor_idx = 0\n            i = 1\n            while i < len(cur) - 1:\n                if self._edge_free(cur[anchor_idx], cur[i + 1]):\n                    i += 1\n                    continue\n                out.append(cur[i])\n                anchor_idx = len(out) - 1\n                i += 1\n            out.append(cur[-1])\n            if len(out) == len(cur):\n                break\n            cur = out\n        return cur\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = path[:]\n        best = self._path_len(pts)\n        tries = 0\n        n = len(pts)\n        while tries < attempts and len(pts) >= 3:\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j >= n:\n                tries += 1\n                continue\n            a, b = pts[i], pts[j]\n            if self._edge_free(a, b):\n                cand = pts[:i + 1] + pts[j:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    pts = cand\n                    best = L\n                    n = len(pts)\n            tries += 1\n        return pts\n\n    def _round_corners(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return path[:]\n        pts = list(path)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dims))\n                if not self._in_bounds(mid):\n                    continue\n                if self._point_blocked(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if pts[i] != mid:\n                        pts[i] = mid\n                        moved = True\n            if not moved:\n                break\n        return pts\n\n    def _postprocess(self, path):\n        p = self._los_collapse(path, rounds=3)\n        p = self._shortcut(p, self.smooth_shortcuts)\n        p = self._round_corners(p, self.smooth_rounds)\n        return p",
          "objective": -34.29181,
          "time_improvement": 72.0,
          "length_improvement": 5.0,
          "smoothness_improvement": 1957.0,
          "node_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008447527885437012,
                    "num_nodes_avg": 92.2,
                    "path_length_avg": 191.3731638691875,
                    "smoothness_avg": 0.048336809326901084,
                    "success_improvement": 0.0,
                    "time_improvement": 65.75968627420662,
                    "node_improvement": 76.78166708637623,
                    "length_improvement": -4.894663618541875,
                    "smoothness_improvement": 656.5760310274793,
                    "objective_score": 20.07398786627425
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.011332845687866211,
                    "num_nodes_avg": 132.2,
                    "path_length_avg": 259.23683578863955,
                    "smoothness_avg": 0.13710610795003553,
                    "success_improvement": 0.0,
                    "time_improvement": 93.22407284919258,
                    "node_improvement": 91.11738224820265,
                    "length_improvement": 13.45928249516016,
                    "smoothness_improvement": 3427.838911092322,
                    "objective_score": 53.18198590731548
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022087860107421874,
                    "num_nodes_avg": 237.8,
                    "path_length_avg": 141.0070779227184,
                    "smoothness_avg": 0.14838337221438208,
                    "success_improvement": 0.0,
                    "time_improvement": 56.24148913608739,
                    "node_improvement": 69.76478067387158,
                    "length_improvement": 6.349812879234684,
                    "smoothness_improvement": 1787.4255420456973,
                    "objective_score": 29.619462178595512
               }
          ],
          "success_rate": 1.0
     }
]