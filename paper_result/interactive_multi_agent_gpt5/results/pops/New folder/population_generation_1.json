[
     {
          "operator": "time_expert",
          "algorithm_description": "HASTE-BiRRT: Hashed, Anytime, Saturation\u2011Throttled, Efficient BiRRT-Connect. It accelerates bidirectional RRT with cached collision tests, hashed nearest search with leader fallbacks, per-cell growth throttling, and duplicate-suppressed commit-only connections. A light visibility prune plus brief shortcutting refines the path while keeping postprocessing costs low.",
          "planning_mechanism": "Alternate expanding start/goal trees with goal-biased sampling; find nearest via grid rings, else leader-guided buckets; steer one step and validate with cached edge checks; suppress inserts in saturated/duplicate cells; attempt a single, commit-only direct bridge to the opposite tree, skipping known-blocked cell pairs; upon success, extract start-to-goal path, visibility-prune, then run a few shortcuts; terminate on success or iteration cap.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=7.0,\n                 goal_bias=0.25,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=40,\n                 max_per_cell=6,\n                 search_r_max=2,\n                 leader_stride=25):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n        self.max_per_cell = max_per_cell\n        self.search_r_max = search_r_max\n        self.leader_stride = leader_stride\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        # Caches\n        self._edge_blocked_cache = set()   # quantized blocked segments (safe to reuse only for blocked)\n        self._edge_exact_cache = {}        # exact endpoint pairs -> bool\n        self._connect_blocked_cells = set()  # (cellA, cellB) pairs known to fail direct connect\n\n    # ------------- Public API -------------\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Parameters derived\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size * 2.5)\n        self.edge_res = max(0.5, self.collision_step)\n\n        # Reset caches\n        self._edge_blocked_cache = set()\n        self._edge_exact_cache = {}\n        self._connect_blocked_cells = set()\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            path = [start, goal]\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Initialize trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Grids and counts\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n        self._grid_add(grid_start, counts_start, start_root)\n        self._grid_add(grid_goal, counts_goal, goal_root)\n\n        # Leaders\n        leaders_start = [start_root]\n        leaders_goal = [goal_root]\n        inserted_since_leader_start = 0\n        inserted_since_leader_goal = 0\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            grid_a = grid_start if active_start else grid_goal\n            counts_a = counts_start if active_start else counts_goal\n            leaders_a = leaders_start if active_start else leaders_goal\n\n            tree_b = goal_tree if active_start else start_tree\n            grid_b = grid_goal if active_start else grid_start\n            counts_b = counts_goal if active_start else counts_start\n            leaders_b = leaders_goal if active_start else leaders_start\n\n            root_other = goal if active_start else start\n\n            # Sample with goal/opposite-root bias\n            if self._rand() < self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest lookup\n            nearest = self._nearest_hashed(grid_a, leaders_a, tree_a, x_rand)\n            if nearest is None:\n                continue\n\n            # Steer\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Per-cell throttling and duplicate suppression\n            key_new = self._grid_key(new_pos)\n            if self._cell_count(counts_a, key_new) >= self.max_per_cell:\n                continue\n            if self._near_duplicate(grid_a, new_pos, dup_radius=0.7 * self.step_size):\n                continue\n\n            # Insert node and edge\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, counts_a, new_node)\n\n            # Leader sampling\n            if active_start:\n                inserted_since_leader_start += 1\n                if inserted_since_leader_start >= self.leader_stride:\n                    leaders_start.append(new_node)\n                    inserted_since_leader_start = 0\n            else:\n                inserted_since_leader_goal += 1\n                if inserted_since_leader_goal >= self.leader_stride:\n                    leaders_goal.append(new_node)\n                    inserted_since_leader_goal = 0\n\n            # Try commit-only direct connection to the other tree (with cell-pair de-dup)\n            other_near = self._nearest_hashed(grid_b, leaders_b, tree_b, new_node.position)\n            if other_near is not None:\n                pair_key = (self._grid_key(new_node.position), self._grid_key(other_near.position))\n                if pair_key not in self._connect_blocked_cells:\n                    if not self._edge_blocked(new_node.position, other_near.position, obstacles, is_3d):\n                        path = self._extract_path(new_node, other_near, a_is_start_tree=active_start)\n                        path = self._visibility_prune(path, obstacles, is_3d)\n                        path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                        return PlannerResult(True, path, start_tree + goal_tree, edges)\n                    else:\n                        # cache blocked cell pair to avoid repeating futile checks\n                        self._connect_blocked_cells.add(pair_key)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ------------- Random -------------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------- Geometry -------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ------------- Collision & caches -------------\n    def _quant(self, p, q=1.5):\n        # Quantize for blocked-segment cache; coarse to avoid false frees; safe for blocked reuse only\n        if self.dim == 3:\n            return (int(p[0] // q), int(p[1] // q), int(p[2] // q))\n        else:\n            return (int(p[0] // q), int(p[1] // q))\n\n    def _seg_key_exact(self, a, b):\n        # Canonicalize order for undirected segment\n        if a <= b:\n            return (a, b)\n        else:\n            return (b, a)\n\n    def _seg_key_quant_blocked(self, a, b):\n        qa = self._quant(a)\n        qb = self._quant(b)\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        # Exact cache check\n        k_exact = self._seg_key_exact(a, b)\n        cached = self._edge_exact_cache.get(k_exact)\n        if cached is not None:\n            return cached\n        # Blocked quantized cache\n        kq = self._seg_key_quant_blocked(a, b)\n        if kq in self._edge_blocked_cache:\n            self._edge_exact_cache[k_exact] = True\n            return True\n        # Compute\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res)\n        # Update caches\n        self._edge_exact_cache[k_exact] = blocked\n        if blocked:\n            self._edge_blocked_cache.add(kq)\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ------------- Sampling -------------\n    def _sample_free(self, obstacles, is_3d):\n        # Rejection sampling within bounds until a free point is found\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ------------- Grid / NN -------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n\n    def _cell_count(self, counts, key):\n        return counts.get(key, 0)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, leaders, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Local rings\n        for r in range(0, self.search_r_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Leader fallback\n        if leaders:\n            lead_best = None\n            lead_bestd = float('inf')\n            for n in leaders:\n                d = self._dist(n.position, pos)\n                if d < lead_bestd:\n                    lead_bestd = d\n                    lead_best = n\n            if lead_best is not None:\n                # Search around leader cell for neighbors\n                lk = self._grid_key(lead_best.position)\n                for r in range(0, min(2, self.search_r_max) + 1):\n                    cand = self._grid_ring_collect(grid, lk, r)\n                    for n in cand:\n                        d = self._dist(n.position, pos)\n                        if d < bestd:\n                            bestd = d\n                            best = n\n                if best is not None:\n                    return best\n        # Sparse random subset fallback (avoid full scan)\n        if tree:\n            trials = min(64, len(tree))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(tree)))\n                n = tree[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            if best is not None:\n                return best\n        return None\n\n    def _near_duplicate(self, grid, pos, dup_radius):\n        key = self._grid_key(pos)\n        r = 1\n        cand = self._grid_ring_collect(grid, key, r)\n        rr = dup_radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # ------------- Path -------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            # start-tree path to meet, then meet->goal via reversed goal-tree path\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -35.78786,
          "time_improvement": 66.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1772.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016536712646484375,
                    "num_nodes_avg": 67.3,
                    "path_length_avg": 176.25078259592178,
                    "smoothness_avg": 0.05067539409595988,
                    "success_improvement": 0.0,
                    "time_improvement": 35.1470831615236,
                    "node_improvement": 83.05212792747419,
                    "length_improvement": 3.3941531868009323,
                    "smoothness_improvement": 693.1799609813568,
                    "objective_score": 16.046516665444422
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023010659217834472,
                    "num_nodes_avg": 105.2,
                    "path_length_avg": 247.25890321415372,
                    "smoothness_avg": 0.1191098532602342,
                    "success_improvement": 0.0,
                    "time_improvement": 85.63605318102866,
                    "node_improvement": 92.93153262111133,
                    "length_improvement": 17.45786115419664,
                    "smoothness_improvement": 2964.7823157454163,
                    "objective_score": 50.989444225553655
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.011754655838012695,
                    "num_nodes_avg": 94.4,
                    "path_length_avg": 127.41557160345823,
                    "smoothness_avg": 0.13822063405561777,
                    "success_improvement": 0.0,
                    "time_improvement": 76.0361625858193,
                    "node_improvement": 87.99745708836618,
                    "length_improvement": 15.376644218505373,
                    "smoothness_improvement": 1658.156262801516,
                    "objective_score": 40.327616620856595
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Adaptive Goal-Biased Grid BiRRT (AG-GBiRRT): a simplified, robust bidirectional RRT with commit-only connection, grid-accelerated nearest search, and light post-connection shortcut smoothing. It alternates growing two trees, uses uniform-with-goal-bias sampling, single-step steering with strict node/edge collision checks, and an early straight-line test. Upon any successful bridge between trees, it extracts the path and performs a few inexpensive shortcuts for smoothness, returning quickly without extra rewiring or bloat.",
          "planning_mechanism": "Mechanism: alternate start/goal tree expansion; sample (goal-biased), find nearest via grid, steer one step, validate node and edge, add node and edge, attempt a direct, collision-free bridge to the opposite tree (commit-only); on success, extract [start\u2192\u2026\u2192meetA, meetB\u2192\u2026\u2192goal] and run brief shortcut smoothing; terminate on success or iteration budget.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size * 2.0)\n        self.edge_res = max(0.5, self.collision_step)\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_res):\n            path = [start, goal]\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Trees and grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = goal if active_start else start\n\n            # Sample with goal/opposite-root bias\n            if self._rand() < self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest and steer\n            nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                continue\n\n            # Insert node (both node and edge validated)\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, new_node)\n\n            # Try commit-only direct connection to the other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None:\n                if not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                    path = self._extract_path(new_node, other_near)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- Random ----------\n    def _rand(self):\n        try:\n            return self._lcg_next()\n        except:\n            return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Sampling ----------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ---------- Grid nearest ----------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    # ---------- Path ----------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # path_a ends at meet_a; we then go straight to meet_b and up to other root\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            # pick two indices i < j with at least one point between\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -32.96764,
          "time_improvement": 69.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1142.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01299290657043457,
                    "num_nodes_avg": 78.8,
                    "path_length_avg": 167.86786188508313,
                    "smoothness_avg": 0.03825680999831742,
                    "success_improvement": 0.0,
                    "time_improvement": 49.04501835909778,
                    "node_improvement": 80.15613195668597,
                    "length_improvement": 7.988964864290817,
                    "smoothness_improvement": 498.8021524662562,
                    "objective_score": 22.000895188635106
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02625594139099121,
                    "num_nodes_avg": 208.9,
                    "path_length_avg": 244.3021244779086,
                    "smoothness_avg": 0.07331771296729457,
                    "success_improvement": 0.0,
                    "time_improvement": 83.61025026480232,
                    "node_improvement": 85.96385137405093,
                    "length_improvement": 18.444919002512343,
                    "smoothness_improvement": 1786.5175632625994,
                    "objective_score": 45.082614297261095
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01305999755859375,
                    "num_nodes_avg": 163.0,
                    "path_length_avg": 140.27860161008172,
                    "smoothness_avg": 0.09759083301298958,
                    "success_improvement": 0.0,
                    "time_improvement": 73.37500455677744,
                    "node_improvement": 79.27527018436109,
                    "length_improvement": 6.833632159773637,
                    "smoothness_improvement": 1141.348192519241,
                    "objective_score": 31.819421625493614
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "Beam-guided BiRRT with ancestor line-of-sight compression and spatial hashing (BG-Connect-LOS). The planner alternates tree growth from start and goal using a small beam of guided samples, accelerates nearest lookups with a grid hash, suppresses near-duplicate nodes, and selects a parent among recent ancestors that maintains direct line-of-sight to the new point to compress chains. A short, capped greedy connect links the two trees. Upon success, a bounded shortcut pass refines the path. This reduces expansions and collision checks while improving path quality and smoothness.",
          "planning_mechanism": "At each iteration, pick the active tree and generate a small beam of guided samples biased toward the opposite root. For each sample: find a nearby node via spatial hashing, steer by a fixed step, enforce node and edge collision checks, reject near-duplicates, and pick an ancestor parent with clear line-of-sight to minimize added cost. Insert the node and attempt a capped greedy connect from the opposite tree toward it; if the two trees meet, extract and lightly shortcut the path. Alternate trees and stop early on success.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        beam_width=3,\n        goal_bias=0.15,\n        connect_steps_limit=20,\n        min_separation_factor=0.6,\n        grid_cell_factor=1.0,\n        los_lookback_depth=8,\n        shortcut_attempts=40\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.connect_steps_limit = connect_steps_limit\n        self.min_separation_factor = min_separation_factor\n        self.grid_cell_factor = grid_cell_factor\n        self.los_lookback_depth = los_lookback_depth\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dims = len(bounds)\n        is_3d = dims == 3\n\n        # Parameters derived from step_size\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root = Node(goal_position, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root, is_3d)\n        self._grid_insert(grid_b, goal_root, is_3d)\n\n        success_state = False\n        extracted_path = []\n\n        for _ in range(self.max_iter):\n            # Alternate trees by swapping references each loop\n            for active_tree, active_grid, other_tree, other_grid, attractor in [\n                (tree_a, grid_a, tree_b, grid_b, goal_position),\n                (tree_b, grid_b, tree_a, grid_a, start_position),\n            ]:\n                made_progress = False\n\n                for _beam in range(self.beam_width):\n                    sample = self._sample_guided(bounds, obstacles, is_3d, attractor)\n\n                    nearest = self._nearest_by_grid(active_tree, active_grid, sample, is_3d)\n                    if nearest is None:\n                        continue\n\n                    new_pos = self._steer(nearest.position, sample)\n                    if not self._within_bounds(new_pos, bounds):\n                        continue\n                    if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                        continue\n                    if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                        continue\n                    if self._has_near_duplicate(active_grid, new_pos, self.min_separation, is_3d):\n                        continue\n\n                    # Choose parent among LOS-capable ancestors to compress path\n                    parent = self._choose_ancestor_parent(nearest, new_pos, obstacles, is_3d)\n                    new_cost = parent.cost + self._distance(parent.position, new_pos)\n\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node, is_3d)\n                    made_progress = True\n\n                    # Try capped greedy connect from the opposite tree toward new_node\n                    connect_node = self._attempt_connect(\n                        other_tree, other_grid, new_node.position, obstacles, is_3d, nodes, edges, bounds\n                    )\n                    if connect_node is not None:\n                        # Trees meet at new_node.position; extract path\n                        path_a = self._path_from_root(new_node)\n                        path_b = self._path_from_root(connect_node)\n                        # Remove duplicate joint if equal\n                        if path_a and path_b and path_a[-1] == path_b[-1]:\n                            path_b = path_b[:-1]\n                        raw_path = path_a + path_b[::-1]\n                        # Light shortcut smoothing\n                        smoothed = self._shortcut_path(raw_path, obstacles, is_3d, attempts=self.shortcut_attempts)\n                        extracted_path = smoothed if smoothed else raw_path\n                        success_state = True\n                        return PlannerResult(True, extracted_path, nodes, edges)\n\n                # If neither beam sample made progress for this tree, continue with the other\n                if not made_progress:\n                    continue\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # --------- Core Geometry / Utilities ---------\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _within_bounds(self, pos, bounds):\n        for i in range(len(bounds)):\n            if pos[i] < 0.0 or pos[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= 1e-9:\n            return from_pos\n        if dist <= self.step_size:\n            return to_pos\n        r = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * r for d in range(len(from_pos)))\n\n    def _sample_guided(self, bounds, obstacles, is_3d, target):\n        # Mild guidance: with some probability sample exactly target, else blend toward target\n        while True:\n            if random.random() < self.goal_bias:\n                p = target\n            else:\n                rand = tuple(random.uniform(0.0, bounds[d]) for d in range(len(bounds)))\n                alpha = 0.2\n                p = tuple(alpha * target[d] + (1.0 - alpha) * rand[d] for d in range(len(bounds)))\n            if self._within_bounds(p, bounds) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _path_from_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\n\n    # --------- Spatial Hash (Grid) ---------\n\n    def _cell_of(self, pos):\n        # integer grid cell indices\n        if len(pos) == 3:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        else:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node, is_3d):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _has_near_duplicate(self, grid, pos, radius, is_3d):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if bucket:\n                            for n in bucket:\n                                if self._distance(n.position, pos) <= radius:\n                                    return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if bucket:\n                        for n in bucket:\n                            if self._distance(n.position, pos) <= radius:\n                                return True\n        return False\n\n    def _nearest_by_grid(self, tree, grid, pos, is_3d, ring_limit=3):\n        # Search neighborhood rings; fallback to linear scan if not found\n        cell = self._cell_of(pos)\n        best = None\n        best_d = float(\"inf\")\n\n        if is_3d:\n            for ring in range(0, ring_limit + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if bucket:\n                                for n in bucket:\n                                    d = self._distance(n.position, pos)\n                                    if d < best_d:\n                                        best_d = d\n                                        best = n\n                                        found = True\n                if found and best is not None:\n                    return best\n        else:\n            for ring in range(0, ring_limit + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if bucket:\n                            for n in bucket:\n                                d = self._distance(n.position, pos)\n                                if d < best_d:\n                                    best_d = d\n                                    best = n\n                                    found = True\n                if found and best is not None:\n                    return best\n\n        # Fallback\n        if not tree:\n            return None\n        return min(tree, key=lambda n: self._distance(n.position, pos))\n\n    # --------- Parent selection via LOS to ancestors ---------\n\n    def _choose_ancestor_parent(self, nearest, new_pos, obstacles, is_3d):\n        best_parent = nearest\n        best_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        steps = 0\n        cur = nearest\n        while cur is not None and steps < self.los_lookback_depth:\n            if not self._is_edge_in_obstacle(cur.position, new_pos, obstacles, is_3d):\n                cand_cost = cur.cost + self._distance(cur.position, new_pos)\n                if cand_cost < best_cost:\n                    best_cost = cand_cost\n                    best_parent = cur\n            cur = cur.parent\n            steps += 1\n        return best_parent\n\n    # --------- Connect attempt ---------\n\n    def _attempt_connect(self, tree, grid, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest_by_grid(tree, grid, target_pos, is_3d)\n        if nearest is None:\n            return None\n\n        current = nearest\n        for _ in range(self.connect_steps_limit):\n            step_pos = self._steer(current.position, target_pos)\n            if not self._within_bounds(step_pos, bounds):\n                return None\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                return None\n\n            # If close enough to target and direct edge exists, finalize with exact target node\n            if self._distance(step_pos, target_pos) <= 1e-6 or (\n                self._distance(step_pos, target_pos) <= self.step_size and\n                not self._is_edge_in_obstacle(step_pos, target_pos, obstacles, is_3d) and\n                not self._is_in_obstacle(target_pos, obstacles, is_3d)\n            ):\n                # Add intermediate step node if it is not exactly current\n                if self._distance(current.position, step_pos) > 1e-9:\n                    if not self._has_near_duplicate(grid, step_pos, self.min_separation, is_3d):\n                        new_node = Node(step_pos, parent=current, cost=current.cost + self._distance(current.position, step_pos))\n                        current.add_child(new_node)\n                        tree.append(new_node)\n                        nodes.append(new_node)\n                        edges.append((current, new_node))\n                        self._grid_insert(grid, new_node, is_3d)\n                        current = new_node\n                    else:\n                        # If duplicate exists, try using current as is\n                        pass\n                # Add final node at the exact target position to guarantee path merge\n                final_node = Node(target_pos, parent=current, cost=current.cost + self._distance(current.position, target_pos))\n                current.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((current, final_node))\n                self._grid_insert(grid, final_node, is_3d)\n                return final_node\n\n            # Regular step addition with duplicate suppression\n            if self._has_near_duplicate(grid, step_pos, self.min_separation, is_3d):\n                # Progress is negligible; stop trying to avoid loops\n                return None\n\n            new_node = Node(step_pos, parent=current, cost=current.cost + self._distance(current.position, step_pos))\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node, is_3d)\n            current = new_node\n\n        return None\n\n    # --------- Collision Checking ---------\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d):\n        distance = self._distance(from_pos, to_pos)\n        resolution = max(0.5, min(1.0, self.step_size * 0.5))\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    # --------- Shortcut Smoothing (bounded) ---------\n\n    def _shortcut_path(self, path, obstacles, is_3d, attempts=40):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        n = len(pts)\n        tries = 0\n        i = 0\n        # Greedy forward skipping with bounded iterations\n        while i < len(pts) - 2 and tries < attempts:\n            j = len(pts) - 1\n            improved = False\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                    # Remove intermediates\n                    del pts[i + 1:j]\n                    improved = True\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n            tries += 1\n        return pts",
          "objective": -28.86257,
          "time_improvement": 43.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1410.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03400664329528809,
                    "num_nodes_avg": 52.1,
                    "path_length_avg": 171.51876006638196,
                    "smoothness_avg": 0.050501544373221775,
                    "success_improvement": 0.0,
                    "time_improvement": -33.36568499023374,
                    "node_improvement": 86.87987912364643,
                    "length_improvement": 5.987849718937115,
                    "smoothness_improvement": 690.45883529979,
                    "objective_score": -2.964701489208901
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.030187082290649415,
                    "num_nodes_avg": 92.2,
                    "path_length_avg": 234.31486940525366,
                    "smoothness_avg": 0.08620583217892899,
                    "success_improvement": 0.0,
                    "time_improvement": 81.1563136658539,
                    "node_improvement": 93.8050124302896,
                    "length_improvement": 21.77895221296278,
                    "smoothness_improvement": 2118.138153515002,
                    "objective_score": 48.004956195108846
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009754443168640136,
                    "num_nodes_avg": 73.2,
                    "path_length_avg": 124.45355479806292,
                    "smoothness_avg": 0.11960663519260235,
                    "success_improvement": 0.0,
                    "time_improvement": 80.11393158758125,
                    "node_improvement": 90.69294342021614,
                    "length_improvement": 17.343874744565582,
                    "smoothness_improvement": 1421.3875712064366,
                    "objective_score": 41.54744217904591
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -25.748381214705063,
          "time_improvement": 87.0,
          "length_improvement": -1.0,
          "smoothness_improvement": 66.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0027012348175048826,
                    "num_nodes_avg": 63.9,
                    "path_length_avg": 172.25635822358078,
                    "smoothness_avg": 0.011148465868680943,
                    "success_improvement": 0.0,
                    "time_improvement": 89.40642189739663,
                    "node_improvement": 83.90833543188114,
                    "length_improvement": 5.5835604809856925,
                    "smoothness_improvement": 74.49770012597358,
                    "objective_score": 30.54455135844027
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.010209250450134277,
                    "num_nodes_avg": 240.4,
                    "path_length_avg": 302.26366463445993,
                    "smoothness_avg": 0.006453038743054631,
                    "success_improvement": 0.0,
                    "time_improvement": 93.62707825364559,
                    "node_improvement": 83.84734260565746,
                    "length_improvement": -0.9043114321748058,
                    "smoothness_improvement": 66.04133479473131,
                    "objective_score": 27.87574329076245
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010564541816711426,
                    "num_nodes_avg": 191.9,
                    "path_length_avg": 163.11362081791123,
                    "smoothness_avg": 0.012350799571145165,
                    "success_improvement": 0.0,
                    "time_improvement": 78.46240962391397,
                    "node_improvement": 75.60076287349014,
                    "length_improvement": -8.332300311300978,
                    "smoothness_improvement": 57.10125890377211,
                    "objective_score": 18.824848994912465
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -24.971436625701273,
          "time_improvement": 62.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 168.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009481477737426757,
                    "num_nodes_avg": 112.0,
                    "path_length_avg": 170.25136521926942,
                    "smoothness_avg": 0.017004537999713392,
                    "success_improvement": 0.0,
                    "time_improvement": 62.815977978432855,
                    "node_improvement": 71.7955175018887,
                    "length_improvement": 6.682528917796031,
                    "smoothness_improvement": 166.15794564080122,
                    "objective_score": 23.68510047241148
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0245816707611084,
                    "num_nodes_avg": 299.2,
                    "path_length_avg": 258.5973544494462,
                    "smoothness_avg": 0.010851066788952054,
                    "success_improvement": 0.0,
                    "time_improvement": 84.6553804394982,
                    "node_improvement": 79.89652623798965,
                    "length_improvement": 13.67275977263268,
                    "smoothness_improvement": 179.20576418723118,
                    "objective_score": 34.496298816365226
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.030178475379943847,
                    "num_nodes_avg": 287.8,
                    "path_length_avg": 139.5271231166937,
                    "smoothness_avg": 0.020290033291575655,
                    "success_improvement": 0.0,
                    "time_improvement": 38.47611641047452,
                    "node_improvement": 63.40750158931977,
                    "length_improvement": 7.332728393521491,
                    "smoothness_improvement": 158.08772581437248,
                    "objective_score": 16.732910588327112
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -20.90414805532173,
          "time_improvement": 74.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 81.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009906005859375,
                    "num_nodes_avg": 119.0,
                    "path_length_avg": 191.04302473496983,
                    "smoothness_avg": 0.011270904212760589,
                    "success_improvement": 0.0,
                    "time_improvement": 61.15108317274382,
                    "node_improvement": 70.03273734575673,
                    "length_improvement": -4.713709127687822,
                    "smoothness_improvement": 76.41412608993974,
                    "objective_score": 15.899170105660149
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.018079090118408202,
                    "num_nodes_avg": 263.8,
                    "path_length_avg": 304.060897710979,
                    "smoothness_avg": 0.007193047909992605,
                    "success_improvement": 0.0,
                    "time_improvement": 88.71448720621899,
                    "node_improvement": 82.2750789491366,
                    "length_improvement": -1.5042795636027118,
                    "smoothness_improvement": 85.08230366710401,
                    "objective_score": 26.13718994203959
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013434433937072754,
                    "num_nodes_avg": 198.2,
                    "path_length_avg": 154.3877135428638,
                    "smoothness_avg": 0.014383244909940574,
                    "success_improvement": 0.0,
                    "time_improvement": 72.61165319885777,
                    "node_improvement": 74.79974570883661,
                    "length_improvement": -2.536968182267624,
                    "smoothness_improvement": 82.95381359374001,
                    "objective_score": 20.676084118265454
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "Adaptive Beam BiRRT-Connect (AB-Connect): a lean, time-focused bidirectional planner that alternates single-step tree growth with a tiny beam of candidate samples. It uses a fine spatial hash for fast nearest queries, corridor-guided sampling around the start\u2013goal line to reduce rejection, and on-the-fly path compression to limit node bloat. A short greedy connect attempts to bridge trees early; upon success, a bounded shortcut pass cleans the path and returns immediately. By avoiding rewiring and heavy optimization while enforcing strict node/edge collision checks, AB-Connect minimizes per-iteration cost and achieves fast solutions.",
          "planning_mechanism": "Mechanism: Initialize two trees at start/goal. Each iteration (alternating trees), generate a small beam of candidate samples (goal/corridor/uniform), steer once from the nearest node, validate node and edge, discard near-duplicates, and keep the candidate that best reduces distance to the opposite tree. Insert it, attempt on-the-fly grandparent line-of-sight compression, then try a direct or short greedy connect toward the other tree. If bridged, extract the path and run bounded shortcut smoothing; else continue until the iteration budget is reached.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=8.0,\n                 goal_bias=0.18,\n                 corridor_bias=0.5,\n                 beam_k=2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=28,\n                 connect_steps=6,\n                 min_sep_ratio=0.25,\n                 dupe_radius_ratio=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.beam_k = beam_k\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n        self.connect_steps = connect_steps\n        self.min_sep_ratio = min_sep_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.start = None\n        self.goal = None\n\n    # ---------------- Planning ----------------\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Setup grid resolution and collision sampling\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.6 * self.step_size)\n        self.edge_res = max(0.75, min(self.collision_step, max(0.5, self.step_size * 0.4)))\n\n        # Validate start/goal and early LOS\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        if not self._is_edge_in_obstacle(self.start, self.goal, obstacles, is_3d, self.edge_res):\n            path = [self.start, self.goal]\n            nodes = [Node(self.start), Node(self.goal)]\n            return PlannerResult(True, path, nodes, [])\n\n        # Initialize structures\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Corridor parameters\n        dsg = self._dist(self.start, self.goal)\n        c_best = float('inf')\n        base_corridor = max(self.step_size, 0.15 * dsg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = self.goal if active_start else self.start\n\n            # Beam of candidates; keep the one that best reduces distance to the other tree\n            best_cand = None\n            best_score = float('inf')\n            other_near_hint = None\n\n            for _ in range(self.beam_k):\n                # Sampling policy: goal-biased, corridor-guided, or uniform\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = root_other\n                elif r < self.goal_bias + self.corridor_bias:\n                    width = base_corridor\n                    if c_best < float('inf'):\n                        width = max(self.step_size, 0.25 * (c_best - dsg) + base_corridor)\n                    x_rand = self._sample_corridor(width, obstacles, is_3d)\n                else:\n                    x_rand = self._sample_free(obstacles, is_3d)\n\n                nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._dist(nearest.position, new_pos) < self.step_size * self.min_sep_ratio:\n                    continue\n                if self._exists_close(grid_a, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                    continue\n\n                # Score: distance to nearest node in the other tree after this move\n                if other_near_hint is None:\n                    other_near_hint = self._nearest_grid(grid_b, tree_b, new_pos)\n                else:\n                    # refresh if new_pos is far from hint\n                    if self._dist(other_near_hint.position, new_pos) > 2.5 * self.step_size:\n                        other_near_hint = self._nearest_grid(grid_b, tree_b, new_pos)\n                if other_near_hint is None:\n                    score = self._dist(new_pos, root_other)\n                else:\n                    score = self._dist(new_pos, other_near_hint.position)\n                if score < best_score:\n                    best_score = score\n                    best_cand = (nearest, new_pos)\n\n            if best_cand is None:\n                continue\n\n            parent_node, new_pos = best_cand\n\n            # Insert node and edge (validated already)\n            new_cost = parent_node.cost + self._dist(parent_node.position, new_pos)\n            new_node = Node(new_pos, parent=parent_node, cost=new_cost)\n            parent_node.add_child(new_node)\n            tree_a.append(new_node)\n            self._edges_add(edges, parent_node, new_node)\n            self._grid_add(grid_a, new_node)\n\n            # On-the-fly grandparent compression\n            gp = parent_node.parent\n            if gp is not None:\n                # If LOS from grandparent to new_node, bypass parent to reduce nodes and cost\n                if not self._is_edge_in_obstacle(gp.position, new_node.position, obstacles, is_3d, self.edge_res):\n                    # Update edges/children coherently\n                    parent_node.remove_child(new_node)\n                    self._edges_remove(edges, parent_node, new_node)\n                    gp.add_child(new_node)\n                    self._edges_add(edges, gp, new_node)\n                    # Update cost\n                    new_node.cost = gp.cost + self._dist(gp.position, new_node.position)\n\n            # Try direct bridge to the nearest node in the other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None and not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                path = self._extract_path(new_node, other_near)\n                c_best = self._path_length(path)\n                path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Short greedy connect toward new_node from the other tree\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, new_node.position, self.step_size)\n                if self._dist(p.position, to_pos) < self.step_size * self.min_sep_ratio:\n                    break\n                if not self._in_bounds(to_pos):\n                    break\n                if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(p.position, to_pos, obstacles, is_3d, self.edge_res):\n                    break\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                self._edges_add(edges, p, q)\n                self._grid_add(grid_b, q)\n                p = q\n                steps += 1\n\n                # Check bridge now\n                if not self._is_edge_in_obstacle(new_node.position, p.position, obstacles, is_3d, self.edge_res):\n                    path = self._extract_path(new_node, p)\n                    c_best = self._path_length(path)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------------- RNG ----------------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------------- Geometry ----------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------------- Collision ----------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------------- Sampling ----------------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        # Sample around the start-goal line with axis-aligned jitter (cheap \"corridor\")\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        # Fallback to uniform if corridor sample is invalid\n        return self._sample_free(obstacles, is_3d)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # ---------------- Grid and neighbors ----------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Expand rings up to modest radius; fallback linear scan if needed\n        for r in range(0, 5):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan (rare with fine grid)\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                return True\n        return False\n\n    # ---------------- Edges and costs ----------------\n    def _edges_add(self, edges, parent, child):\n        edges.append((parent, child))\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # ---------------- Paths ----------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        # Path A: root_A -> meet_a\n        path_a = self._path_to_root(meet_a)\n        # Path B: meet_b -> root_B (following parent links)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # Concatenate, implying a straight edge between meet_a and meet_b (validated before)\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        # Final LOS collapse forward\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            for k in range(1, len(pts) - 1):\n                nxt = pts[k + 1]\n                if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d, self.edge_res):\n                    collapsed.append(pts[k])\n                    last = pts[k]\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
          "objective": -20.0019,
          "time_improvement": 15.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1665.0,
          "node_improvement": 85.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022508907318115234,
                    "num_nodes_avg": 61.9,
                    "path_length_avg": 173.37195960178056,
                    "smoothness_avg": 0.04856882636983518,
                    "success_improvement": 0.0,
                    "time_improvement": 11.725605588421473,
                    "node_improvement": 84.41198690506171,
                    "length_improvement": 4.972081687759297,
                    "smoothness_improvement": 660.2076015824708,
                    "objective_score": 9.801968697094374
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04350669384002685,
                    "num_nodes_avg": 122.6,
                    "path_length_avg": 245.93388702328062,
                    "smoothness_avg": 0.11098748565610625,
                    "success_improvement": 0.0,
                    "time_improvement": 72.84181080292292,
                    "node_improvement": 91.76241349190352,
                    "length_improvement": 17.900189697186487,
                    "smoothness_improvement": 2755.78794698629,
                    "objective_score": 46.371596794120215
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06773929595947266,
                    "num_nodes_avg": 163.7,
                    "path_length_avg": 132.06627662911285,
                    "smoothness_avg": 0.13189994478614067,
                    "success_improvement": 0.0,
                    "time_improvement": -38.09791603378091,
                    "node_improvement": 79.18626827717736,
                    "length_improvement": 12.287867383240805,
                    "smoothness_improvement": 1577.7575618385185,
                    "objective_score": 3.832133429002802
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "IBEX-BiRRT (Informed Beam EXploration BiRRT): a bidirectional planner that couples ellipse-informed beam sampling with dual-state edge memoization, anchor-guided hashed nearest search, and local LOS-based parent selection. It throttles per-cell growth, rejects near-duplicates, and performs micro-connect probes with cached collision results. A provisional path immediately activates an informed ellipse to focus sampling; final paths are lightly shortcut and LOS-collapsed for length and smoothness.",
          "planning_mechanism": "Alternate growing start/goal trees. For each side, generate a small beam of samples from goal/corridor/uniform, switching to ellipse-informed sampling once a path exists. For each sample: find a near node via grid+anchors, steer, ensure node and edge collision-free, then choose a best-cost parent among a few nearby LOS-feasible nodes. Insert the node, attempt a direct bridge, else try a few micro connect steps from the opposite tree. Both node and edge checks are enforced before any insertion. On success, extract and shortcut the path; otherwise iterate up to a cap.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=10.0,\n        collision_step=1.0,\n        beam_k=3,\n        goal_bias=0.2,\n        corridor_bias=0.5,\n        informed_bias=0.6,\n        grid_cell_factor=0.9,\n        min_sep_ratio=0.4,\n        dupe_radius_ratio=0.6,\n        cell_expand_limit=3,\n        max_rings=3,\n        parent_search_rings=2,\n        connect_micro_steps=4,\n        smoothing_attempts=40,\n        anchors_stride=24,\n        edge_cache_max=12000,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_step = collision_step\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.informed_bias = informed_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.min_sep_ratio = min_sep_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.cell_expand_limit = max(1, int(cell_expand_limit))\n        self.max_rings = max_rings\n        self.parent_search_rings = parent_search_rings\n        self.connect_micro_steps = connect_micro_steps\n        self.smoothing_attempts = smoothing_attempts\n        self.anchors_stride = max(1, int(anchors_stride))\n        self.edge_cache_max = edge_cache_max\n\n        # Runtime fields\n        self.bounds = None\n        self.dim = 2\n        self.edge_res = 1.0\n        self.cache_bin = 1.0\n        self.edge_cache = None  # dict[(qa,qb)] = 1(blocked) or 2(free)\n        self.cell_size = 1.0\n        self.min_sep = 1.0\n        self.dupe_radius = 1.0\n        self.start = None\n        self.goal = None\n\n    # ------------- Public entry ----------------\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Parameterize discretizations\n        self.edge_res = max(0.75, min(self.collision_step, self.step_size * 0.5))\n        self.cache_bin = max(1.0, self.edge_res)\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step_size * self.min_sep_ratio)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.edge_cache = {}\n\n        # Validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n        if not self._edge_blocked_memo(self.start, self.goal, obstacles, is_3d):\n            n0 = Node(self.start)\n            n1 = Node(self.goal, parent=n0, cost=self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Init trees, grids, anchors, throttles\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        anchors_a, anchors_b = [start_root], [goal_root]\n        cell_expands_a, cell_expands_b = {}, {}\n\n        best_path_len = float('inf')\n        d_sg = self._dist(self.start, self.goal)\n        base_corridor_w = max(self.step_size, 0.2 * d_sg)\n\n        # Main loop\n        for it in range(self.max_iter):\n            # alternate sides\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            anchors1 = anchors_a if active_start else anchors_b\n            anchors2 = anchors_b if active_start else anchors_a\n            throttles1 = cell_expands_a if active_start else cell_expands_b\n            other_root = self.goal if active_start else self.start\n\n            best_candidate = None  # (parent_node, new_pos, score)\n\n            for _ in range(self.beam_k):\n                # Guided sampling with informed ellipse if available\n                x_rand = None\n                r = self._rand()\n                if best_path_len < float('inf') and r < self.informed_bias:\n                    x_rand = self._sample_informed(best_path_len, obstacles, is_3d)\n                else:\n                    r2 = self._rand()\n                    if r2 < self.goal_bias:\n                        x_rand = other_root\n                    elif r2 < self.goal_bias + self.corridor_bias:\n                        width = base_corridor_w\n                        if best_path_len < float('inf'):\n                            slack = max(0.0, best_path_len - d_sg)\n                            width = max(self.step_size, 0.15 * slack + base_corridor_w)\n                        x_rand = self._sample_corridor(width, obstacles, is_3d)\n                    else:\n                        x_rand = self._sample_free(obstacles, is_3d)\n\n                nearest = self._nearest_hashed(grid1, tree1, anchors1, x_rand)\n                if nearest is None:\n                    continue\n\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._exists_close(grid1, new_pos, self.dupe_radius):\n                    continue\n\n                # Throttle expansions per cell\n                kcell = self._grid_key(new_pos)\n                if throttles1.get(kcell, 0) >= self.cell_expand_limit:\n                    continue\n\n                # Candidate parent selection: consider a few nearby nodes with LOS and lower cost\n                parent = self._choose_parent(nearest, grid1, new_pos, obstacles, is_3d)\n                if parent is None:\n                    continue\n                # Edge check (both checks enforced before insertion)\n                if self._edge_blocked_memo(parent.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Score: distance to nearest on opposite tree (encourage bridging)\n                near2 = self._nearest_hashed(grid2, tree2, anchors2, new_pos)\n                score = self._dist(new_pos, near2.position) if near2 is not None else self._dist(new_pos, other_root)\n\n                if best_candidate is None or score < best_candidate[2]:\n                    best_candidate = (parent, new_pos, score)\n\n            if best_candidate is None:\n                continue\n\n            parent, new_pos, _score = best_candidate\n\n            # Final checks before adding\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked_memo(parent.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Insert node\n            new_cost = parent.cost + self._dist(parent.position, new_pos)\n            new_node = Node(new_pos, parent=parent, cost=new_cost)\n            parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(grid1, new_node)\n            kc = self._grid_key(new_pos)\n            throttles1[kc] = throttles1.get(kc, 0) + 1\n            if len(tree1) % self.anchors_stride == 0:\n                anchors1.append(new_node)\n\n            # Grandparent LOS compression (cheap)\n            gp = parent.parent\n            if gp is not None and not self._edge_blocked_memo(gp.position, new_node.position, obstacles, is_3d):\n                parent.children = [c for c in parent.children if c is not new_node]\n                new_node.parent = gp\n                gp.add_child(new_node)\n                new_node.cost = gp.cost + self._dist(gp.position, new_node.position)\n                # edges bookkeeping: replace edge (parent,new_node) by (gp,new_node)\n                try:\n                    idx = -1\n                    for i in range(len(edges)):\n                        if edges[i][0] is parent and edges[i][1] is new_node:\n                            idx = i\n                            break\n                    if idx >= 0:\n                        edges.pop(idx)\n                except:\n                    pass\n                edges.append((gp, new_node))\n\n            # Try direct bridge\n            other_near = self._nearest_hashed(grid2, tree2, anchors2, new_node.position)\n            if other_near is not None and not self._edge_blocked_memo(new_node.position, other_near.position, obstacles, is_3d):\n                path = self._extract_path(new_node, other_near)\n                best_path_len = self._path_length(path)\n                path = self._smooth_path(path, obstacles, is_3d, self.smoothing_attempts)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Micro-connect from the other side\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_micro_steps:\n                step_pos = self._steer(p.position, new_node.position, self.step_size)\n                if not self._in_bounds(step_pos):\n                    break\n                if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._exists_close(grid2, step_pos, self.dupe_radius):\n                    break\n                if self._edge_blocked_memo(p.position, step_pos, obstacles, is_3d):\n                    break\n\n                # Add micro step node (both checks passed)\n                q = Node(step_pos, parent=p, cost=p.cost + self._dist(p.position, step_pos))\n                p.add_child(q)\n                tree2.append(q)\n                nodes.append(q)\n                edges.append((p, q))\n                self._grid_add(grid2, q)\n                if len(tree2) % self.anchors_stride == 0:\n                    anchors2.append(q)\n                k2 = self._grid_key(step_pos)\n                if active_start:\n                    cell_expands_b[k2] = cell_expands_b.get(k2, 0) + 1\n                else:\n                    cell_expands_a[k2] = cell_expands_a.get(k2, 0) + 1\n\n                p = q\n                steps += 1\n\n                # Check bridge after each micro step\n                if not self._edge_blocked_memo(new_node.position, p.position, obstacles, is_3d):\n                    path = self._extract_path(new_node, p)\n                    best_path_len = self._path_length(path)\n                    path = self._smooth_path(path, obstacles, is_3d, self.smoothing_attempts)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # ------------- RNG -------------\n    def _rand(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------- Geometry -------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp_tuple(to_pos)\n        if d <= 1e-12:\n            return self._clamp_tuple(from_pos)\n        r = step / d\n        return self._clamp_tuple(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ------------- Collision -------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked_memo(self, a, b, obstacles, is_3d):\n        key = self._edge_key_q(a, b)\n        state = self.edge_cache.get(key)\n        if state is not None:\n            return state == 1\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d)\n        self.edge_cache[key] = 1 if blocked else 2\n        if len(self.edge_cache) > self.edge_cache_max:\n            # Simple aging: clear cache to bound memory\n            self.edge_cache.clear()\n        return blocked\n\n    # ------------- Sampling -------------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        base_t = self._rand()\n        base = tuple(self.start[i] + base_t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            # Random offset in sphere\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n        else:\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d):\n        # Rejection sampling in prolate ellipse (sum of distances to foci <= best_len)\n        for _ in range(40):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= best_len and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # Fallback if rejection too strict\n        return self._sample_corridor(max(self.step_size, 0.2 * self._dist(self.start, self.goal)), obstacles, is_3d)\n\n    # ------------- Grid Hashing -------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, tree, anchors, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.max_rings + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback to anchors (sparse subset)\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # Rare: full scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.cell_size) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    def _nearby_candidates(self, grid, pos, rings):\n        key = self._grid_key(pos)\n        cand = []\n        for r in range(0, rings + 1):\n            cand.extend(self._grid_ring_collect(grid, key, r))\n        return cand\n\n    # ------------- Parent selection -------------\n    def _choose_parent(self, nearest, grid, new_pos, obstacles, is_3d):\n        best_parent = nearest\n        best_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        # include a few nearby candidates\n        candidates = self._nearby_candidates(grid, new_pos, self.parent_search_rings)\n        if not candidates:\n            candidates = [nearest]\n        for cand in candidates:\n            # Avoid trivial duplicate\n            if cand is None:\n                continue\n            # LOS check to new_pos\n            if not self._edge_blocked_memo(cand.position, new_pos, obstacles, is_3d):\n                c = cand.cost + self._dist(cand.position, new_pos)\n                if c < best_cost:\n                    best_cost = c\n                    best_parent = cand\n        return best_parent\n\n    # ------------- Paths -------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node):\n        path_a = self._path_to_root(a_node)\n        path_b = []\n        cur = b_node\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _smooth_path(self, path, obstacles, is_3d, attempts):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and len(pts) >= 3:\n            i = int(self._uniform(0, len(pts) - 2))\n            j = int(self._uniform(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked_memo(a, b, obstacles, is_3d):\n                # remove intermediates\n                pts = pts[:i + 1] + pts[j:]\n            tries += 1\n        # Forward LOS collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            k = 1\n            while k < len(pts) - 1:\n                nxt = pts[k + 1]\n                if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d):\n                    collapsed.append(pts[k])\n                    last = pts[k]\n                k += 1\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
          "objective": -19.56842,
          "time_improvement": 16.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 1708.0,
          "node_improvement": 91.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.034371376037597656,
                    "num_nodes_avg": 54.5,
                    "path_length_avg": 176.5532757902085,
                    "smoothness_avg": 0.04933649347201097,
                    "success_improvement": 0.0,
                    "time_improvement": -34.79607703434419,
                    "node_improvement": 86.27549735582977,
                    "length_improvement": 3.2283518737009844,
                    "smoothness_improvement": 672.2232587473158,
                    "objective_score": -5.140695692346085
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.049022126197814944,
                    "num_nodes_avg": 74.3,
                    "path_length_avg": 244.4349083904013,
                    "smoothness_avg": 0.12138388867178254,
                    "success_improvement": 0.0,
                    "time_improvement": 69.39891173945327,
                    "node_improvement": 95.00772693677351,
                    "length_improvement": 18.400591910549277,
                    "smoothness_improvement": 3023.294884806057,
                    "objective_score": 46.976503092195834
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04275155067443848,
                    "num_nodes_avg": 61.0,
                    "path_length_avg": 135.83592104549325,
                    "smoothness_avg": 0.12021718235188508,
                    "success_improvement": 0.0,
                    "time_improvement": 12.8437936691172,
                    "node_improvement": 92.2441195168468,
                    "length_improvement": 9.784249053058426,
                    "smoothness_improvement": 1429.1536860066096,
                    "objective_score": 16.869455962603265
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -17.205069232007403,
          "time_improvement": 34.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 176.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0216599702835083,
                    "num_nodes_avg": 94.5,
                    "path_length_avg": 179.3326139424124,
                    "smoothness_avg": 0.016628736549943037,
                    "success_improvement": 0.0,
                    "time_improvement": 15.05492769030675,
                    "node_improvement": 76.20246789221858,
                    "length_improvement": 1.7049525910466614,
                    "smoothness_improvement": 160.2758368859854,
                    "objective_score": 6.340829046149949
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02987968921661377,
                    "num_nodes_avg": 216.6,
                    "path_length_avg": 257.061927055405,
                    "smoothness_avg": 0.010384869878880055,
                    "success_improvement": 0.0,
                    "time_improvement": 81.34819768474138,
                    "node_improvement": 85.44648256399921,
                    "length_improvement": 14.185329631590712,
                    "smoothness_improvement": 167.21018190301697,
                    "objective_score": 33.75170799389193
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.046378374099731445,
                    "num_nodes_avg": 257.2,
                    "path_length_avg": 128.26306667164565,
                    "smoothness_avg": 0.023576110070462338,
                    "success_improvement": 0.0,
                    "time_improvement": 5.449905826599429,
                    "node_improvement": 67.29815638906548,
                    "length_improvement": 14.813778347593729,
                    "smoothness_improvement": 199.8863798888539,
                    "objective_score": 11.522670655980336
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "FlashConnect BiRRT (FC-BiRRT): a cache-accelerated bidirectional planner with throttled growth and corridor-guided micro-batches. It couples an adaptive hashed-nearest structure with a conservative edge-collision memo (blocked-edge cache), per-cell expansion throttling, and sparse \u201cleader\u201d fallbacks to avoid O(N) scans. Direct bridges and short greedy connects are attempted with cached checks; on success, a bounded shortcut and line-of-sight collapse return a clean path fast.",
          "planning_mechanism": "Mechanism: Initialize start/goal trees with grid buckets and sparse leaders. Each iteration alternates trees, samples a tiny beam (goal/corridor/uniform), steers once from the nearest, enforces node/edge validity, prunes duplicates and saturated cells, and keeps the candidate that best reduces distance to the other tree. Insert with optional grandparent LOS compression, then attempt a direct bridge; if blocked, execute a few greedy connect steps using the blocked-edge cache. On bridge, extract and lightly smooth the path; otherwise continue until the iteration cap.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=8.0,\n                 goal_bias=0.2,\n                 corridor_bias=0.55,\n                 beam_k=2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 connect_steps=5,\n                 smoothing_iters=18,\n                 min_sep_ratio=0.25,\n                 dupe_radius_ratio=0.5,\n                 cell_expand_limit=3,\n                 leader_stride=16):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.beam_k = beam_k\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.connect_steps = connect_steps\n        self.smoothing_iters = smoothing_iters\n        self.min_sep_ratio = min_sep_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.cell_expand_limit = max(1, int(cell_expand_limit))\n        self.leader_stride = max(1, int(leader_stride))\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.start = None\n        self.goal = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Setup grid and edge sampling step\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.8 * self.step_size)\n        self.edge_res = max(0.75, min(self.collision_step, max(0.5, self.step_size * 0.4)))\n        self.cache_bin = max(1.0, self.edge_res)  # quantization for blocked-edge cache\n\n        # Validate start/goal and early LOS\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n        if not self._is_edge_in_obstacle(self.start, self.goal, obstacles, is_3d, self.edge_res):\n            nodes = [Node(self.start), Node(self.goal)]\n            return PlannerResult(True, [self.start, self.goal], nodes, [])\n\n        # Initialize trees, grids, leaders, edges, caches\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start, grid_goal = {}, {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        leaders_start, leaders_goal = [start_root], [goal_root]\n        cell_expands_start, cell_expands_goal = {}, {}\n\n        blocked_edge_cache = set()\n\n        # Corridor parameters\n        dsg = self._dist(self.start, self.goal)\n        base_corridor = max(self.step_size, 0.15 * dsg)\n        best_path_len = float('inf')\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            leaders_a = leaders_start if active_start else leaders_goal\n            leaders_b = leaders_goal if active_start else leaders_start\n            cell_count_a = cell_expands_start if active_start else cell_expands_goal\n            root_other = self.goal if active_start else self.start\n\n            # Candidate beam; keep one that best approaches the other tree\n            best_parent = None\n            best_newpos = None\n            best_score = float('inf')\n\n            for _ in range(self.beam_k):\n                # Sampling: goal-biased, corridor-guided, or uniform\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = root_other\n                elif r < self.goal_bias + self.corridor_bias:\n                    width = base_corridor\n                    if best_path_len < float('inf'):\n                        width = max(self.step_size, 0.25 * (best_path_len - dsg) + base_corridor)\n                    x_rand = self._sample_corridor(width, obstacles, is_3d)\n                else:\n                    x_rand = self._sample_free(obstacles, is_3d)\n\n                nearest = self._nearest_hashed(grid_a, tree_a, leaders_a, x_rand)\n                if nearest is None:\n                    continue\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n\n                # De-duplicate and throttle saturated cells\n                if self._dist(nearest.position, new_pos) < self.step_size * self.min_sep_ratio:\n                    continue\n                if self._exists_close(grid_a, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                kcell = self._grid_key(new_pos)\n                if cell_count_a.get(kcell, 0) >= self.cell_expand_limit:\n                    continue\n\n                # Edge validity with blocked-edge cache\n                if self._is_edge_blocked_cached(nearest.position, new_pos, obstacles, is_3d, blocked_edge_cache):\n                    continue\n\n                # Score: distance to nearest in opposite tree (leaders-assisted)\n                other_near = self._nearest_hashed(grid_b, tree_b, leaders_b, new_pos)\n                if other_near is not None:\n                    score = self._dist(new_pos, other_near.position)\n                else:\n                    score = self._dist(new_pos, root_other)\n\n                if score < best_score:\n                    best_score = score\n                    best_parent = nearest\n                    best_newpos = new_pos\n\n            if best_parent is None:\n                continue\n\n            # Final validity before insertion (both checks)\n            if self._is_in_obstacle(best_newpos, obstacles, is_3d):\n                continue\n            if self._is_edge_blocked_cached(best_parent.position, best_newpos, obstacles, is_3d, blocked_edge_cache):\n                continue\n\n            # Insert node and edge\n            new_cost = best_parent.cost + self._dist(best_parent.position, best_newpos)\n            new_node = Node(best_newpos, parent=best_parent, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            self._edges_add(edges, best_parent, new_node)\n            self._grid_add(grid_a, new_node)\n            # Update per-cell throttle\n            kc = self._grid_key(new_node.position)\n            cell_count_a[kc] = cell_count_a.get(kc, 0) + 1\n            # Sparse leaders\n            if len(tree_a) % self.leader_stride == 0:\n                leaders_a.append(new_node)\n\n            # On-the-fly grandparent compression\n            gp = best_parent.parent\n            if gp is not None:\n                if not self._is_edge_blocked_cached(gp.position, new_node.position, obstacles, is_3d, blocked_edge_cache):\n                    best_parent.remove_child(new_node)\n                    self._edges_remove(edges, best_parent, new_node)\n                    gp.add_child(new_node)\n                    self._edges_add(edges, gp, new_node)\n                    new_node.cost = gp.cost + self._dist(gp.position, new_node.position)\n\n            # Attempt direct bridge to nearest in the other tree\n            other_near = self._nearest_hashed(grid_b, tree_b, leaders_b, new_node.position)\n            if other_near is not None and not self._is_edge_blocked_cached(new_node.position, other_near.position, obstacles, is_3d, blocked_edge_cache):\n                path = self._extract_path(new_node, other_near)\n                best_path_len = self._path_length(path)\n                path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Short greedy connect from the other tree toward the new node\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, new_node.position, self.step_size)\n                if self._dist(p.position, to_pos) < self.step_size * self.min_sep_ratio:\n                    break\n                if not self._in_bounds(to_pos):\n                    break\n                if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                    break\n                if self._exists_close(grid_b, to_pos, self.step_size * self.dupe_radius_ratio):\n                    break\n                if self._is_edge_blocked_cached(p.position, to_pos, obstacles, is_3d, blocked_edge_cache):\n                    break\n\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                self._edges_add(edges, p, q)\n                self._grid_add(grid_b, q)\n                # leaders and per-cell throttle for tree_b\n                if len(tree_b) % self.leader_stride == 0:\n                    leaders_b.append(q)\n                kc_b = self._grid_key(q.position)\n                if active_start:\n                    cell_expands_goal[kc_b] = cell_expands_goal.get(kc_b, 0) + 1\n                else:\n                    cell_expands_start[kc_b] = cell_expands_start.get(kc_b, 0) + 1\n\n                p = q\n                steps += 1\n\n                # Check bridge now\n                if not self._is_edge_blocked_cached(new_node.position, p.position, obstacles, is_3d, blocked_edge_cache):\n                    path = self._extract_path(new_node, p)\n                    best_path_len = self._path_length(path)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # RNG\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _is_edge_blocked_cached(self, a, b, obstacles, is_3d, blocked_cache):\n        key = self._edge_key_q(a, b)\n        if key in blocked_cache:\n            return True\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res)\n        if blocked:\n            blocked_cache.add(key)\n        return blocked\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # Grid and neighbors\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, leaders, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Limited rings, then leader fallback to avoid O(N)\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fall back to leaders (sparse)\n        for n in leaders:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # Fallback full scan (rare)\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                return True\n        return False\n\n    # Edges\n    def _edges_add(self, edges, parent, child):\n        edges.append((parent, child))\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        # Forward LOS collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            for k in range(1, len(pts) - 1):\n                nxt = pts[k + 1]\n                if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d, self.edge_res):\n                    collapsed.append(pts[k])\n                    last = pts[k]\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
          "objective": -14.73772,
          "time_improvement": 1.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 1829.0,
          "node_improvement": 84.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03957667350769043,
                    "num_nodes_avg": 89.6,
                    "path_length_avg": 173.3707237388481,
                    "smoothness_avg": 0.05077321918948241,
                    "success_improvement": 0.0,
                    "time_improvement": -55.2099725384924,
                    "node_improvement": 77.43641400151094,
                    "length_improvement": 4.972759083816072,
                    "smoothness_improvement": 694.711136125575,
                    "objective_score": -10.105780630630203
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05332317352294922,
                    "num_nodes_avg": 145.0,
                    "path_length_avg": 246.8569464197752,
                    "smoothness_avg": 0.11933221064521529,
                    "success_improvement": 0.0,
                    "time_improvement": 66.7140684040557,
                    "node_improvement": 90.25734058993481,
                    "length_improvement": 17.592045901845015,
                    "smoothness_improvement": 2970.5037314185306,
                    "objective_score": 45.42196671941637
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.052624630928039554,
                    "num_nodes_avg": 134.3,
                    "path_length_avg": 145.60396458843502,
                    "smoothness_avg": 0.1510094522023601,
                    "success_improvement": 0.0,
                    "time_improvement": -7.284136338781219,
                    "node_improvement": 82.92434837889384,
                    "length_improvement": 3.2967796360860238,
                    "smoothness_improvement": 1820.829085655716,
                    "objective_score": 8.896972308295828
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "BG-BiRRT-LC: Beam-Guided Bidirectional RRT-Connect with Line-of-Sight Compression, Duplicate Suppression, Spatial Hashing, and Informed Sampling. It prioritizes time efficiency by limiting neighbor/rewire costs, pruning near-duplicates, compressing parents via direct line-of-sight, and using a beam of goal-directed samples with a lightweight grid for fast nearest/near queries.",
          "planning_mechanism": "Alternate expanding start/goal trees: for each side, beam-sample k candidates (goal-biased and informed after first path), pick the most promising, steer one step, validate node and edge, suppress near-duplicates, pick a best parent from a tiny local set, then compress to an ancestor if line-of-sight holds. Attempt a bounded greedy connect from the other tree to the new node. Upon a connection, merge paths and optionally continue a few refinement iterations; finally apply capped shortcut smoothing.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def detach_from_parent(self):\n        if self.parent is not None and self in self.parent.children:\n            self.parent.children.remove(self)\n        self.parent = None\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 9.0,\n        goal_bias: float = 0.12,\n        beam_k: int = 3,\n        parent_k: int = 5,\n        connect_steps: int = 6,\n        time_limit_sec: float = 15.0,\n        smooth_attempts: int = 80,\n        post_opt_iters: int = 120,\n        no_improve_limit: int = 80,\n        compress_ancestors: int = 3\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.beam_k = max(1, beam_k)\n        self.parent_k = max(1, parent_k)\n        self.connect_steps = connect_steps\n        self.time_limit_sec = time_limit_sec\n        self.smooth_attempts = smooth_attempts\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit\n        self.compress_ancestors = compress_ancestors\n\n        # Spatial hash cell size and duplicate suppression radii\n        self.cell_size = max(6.0, step_size * 1.5)\n        self.dup_radius = step_size * 1.25\n        self.dup_thresh = step_size * 0.6\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes = []\n        edges = []\n        success_state = False\n        best_path = []\n        best_cost = float('inf')\n\n        # Roots\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Spatial hashes\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        c_min = self._dist(start_position, goal_position)\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        t0 = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - t0 > self.time_limit_sec:\n                break\n\n            # Alternate expansion\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n                grid_a, grid_b = grid_start, grid_goal\n                root_a, root_b = start_root, goal_root\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n                grid_a, grid_b = grid_goal, grid_start\n                root_a, root_b = goal_root, start_root\n\n            # Beam-guided sampling\n            x_rand = self._beam_sample(bounds, obstacles, is_3d, root_a.position, root_b.position, best_cost, c_min, grid_a, tree_a)\n\n            # Nearest and steer\n            a_near = self._nearest(grid_a, tree_a, x_rand, bounds)\n            a_new_pos = self._steer(a_near.position, x_rand, self.step_size)\n\n            # Bounds and collision checks before adding\n            if not self._in_bounds(a_new_pos, bounds):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n            if self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n            if self._hit_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Duplicate/near-duplicate suppression\n            near_dups = self._grid_neighbors(grid_a, a_new_pos, self.dup_radius)\n            skip = False\n            for nb in near_dups:\n                if self._dist(nb.position, a_new_pos) <= self.dup_thresh:\n                    skip = True\n                    break\n            if skip:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Parent selection among a tiny local set\n            parent_radius = max(self.step_size * 2.0, 12.0)\n            neighbors = self._grid_neighbors(grid_a, a_new_pos, parent_radius)\n            if not neighbors:\n                neighbors = [a_near]\n            # Choose up to parent_k closest neighbors\n            neighbors.sort(key=lambda n: self._dist(n.position, a_new_pos))\n            candidates = neighbors[:self.parent_k]\n\n            best_parent = None\n            best_g = float('inf')\n            for cand in candidates:\n                if self._hit_obstacle(cand.position, a_new_pos, obstacles, is_3d):\n                    continue\n                g = cand.cost + self._dist(cand.position, a_new_pos)\n                if g < best_g:\n                    best_g = g\n                    best_parent = cand\n\n            if best_parent is None:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Line-of-sight compression to ancestors\n            best_parent, best_g = self._compress_parent(best_parent, a_new_pos, best_g, obstacles, is_3d)\n\n            # Add node to tree_a\n            a_new = Node(a_new_pos, parent=None, cost=best_g)\n            best_parent.add_child(a_new)\n            tree_a.append(a_new)\n            nodes.append(a_new)\n            edges.append((best_parent, a_new))\n            self._grid_add(grid_a, a_new)\n\n            # Attempt to connect other tree to this new node\n            b_meet = self._try_connect(tree_b, grid_b, a_new, obstacles, is_3d, bounds, nodes, edges)\n            if b_meet is not None:\n                # Merge path start->goal\n                pathA = a_new.path_from_root()\n                pathB = b_meet.path_from_root()\n                if root_a is start_root:\n                    merged = pathA + pathB[-2::-1]\n                else:\n                    merged = pathB + pathA[-2::-1]\n\n                cost = self._path_cost(merged)\n                if cost < best_cost - 1e-9:\n                    best_cost = cost\n                    best_path = merged\n                    success_state = True\n                    no_improve = 0\n                else:\n                    no_improve += 1\n\n                if not found_first:\n                    found_first = True\n                    post_iters = 0\n                else:\n                    post_iters += 1\n\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n            else:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n\n        # Final smoothing\n        if success_state and best_path:\n            best_path = self._shortcut_smooth(best_path, obstacles, is_3d, attempts=self.smooth_attempts)\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ---------------- Spatial Hash ----------------\n    def _key(self, pos):\n        return tuple(int(pos[d] // self.cell_size) for d in range(len(pos)))\n\n    def _grid_add(self, grid, node):\n        k = self._key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_neighbors(self, grid, pos, radius):\n        dim = len(pos)\n        span = int(max(1, math.ceil(radius / self.cell_size)))\n        kc = self._key(pos)\n        result = []\n        if dim == 2:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    k = (kc[0] + dx, kc[1] + dy)\n                    if k in grid:\n                        for n in grid[k]:\n                            if self._dist(n.position, pos) <= radius:\n                                result.append(n)\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        k = (kc[0] + dx, kc[1] + dy, kc[2] + dz)\n                        if k in grid:\n                            for n in grid[k]:\n                                if self._dist(n.position, pos) <= radius:\n                                    result.append(n)\n        return result\n\n    def _nearest(self, grid, tree, pos, bounds):\n        radius = self.cell_size\n        for _ in range(4):\n            cands = self._grid_neighbors(grid, pos, radius)\n            if cands:\n                return min(cands, key=lambda n: self._dist(n.position, pos))\n            radius *= 2.0\n        return min(tree, key=lambda n: self._dist(n.position, pos))\n\n    # --------------- Beam-Guided Sampling ---------------\n    def _beam_sample(self, bounds, obstacles, is_3d, root_a, root_b, c_best, c_min, grid_a, tree_a):\n        # Goal bias\n        if random.random() < self.goal_bias:\n            goal_tgt = root_b\n            if not self._is_in_obstacle(goal_tgt, obstacles, is_3d):\n                return goal_tgt\n\n        best = None\n        best_score = float('inf')\n        for _ in range(self.beam_k):\n            if c_best < float('inf') and c_min > 1e-12:\n                x = self._sample_informed_ellipsoid(root_a, root_b, c_best, c_min, bounds)\n            else:\n                x = self._sample_uniform_free(bounds, obstacles, is_3d)\n            # Score: favor closeness to opposite root and ease of reaching from current tree\n            near = self._nearest(grid_a, tree_a, x, bounds)\n            score = self._dist(x, root_b) + 0.3 * self._dist(near.position, x)\n            if score < best_score:\n                best_score = score\n                best = x\n        return best\n\n    def _sample_uniform_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]), random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_informed_ellipsoid(self, start, goal, c_best, c_min, bounds):\n        dim = len(bounds)\n        # Prolate ellipsoid with foci at start and goal\n        r1 = c_best / 2.0\n        r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n        center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n        a1 = self._unit(self._vec(goal, start))\n        if dim == 2:\n            a2 = (-a1[1], a1[0])\n            basis = (a1, a2)\n            radii = (r1, r2)\n        else:\n            ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = self._unit(self._cross(a1, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._unit(self._cross(a1, ref))\n            b3 = self._cross(a1, b2)\n            basis = (a1, b2, b3)\n            radii = (r1, r2, r2)\n\n        u = self._sample_unit_ball(dim)\n        x = [center[d] for d in range(dim)]\n        for i in range(dim):\n            for d in range(dim):\n                x[d] += basis[i][d] * radii[i] * u[i]\n        x = tuple(min(max(x[d], 0.0), bounds[d]) for d in range(dim))\n        return x\n\n    def _sample_unit_ball(self, dim):\n        while True:\n            v = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(vi * vi for vi in v))\n            if n > 1e-12:\n                v = [vi / n for vi in v]\n                r = random.random() ** (1.0 / dim)\n                return tuple(v[i] * r for i in range(dim))\n\n    # --------------- Parent Compression ---------------\n    def _compress_parent(self, parent, new_pos, current_g, obstacles, is_3d):\n        # Try a few ancestors for direct line-of-sight to reduce chain depth\n        anc = parent\n        best_parent = parent\n        best_g = current_g\n        steps = 0\n        while anc is not None and anc.parent is not None and steps < self.compress_ancestors:\n            grand = anc.parent\n            if not self._hit_obstacle(grand.position, new_pos, obstacles, is_3d):\n                g = grand.cost + self._dist(grand.position, new_pos)\n                if g + 1e-12 < best_g:\n                    best_g = g\n                    best_parent = grand\n            anc = grand\n            steps += 1\n        return best_parent, best_g\n\n    # --------------- Connect Attempt ---------------\n    def _try_connect(self, tree, grid, target_node, obstacles, is_3d, bounds, nodes, edges):\n        target_pos = target_node.position\n        connect_thresh = self.step_size * 1.2\n\n        # Try direct connect via best local parent\n        rad = max(self.step_size * 2.0, 12.0)\n        neigh = self._grid_neighbors(grid, target_pos, rad)\n        if not neigh:\n            neigh = [self._nearest(grid, tree, target_pos, bounds)]\n        neigh.sort(key=lambda n: self._dist(n.position, target_pos))\n        candidates = neigh[:self.parent_k]\n        best_parent = None\n        best_g = float('inf')\n        for cand in candidates:\n            if self._hit_obstacle(cand.position, target_pos, obstacles, is_3d):\n                continue\n            g = cand.cost + self._dist(cand.position, target_pos)\n            if g < best_g:\n                best_g = g\n                best_parent = cand\n        if best_parent is not None:\n            if (not self._is_in_obstacle(target_pos, obstacles, is_3d)):\n                meet = Node(target_pos, parent=None, cost=best_g)\n                best_parent.add_child(meet)\n                tree.append(meet)\n                nodes.append(meet)\n                edges.append((best_parent, meet))\n                self._grid_add(grid, meet)\n                return meet\n\n        # Greedy bounded stepping toward target\n        current = self._nearest(grid, tree, target_pos, bounds)\n        steps = 0\n        while steps < self.connect_steps:\n            nxt = self._steer(current.position, target_pos, self.step_size)\n            if not self._in_bounds(nxt, bounds):\n                return None\n            if self._is_in_obstacle(nxt, obstacles, is_3d):\n                return None\n            if self._hit_obstacle(current.position, nxt, obstacles, is_3d):\n                return None\n\n            # Duplicate suppression in other tree\n            near_dups = self._grid_neighbors(grid, nxt, self.dup_radius)\n            dup = False\n            for nb in near_dups:\n                if self._dist(nb.position, nxt) <= self.dup_thresh:\n                    dup = True\n                    break\n            if dup:\n                return None\n\n            # Choose local parent\n            neigh2 = self._grid_neighbors(grid, nxt, rad)\n            if not neigh2:\n                neigh2 = [current]\n            neigh2.sort(key=lambda n: self._dist(n.position, nxt))\n            cand2 = neigh2[:self.parent_k]\n\n            best_p = None\n            best_g2 = float('inf')\n            for cand in cand2:\n                if self._hit_obstacle(cand.position, nxt, obstacles, is_3d):\n                    continue\n                g2 = cand.cost + self._dist(cand.position, nxt)\n                if g2 < best_g2:\n                    best_g2 = g2\n                    best_p = cand\n            if best_p is None:\n                return None\n\n            new_b = Node(nxt, parent=None, cost=best_g2)\n            best_p.add_child(new_b)\n            tree.append(new_b)\n            nodes.append(new_b)\n            edges.append((best_p, new_b))\n            self._grid_add(grid, new_b)\n\n            # Close enough for final snap\n            if self._dist(new_b.position, target_pos) <= connect_thresh:\n                if (not self._is_in_obstacle(target_pos, obstacles, is_3d)) and (not self._hit_obstacle(new_b.position, target_pos, obstacles, is_3d)):\n                    final_b = Node(target_pos, parent=None, cost=new_b.cost + self._dist(new_b.position, target_pos))\n                    new_b.add_child(final_b)\n                    tree.append(final_b)\n                    nodes.append(final_b)\n                    edges.append((new_b, final_b))\n                    self._grid_add(grid, final_b)\n                    return final_b\n                return None\n\n            current = new_b\n            steps += 1\n\n        return None\n\n    # --------------- Utilities ---------------\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _vec(self, a, b):\n        return tuple(a[i] - b[i] for i in range(len(a)))\n\n    def _norm(self, v):\n        return math.sqrt(sum(vi * vi for vi in v))\n\n    def _unit(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return tuple(0.0 for _ in v)\n        return tuple(vi / n for vi in v)\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0.0 <= pos[i] <= bounds[i] for i in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _hit_obstacle(self, a, b, obstacles, is_3d, res=1.0):\n        L = self._dist(a, b)\n        steps = max(1, int(L / res))\n        for i in range(steps + 1):\n            t = i / steps\n            p = tuple(a[d] + (b[d] - a[d]) * t for d in range(len(a)))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _path_cost(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(len(path) - 1):\n            s += self._dist(path[i], path[i + 1])\n        return s\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, attempts=80):\n        if len(path) < 3:\n            return path[:]\n        best = path[:]\n        best_cost = self._path_cost(best)\n        n = len(best)\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = best[i]\n            b = best[j]\n            if not self._hit_obstacle(a, b, obstacles, is_3d):\n                new_path = best[:i + 1] + best[j:]\n                new_cost = self._path_cost(new_path)\n                if new_cost < best_cost - 1e-9:\n                    best = new_path\n                    best_cost = new_cost\n                    n = len(best)\n        # Greedy corner culling\n        changed = True\n        while changed and len(best) > 2:\n            changed = False\n            k = 1\n            while k < len(best) - 1:\n                if not self._hit_obstacle(best[k - 1], best[k + 1], obstacles, is_3d):\n                    best.pop(k)\n                    changed = True\n                else:\n                    k += 1\n        return best\n\n    # --------------- Controls ---------------\n    def _post_update(self, found_first, post_iters, no_improve):\n        if found_first:\n            post_iters += 1\n            no_improve += 1\n        return post_iters, no_improve\n\n    def _should_stop(self, found_first, post_iters, no_improve):\n        if not found_first:\n            return False\n        if post_iters >= self.post_opt_iters:\n            return True\n        if no_improve >= self.no_improve_limit:\n            return True\n        return False",
          "objective": -12.24798,
          "time_improvement": -23.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1613.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.044426774978637694,
                    "num_nodes_avg": 56.4,
                    "path_length_avg": 157.31603480322116,
                    "smoothness_avg": 0.04606013663224119,
                    "success_improvement": 0.0,
                    "time_improvement": -74.23087675795257,
                    "node_improvement": 85.79702845630824,
                    "length_improvement": 13.772588492259377,
                    "smoothness_improvement": 620.9411594821662,
                    "objective_score": -10.901004134619315
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.16415343284606934,
                    "num_nodes_avg": 126.7,
                    "path_length_avg": 235.87995732976475,
                    "smoothness_avg": 0.12420346154518477,
                    "success_improvement": 0.0,
                    "time_improvement": -2.469518896922128,
                    "node_improvement": 91.4869313982396,
                    "length_improvement": 21.256480815202853,
                    "smoothness_improvement": 3095.8445256949494,
                    "objective_score": 27.49225544851982
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.045468711853027345,
                    "num_nodes_avg": 87.9,
                    "path_length_avg": 119.57596595535551,
                    "smoothness_avg": 0.09609107280574067,
                    "success_improvement": 0.0,
                    "time_improvement": 7.30440488486542,
                    "node_improvement": 88.82390336935792,
                    "length_improvement": 20.583337008070234,
                    "smoothness_improvement": 1122.2713533838182,
                    "objective_score": 20.152680437220855
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "CELLO-Connect: Cached-Edge Leader-Limited BiRRT. A fast bidirectional planner that combines beam-steered growth with edge-collision memoization, per-cell node quotas, and leader-based nearest search. Corridor-guided sampling narrows focus once a path bound is known; multi-hop ancestor line-of-sight compression reduces zig-zags without rewiring. A commit-free direct bridge terminates early with bounded shortcut smoothing, minimizing expansions and redundant checks.",
          "planning_mechanism": "Mechanism: Alternate growing start/goal trees. Each iteration, sample a small beam (goal/corridor/uniform), steer once from the hashed-nearest; validate node and edge; enforce per-cell quotas and duplicate suppression; choose the beam candidate that most reduces distance to the opposite tree. Before insertion, climb ancestors to the farthest line-of-sight parent, then insert and update grids/leaders/edges. Try an immediate direct bridge to the other tree; on success, extract and shortcut the path and return. Edge-collision checks are cached via quantized keys; nearest queries use limited grid rings with leader fallbacks to avoid full scans.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=7.0,\n                 goal_bias=0.22,\n                 corridor_bias=0.55,\n                 beam_k=3,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 cell_quota=6,\n                 dupe_radius_ratio=0.5,\n                 smoothing_iters=60,\n                 max_grid_ring=3,\n                 edge_cache_quant=1.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.beam_k = beam_k\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.cell_quota = cell_quota\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.smoothing_iters = smoothing_iters\n        self.max_grid_ring = max_grid_ring\n        self.edge_cache_quant = edge_cache_quant\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.dupe_radius = 1.0\n        self.start = None\n        self.goal = None\n        self._ecache = {}\n\n    # --------------- Planning ---------------\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n\n        # Configure resolutions\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.8 * self.step_size)\n        self.edge_res = max(0.75, min(self.collision_step, self.step_size * 0.5))\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self._ecache = {}\n\n        # Validate start/goal and early LOS path\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._pt_in_obs(self.start, obstacles, is_3d) or self._pt_in_obs(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n        if not self._edge_blocked(self.start, self.goal, obstacles, is_3d):\n            nodes = [Node(self.start), Node(self.goal)]\n            return PlannerResult(True, [self.start, self.goal], nodes, [])\n\n        # Initialize trees, grids, leaders, edges\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        leaders_start = []\n        leaders_goal = []\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n        self._maybe_set_leader(grid_start, leaders_start, start_root)\n        self._maybe_set_leader(grid_goal, leaders_goal, goal_root)\n\n        # Corridor parameters\n        dsg = self._dist(self.start, self.goal)\n        base_corridor = max(self.step_size, 0.2 * dsg)\n        c_best = float('inf')  # incumbent best path length bound\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            leaders_a = leaders_start if active_start else leaders_goal\n            leaders_b = leaders_goal if active_start else leaders_start\n            root_other = self.goal if active_start else self.start\n\n            best_cand = None\n            best_score = float('inf')\n\n            # Beam of candidates\n            for _ in range(self.beam_k):\n                # Sample\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = root_other\n                elif r < self.goal_bias + self.corridor_bias:\n                    width = base_corridor if c_best == float('inf') else max(self.step_size, 0.25 * (c_best - dsg) + base_corridor)\n                    x_rand = self._sample_corridor(width, obstacles, is_3d)\n                else:\n                    x_rand = self._sample_free(obstacles, is_3d)\n\n                # Nearest and steer\n                nearest = self._nearest_hash(grid_a, leaders_a, tree_a, x_rand)\n                if nearest is None:\n                    nearest = tree_a[0]\n                x_new = self._steer(nearest.position, x_rand, self.step_size)\n\n                # Bounds and collisions\n                if not self._in_bounds(x_new):\n                    continue\n                if self._pt_in_obs(x_new, obstacles, is_3d):\n                    continue\n                # Node separation and duplication suppression\n                if self._exists_close(grid_a, x_new, self.dupe_radius):\n                    continue\n                # Edge check from nearest\n                if self._edge_blocked(nearest.position, x_new, obstacles, is_3d):\n                    continue\n                # Per-cell quota\n                if self._cell_full(grid_a, x_new):\n                    continue\n\n                # Score: distance to nearest in the other tree\n                other_near = self._nearest_hash(grid_b, leaders_b, tree_b, x_new)\n                if other_near is None:\n                    score = self._dist(x_new, root_other)\n                else:\n                    score = self._dist(x_new, other_near.position)\n                if score < best_score:\n                    best_score = score\n                    best_cand = (nearest, x_new)\n\n            if best_cand is None:\n                continue\n\n            parent_node, new_pos = best_cand\n\n            # Multi-hop ancestor LOS compression before insertion\n            best_parent = parent_node\n            gp = parent_node.parent\n            while gp is not None:\n                if not self._edge_blocked(gp.position, new_pos, obstacles, is_3d):\n                    best_parent = gp\n                    gp = gp.parent\n                else:\n                    break\n\n            # Final edge validation with chosen parent (redundant safe-guard)\n            if self._edge_blocked(best_parent.position, new_pos, obstacles, is_3d):\n                continue\n            if self._pt_in_obs(new_pos, obstacles, is_3d):\n                continue\n\n            # Insert node\n            new_cost = best_parent.cost + self._dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            self._grid_add(grid_a, new_node)\n            self._maybe_set_leader(grid_a, leaders_a, new_node)\n\n            # Try direct bridge to opposite tree\n            other_near = self._nearest_hash(grid_b, leaders_b, tree_b, new_node.position)\n            if other_near is not None and not self._edge_blocked(new_node.position, other_near.position, obstacles, is_3d):\n                # Extract path and smooth\n                path = self._extract_path(new_node, other_near)\n                c_best = self._path_len(path)\n                path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # --------------- RNG ---------------\n    def _rand(self):\n        # LCG\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # --------------- Geometry ---------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        r = step / max(1e-9, d)\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # --------------- Collision (with cache) ---------------\n    def _pt_in_obs(self, p, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = p\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = p\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        # Symmetric quantized key\n        qa = tuple(int(a[i] / self.edge_cache_quant) for i in range(self.dim))\n        qb = tuple(int(b[i] / self.edge_cache_quant) for i in range(self.dim))\n        if qa <= qb:\n            key = (qa, qb, self.dim)\n        else:\n            key = (qb, qa, self.dim)\n        hit = self._ecache.get(key, None)\n        if hit is not None:\n            return hit\n        # Evaluate\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        blocked = False\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._pt_in_obs(p, obstacles, is_3d):\n                blocked = True\n                break\n        self._ecache[key] = blocked\n        return blocked\n\n    # --------------- Sampling ---------------\n    def _sample_free(self, obstacles, is_3d):\n        # Rejection with modest retries; always returns valid\n        for _ in range(64):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._pt_in_obs(p, obstacles, is_3d):\n                return p\n        # fallback deterministic scan-like sample\n        t = self._rand()\n        if self.dim == 3:\n            p = (t * self.bounds[0], (1.0 - t) * self.bounds[1], (0.5 + 0.5 * t) * self.bounds[2])\n        else:\n            p = (t * self.bounds[0], (1.0 - t) * self.bounds[1])\n        if not self._pt_in_obs(p, obstacles, is_3d):\n            return p\n        # ensure valid\n        return (min(self.bounds[0], max(0.0, p[0])), min(self.bounds[1], max(0.0, p[1]))) if self.dim == 2 else \\\n               (min(self.bounds[0], max(0.0, p[0])), min(self.bounds[1], max(0.0, p[1])), min(self.bounds[2], max(0.0, p[2])))\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        # Sample around start-goal segment with axis-aligned jitter\n        for _ in range(32):\n            t = self._rand()\n            base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n            if self.dim == 3:\n                p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                     self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                     self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n            else:\n                p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                     self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n            if not self._pt_in_obs(p, obstacles, is_3d):\n                return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # --------------- Grid and neighborhoods ---------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _cell_full(self, grid, pos):\n        k = self._grid_key(pos)\n        bucket = grid.get(k)\n        if bucket is None:\n            return False\n        return len(bucket) >= self.cell_quota\n\n    def _ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hash(self, grid, leaders, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        found = False\n        for r in range(0, self.max_grid_ring + 1):\n            cand = self._ring_collect(grid, key, r)\n            if cand:\n                found = True\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                break\n        if not found and leaders:\n            for n in leaders:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        if best is None and tree:\n            best = tree[0]\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r = int(radius / self.grid_cell) + 1\n        cand = self._ring_collect(grid, key, r)\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                di = n.position[i] - pos[i]\n                d += di * di\n            if d <= r2:\n                return True\n        return False\n\n    def _maybe_set_leader(self, grid, leaders, node):\n        k = self._grid_key(node.position)\n        # Set first node in cell as leader to sparsify fallback set\n        # if this cell has exactly one node (the newly added), it becomes leader\n        if len(grid.get(k, [])) == 1:\n            leaders.append(node)\n\n    # --------------- Paths and smoothing ---------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        # meet_a is in active tree; meet_b in other tree\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        # Greedy forward collapse\n        collapsed = [pts[0]]\n        last = pts[0]\n        for k in range(1, len(pts) - 1):\n            nxt = pts[k + 1]\n            if self._edge_blocked(last, nxt, obstacles, is_3d):\n                collapsed.append(pts[k])\n                last = pts[k]\n        collapsed.append(pts[-1])\n        return collapsed",
          "objective": -9.51759,
          "time_improvement": 36.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1559.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.019199538230895995,
                    "num_nodes_avg": 56.3,
                    "path_length_avg": 172.05318967894075,
                    "smoothness_avg": 0.049013113733349156,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 24.70413661749402,
                    "node_improvement": 85.82221102996726,
                    "length_improvement": 5.694920379714498,
                    "smoothness_improvement": 667.1616636069162,
                    "objective_score": -35.835998468888505
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06343717575073242,
                    "num_nodes_avg": 171.6,
                    "path_length_avg": 243.11852777140348,
                    "smoothness_avg": 0.1030962934635256,
                    "success_improvement": 0.0,
                    "time_improvement": 60.40060346802124,
                    "node_improvement": 88.470066518847,
                    "length_improvement": 18.840037651086,
                    "smoothness_improvement": 2552.7418880751943,
                    "objective_score": 42.18791307143394
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03833181858062744,
                    "num_nodes_avg": 114.0,
                    "path_length_avg": 129.60812530625563,
                    "smoothness_avg": 0.12252173094929772,
                    "success_improvement": 0.0,
                    "time_improvement": 21.854158818883292,
                    "node_improvement": 85.50540368722187,
                    "length_improvement": 13.920454447295166,
                    "smoothness_improvement": 1458.4673740616154,
                    "objective_score": 22.200857184350163
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "cross_over",
          "algorithm_description": "BCI-BiRRT: Beam-Compressed Informed BiRRT \u2014 a bidirectional planner that uses small-beam guided sampling, per-cell duplicate suppression, line-of-sight ancestor compression, grid-accelerated nearest/near queries, and k-near minimal-cost bridging with post-connection informed shortcuts to deliver fast, short, and smooth paths.",
          "planning_mechanism": "Mechanism: adaptively choose a tree to expand; sample a small beam (goal/line/informed-biased), steer and validate candidates, select the one that most reduces distance to the opposite tree, compress the parent via line-of-sight to an ancestor, commit the node (after node+edge checks and duplicate pruning), then attempt a k-near bridge to the opposite tree minimizing total start-to-goal cost; upon success, extract [start\u2192\u2026\u2192meetA, meetB\u2192\u2026\u2192goal], compress and shortcut, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=6.0,\n                 beam_k=3,\n                 goal_bias=0.18,\n                 line_bias=0.35,\n                 connect_radius_factor=3.0,\n                 k_bridge=6,\n                 occ_gain_ratio=0.99,\n                 compress_depth=3,\n                 smoothing_iters=100,\n                 ellipse_tries=90,\n                 switch_fail_thresh=6,\n                 grid_cell=None):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.connect_radius_factor = connect_radius_factor\n        self.k_bridge = k_bridge\n        self.occ_gain_ratio = occ_gain_ratio\n        self.compress_depth = compress_depth\n        self.smoothing_iters = smoothing_iters\n        self.ellipse_tries = ellipse_tries\n        self.switch_fail_thresh = switch_fail_thresh\n        self.grid_cell = grid_cell\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Basic parameters\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.9 * self.step_size)\n        self.edge_res = max(0.5, min(1.0, 0.5 * self.step_size))\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line check\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_res):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.append(g)\n            nodes = [s, g]\n            edges = [(s, g)]\n            return PlannerResult(True, [start, goal], nodes, edges)\n\n        # Initialize trees (start-rooted, goal-rooted)\n        s_root = Node(start, None, 0.0)\n        g_root = Node(goal, None, 0.0)\n        start_tree = [s_root]\n        goal_tree = [g_root]\n        edges = []\n\n        grid_s = {}\n        grid_g = {}\n        self._grid_add(grid_s, s_root, self.grid_cell)\n        self._grid_add(grid_g, g_root, self.grid_cell)\n\n        # Per-cell best cost to suppress near-duplicates\n        occ_cell = max(0.5, 0.7 * self.step_size)\n        occ_s = {self._occ_key(start, occ_cell): 0.0}\n        occ_g = {self._occ_key(goal, occ_cell): 0.0}\n\n        # Bookkeeping\n        failed_s = 0\n        failed_g = 0\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            # Choose which tree to grow (adaptive alternation)\n            active_start = (it % 2 == 0)\n            if (active_start and failed_s >= self.switch_fail_thresh) or ((not active_start) and failed_g >= self.switch_fail_thresh):\n                active_start = not active_start\n\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_s if active_start else grid_g\n            grid_b = grid_g if active_start else grid_s\n            occ_a = occ_s if active_start else occ_g\n            root_other = goal if active_start else start\n            root_self = start if active_start else goal\n\n            # Beam sampling\n            candidates = []\n            for _ in range(self.beam_k):\n                x_rand = None\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = root_other\n                else:\n                    # informed ellipsoid after first solution\n                    if best_len < float('inf'):\n                        got = False\n                        for _t in range(self.ellipse_tries):\n                            p = self._uniform_point()\n                            if self._in_bounds(p):\n                                if self._dist(p, start) + self._dist(p, goal) <= best_len:\n                                    x_rand = p\n                                    got = True\n                                    break\n                        if not got:\n                            x_rand = self._uniform_point()\n                    else:\n                        if self._rand() < self.line_bias:\n                            # line-biased with jitter\n                            t = self._uniform(0.0, 1.0)\n                            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n                            jit = 0.5 * self.step_size\n                            x_rand = tuple(self._clip(base[i] + self._uniform(-jit, jit), 0.0, self.bounds[i]) for i in range(self.dim))\n                        else:\n                            x_rand = self._uniform_point()\n\n                # Nearest and steer\n                n_near = self._nearest(grid_a, tree_a, x_rand, self.grid_cell)\n                x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n                if not self._in_bounds(x_new_pos):\n                    continue\n                if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(n_near.position, x_new_pos, obstacles, is_3d, self.edge_res):\n                    continue\n\n                # Line-of-sight ancestor compression (limited depth)\n                best_parent = n_near\n                best_cost = n_near.cost + self._dist(n_near.position, x_new_pos)\n                anc = n_near.parent\n                depth = 0\n                while anc is not None and depth < self.compress_depth:\n                    if not self._is_edge_in_obstacle(anc.position, x_new_pos, obstacles, is_3d, self.edge_res):\n                        alt = anc.cost + self._dist(anc.position, x_new_pos)\n                        if alt + 1e-12 < best_cost:\n                            best_cost = alt\n                            best_parent = anc\n                    anc = anc.parent\n                    depth += 1\n\n                # Duplicate suppression in occupancy grid\n                k_occ = self._occ_key(x_new_pos, occ_cell)\n                prev_best = occ_a.get(k_occ, float('inf'))\n                if best_cost >= prev_best * self.occ_gain_ratio:\n                    continue\n\n                # Progress score: distance to other tree after extension\n                other_near = self._nearest(grid_b, tree_b, x_new_pos, self.grid_cell)\n                score = self._dist(x_new_pos, other_near.position) if other_near is not None else self._dist(x_new_pos, root_other)\n                candidates.append((score, x_new_pos, best_parent, best_cost))\n\n            if not candidates:\n                if active_start:\n                    failed_s += 1\n                else:\n                    failed_g += 1\n                continue\n\n            # Commit the best candidate\n            candidates.sort(key=lambda t: t[0])\n            _, new_pos, parent, new_cost = candidates[0]\n\n            new_node = Node(new_pos, None, new_cost)\n            new_node.attach(parent)\n            tree_a.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(grid_a, new_node, self.grid_cell)\n            k_occ_new = self._occ_key(new_pos, occ_cell)\n            if new_cost < occ_a.get(k_occ_new, float('inf')):\n                occ_a[k_occ_new] = new_cost\n\n            if active_start:\n                failed_s = 0\n            else:\n                failed_g = 0\n\n            # Attempt k-near best-cost bridge to the other tree\n            r_conn = max(self.connect_radius_factor * self.step_size, self.step_size)\n            near_b = self._near(grid_b, new_pos, r_conn, self.grid_cell)\n            if not near_b:\n                nn_b = self._nearest(grid_b, tree_b, new_pos, self.grid_cell)\n                if nn_b is not None:\n                    near_b = [nn_b]\n\n            # Select up to k closest in Euclidean distance to new_pos\n            if len(near_b) > self.k_bridge:\n                # partial selection\n                dist_idx = [(self._dist(n.position, new_pos), i) for i, n in enumerate(near_b)]\n                dist_idx.sort(key=lambda t: t[0])\n                near_b = [near_b[i] for (_, i) in dist_idx[:self.k_bridge]]\n\n            best_bridge = None\n            best_total = best_len\n            for nb in near_b:\n                if not self._is_edge_in_obstacle(new_pos, nb.position, obstacles, is_3d, self.edge_res):\n                    total = new_node.cost + self._dist(new_pos, nb.position) + nb.cost\n                    if total + 1e-12 < best_total:\n                        best_total = total\n                        best_bridge = nb\n\n            if best_bridge is not None:\n                # Extract path\n                if active_start:\n                    meet_a = new_node\n                    meet_b = best_bridge\n                else:\n                    meet_a = best_bridge\n                    meet_b = new_node\n\n                path = self._extract_path(meet_a, meet_b)\n                path = self._compress(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n                plen = self._path_length(path)\n                if plen < best_len:\n                    best_len = plen\n                    best_path = path\n                return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        # If loop ends without connection\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- Random ----------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _uniform_point(self):\n        if self.dim == 3:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]),\n                    self._uniform(0.0, self.bounds[2]))\n        else:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]))\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return tuple(self._clip(to_pos[i], 0.0, self.bounds[i]) for i in range(self.dim))\n        r = step / d\n        return tuple(self._clip(from_pos[i] + (to_pos[i] - from_pos[i]) * r, 0.0, self.bounds[i]) for i in range(self.dim))\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Spatial hash ----------\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest(self, grid, nodes, pos, cell):\n        # Expand radius until found, then fallback to scan\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        limit = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > limit:\n                limit = self.bounds[i]\n        limit = limit * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        # Fallback\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        r2 = radius\n        for n in cand:\n            if self._dist(n.position, pos) <= r2:\n                out.append(n)\n        return out\n\n    def _occ_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    # ---------- Path utilities ----------\n    def _path_to_root(self, node):\n        seq = []\n        cur = node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _extract_path(self, meet_a, meet_b):\n        # meet_a is in start-tree side, meet_b is in goal-tree side\n        path_a = self._path_to_root(meet_a)\n        # ascend from meet_b to goal root\n        tail = []\n        cur = meet_b\n        while cur is not None:\n            tail.append(cur.position)\n            cur = cur.parent\n        # path: start ... meet_a, then straight to meet_b (implied), then ... goal\n        return path_a + tail\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.edge_res):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
          "objective": -4.32865,
          "time_improvement": -45.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1649.0,
          "node_improvement": 81.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05528700351715088,
                    "num_nodes_avg": 52.7,
                    "path_length_avg": 159.23267345792033,
                    "smoothness_avg": 0.04720018064341601,
                    "success_improvement": 0.0,
                    "time_improvement": -116.82202007111755,
                    "node_improvement": 86.72878368169226,
                    "length_improvement": 12.722048474535743,
                    "smoothness_improvement": 638.7853239022464,
                    "objective_score": -24.219450317102588
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.128195858001709,
                    "num_nodes_avg": 251.0,
                    "path_length_avg": 244.97426414775782,
                    "smoothness_avg": 0.11245472368962676,
                    "success_improvement": 0.0,
                    "time_improvement": 19.976282760218798,
                    "node_improvement": 83.13512060740442,
                    "length_improvement": 18.22053943424897,
                    "smoothness_improvement": 2793.541038397612,
                    "objective_score": 30.89291368060308
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06766645908355713,
                    "num_nodes_avg": 219.1,
                    "path_length_avg": 125.15812725071248,
                    "smoothness_avg": 0.12691495233302894,
                    "success_improvement": 0.0,
                    "time_improvement": -37.949425846041684,
                    "node_improvement": 72.14240305149396,
                    "length_improvement": 16.875931269650575,
                    "smoothness_improvement": 1514.3488257888052,
                    "objective_score": 6.312475136921865
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "UniGrid Informed RRT*-Fast (UG-IRRT*-F): a single-tree, cost-optimal planner that uses a uniform spatial hash for O(1)-average neighbor queries, \u03b3(log n/n)^(1/d) adaptive neighborhoods, informed ellipsoidal sampling after the first solution, duplicate-node suppression, lazy rewires with incremental cost push, and goal-side best-parent connection; it continues optimizing under a focused post-optimization budget and returns a compressed, shortcut-smoothed path.",
          "planning_mechanism": "At each iteration, sample (goal/line/ellipse-biased), steer one step from the nearest node, validate node and edge, choose the lowest-cost valid parent within an adaptive radius, add the node, and lazily rewire cheaper neighbors. If close to the goal, select the best-cost valid parent for the goal among nearby nodes and update the incumbent path. After finding a solution, restrict sampling to the informed set and terminate on a time/no-improvement budget, then compress and shortcut the path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=4200,\n                 step_size=5.0,\n                 gamma_radius=55.0,\n                 min_radius_factor=1.0,\n                 goal_bias=0.12,\n                 line_bias=0.38,\n                 connect_factor=2.0,\n                 near_cap=64,\n                 post_opt_iters=450,\n                 max_no_improve=180,\n                 smoothing_iters=160):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_radius = gamma_radius\n        self.min_radius_factor = min_radius_factor\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.connect_factor = connect_factor\n        self.near_cap = near_cap\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        root = Node(start, None, 0.0)\n        nodes = [root]\n\n        # spatial hash grid\n        cell = max(1.0, 0.8 * self.step_size)\n        grid = {}\n        self._grid_add(grid, root, cell)\n\n        # coarse occupancy to suppress duplicates\n        occ_cell = max(0.5, 0.6 * self.step_size)\n        occ = {self._occ_key(start, occ_cell): True}\n\n        success = False\n        best_cost = float('inf')\n        goal_node = None\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            # sample\n            if self._rand() < self.goal_bias:\n                x_rand = goal\n            else:\n                x_rand = self._sample_biased(start, goal, best_cost)\n\n            # nearest\n            n_near = self._nearest(grid, nodes, x_rand, cell)\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n\n            # bounds and node collision\n            if not self._in_bounds(x_new_pos):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # duplicate suppression\n            k_occ = self._occ_key(x_new_pos, occ_cell)\n            if k_occ in occ:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # incoming edge collision\n            if self._is_edge_in_obstacle(n_near.position, x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # choose best parent within adaptive radius\n            r_near = self._rrtstar_radius(max(2, len(nodes)))\n            near_nodes = self._near(grid, x_new_pos, r_near, cell)\n            if near_nodes:\n                near_nodes = self._limit_by_distance(near_nodes, x_new_pos, self.near_cap)\n            best_parent = n_near\n            best_pc = n_near.cost + self._dist(n_near.position, x_new_pos)\n            for nn in near_nodes:\n                if nn is n_near:\n                    continue\n                c = nn.cost + self._dist(nn.position, x_new_pos)\n                if c + 1e-12 < best_pc:\n                    if not self._is_edge_in_obstacle(nn.position, x_new_pos, obstacles, is_3d):\n                        best_pc = c\n                        best_parent = nn\n\n            # commit new node (both checks were done above for chosen parent)\n            x_new = Node(x_new_pos, None, best_pc)\n            x_new.attach(best_parent)\n            nodes.append(x_new)\n            self._grid_add(grid, x_new, cell)\n            occ[k_occ] = True\n\n            # rewire nearby nodes\n            for nn in near_nodes:\n                if nn is best_parent or nn is x_new:\n                    continue\n                alt = x_new.cost + self._dist(x_new.position, nn.position)\n                if alt + 1e-12 < nn.cost:\n                    if not self._is_edge_in_obstacle(x_new.position, nn.position, obstacles, is_3d):\n                        nn.attach(x_new)\n                        self._propagate_costs_from(nn)\n\n            # goal-side best-parent connection when close\n            improved = False\n            r_conn = max(r_near, self.connect_factor * self.step_size)\n            if self._dist(x_new.position, goal) <= r_conn:\n                if not self._is_in_obstacle(goal, obstacles, is_3d):\n                    # consider best parent among nodes near goal (including x_new)\n                    cand = self._near(grid, goal, r_conn, cell)\n                    if x_new not in cand:\n                        cand.append(x_new)\n                    best_parent_goal = None\n                    best_goal_cost = best_cost\n                    for p in cand:\n                        if not self._is_edge_in_obstacle(p.position, goal, obstacles, is_3d):\n                            ctot = p.cost + self._dist(p.position, goal)\n                            if ctot + 1e-12 < best_goal_cost:\n                                best_goal_cost = ctot\n                                best_parent_goal = p\n                    if best_parent_goal is not None:\n                        if goal_node is None:\n                            goal_node = Node(goal, None, best_goal_cost)\n                            goal_node.attach(best_parent_goal)\n                            nodes.append(goal_node)\n                        else:\n                            goal_node.cost = best_goal_cost\n                            goal_node.attach(best_parent_goal)\n                        best_cost = best_goal_cost\n                        success = True\n                        found_first = True\n                        improved = True\n                        post_iters = 0\n                        no_improve = 0\n\n            if found_first and not improved:\n                post_iters += 1\n                no_improve += 1\n\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        path = []\n        if success and goal_node is not None:\n            # extract\n            cur = goal_node\n            while cur is not None:\n                path.append(cur.position)\n                cur = cur.parent\n            path.reverse()\n            # postprocess\n            path = self._compress(path, obstacles, is_3d)\n            path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n\n        # build edges from parent pointers\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # ---------- Utilities ----------\n    def _rand(self):\n        try:\n            return self._lcg_next()\n        except:\n            return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 1103515245\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = min(1.0, 0.5 * self.step_size)\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _log_approx(self, n):\n        if n <= 1:\n            return 0.0\n        return (int(n).bit_length()) * 0.6931471805599453\n\n    def _rrtstar_radius(self, n):\n        r = self.gamma_radius\n        if n > 2:\n            expo = 1.0 / float(max(2, self.dim))\n            r = self.gamma_radius * ((self._log_approx(n) / float(n)) ** expo)\n        rmin = max(self.min_radius_factor * self.step_size, 1e-6)\n        if r < rmin:\n            r = rmin\n        return r\n\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest(self, grid, nodes, pos, cell):\n        # exponential expansion until candidates appear\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        max_span = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > max_span:\n                max_span = self.bounds[i]\n        limit = max_span * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        # fallback linear scan\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _limit_by_distance(self, nodes, center, k):\n        # partial selection of up to k nearest without full sort when large\n        if len(nodes) <= k:\n            return nodes\n        # simple reservoir based on distance threshold\n        # compute distances\n        idx = []\n        for i, n in enumerate(nodes):\n            idx.append((self._dist(n.position, center), i))\n        # partial selection: nth-element by repeated scanning (k small)\n        # choose k smallest by single pass selection\n        # fallback: simple sort when moderate\n        if len(nodes) <= 4 * k:\n            idx.sort(key=lambda t: t[0])\n            sel = [nodes[t[1]] for t in idx[:k]]\n            return sel\n        # approximate: pick k minima by iterative pass\n        sel = []\n        used = [False] * len(nodes)\n        for _ in range(k):\n            best = -1\n            bestd = float('inf')\n            for j, (d, i) in enumerate(idx):\n                if not used[j] and d < bestd:\n                    bestd = d\n                    best = j\n            if best == -1:\n                break\n            used[best] = True\n            sel.append(nodes[idx[best][1]])\n        return sel\n\n    def _occ_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _sample_biased(self, start, goal, c_best):\n        # informed ellipsoidal rejection after first solution; else line/uniform mix\n        if c_best < float('inf'):\n            for _ in range(20):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._dist(p, start) + self._dist(p, goal) <= c_best and self._in_bounds(p):\n                    return p\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jitter = 0.5 * self.step_size\n            p = tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n            return p\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _propagate_costs_from(self, node):\n        stack = []\n        for c in node.children:\n            stack.append(c)\n        while stack:\n            u = stack.pop()\n            if u.parent is not None:\n                u.cost = u.parent.cost + self._dist(u.parent.position, u.position)\n            for c in u.children:\n                stack.append(c)\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
          "objective": -3.65664,
          "time_improvement": -50.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1436.0,
          "node_improvement": 46.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06231374740600586,
                    "num_nodes_avg": 244.5,
                    "path_length_avg": 159.99708988452147,
                    "smoothness_avg": 0.04079917273665813,
                    "success_improvement": 0.0,
                    "time_improvement": -144.3791801192523,
                    "node_improvement": 38.42860740367666,
                    "length_improvement": 12.303059718162231,
                    "smoothness_improvement": 538.5956501503387,
                    "objective_score": -33.238939954126664
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.11423308849334717,
                    "num_nodes_avg": 663.4,
                    "path_length_avg": 229.07326285952672,
                    "smoothness_avg": 0.10084089211799352,
                    "success_improvement": 0.0,
                    "time_improvement": 28.69226420016899,
                    "node_improvement": 55.42565343008802,
                    "length_improvement": 23.528751349205564,
                    "smoothness_improvement": 2494.7087869547277,
                    "objective_score": 35.19847400434767
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06615550518035888,
                    "num_nodes_avg": 438.5,
                    "path_length_avg": 117.70760748606574,
                    "smoothness_avg": 0.108123212990666,
                    "success_improvement": 0.0,
                    "time_improvement": -34.86909289750288,
                    "node_improvement": 44.24666242848061,
                    "length_improvement": 21.824211741702758,
                    "smoothness_improvement": 1275.3192884158632,
                    "objective_score": 9.010395617850108
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a sampling-based path planning algorithm that incrementally builds a space-filling tree rooted at the start position by randomly sampling the configuration space and extending the nearest existing node toward the sample. It continues this process until the goal is reached or a maximum number of iterations is exceeded.",
          "planning_mechanism": "The planner randomly samples free configurations, finds the nearest node in the current tree, attempts to extend toward the sample by a fixed step size, and adds the new node if the move is valid. This repeats until the goal is reached or iteration limit is hit.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            unit = tuple(d / length for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, length) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_position))\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -0.34654308134575357,
          "time_improvement": 4.0,
          "length_improvement": -1.0,
          "smoothness_improvement": -1.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019024872779846193,
                    "num_nodes_avg": 342.1,
                    "path_length_avg": 183.43739556264873,
                    "smoothness_avg": 0.006385834396773478,
                    "success_improvement": 0.0,
                    "time_improvement": 25.389131526315634,
                    "node_improvement": 13.850415512465371,
                    "length_improvement": -0.5449432594320321,
                    "smoothness_improvement": -0.04782462915247019,
                    "objective_score": 7.289534379089709
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.17418217658996582,
                    "num_nodes_avg": 1516.5,
                    "path_length_avg": 301.18370128226945,
                    "smoothness_avg": 0.0038900242992520456,
                    "success_improvement": 0.0,
                    "time_improvement": -8.729762918387298,
                    "node_improvement": -1.8947792783712991,
                    "length_improvement": -0.5437885801920883,
                    "smoothness_improvement": 0.09312709100540162,
                    "objective_score": -2.9447363881764153
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05132777690887451,
                    "num_nodes_avg": 764.9,
                    "path_length_avg": 155.33909758301323,
                    "smoothness_avg": 0.007676382971521437,
                    "success_improvement": 0.0,
                    "time_improvement": -4.640281912631381,
                    "node_improvement": 2.7463445645263858,
                    "length_improvement": -3.1688321616952084,
                    "smoothness_improvement": -2.3569752138986897,
                    "objective_score": -3.3051687468760327
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "GH-Connect-Lite: Guided Hash RRT-Connect Lite \u2014 a single-tree, grid-accelerated planner that combines fast goal/line-biased informed sampling, lightweight duplicate suppression, short greedy goal-connection, and bounded smoothing. It commits only validated nodes/edges, uses an occupancy-cost ledger to avoid redundant expansions, and performs micro local shortcuts and post-improvement polishing for shorter, smoother paths while keeping per-iteration work small.",
          "planning_mechanism": "Initialize with early straight-line check. Maintain a hash-grid for fast nearest queries and a per-cell best-cost ledger. Each iteration: sample (goal/line/uniform; switch to ellipsoid gating after first solution), steer one step, validate node and edge, apply duplicate-cost filter, then commit the node. Perform a tiny greedy connect toward the goal (few steps) with the same validations and a local grandparent shortcut if it lowers cost. When near the goal, attempt a direct validated bridge; on improvement, run bounded compression/shortcuts to tighten c_best and focus sampling. Use post-optimization and no-improvement budgets to terminate early and return the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=4.0,\n        goal_bias=0.2,\n        line_bias=0.35,\n        connect_steps=2,\n        connect_radius_factor=3.0,\n        occ_relax=1.02,\n        post_opt_iters=500,\n        max_no_improve=220,\n        smoothing_iters=220,\n        online_shortcuts_per_improve=40\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.connect_steps = connect_steps\n        self.connect_radius_factor = connect_radius_factor\n        self.occ_relax = occ_relax\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n        self.online_shortcuts_per_improve = online_shortcuts_per_improve\n\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Early straight-line feasibility\n        if self._in_bounds(start) and self._in_bounds(goal):\n            if (not self._is_in_obstacle(start, obstacles, is_3d)) and (not self._is_in_obstacle(goal, obstacles, is_3d)):\n                if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d):\n                    s = Node(start, None, 0.0)\n                    g = Node(goal, None, self._dist(start, goal))\n                    g.attach(s)\n                    nodes = [s, g]\n                    edges = [(s, g)]\n                    path = [start, goal]\n                    return PlannerResult(success=True, path=path, nodes=nodes, edges=edges)\n\n        root = Node(start, None, 0.0)\n        nodes = [root]\n\n        cell = max(1.0, 0.8 * self.step_size)\n        grid = {}\n        self._grid_add(grid, root, cell)\n\n        occ_cell = max(0.5, 0.6 * self.step_size)\n        occ_best = {self._grid_key(start, occ_cell): 0.0}\n\n        success = False\n        goal_node = None\n        best_cost = float('inf')\n        best_path_pts = None\n\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            # Sampling\n            if self._rand() < self.goal_bias:\n                x_rand = goal\n            else:\n                x_rand = self._sample(start, goal, best_cost)\n\n            # Nearest\n            n_near = self._nearest(grid, nodes, x_rand, cell)\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n\n            # Bounds and node collision\n            if not self._in_bounds(x_new_pos):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Edge collision for candidate parent\n            if self._is_edge_in_obstacle(n_near.position, x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            base_cost = n_near.cost + self._dist(n_near.position, x_new_pos)\n\n            # Duplicate suppression\n            ok = self._occ_accept(occ_best, x_new_pos, base_cost, occ_cell, self.occ_relax)\n            if not ok:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Commit new node\n            x_new = Node(x_new_pos, None, base_cost)\n            x_new.attach(n_near)\n            nodes.append(x_new)\n            self._grid_add(grid, x_new, cell)\n            self._occ_update(occ_best, x_new_pos, base_cost, occ_cell)\n\n            # Local grandparent shortcut\n            gp = n_near.parent\n            if gp is not None:\n                alt = gp.cost + self._dist(gp.position, x_new.position)\n                if alt + 1e-12 < x_new.cost:\n                    if not self._is_edge_in_obstacle(gp.position, x_new.position, obstacles, is_3d):\n                        x_new.attach(gp)\n                        x_new.cost = alt\n                        self._occ_update(occ_best, x_new_pos, alt, occ_cell)\n\n            # Tiny greedy connect toward goal (few validated steps)\n            cur = x_new\n            for _ in range(self.connect_steps):\n                if self._dist(cur.position, goal) <= self.connect_radius_factor * self.step_size:\n                    break\n                step_pos = self._steer(cur.position, goal, self.step_size)\n                if not self._in_bounds(step_pos) or self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(cur.position, step_pos, obstacles, is_3d):\n                    break\n                c_cost = cur.cost + self._dist(cur.position, step_pos)\n                if not self._occ_accept(occ_best, step_pos, c_cost, occ_cell, self.occ_relax):\n                    break\n                nxt = Node(step_pos, None, c_cost)\n                nxt.attach(cur)\n                nodes.append(nxt)\n                self._grid_add(grid, nxt, cell)\n                self._occ_update(occ_best, step_pos, c_cost, occ_cell)\n                # Local grandparent shortcut for connect step\n                gp2 = cur.parent\n                if gp2 is not None:\n                    alt2 = gp2.cost + self._dist(gp2.position, nxt.position)\n                    if alt2 + 1e-12 < nxt.cost:\n                        if not self._is_edge_in_obstacle(gp2.position, nxt.position, obstacles, is_3d):\n                            nxt.attach(gp2)\n                            nxt.cost = alt2\n                            self._occ_update(occ_best, step_pos, alt2, occ_cell)\n                cur = nxt\n\n            # Try direct goal connection when near\n            improved = False\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                r_conn = self.connect_radius_factor * self.step_size\n                tip = cur\n                if self._dist(tip.position, goal) <= r_conn:\n                    if not self._is_edge_in_obstacle(tip.position, goal, obstacles, is_3d):\n                        g_cost = tip.cost + self._dist(tip.position, goal)\n                        if g_cost + 1e-12 < best_cost:\n                            if goal_node is None:\n                                goal_node = Node(goal, None, g_cost)\n                                goal_node.attach(tip)\n                                nodes.append(goal_node)\n                            else:\n                                goal_node.attach(tip)\n                                goal_node.cost = g_cost\n                            best_cost = g_cost\n                            success = True\n                            found_first = True\n                            improved = True\n\n            # Post-improvement polishing\n            if improved and goal_node is not None:\n                cur_path = self._extract_path(goal_node)\n                cur_path = self._compress(cur_path, obstacles, is_3d)\n                cur_path = self._shortcuts(cur_path, obstacles, is_3d, self.online_shortcuts_per_improve)\n                L = self._path_length(cur_path)\n                if L + 1e-12 < best_cost:\n                    best_cost = L\n                best_path_pts = cur_path\n                post_iters = 0\n                no_improve = 0\n            else:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        # Final path\n        path = []\n        if success and goal_node is not None:\n            if best_path_pts is None:\n                path = self._extract_path(goal_node)\n                path = self._compress(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n            else:\n                path = self._shortcuts(best_path_pts, obstacles, is_3d, self.smoothing_iters)\n\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # --------- Utilities ---------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 390451501\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = min(1.0, 0.5 * self.step_size)\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Spatial hashing\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest(self, grid, nodes, pos, cell):\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        limit = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > limit:\n                limit = self.bounds[i]\n        limit = limit * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    # Sampling with informed gating after first solution\n    def _sample(self, start, goal, c_best):\n        if c_best < float('inf'):\n            for _ in range(120):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._in_bounds(p):\n                    if self._dist(p, start) + self._dist(p, goal) <= c_best:\n                        return p\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jitter = 0.5 * self.step_size\n            return tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    # Occupancy cost ledger\n    def _occ_accept(self, occ_best, pos, cost, cell, relax):\n        k = self._grid_key(pos, cell)\n        prev = occ_best.get(k, float('inf'))\n        return cost < prev * relax\n\n    def _occ_update(self, occ_best, pos, cost, cell):\n        k = self._grid_key(pos, cell)\n        prev = occ_best.get(k, float('inf'))\n        if cost < prev:\n            occ_best[k] = cost\n\n    # Path utilities\n    def _extract_path(self, goal_node):\n        seq = []\n        cur = goal_node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
          "objective": 2.59026,
          "time_improvement": -73.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1563.0,
          "node_improvement": 9.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06812853813171386,
                    "num_nodes_avg": 406.1,
                    "path_length_avg": 156.52382632264067,
                    "smoothness_avg": 0.05238387996289982,
                    "success_improvement": 0.0,
                    "time_improvement": -167.18335815808737,
                    "node_improvement": -2.2664316293125157,
                    "length_improvement": 14.20681051381224,
                    "smoothness_improvement": 719.921474835408,
                    "objective_score": -38.03131376496182
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.16287810802459718,
                    "num_nodes_avg": 1172.8,
                    "path_length_avg": 229.408680422303,
                    "smoothness_avg": 0.09093924935533,
                    "success_improvement": 0.0,
                    "time_improvement": -1.673422716490134,
                    "node_improvement": 21.198683061210776,
                    "length_improvement": 23.4167793122916,
                    "smoothness_improvement": 2239.9323868063857,
                    "objective_score": 24.747702706459847
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0729496955871582,
                    "num_nodes_avg": 734.6,
                    "path_length_avg": 121.75542214035515,
                    "smoothness_avg": 0.1438275075521862,
                    "success_improvement": 0.0,
                    "time_improvement": -48.7201895619418,
                    "node_improvement": 6.598855689764778,
                    "length_improvement": 19.135845984544524,
                    "smoothness_improvement": 1729.4752798215147,
                    "objective_score": 5.512827121251748
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "SPARKL-RRT*: Sparse Path-Aware Rewired K-Limited RRT* \u2014 a single-tree, path-quality\u2013focused planner that mixes corridor-guided and informed sampling, uses early heuristic and per-cell gates to curb wasteful expansions, selects parents from a capped K-neighborhood, applies on-the-fly line-of-sight ancestor compression, performs bounded rewiring for local optimality, and incrementally shortens the incumbent path to minimize length while keeping search time low.",
          "planning_mechanism": "Each iteration samples with a blend of goal/line/uniform and, after the first solution, corridor and ellipse-biased points; a node is steered with an adaptive step, quickly pruned by g+h and per-cell cost gates, then attached to the cheapest collision-free parent among the K nearest within an adaptive radius; the parent is upgraded to the farthest visible ancestor (compression), neighbors are rewired within a small cap when beneficial, and a bounded goal-connection is attempted; upon improvement, short-cutting tightens c_best to refocus sampling; termination uses improvement/time budgets.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_explore=6.0,\n                 step_refine=3.0,\n                 gamma_radius=50.0,\n                 k_parent=16,\n                 k_rewire=10,\n                 near_cap=40,\n                 goal_bias=0.12,\n                 line_bias=0.28,\n                 corridor_bias=0.45,\n                 prune_margin=1.002,\n                 occ_gain=1.01,\n                 post_opt_iters=400,\n                 no_improve_limit=220,\n                 smoothing_iters=140,\n                 shortcuts_per_improve=30):\n        self.max_iter = max_iter\n        self.step_explore = step_explore\n        self.step_refine = step_refine\n        self.gamma_radius = gamma_radius\n        self.k_parent = k_parent\n        self.k_rewire = k_rewire\n        self.near_cap = near_cap\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.corridor_bias = corridor_bias\n        self.prune_margin = prune_margin\n        self.occ_gain = occ_gain\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit\n        self.smoothing_iters = smoothing_iters\n        self.shortcuts_per_improve = shortcuts_per_improve\n\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(success=False, path=[], nodes=[], edges=[])\n\n        # Early straight-line feasibility\n        if (not self._is_in_obstacle(start, obstacles, is_3d)) and (not self._is_in_obstacle(goal, obstacles, is_3d)):\n            if not self._edge_blocked(start, goal, obstacles, is_3d, min(1.0, 0.6 * self.step_explore)):\n                s = Node(start, None, 0.0)\n                g = Node(goal, s, self._dist(start, goal))\n                s.children.append(g)\n                nodes = [s, g]\n                edges = [(s, g)]\n                return PlannerResult(success=True, path=[start, goal], nodes=nodes, edges=edges)\n\n        root = Node(start, None, 0.0)\n        nodes = [root]\n        grid = {}\n        cell = max(1.0, 0.8 * self.step_explore)\n        self._grid_add(grid, root, cell)\n\n        occ_cell = max(0.75, 0.7 * self.step_explore)\n        occ_best = {self._occ_key(start, occ_cell): 0.0}\n\n        best_cost = float('inf')\n        goal_node = None\n        best_path_pts = None\n        found = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            step = self.step_refine if found else self.step_explore\n            # Sampling strategy\n            r = self._randf()\n            if r < self.goal_bias:\n                x_rand = goal\n            else:\n                if found and self._randf() < self.corridor_bias and best_path_pts is not None:\n                    x_rand = self._sample_corridor(best_path_pts, 1.5 * step)\n                else:\n                    x_rand = self._sample_informed_or_line(start, goal, best_cost, step)\n\n            # Nearest node\n            n_near = self._nearest(grid, nodes, x_rand, cell)\n            x_new_pos = self._steer(n_near.position, x_rand, step)\n\n            # Bounds and node collision\n            if not self._in_bounds(x_new_pos):\n                if found:\n                    post_iters += 1; no_improve += 1\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                if found:\n                    post_iters += 1; no_improve += 1\n                continue\n\n            # Early heuristic gate using cheap lower-bound g+h\n            g_lb = n_near.cost + self._dist(n_near.position, x_new_pos)\n            if best_cost < float('inf'):\n                if g_lb + self._dist(x_new_pos, goal) >= best_cost * self.prune_margin:\n                    post_iters += 1; no_improve += 1\n                    continue\n\n            # Per-cell cost suppression (soft to keep alternatives for path quality)\n            k_occ = self._occ_key(x_new_pos, occ_cell)\n            prev = occ_best.get(k_occ, float('inf'))\n            if g_lb >= prev * self.occ_gain:\n                if found:\n                    post_iters += 1; no_improve += 1\n                continue\n\n            # Candidate parents: K nearest within adaptive radius\n            r_near = self._rrtstar_radius(max(2, len(nodes)))\n            near_nodes = self._near(grid, x_new_pos, r_near, cell)\n            if n_near not in near_nodes:\n                near_nodes.append(n_near)\n            if len(near_nodes) > self.near_cap:\n                near_nodes = self._k_limit(near_nodes, x_new_pos, self.near_cap)\n            cand = self._k_limit(near_nodes, x_new_pos, self.k_parent)\n\n            best_parent = None\n            best_pc = float('inf')\n            # Parent selection with heuristic pruning\n            for nn in cand:\n                base = nn.cost + self._dist(nn.position, x_new_pos)\n                if base >= best_pc:\n                    continue\n                if best_cost < float('inf'):\n                    if base + self._dist(x_new_pos, goal) >= best_cost * self.prune_margin:\n                        continue\n                if not self._edge_blocked(nn.position, x_new_pos, obstacles, is_3d, min(1.0, 0.6 * step)):\n                    best_parent = nn\n                    best_pc = base\n\n            if best_parent is None:\n                if found:\n                    post_iters += 1; no_improve += 1\n                continue\n\n            # On-the-fly line-of-sight ancestor compression (bounded hops)\n            compressed_parent = best_parent\n            compressed_cost = best_pc\n            hops = 0\n            anc = best_parent.parent\n            while anc is not None and hops < 5:\n                hops += 1\n                trial_cost = anc.cost + self._dist(anc.position, x_new_pos)\n                if trial_cost + 1e-12 < compressed_cost:\n                    if not self._edge_blocked(anc.position, x_new_pos, obstacles, is_3d, min(1.0, 0.6 * step)):\n                        compressed_parent = anc\n                        compressed_cost = trial_cost\n                anc = anc.parent\n\n            # Ensure both checks before adding: node collision checked; edge collision checked above\n            # Commit new node\n            new_node = Node(x_new_pos, None, compressed_cost)\n            new_node.attach(compressed_parent)\n            nodes.append(new_node)\n            self._grid_add(grid, new_node, cell)\n            if compressed_cost < prev:\n                occ_best[k_occ] = compressed_cost\n\n            # Bounded rewiring for local optimality and length reduction\n            rewire_neighbors = self._k_limit(near_nodes, x_new_pos, self.k_rewire)\n            for nn in rewire_neighbors:\n                if nn is new_node or nn is compressed_parent:\n                    continue\n                alt = new_node.cost + self._dist(new_node.position, nn.position)\n                if alt + 1e-12 < nn.cost:\n                    if best_cost < float('inf'):\n                        # prune rewires unlikely to improve global path\n                        if alt + self._dist(nn.position, goal) >= best_cost * self.prune_margin:\n                            continue\n                    if not self._edge_blocked(new_node.position, nn.position, obstacles, is_3d, min(1.0, 0.6 * step)):\n                        nn.attach(new_node)\n                        nn.cost = alt\n                        self._propagate_costs_from(nn)\n\n            # Try connecting/improving goal with a small candidate set\n            improved = False\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                r_conn = max(r_near, 2.5 * step)\n                gcand = self._near(grid, goal, r_conn, cell)\n                if new_node not in gcand:\n                    gcand.append(new_node)\n                best_goal_parent = None\n                best_goal_cost = best_cost\n                for p in self._k_limit(gcand, goal, min(self.k_parent, 1 + self.k_parent // 2)):\n                    ctot = p.cost + self._dist(p.position, goal)\n                    if ctot + 1e-12 < best_goal_cost:\n                        if not self._edge_blocked(p.position, goal, obstacles, is_3d, min(1.0, 0.6 * step)):\n                            best_goal_cost = ctot\n                            best_goal_parent = p\n                if best_goal_parent is not None:\n                    if goal_node is None:\n                        goal_node = Node(goal, best_goal_parent, best_goal_cost)\n                        best_goal_parent.children.append(goal_node)\n                        nodes.append(goal_node)\n                    else:\n                        goal_node.attach(best_goal_parent)\n                        goal_node.cost = best_goal_cost\n                    best_cost = best_goal_cost\n                    improved = True\n                    found = True\n\n            if improved and goal_node is not None:\n                cur_path = self._extract_path(goal_node)\n                cur_path = self._compress(cur_path, obstacles, is_3d)\n                cur_path = self._shortcuts(cur_path, obstacles, is_3d, self.shortcuts_per_improve)\n                path_len = self._path_length(cur_path)\n                if path_len + 1e-12 < best_cost:\n                    best_cost = path_len\n                best_path_pts = cur_path\n                post_iters = 0\n                no_improve = 0\n            else:\n                if found:\n                    post_iters += 1\n                    no_improve += 1\n\n            if found and (post_iters >= self.post_opt_iters or no_improve >= self.no_improve_limit):\n                break\n\n        # Finalize path\n        path = []\n        success = (goal_node is not None)\n        if success:\n            if best_path_pts is None:\n                path = self._extract_path(goal_node)\n                path = self._compress(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n            else:\n                path = self._shortcuts(best_path_pts, obstacles, is_3d, self.smoothing_iters)\n\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # ------------- Utilities -------------\n    def _randf(self):\n        # xorshift32\n        if not hasattr(self, \"_xs\"):\n            self._xs = 2463534242\n        x = self._xs\n        x ^= (x << 13) & 0xFFFFFFFF\n        x ^= (x >> 17) & 0xFFFFFFFF\n        x ^= (x << 5) & 0xFFFFFFFF\n        self._xs = x & 0xFFFFFFFF\n        return (self._xs % 1000003) / 1000003.0\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._randf()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return 0.0 if s <= 0.0 else s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _steer(self, frm, to, step):\n        d = self._dist(frm, to)\n        if d <= step:\n            return to\n        r = step / d\n        return tuple(frm[i] + (to[i] - frm[i]) * r for i in range(self.dim))\n\n    def _clip(self, v, lo, hi):\n        return lo if v < lo else (hi if v > hi else v)\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_blocked(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _rrtstar_radius(self, n):\n        expo = 1.0 / float(max(2, self.dim))\n        r = self.gamma_radius * ((self._ln_approx(n) / float(n)) ** expo) if n > 2 else self.gamma_radius\n        rmin = max(1.0, 1.25 * min(self.step_explore, self.step_refine))\n        return r if r > rmin else rmin\n\n    def _ln_approx(self, n):\n        if n <= 1:\n            return 0.0\n        return (int(n).bit_length()) * 0.6931471805599453\n\n    # Spatial hashing\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        grid.setdefault(k, []).append(node)\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        out = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        out.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            out.extend(grid[k])\n        return out\n\n    def _nearest(self, grid, nodes, pos, cell):\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        max_span = max(self.bounds[i] for i in range(self.dim))\n        limit = max_span * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        # fallback\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _k_limit(self, nodes, center, k):\n        if len(nodes) <= k:\n            return list(nodes)\n        # Select k nearest without full sort\n        best = []\n        best_d = []\n        for n in nodes:\n            d = self._dist(n.position, center)\n            if len(best) < k:\n                best.append(n)\n                best_d.append(d)\n            else:\n                # find worst\n                wi = 0\n                wv = best_d[0]\n                for i in range(1, k):\n                    if best_d[i] > wv:\n                        wi = i\n                        wv = best_d[i]\n                if d < wv:\n                    best[wi] = n\n                    best_d[wi] = d\n        return best\n\n    def _occ_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _extract_path(self, goal_node):\n        seq = []\n        cur = goal_node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._edge_blocked(path[i], path[j], obstacles, is_3d, min(1.0, 0.6 * self.step_refine)):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d, min(1.0, 0.6 * self.step_refine)):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts\n\n    def _propagate_costs_from(self, node):\n        # BFS over subtree to refresh costs\n        q = []\n        for c in node.children:\n            q.append(c)\n        while q:\n            u = q.pop()\n            if u.parent is not None:\n                u.cost = u.parent.cost + self._dist(u.parent.position, u.position)\n            for c in u.children:\n                q.append(c)\n\n    def _sample_informed_or_line(self, start, goal, c_best, step):\n        # Try informed ellipse; else line-biased; else uniform\n        if c_best < float('inf'):\n            # rejection sampling inside triangle inequality set\n            for _ in range(30):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._dist(p, start) + self._dist(p, goal) <= c_best * 1.01:\n                    return p\n        if self._randf() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jitter = 0.6 * step\n            p = tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n            return p\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _sample_corridor(self, path, radius):\n        # pick a random segment and sample around it\n        m = len(path)\n        if m < 2:\n            return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n        i = int(self._uniform(0, m - 1))\n        if i >= m - 1:\n            i = m - 2\n        a = path[i]\n        b = path[i + 1]\n        t = self._uniform(0.0, 1.0)\n        base = tuple(a[d] + t * (b[d] - a[d]) for d in range(self.dim))\n        if self.dim == 2:\n            ox = self._uniform(-radius, radius)\n            oy = self._uniform(-radius, radius)\n            p = (self._clip(base[0] + ox, 0.0, self.bounds[0]),\n                 self._clip(base[1] + oy, 0.0, self.bounds[1]))\n            return p\n        else:\n            ox = self._uniform(-radius, radius)\n            oy = self._uniform(-radius, radius)\n            oz = self._uniform(-radius, radius)\n            p = (self._clip(base[0] + ox, 0.0, self.bounds[0]),\n                 self._clip(base[1] + oy, 0.0, self.bounds[1]),\n                 self._clip(base[2] + oz, 0.0, self.bounds[2]))\n            return p",
          "objective": 6.00916,
          "time_improvement": -82.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1444.0,
          "node_improvement": 65.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.09160439968109131,
                    "num_nodes_avg": 192.5,
                    "path_length_avg": 160.40851016454332,
                    "smoothness_avg": 0.054526371814066096,
                    "success_improvement": 0.0,
                    "time_improvement": -259.24990906940366,
                    "node_improvement": 51.5235457063712,
                    "length_improvement": 12.077553743310729,
                    "smoothness_improvement": 753.4561248016809,
                    "objective_score": -66.76115985082626
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.12747783660888673,
                    "num_nodes_avg": 403.5,
                    "path_length_avg": 226.54832626815246,
                    "smoothness_avg": 0.08438589524949383,
                    "success_improvement": 0.0,
                    "time_improvement": 20.42449334835306,
                    "node_improvement": 72.88853053819794,
                    "length_improvement": 24.371647859676425,
                    "smoothness_improvement": 2071.3098654730497,
                    "objective_score": 31.106886047677023
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05217916965484619,
                    "num_nodes_avg": 232.5,
                    "path_length_avg": 120.46051392948111,
                    "smoothness_avg": 0.12644824403886157,
                    "success_improvement": 0.0,
                    "time_improvement": -6.375988820705992,
                    "node_improvement": 70.43865225683408,
                    "length_improvement": 19.995862361304226,
                    "smoothness_improvement": 1508.4123307358193,
                    "objective_score": 17.626782424249836
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "Bi-Informed Dual-Tree RRT*-Connect with Adaptive Neighborhoods and Shortcut Smoothing: a bidirectional planner that alternates growing optimized trees from start and goal, uses adaptive near-radius rewiring, informed rejection sampling after the first solution, and a connection step akin to RRT-Connect, followed by fast shortcut smoothing.",
          "planning_mechanism": "Mechanism: alternate tree expansion with goal-biased, bounds-respecting sampling; steer a step, validate node and edge, choose the lowest-cost parent among adaptive-radius neighbors, rewire and propagate costs; attempt to connect to the opposite tree via progressive extensions; upon any feasible join, update the incumbent cost and restrict future samples to the prolate hyperspheroid defined by start, goal, and best cost; terminate after a post-optimization budget or stagnation and return a smoothed path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=5.0,\n                 base_radius=25.0,\n                 min_radius=6.0,\n                 goal_bias=0.12,\n                 post_opt_iters=800,\n                 max_no_improve=200,\n                 smoothing_iters=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.goal_bias = goal_bias\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_cell = max(self.step_size, self.base_radius * 0.5)\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root, grid_cell)\n        self._grid_add(grid_goal, goal_root, grid_cell)\n\n        success = False\n        best_cost = float('inf')\n        best_join = (None, None)\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            active_first = (it % 2 == 0)\n            for which in (0, 1):\n                tree_a = start_tree if (active_first ^ (which == 1)) else goal_tree\n                tree_b = goal_tree if (tree_a is start_tree) else start_tree\n                grid_a = grid_start if (tree_a is start_tree) else grid_goal\n                grid_b = grid_goal if (tree_b is goal_tree) else grid_start\n\n                x_rand = self._sample(start, goal, best_cost, is_3d)\n                if self._rand() < self.goal_bias:\n                    x_rand = goal if (tree_a is start_tree) else start\n\n                x_nearest = self._nearest_grid(grid_a, tree_a, x_rand, grid_cell)\n                x_new_pos = self._steer(x_nearest.position, x_rand, self.step_size)\n\n                if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n                    continue\n                if self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n                    continue\n\n                x_new = Node(x_new_pos)\n                n_nodes = len(tree_a) + 1\n                r_near = self._adaptive_radius(n_nodes)\n                near_nodes = self._near_grid(grid_a, x_new_pos, r_near, grid_cell)\n\n                best_parent = x_nearest\n                best_pc = x_nearest.cost + self._dist(x_nearest.position, x_new_pos)\n                for nn in near_nodes:\n                    cand_cost = nn.cost + self._dist(nn.position, x_new_pos)\n                    if cand_cost < best_pc and not self._is_edge_in_obstacle(nn.position, x_new_pos, obstacles, is_3d):\n                        best_parent = nn\n                        best_pc = cand_cost\n\n                best_parent.add_child(x_new)\n                x_new.cost = best_pc\n                tree_a.append(x_new)\n                nodes.append(x_new)\n                edges.append((best_parent, x_new))\n                self._grid_add(grid_a, x_new, grid_cell)\n\n                for nn in near_nodes:\n                    alt = x_new.cost + self._dist(x_new.position, nn.position)\n                    if alt + 1e-12 < nn.cost and not self._is_edge_in_obstacle(x_new.position, nn.position, obstacles, is_3d):\n                        op = nn.parent\n                        if op is not None:\n                            try:\n                                edges.remove((op, nn))\n                            except:\n                                pass\n                            try:\n                                op.children.remove(nn)\n                            except:\n                                pass\n                        x_new.add_child(nn)\n                        nn.cost = alt\n                        edges.append((x_new, nn))\n                        self._propagate_costs_from(nn, edges)\n\n                connect_success, meet_a, meet_b = self._connect_trees(x_new, tree_b, grid_b, obstacles, is_3d, grid_cell, nodes, edges)\n                if connect_success:\n                    path_cost = meet_a.cost + self._dist(meet_a.position, meet_b.position) + meet_b.cost\n                    if path_cost + 1e-12 < best_cost:\n                        best_cost = path_cost\n                        best_join = (meet_a, meet_b)\n                        success = True\n                        found_first = True\n                        post_iters = 0\n                        no_improve = 0\n                    else:\n                        if found_first:\n                            post_iters += 1\n                            no_improve += 1\n                else:\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n\n                if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                    break\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        path = []\n        if success and best_join[0] is not None:\n            path = self._extract_path(best_join[0], best_join[1])\n            path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _rand(self):\n        try:\n            return random.random()\n        except:\n            # fallback LCG if random unavailable\n            if not hasattr(self, \"_lcg_state\"):\n                self._lcg_state = 1234567\n            self._lcg_state = (1103515245 * self._lcg_state + 12345) % (1 << 31)\n            return (self._lcg_state / float(1 << 31))\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = (a[i] - b[i])\n            s += d * d\n        return s ** 0.5\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        ratio = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(self.dim))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=1.0):\n        d = self._dist(a, b)\n        steps = int(d / resolution)\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _sample(self, start, goal, c_best, is_3d):\n        for _ in range(50):\n            p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n            if c_best < float('inf'):\n                if self._dist(p, start) + self._dist(p, goal) <= c_best and self._in_bounds(p):\n                    return p\n            else:\n                if self._in_bounds(p):\n                    return p\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _adaptive_radius(self, n):\n        if n <= 1:\n            return max(self.min_radius, self.base_radius)\n        r = self.base_radius * (n ** (-1.0 / max(2, self.dim)))\n        if r < self.min_radius:\n            r = self.min_radius\n        return r\n\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        key = self._grid_key(node.position, cell)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_gather(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos, cell):\n        # Expand rings until any candidates are found; fallback to linear scan\n        rng = 0\n        best = None\n        bestd = float('inf')\n        while rng < 6:\n            radius = (rng + 1) * cell\n            cand = self._grid_gather(grid, pos, radius, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                return best\n            rng += 1\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_grid(self, grid, pos, radius, cell):\n        cand = self._grid_gather(grid, pos, radius, cell)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _connect_trees(self, node_a, tree_b, grid_b, obstacles, is_3d, cell, nodes, edges):\n        target = node_a.position\n        nnear = self._nearest_grid(grid_b, tree_b, target, cell)\n        current = nnear\n        last_new = None\n        max_steps = int((self._dist(current.position, target) / self.step_size)) + 2\n        for _ in range(max_steps):\n            new_pos = self._steer(current.position, target, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False, None, None\n            if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                return False, None, None\n            new_node = Node(new_pos)\n            new_node.cost = current.cost + self._dist(current.position, new_pos)\n            current.add_child(new_node)\n            tree_b.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_add(grid_b, new_node, cell)\n            last_new = new_node\n            current = new_node\n            if self._dist(current.position, target) <= self.step_size and not self._is_edge_in_obstacle(current.position, target, obstacles, is_3d):\n                meet_b = current\n                meet_a = node_a\n                return True, meet_a, meet_b\n        if last_new is not None and self._dist(last_new.position, target) <= self.step_size and not self._is_edge_in_obstacle(last_new.position, target, obstacles, is_3d):\n            return True, node_a, last_new\n        return False, None, None\n\n    def _path_to_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        path.reverse()\n        return path\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        # meet_b is on the tree rooted at goal; follow parents to goal\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # path_a ends at meet_a; path_b starts at meet_b; edge between them is implicit\n        return path_a + path_b\n\n    def _propagate_costs_from(self, node, edges):\n        q = []\n        for c in node.children:\n            q.append(c)\n        while q:\n            u = q.pop(0)\n            if u.parent is not None:\n                u.cost = u.parent.cost + self._dist(u.parent.position, u.position)\n            for c in u.children:\n                q.append(c)\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                new_pts = pts[:i + 1] + pts[j:]\n                pts = new_pts\n                n = len(pts)\n        return pts",
          "objective": 13.17506,
          "time_improvement": -100.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1141.0,
          "node_improvement": -19.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04533350467681885,
                    "num_nodes_avg": 475.2,
                    "path_length_avg": 160.00839630243624,
                    "smoothness_avg": 0.03538840033717765,
                    "success_improvement": 0.0,
                    "time_improvement": -77.78684746193773,
                    "node_improvement": -19.66759002770082,
                    "length_improvement": 12.296862491341491,
                    "smoothness_improvement": 453.90531241814347,
                    "objective_score": -13.688410181685704
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.14875941276550292,
                    "num_nodes_avg": 1244.7,
                    "path_length_avg": 229.2684850165445,
                    "smoothness_avg": 0.07592744364942347,
                    "success_improvement": 0.0,
                    "time_improvement": 7.13989227527299,
                    "node_improvement": 16.367667808909488,
                    "length_improvement": 23.463580574034797,
                    "smoothness_improvement": 1853.6678134268077,
                    "objective_score": 25.48845509413681
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1614241361618042,
                    "num_nodes_avg": 1203.4,
                    "path_length_avg": 120.8833554675142,
                    "smoothness_avg": 0.09548517805346257,
                    "success_improvement": 0.0,
                    "time_improvement": -229.0901755878243,
                    "node_improvement": -53.00699300699302,
                    "length_improvement": 19.715031145292965,
                    "smoothness_improvement": 1114.5644168573392,
                    "objective_score": -51.32521190488481
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Bi-Guide ARC: A bidirectional, goal-aware RRT*-Connect with Adaptive Radius, spatial hashing, subtree cost propagation, and post-planning shortcut smoothing. It balances fast greedy connections with cost-optimal rewiring, focuses samples within an informed ellipsoid after the first solution, and uses a lightweight grid index for efficient nearest/near queries to improve path length and smoothness with lower planning time.",
          "planning_mechanism": "Alternate growing start/goal trees: sample (goal-biased; informed after first path), steer one step, select best parent within an adaptive radius, add if both node and edge are collision-free, locally rewire with subtree cost updates, then attempt a bounded greedy connect of the opposite tree to the new node. Maintain best path and stop upon time/iteration/no-improvement limits; finally apply randomized shortcut smoothing to the best path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def detach_from_parent(self):\n        if self.parent is not None and self in self.parent.children:\n            self.parent.children.remove(self)\n        self.parent = None\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 6000,\n        step_size: float = 5.0,\n        goal_bias: float = 0.15,\n        base_radius: float = 35.0,\n        max_radius: float = 60.0,\n        connect_steps: int = 20,\n        post_opt_iters: int = 300,\n        no_improve_limit: int = 180,\n        time_limit_sec: float = 20.0,\n        smooth_attempts: int = 120\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.base_radius = base_radius\n        self.max_radius = max_radius\n        self.connect_steps = connect_steps\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit\n        self.time_limit_sec = time_limit_sec\n        self.smooth_attempts = smooth_attempts\n\n        # Spatial hash cell size\n        self.cell_size = max(8.0, step_size * 2.0)\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Core containers\n        nodes = []\n        edges = []\n        success_state = False\n        best_path = []\n        best_cost = float('inf')\n\n        # Initialize trees and spatial hashes\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Dist between start and goal\n        c_min = self._dist(start_position, goal_position)\n\n        # States\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            # Alternate expansion direction\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n                grid_a, grid_b = grid_start, grid_goal\n                root_a, root_b = start_root, goal_root\n                sample_goal = goal_position\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n                grid_a, grid_b = grid_goal, grid_start\n                root_a, root_b = goal_root, start_root\n                sample_goal = start_position\n\n            # Sampling with goal bias and informed focus\n            x_rand = self._sample(bounds, obstacles, is_3d, start_position, goal_position, best_cost, c_min, sample_goal)\n\n            # Nearest in tree_a\n            a_near = self._nearest(grid_a, tree_a, x_rand, bounds)\n            a_new_pos = self._steer(a_near.position, x_rand, self.step_size)\n\n            # Bound check\n            if not self._in_bounds(a_new_pos, bounds):\n                self._advance_counters(found_first, True)\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Node and edge collision checks before adding\n            if self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n            if self._hit_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Best parent selection within adaptive radius\n            rad = self._adaptive_radius(len(tree_a), dim)\n            neighbors = self._grid_neighbors(grid_a, a_new_pos, rad)\n            if not neighbors:\n                neighbors = [a_near]\n\n            best_parent = None\n            best_g = float('inf')\n            for cand in neighbors:\n                if self._hit_obstacle(cand.position, a_new_pos, obstacles, is_3d):\n                    continue\n                g = cand.cost + self._dist(cand.position, a_new_pos)\n                if g < best_g:\n                    best_g = g\n                    best_parent = cand\n\n            if best_parent is None:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Add new node to tree_a\n            a_new = Node(a_new_pos, parent=None, cost=best_g)\n            best_parent.add_child(a_new)\n            tree_a.append(a_new)\n            nodes.append(a_new)\n            edges.append((best_parent, a_new))\n            self._grid_add(grid_a, a_new)\n\n            # Local rewiring from a_new\n            self._rewire_from(a_new, neighbors, obstacles, is_3d, edges)\n\n            # Attempt to connect tree_b to a_new (bounded)\n            b_meet = self._attempt_connect(tree_b, grid_b, a_new, obstacles, is_3d, bounds, nodes, edges, dim)\n\n            if b_meet is not None:\n                # Merge full path\n                if root_a is start_root:\n                    path_a = a_new.path_from_root()\n                    path_b = b_meet.path_from_root()\n                else:\n                    path_a = b_meet.path_from_root()\n                    path_b = a_new.path_from_root()\n\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged = path_a + path_b[-2::-1]\n                else:\n                    merged = path_a + path_b[::-1]\n\n                cost = self._path_cost(merged)\n                if cost < best_cost - 1e-9:\n                    best_cost = cost\n                    best_path = merged\n                    success_state = True\n                    no_improve = 0\n                else:\n                    no_improve += 1\n\n                if not found_first:\n                    found_first = True\n                    post_iters = 0\n                else:\n                    post_iters += 1\n\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n            else:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n\n        # Final smoothing of best path\n        if success_state and best_path:\n            best_path = self._shortcut_smooth(best_path, obstacles, is_3d, attempts=self.smooth_attempts)\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ------------------ Spatial Hash ------------------\n    def _key(self, pos):\n        return tuple(int(pos[d] // self.cell_size) for d in range(len(pos)))\n\n    def _grid_add(self, grid, node):\n        k = self._key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_neighbors(self, grid, pos, radius):\n        # Collect nodes in cells within radius\n        dim = len(pos)\n        span = int(max(1, math.ceil(radius / self.cell_size)))\n        key_center = self._key(pos)\n        result = []\n        if dim == 2:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    k = (key_center[0] + dx, key_center[1] + dy)\n                    if k in grid:\n                        for n in grid[k]:\n                            if self._dist(n.position, pos) <= radius:\n                                result.append(n)\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        k = (key_center[0] + dx, key_center[1] + dy, key_center[2] + dz)\n                        if k in grid:\n                            for n in grid[k]:\n                                if self._dist(n.position, pos) <= radius:\n                                    result.append(n)\n        return result\n\n    def _nearest(self, grid, tree, pos, bounds):\n        # Try increasing radii using grid; fallback to full scan\n        radius = self.cell_size\n        for _ in range(4):\n            cands = self._grid_neighbors(grid, pos, radius)\n            if cands:\n                return min(cands, key=lambda n: self._dist(n.position, pos))\n            radius *= 2.0\n        return min(tree, key=lambda n: self._dist(n.position, pos))\n\n    # ------------------ Connect Attempt ------------------\n    def _attempt_connect(self, tree, grid, target_node, obstacles, is_3d, bounds, nodes, edges, dim):\n        target_pos = target_node.position\n\n        # Direct connect via best parent in radius\n        rad = self._adaptive_radius(len(tree), dim)\n        neigh = self._grid_neighbors(grid, target_pos, rad)\n        if not neigh:\n            # include nearest if none\n            neigh = [self._nearest(grid, tree, target_pos, bounds)]\n        best_parent = None\n        best_cost = float('inf')\n        for cand in neigh:\n            if self._hit_obstacle(cand.position, target_pos, obstacles, is_3d):\n                continue\n            g = cand.cost + self._dist(cand.position, target_pos)\n            if g < best_cost:\n                best_cost = g\n                best_parent = cand\n        if best_parent is not None and not self._is_in_obstacle(target_pos, obstacles, is_3d):\n            meet = Node(target_pos, parent=None, cost=best_cost)\n            best_parent.add_child(meet)\n            tree.append(meet)\n            nodes.append(meet)\n            edges.append((best_parent, meet))\n            self._grid_add(grid, meet)\n            # Local rewiring at seam improves junction quality\n            seam_neighbors = self._grid_neighbors(grid, target_pos, rad)\n            self._rewire_from(meet, seam_neighbors, obstacles, is_3d, edges)\n            return meet\n\n        # Greedy bounded stepping toward target\n        current = self._nearest(grid, tree, target_pos, bounds)\n        steps = 0\n        while steps < self.connect_steps:\n            nxt = self._steer(current.position, target_pos, self.step_size)\n            if not self._in_bounds(nxt, bounds):\n                return None\n            if self._is_in_obstacle(nxt, obstacles, is_3d):\n                return None\n            if self._hit_obstacle(current.position, nxt, obstacles, is_3d):\n                return None\n\n            # Insert with best parent among neighbors around nxt\n            neigh2 = self._grid_neighbors(grid, nxt, rad)\n            if not neigh2:\n                neigh2 = [current]\n            best_p = None\n            best_g2 = float('inf')\n            for cand in neigh2:\n                if self._hit_obstacle(cand.position, nxt, obstacles, is_3d):\n                    continue\n                g2 = cand.cost + self._dist(cand.position, nxt)\n                if g2 < best_g2:\n                    best_g2 = g2\n                    best_p = cand\n            if best_p is None:\n                return None\n\n            new_b = Node(nxt, parent=None, cost=best_g2)\n            best_p.add_child(new_b)\n            tree.append(new_b)\n            nodes.append(new_b)\n            edges.append((best_p, new_b))\n            self._grid_add(grid, new_b)\n\n            self._rewire_from(new_b, neigh2, obstacles, is_3d, edges)\n\n            if self._dist(new_b.position, target_pos) <= self.step_size:\n                if (not self._is_in_obstacle(target_pos, obstacles, is_3d)) and (not self._hit_obstacle(new_b.position, target_pos, obstacles, is_3d)):\n                    final_b = Node(target_pos, parent=None, cost=new_b.cost + self._dist(new_b.position, target_pos))\n                    new_b.add_child(final_b)\n                    tree.append(final_b)\n                    nodes.append(final_b)\n                    edges.append((new_b, final_b))\n                    self._grid_add(grid, final_b)\n                    return final_b\n                return None\n\n            current = new_b\n            steps += 1\n\n        return None\n\n    # ------------------ Rewiring ------------------\n    def _rewire_from(self, pivot, neighbors, obstacles, is_3d, edges):\n        for nb in neighbors:\n            if nb is pivot or nb.parent is None:\n                continue\n            if self._hit_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                continue\n            new_cost = pivot.cost + self._dist(pivot.position, nb.position)\n            if new_cost + 1e-12 < nb.cost:\n                old_parent = nb.parent\n                nb.detach_from_parent()\n                pivot.add_child(nb)\n                try:\n                    edges.remove((old_parent, nb))\n                except Exception:\n                    pass\n                edges.append((pivot, nb))\n                delta = new_cost - nb.cost\n                nb.cost = new_cost\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        # BFS update costs down the subtree to maintain coherence\n        queue = [node]\n        while queue:\n            cur = queue.pop(0)\n            for ch in cur.children:\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                queue.append(ch)\n\n    # ------------------ Sampling ------------------\n    def _sample(self, bounds, obstacles, is_3d, start, goal, c_best, c_min, biased_goal):\n        dim = len(bounds)\n        # Goal bias\n        if random.random() < self.goal_bias:\n            target = goal if biased_goal == goal else start\n            if not self._is_in_obstacle(target, obstacles, is_3d):\n                return target\n\n        # Informed sampling after first solution\n        if c_best < float('inf') and c_min > 1e-12:\n            for _ in range(50):\n                x = self._sample_informed_ellipsoid(start, goal, c_best, c_min, bounds)\n                if not self._is_in_obstacle(x, obstacles, is_3d):\n                    return x\n\n        # Uniform fallback\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]), random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_informed_ellipsoid(self, start, goal, c_best, c_min, bounds):\n        # Prolate ellipsoid with foci at start and goal\n        dim = len(bounds)\n        r1 = c_best / 2.0\n        r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n        center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n        a1 = self._unit(self._vec(goal, start))\n        if dim == 2:\n            a2 = (-a1[1], a1[0])\n            basis = (a1, a2)\n            radii = (r1, r2)\n        else:\n            ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = self._unit(self._cross(a1, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._unit(self._cross(a1, ref))\n            b3 = self._cross(a1, b2)\n            basis = (a1, b2, b3)\n            radii = (r1, r2, r2)\n\n        u = self._sample_unit_ball(dim)\n        x = [center[d] for d in range(dim)]\n        for i in range(dim):\n            for d in range(dim):\n                x[d] += basis[i][d] * radii[i] * u[i]\n        # Clamp to bounds\n        x = tuple(min(max(x[d], 0.0), bounds[d]) for d in range(dim))\n        return x\n\n    def _sample_unit_ball(self, dim):\n        while True:\n            v = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(vi * vi for vi in v))\n            if n > 1e-12:\n                v = [vi / n for vi in v]\n                r = random.random() ** (1.0 / dim)\n                return tuple(v[i] * r for i in range(dim))\n\n    # ------------------ Geometry/Collision ------------------\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _vec(self, a, b):\n        return tuple(a[i] - b[i] for i in range(len(a)))\n\n    def _norm(self, v):\n        return math.sqrt(sum(vi * vi for vi in v))\n\n    def _unit(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return tuple(0.0 for _ in v)\n        return tuple(vi / n for vi in v)\n\n    def _cross(self, a, b):\n        # Only used in 3D informed sampling\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0.0 <= pos[i] <= bounds[i] for i in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _hit_obstacle(self, a, b, obstacles, is_3d, res=1.0):\n        L = self._dist(a, b)\n        steps = max(1, int(L / res))\n        for i in range(steps + 1):\n            t = i / steps\n            p = tuple(a[d] + (b[d] - a[d]) * t for d in range(len(a)))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _path_cost(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(len(path) - 1):\n            s += self._dist(path[i], path[i + 1])\n        return s\n\n    # ------------------ Controls ------------------\n    def _adaptive_radius(self, n, dim):\n        if n <= 1:\n            return self.base_radius\n        # RRT* style shrinkage\n        r = self.base_radius * (math.log(n + 1) / (n + 1)) ** (1.0 / dim)\n        r = max(self.step_size * 1.5, min(self.max_radius, r))\n        return r\n\n    def _post_update(self, found_first, post_iters, no_improve):\n        if found_first:\n            post_iters += 1\n            no_improve += 1\n        return post_iters, no_improve\n\n    def _should_stop(self, found_first, post_iters, no_improve):\n        if not found_first:\n            return False\n        if post_iters >= self.post_opt_iters:\n            return True\n        if no_improve >= self.no_improve_limit:\n            return True\n        return False\n\n    # ------------------ Smoothing ------------------\n    def _shortcut_smooth(self, path, obstacles, is_3d, attempts=100):\n        if len(path) < 3:\n            return path[:]\n        best = path[:]\n        best_cost = self._path_cost(best)\n        n = len(best)\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = best[i]\n            b = best[j]\n            if not self._hit_obstacle(a, b, obstacles, is_3d):\n                # shortcut\n                new_path = best[:i + 1] + best[j:]\n                new_cost = self._path_cost(new_path)\n                if new_cost < best_cost - 1e-9:\n                    best = new_path\n                    best_cost = new_cost\n                    n = len(best)\n        # Greedy corner culling\n        changed = True\n        while changed and len(best) > 2:\n            changed = False\n            k = 1\n            while k < len(best) - 1:\n                if not self._hit_obstacle(best[k - 1], best[k + 1], obstacles, is_3d):\n                    best.pop(k)\n                    changed = True\n                else:\n                    k += 1\n        return best",
          "objective": 14.38104,
          "time_improvement": -107.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1417.0,
          "node_improvement": 44.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.11155118942260742,
                    "num_nodes_avg": 362.3,
                    "path_length_avg": 155.15168551902272,
                    "smoothness_avg": 0.04619305292125599,
                    "success_improvement": 0.0,
                    "time_improvement": -337.47630895645335,
                    "node_improvement": 8.76353563334173,
                    "length_improvement": 14.95890263123767,
                    "smoothness_improvement": 623.021588037589,
                    "objective_score": -89.15244316800546
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08458755016326905,
                    "num_nodes_avg": 414.7,
                    "path_length_avg": 238.39539805931153,
                    "smoothness_avg": 0.09691449918612544,
                    "success_improvement": 0.0,
                    "time_improvement": 47.197902476841236,
                    "node_improvement": 72.13599408721359,
                    "length_improvement": 20.416754296733227,
                    "smoothness_improvement": 2393.679868751244,
                    "objective_score": 38.37782266484852
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06439132690429687,
                    "num_nodes_avg": 395.9,
                    "path_length_avg": 123.34270106287966,
                    "smoothness_avg": 0.1047845601402689,
                    "success_improvement": 0.0,
                    "time_improvement": -31.272519594143017,
                    "node_improvement": 49.66306420851876,
                    "length_improvement": 18.081650902303785,
                    "smoothness_improvement": 1232.8518705925312,
                    "objective_score": 7.631494016102023
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "Beam-Informed Hash-RRT (BIH-RRT): a single-tree, anytime sampler that couples a spatial hash for near/nearest queries with beam-guided sampling, informed ellipsoid sampling after the first solution, duplicate suppression, on-the-fly line-of-sight compression, and capped local rewiring with subtree cost propagation. It returns the best path found within a strict time/iteration budget and applies bounded shortcut smoothing to improve length and smoothness.",
          "planning_mechanism": "Mechanism: Grow one tree from the start. Each iteration, draw a small beam of biased samples (goal/corridor/uniform or informed-ellipsoid after a first solution), pick the lowest f = g + h expansion, and add at most one node after validating node and edge collisions. Parent selection considers near neighbors (via a spatial hash) and rewires a limited set when beneficial, propagating cost changes to descendants. Newly added nodes attempt line-of-sight compression to the grandparent if valid. Attempt goal connection opportunistically; upon a solution, switch to informed sampling and continue only a bounded number of additional iterations or until no improvement. Maintain coherent nodes/edges and return the best (smoothed) path within time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=7.5,\n        beam_k=3,\n        goal_sample_rate=0.08,\n        corridor_bias_rate=0.40,\n        informed_bias_rate=0.65,\n        neighbor_gamma=50.0,\n        min_radius_factor=1.5,\n        grid_scale=1.0,\n        min_separation_factor=0.7,\n        max_rewire=6,\n        post_opt_iters=300,\n        max_no_improve=120,\n        improve_tol=1e-6,\n        time_limit_sec=15.0\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_k = beam_k\n        self.goal_sample_rate = goal_sample_rate\n        self.corridor_bias_rate = corridor_bias_rate\n        self.informed_bias_rate = informed_bias_rate\n        self.neighbor_gamma = neighbor_gamma\n        self.min_radius_factor = min_radius_factor\n        self.grid_scale = grid_scale\n        self.min_separation_factor = min_separation_factor\n        self.max_rewire = max_rewire\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes = []\n        edges = []\n\n        # root and structures\n        root = Node(start, parent=None, cost=0.0)\n        nodes.append(root)\n        tree = [root]\n\n        # Spatial hash grid for approximate NN and near queries\n        grid_res = max(self.step_size * self.grid_scale, 1.0)\n        grid = {}\n        def cell_index(p):\n            return tuple(int(p[d] // grid_res) for d in range(dim))\n        def grid_insert(n):\n            idx = cell_index(n.position)\n            if idx not in grid:\n                grid[idx] = []\n            grid[idx].append(n)\n        grid_insert(root)\n\n        # Helper geometry\n        def dist(a, b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i] - b[i]\n                s += d * d\n            return s ** 0.5\n\n        def within_bounds(p):\n            for i in range(dim):\n                if p[i] < 0.0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def clamp(p):\n            return tuple(min(max(p[i], 0.0), bounds[i]) for i in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return clamp(to_pos)\n            r = self.step_size / max(d, 1e-12)\n            return clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(dim)))\n\n        def nearest_node(sample):\n            # search in expanding grid rings, fallback to linear if needed\n            ci = cell_index(sample)\n            best = None\n            bestd = 1e18\n            max_ring = 3\n            for R in range(max_ring + 1):\n                found = False\n                # iterate hypercube of cells with Chebyshev radius R\n                ranges = []\n                for i in range(dim):\n                    ranges.append(range(ci[i] - R, ci[i] + R + 1))\n                # nested loops over ranges\n                def recurse(idx, acc):\n                    nonlocal found, best, bestd\n                    if idx == dim:\n                        bucket = grid.get(tuple(acc))\n                        if bucket:\n                            found = True\n                            for n in bucket:\n                                dd = dist(n.position, sample)\n                                if dd < bestd:\n                                    bestd = dd\n                                    best = n\n                        return\n                    for v in ranges[idx]:\n                        acc.append(v)\n                        recurse(idx + 1, acc)\n                        acc.pop()\n                recurse(0, [])\n                if found:\n                    return best\n            # fallback\n            for n in tree:\n                dd = dist(n.position, sample)\n                if dd < bestd:\n                    bestd = dd\n                    best = n\n            return best\n\n        def near_nodes(pos, radius):\n            # gather cells overlapping radius ball\n            res = []\n            min_i = [int((pos[d] - radius) // grid_res) for d in range(dim)]\n            max_i = [int((pos[d] + radius) // grid_res) for d in range(dim)]\n            def recurse(d, acc):\n                if d == dim:\n                    bucket = grid.get(tuple(acc))\n                    if bucket:\n                        for n in bucket:\n                            if dist(n.position, pos) <= radius:\n                                res.append(n)\n                    return\n                for v in range(min_i[d], max_i[d] + 1):\n                    acc.append(v)\n                    recurse(d + 1, acc)\n                    acc.pop()\n            recurse(0, [])\n            return res\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(self.step_size * self.min_radius_factor, 5.0)\n            import_math_log = math.log if 'math' in globals() else (lambda x: x)  # fallback no-op (unlikely)\n            rn = self.neighbor_gamma * ((import_math_log(n_nodes) / n_nodes) ** (1.0 / dim))\n            rmin = max(self.step_size * self.min_radius_factor, 5.0)\n            rmax = max(bounds) * 0.25\n            if rn < rmin:\n                rn = rmin\n            if rn > rmax:\n                rn = rmax\n            return rn\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d0 = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d0:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_blocked(a, b, resolution=1.0):\n            L = dist(a, b)\n            steps = int(max(1, L / resolution))\n            for i in range(steps + 1):\n                t = i / float(steps)\n                p = tuple(a[d] + (b[d] - a[d]) * t for d in range(dim))\n                if is_in_obstacle(p):\n                    return True\n            return False\n\n        # Basis utilities for corridor/informed sampling\n        def unit(v):\n            n = dist(v, tuple(0.0 for _ in range(dim)))\n            if n < 1e-12:\n                return tuple(0.0 for _ in range(dim))\n            return tuple(v[i] / n for i in range(dim))\n\n        def sub(a, b):\n            return tuple(a[i] - b[i] for i in range(dim))\n\n        def add(a, b):\n            return tuple(a[i] + b[i] for i in range(dim))\n\n        def mul(v, s):\n            return tuple(v[i] * s for i in range(dim))\n\n        def dot(a, b):\n            return sum(a[i] * b[i] for i in range(dim))\n\n        def cross3(a, b):\n            return (a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0])\n\n        def ortho_basis(u):\n            # returns (u, v, w?) orthonormal basis; in 2D returns (u, v)\n            if dim == 2:\n                ux, uy = u\n                v = (-uy, ux)\n                vn = dist(v, (0.0, 0.0))\n                if vn < 1e-12:\n                    v = (0.0, 1.0)\n                else:\n                    v = (v[0] / vn, v[1] / vn)\n                return (u, v)\n            else:\n                # pick any vector not parallel\n                a = (1.0, 0.0, 0.0) if abs(u[0]) < 0.9 else (0.0, 1.0, 0.0)\n                v = cross3(u, a)\n                vn = dist(v, (0.0, 0.0, 0.0))\n                if vn < 1e-12:\n                    a = (0.0, 0.0, 1.0)\n                    v = cross3(u, a)\n                    vn = dist(v, (0.0, 0.0, 0.0))\n                v = (v[0]/vn, v[1]/vn, v[2]/vn)\n                w = cross3(u, v)\n                wn = dist(w, (0.0, 0.0, 0.0))\n                w = (w[0]/wn, w[1]/wn, w[2]/wn)\n                return (u, v, w)\n\n        # Sampling\n        start_to_goal = sub(goal, start)\n        c_min = dist(start, goal)\n        center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n        u_dir = unit(start_to_goal)\n        basis = ortho_basis(u_dir)\n\n        def sample_uniform():\n            return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n\n        def sample_corridor(width_scale=2.0):\n            t = random.random()\n            base = add(start, mul(start_to_goal, t))\n            if dim == 2:\n                _, v = basis\n                w = width_scale * self.step_size\n                offset = mul(v, random.uniform(-w, w))\n                return clamp(add(base, offset))\n            else:\n                _, v, wv = basis\n                w = width_scale * self.step_size\n                off = add(mul(v, random.uniform(-w, w)), mul(wv, random.uniform(-w, w)))\n                return clamp(add(base, off))\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            a = max(c_best * 0.5, c_min * 0.5)\n            b_sq = max(a*a - (c_min*0.5)*(c_min*0.5), 0.0)\n            b = b_sq ** 0.5\n            # sample in unit ball then scale and rotate\n            while True:\n                if dim == 2:\n                    x = (random.uniform(-1.0, 1.0), random.uniform(-1.0, 1.0))\n                    if x[0]*x[0] + x[1]*x[1] > 1.0:\n                        continue\n                    # scale components\n                    y_local = (x[0] * a, x[1] * b)\n                    u, v = basis\n                    p = add(center, add(mul(u, y_local[0]), mul(v, y_local[1])))\n                else:\n                    x = (random.uniform(-1.0, 1.0),\n                         random.uniform(-1.0, 1.0),\n                         random.uniform(-1.0, 1.0))\n                    if x[0]*x[0] + x[1]*x[1] + x[2]*x[2] > 1.0:\n                        continue\n                    y_local = (x[0]*a, x[1]*b, x[2]*b)\n                    u, v, wv = basis\n                    p = add(center, add(add(mul(u, y_local[0]), mul(v, y_local[1])), mul(wv, y_local[2])))\n                if within_bounds(p):\n                    return p\n\n        def heuristic(p):\n            return dist(p, goal)\n\n        # Insertion helpers\n        def try_add_node(parent, new_pos):\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos):\n                return None\n            if is_edge_blocked(parent.position, new_pos):\n                return None\n\n            # Best-parent among neighbors (limited) and duplicate suppression\n            radius = neighbor_radius(len(tree))\n            neigh = near_nodes(new_pos, radius)\n            # duplicate/near-duplicate suppression\n            min_sep = max(self.step_size * self.min_separation_factor, 1.0)\n            for nb in neigh:\n                if dist(nb.position, new_pos) <= min_sep:\n                    # If not significantly better than existing, skip\n                    if parent.cost + dist(parent.position, new_pos) >= nb.cost - 1e-9:\n                        return None\n\n            # choose parent with least cost if edge valid\n            best_p = parent\n            best_c = parent.cost + dist(parent.position, new_pos)\n            # limit neighbor checks\n            neigh_sorted = sorted(neigh, key=lambda n: dist(n.position, new_pos))[:15]\n            for nb in neigh_sorted:\n                cand_c = nb.cost + dist(nb.position, new_pos)\n                if cand_c + 1e-12 < best_c:\n                    if not is_edge_blocked(nb.position, new_pos):\n                        best_p = nb\n                        best_c = cand_c\n\n            new_node = Node(new_pos, parent=None, cost=best_c)\n            best_p.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_p, new_node))\n            grid_insert(new_node)\n\n            # On-the-fly line-of-sight compression to grandparent\n            gp = best_p.parent\n            if gp is not None:\n                if not is_edge_blocked(gp.position, new_pos):\n                    gp_cost = gp.cost + dist(gp.position, new_pos)\n                    if gp_cost + 1e-12 < new_node.cost:\n                        # rewire new_node from best_p -> gp\n                        try:\n                            edges.remove((best_p, new_node))\n                        except Exception:\n                            pass\n                        if new_node in best_p.children:\n                            best_p.children.remove(new_node)\n                        gp.add_child(new_node)\n                        new_node.cost = gp_cost\n                        edges.append((gp, new_node))\n\n            # Local rewiring (limited) with subtree cost propagation\n            rewired = 0\n            for nb in neigh_sorted:\n                if nb is new_node:\n                    continue\n                cand = new_node.cost + dist(new_node.position, nb.position)\n                if cand + 1e-12 < nb.cost and not is_edge_blocked(new_node.position, nb.position):\n                    old_parent = nb.parent\n                    old_cost = nb.cost\n                    # detach\n                    if old_parent is not None:\n                        try:\n                            edges.remove((old_parent, nb))\n                        except Exception:\n                            pass\n                        if nb in old_parent.children:\n                            old_parent.children.remove(nb)\n                    # attach\n                    new_node.add_child(nb)\n                    nb.cost = cand\n                    edges.append((new_node, nb))\n                    delta = nb.cost - old_cost\n                    if abs(delta) > 1e-15:\n                        self._propagate_cost(nb, delta, edges)\n                    rewired += 1\n                    if rewired >= self.max_rewire:\n                        break\n\n            return new_node\n\n        # Goal connection management\n        goal_node = None  # unique goal node in the tree\n        def try_connect_goal(anchor):\n            nonlocal goal_node\n            if dist(anchor.position, goal) <= self.step_size * 1.5:\n                if not is_edge_blocked(anchor.position, goal) and not is_in_obstacle(goal):\n                    if goal_node is None:\n                        goal_node = Node(goal, parent=None, cost=0.0)\n                        nodes.append(goal_node)\n                    # Consider re-parenting goal_node if better\n                    new_cost = anchor.cost + dist(anchor.position, goal)\n                    if goal_node.parent is None:\n                        anchor.add_child(goal_node)\n                        goal_node.cost = new_cost\n                        edges.append((anchor, goal_node))\n                        return True\n                    else:\n                        if new_cost + 1e-12 < goal_node.cost:\n                            old_parent = goal_node.parent\n                            try:\n                                edges.remove((old_parent, goal_node))\n                            except Exception:\n                                pass\n                            if goal_node in old_parent.children:\n                                old_parent.children.remove(goal_node)\n                            anchor.add_child(goal_node)\n                            goal_node.cost = new_cost\n                            edges.append((anchor, goal_node))\n                            return True\n            return False\n\n        def extract_path(n):\n            if n is None:\n                return []\n            return n.path_from_root()\n\n        def path_length(path):\n            if not path or len(path) < 2:\n                return 0.0\n            total = 0.0\n            for i in range(len(path)-1):\n                total += dist(path[i], path[i+1])\n            return total\n\n        def shortcut_path(path, max_trials=60):\n            if len(path) <= 2:\n                return path\n            pts = list(path)\n            trials = 0\n            while trials < max_trials and len(pts) > 2:\n                i = int(random.uniform(0, len(pts)-2))\n                j = int(random.uniform(i+2, len(pts)))\n                a = pts[i]\n                b = pts[j]\n                if not is_edge_blocked(a, b):\n                    # collapse intermediate\n                    pts = pts[:i+1] + pts[j:]\n                trials += 1\n            return pts\n\n        # Planning loop with anytime budget\n        best_cost = float('inf')\n        best_path = []\n        found_first = False\n        post_iter = 0\n        no_improve = 0\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            # Build a small beam of candidates without committing\n            cands = []\n            for _ in range(self.beam_k):\n                if random.random() < self.goal_sample_rate:\n                    s = goal\n                else:\n                    if found_first and random.random() < self.informed_bias_rate:\n                        s = sample_informed(best_cost)\n                    elif random.random() < self.corridor_bias_rate:\n                        s = sample_corridor()\n                    else:\n                        s = sample_uniform()\n                nn = nearest_node(s)\n                step_pos = steer(nn.position, s)\n                # Candidate priority by f = g + h using parent nn\n                f = nn.cost + dist(nn.position, step_pos) + 0.8 * heuristic(step_pos)\n                cands.append((f, nn, step_pos))\n\n            # Choose best candidate and try to add\n            cands.sort(key=lambda x: x[0])\n            new_node = None\n            for _, parent, new_pos in cands:\n                new_node = try_add_node(parent, new_pos)\n                if new_node is not None:\n                    break\n\n            if new_node is not None:\n                # Attempt to connect goal opportunistically\n                improved = False\n                if try_connect_goal(new_node):\n                    # evaluate best path\n                    if goal_node is not None:\n                        cand_path = extract_path(goal_node)\n                        cand_cost = path_length(cand_path)\n                        if cand_cost + self.improve_tol < best_cost:\n                            best_cost = cand_cost\n                            best_path = cand_path\n                            improved = True\n                            no_improve = 0\n                        else:\n                            no_improve += 1\n                else:\n                    if found_first:\n                        no_improve += 1\n\n                # Manage anytime schedule\n                if best_path:\n                    if not found_first:\n                        found_first = True\n                        post_iter = 0\n                    else:\n                        post_iter += 1\n                    if post_iter >= self.post_opt_iters or no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_iter += 1\n                    no_improve += 1\n                    if post_iter >= self.post_opt_iters or no_improve >= self.max_no_improve:\n                        break\n\n        # Finalize best path (with bounded smoothing)\n        final_path = best_path[:]\n        if final_path:\n            final_path = shortcut_path(final_path, max_trials=60)\n\n        return PlannerResult(\n            success=(len(final_path) > 0),\n            path=final_path if final_path else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    # Propagate cost delta to descendants\n    def _propagate_cost(self, node, delta, edges):\n        stack = list(node.children)\n        while stack:\n            c = stack.pop()\n            c.cost += delta\n            for ch in c.children:\n                stack.append(ch)",
          "objective": 14.38246,
          "time_improvement": -56.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 2016.0,
          "node_improvement": 77.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0577272891998291,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 172.41640300447878,
                    "smoothness_avg": 0.04437067659715756,
                    "success_improvement": 0.0,
                    "time_improvement": -126.39221989402493,
                    "node_improvement": 66.50717703349282,
                    "length_improvement": 5.495837400503652,
                    "smoothness_improvement": 594.4974412119211,
                    "objective_score": -31.647676321845687
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0929105281829834,
                    "num_nodes_avg": 194.0,
                    "path_length_avg": 239.9939952470921,
                    "smoothness_avg": 0.11970092434149775,
                    "success_improvement": 0.0,
                    "time_improvement": 42.002448816913656,
                    "node_improvement": 86.96499361687832,
                    "length_improvement": 19.883096542383285,
                    "smoothness_improvement": 2979.9910003976192,
                    "objective_score": 39.430547572492166
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.09008440971374512,
                    "num_nodes_avg": 172.7,
                    "path_length_avg": 120.96200268725316,
                    "smoothness_avg": 0.20232399475529045,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -83.65217813961966,
                    "node_improvement": 78.04195804195804,
                    "length_improvement": 19.662797406720507,
                    "smoothness_improvement": 2473.546279283454,
                    "objective_score": -50.93024360143632
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m1",
          "algorithm_description": "GB-RRT* Connect with bounded rewiring and informed goal bias: a bidirectional, RRT*-style planner that alternates growing start/goal trees using k-nearest best-parent selection and local rewiring, uses goal/informed sampling for fast convergence, caches edge checks, and applies shortcut smoothing; it lazily bridges trees without duplicating meeting nodes and limits post-solution optimization for efficiency.",
          "planning_mechanism": "Alternate expanding the two trees toward informed/goal-biased samples; for each new node, pick the lowest-cost collision-free parent among k nearest neighbors, rewire locally with cost propagation, and attempt a short greedy connection to the opposite tree. Upon first connection, switch to ellipsoidal informed sampling and continue for a bounded number of iterations or until no improvement. Edge checks are cached; final path is shortcut-smoothed before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        neighbor_k: int = 18,\n        time_limit_sec: float = 30.0,\n        goal_bias: float = 0.10,\n        post_opt_iters: int = 300,\n        no_improve_limit: int = 120,\n        smooth_iters: int = 120\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_k = neighbor_k\n        self.time_limit_sec = time_limit_sec\n        self.goal_bias = goal_bias\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit\n        self.smooth_iters = smooth_iters\n\n        self._edge_cache = {}\n        self._edge_cache_limit = 50000\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes = []\n        edges = []\n        success = False\n        best_path = []\n        best_cost = float(\"inf\")\n\n        # Early infeasible start/goal\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early direct connection\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d):\n            return PlannerResult(True, [start, goal], [Node(start), Node(goal)], [(Node(start), Node(goal))])\n\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        c_min = self._dist(start, goal)\n        start_time = self._now()\n\n        # RRT* neighborhood parameters\n        gamma_rrt = 60.0\n        max_radius = max(bounds) * 0.20\n        min_radius = max(self.step_size * 1.5, 5.0)\n\n        # Post-optimization bookkeeping\n        found_solution = False\n        post_iter = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            if self._now() - start_time > self.time_limit_sec:\n                break\n\n            # Alternate growing sides\n            if it % 2 == 0:\n                grow_tree, other_tree = tree_a, tree_b\n                a_is_start_side = True\n            else:\n                grow_tree, other_tree = tree_b, tree_a\n                a_is_start_side = False\n\n            # Sample with goal/informed bias\n            sample = self._sample_informed(start, goal, best_cost, c_min, bounds, obstacles, is_3d, found_solution)\n\n            # Extend grow_tree\n            a_near = self._nearest(grow_tree, sample)\n            a_new_pos = self._steer(a_near.position, sample, self.step_size)\n            if (not self._in_bounds(a_new_pos, bounds)) or self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                if found_solution:\n                    post_iter += 1\n                    no_improve += 1\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve >= self.no_improve_limit):\n                    break\n                continue\n            if self._is_edge_in_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                if found_solution:\n                    post_iter += 1\n                    no_improve += 1\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve >= self.no_improve_limit):\n                    break\n                continue\n\n            # Insert with best-parent among k-nearest inside adaptive radius\n            r_n = self._neighbor_radius(len(grow_tree), dim, gamma_rrt, min_radius, max_radius)\n            a_new, a_neigh = self._add_with_best_parent(grow_tree, nodes, edges, a_new_pos, obstacles, is_3d, r_n)\n            if a_new is None:\n                if found_solution:\n                    post_iter += 1\n                    no_improve += 1\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve >= self.no_improve_limit):\n                    break\n                continue\n\n            # Local rewiring around the inserted node with cost propagation\n            self._rewire_from(a_new, a_neigh, edges, obstacles, is_3d)\n\n            # Try short greedy connection from other_tree to a_new\n            connected_b = self._greedy_connect(other_tree, a_new.position, nodes, edges, obstacles, is_3d, dim, gamma_rrt, min_radius, max_radius, max_steps=3)\n\n            # Attempt final bridge if close\n            candidate_path = None\n            if connected_b is not None:\n                if self._dist(connected_b.position, a_new.position) <= self.step_size and not self._is_edge_in_obstacle(connected_b.position, a_new.position, obstacles, is_3d):\n                    # Add a visual bridge edge without altering parents (lazy bridge)\n                    edges.append((connected_b, a_new))\n                    # Stitch paths for evaluation\n                    path_a = a_new.path_from_root()\n                    path_b = connected_b.path_from_root()\n                    merged = path_a + path_b[-2::-1] if (path_a and path_b and path_a[-1] == path_b[-1]) else path_a + path_b[::-1]\n                    candidate_path = merged if a_is_start_side else merged[::-1]\n\n            if candidate_path:\n                cand_cost = self._path_cost(candidate_path)\n                if cand_cost + 1e-9 < best_cost:\n                    best_cost = cand_cost\n                    best_path = candidate_path\n                    success = True\n                    found_solution = True\n                    post_iter = 0\n                    no_improve = 0\n                else:\n                    if found_solution:\n                        post_iter += 1\n                        no_improve += 1\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve >= self.no_improve_limit):\n                    break\n            else:\n                if found_solution:\n                    post_iter += 1\n                    no_improve += 1\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve >= self.no_improve_limit):\n                    break\n\n        # Final smoothing\n        if success and len(best_path) >= 2:\n            best_path = self._shortcut_smooth(best_path, obstacles, is_3d, self.smooth_iters)\n\n        return PlannerResult(success, best_path if success else [], nodes, edges)\n\n    # ---------- Geometry / Utility ----------\n    def _now(self):\n        return time.time()\n\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _in_bounds(self, p, bounds):\n        for d in range(len(bounds)):\n            if p[d] < 0.0 or p[d] > bounds[d]:\n                return False\n        return True\n\n    def _nearest(self, tree, pt):\n        return min(tree, key=lambda n: self._dist(n.position, pt))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    def _neighbor_radius(self, n_nodes, dim, gamma, rmin, rmax):\n        if n_nodes < 2:\n            return rmin\n        val = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n        return max(rmin, min(rmax, val))\n\n    def _k_nearest_within(self, tree, pos, k, radius):\n        # Filter by radius then choose up to k nearest\n        pairs = []\n        for nd in tree:\n            d = self._dist(nd.position, pos)\n            if d <= radius:\n                pairs.append((d, nd))\n        if not pairs:\n            return []\n        pairs.sort(key=lambda x: x[0])\n        return [nd for _, nd in pairs[:min(k, len(pairs))]]\n\n    def _add_with_best_parent(self, tree, nodes, edges, new_pos, obstacles, is_3d, radius):\n        # Parent candidates among k-nearest inside radius; ensure edge collision free\n        neigh = self._k_nearest_within(tree, new_pos, self.neighbor_k, radius)\n        if not neigh:\n            # fallback to nearest\n            neigh = [self._nearest(tree, new_pos)]\n        parent_candidates = [nb for nb in neigh if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d)]\n        if not parent_candidates:\n            return None, []\n        best_parent = min(parent_candidates, key=lambda nb: nb.cost + self._dist(nb.position, new_pos))\n        new_node = Node(new_pos, parent=None, cost=best_parent.cost + self._dist(best_parent.position, new_pos))\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neigh\n\n    def _rewire_from(self, pivot, neigh, edges, obstacles, is_3d):\n        for nb in neigh:\n            if nb is pivot:\n                continue\n            if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                continue\n            new_cost = pivot.cost + self._dist(pivot.position, nb.position)\n            if new_cost + 1e-12 < nb.cost:\n                old_parent = nb.parent\n                if old_parent is not None:\n                    # Remove old edge if present\n                    try:\n                        edges.remove((old_parent, nb))\n                    except ValueError:\n                        pass\n                    try:\n                        old_parent.children.remove(nb)\n                    except ValueError:\n                        pass\n                pivot.add_child(nb)\n                nb.cost = new_cost\n                edges.append((pivot, nb))\n                self._propagate_cost_from(nb, edges)\n\n    def _propagate_cost_from(self, node, edges):\n        # Update costs in subtree after rewiring\n        queue = [node]\n        while queue:\n            cur = queue.pop(0)\n            for ch in cur.children:\n                new_c = cur.cost + self._dist(cur.position, ch.position)\n                if abs(new_c - ch.cost) > 1e-12:\n                    ch.cost = new_c\n                    queue.append(ch)\n\n    def _greedy_connect(self, tree, target_pos, nodes, edges, obstacles, is_3d, dim, gamma_rrt, rmin, rmax, max_steps=3):\n        current = self._nearest(tree, target_pos)\n        steps = 0\n        last_new = None\n        while steps < max_steps:\n            steps += 1\n            step_pos = self._steer(current.position, target_pos, self.step_size)\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                break\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                break\n            radius = self._neighbor_radius(len(tree), dim, gamma_rrt, rmin, rmax)\n            new_node, neigh = self._add_with_best_parent(tree, nodes, edges, step_pos, obstacles, is_3d, radius)\n            if new_node is None:\n                break\n            self._rewire_from(new_node, neigh, edges, obstacles, is_3d)\n            current = new_node\n            last_new = new_node\n            if self._dist(current.position, target_pos) <= self.step_size:\n                break\n        return last_new\n\n    def _path_cost(self, path):\n        total = 0.0\n        for i in range(len(path) - 1):\n            total += self._dist(path[i], path[i + 1])\n        return total\n\n    # ---------- Sampling ----------\n    def _sample_informed(self, start, goal, c_best, c_min, bounds, obstacles, is_3d, have_solution):\n        dim = len(bounds)\n        # Try a few times to avoid sampling inside obstacles\n        for _ in range(50):\n            if not have_solution or c_best == float(\"inf\") or c_min <= 1e-12:\n                # Pre-solution: goal bias\n                if random.random() < self.goal_bias:\n                    sample = goal\n                else:\n                    sample = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n            else:\n                # Post-solution: informed ellipsoidal sampling with some uniform escape\n                if random.random() < 0.80:\n                    sample = self._sample_ellipsoid(start, goal, c_best, c_min, bounds)\n                else:\n                    sample = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n            if self._in_bounds(sample, bounds) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                return sample\n        # Fallback uniform\n        return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n    def _sample_ellipsoid(self, start, goal, c_best, c_min, bounds):\n        dim = len(bounds)\n        center = tuple((s + g) / 2.0 for s, g in zip(start, goal))\n        a1 = tuple((goal[d] - start[d]) / (c_min if c_min > 1e-12 else 1.0) for d in range(dim))\n        r1 = c_best / 2.0\n        r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n        r_other = math.sqrt(r_other_sq) / 2.0\n        if dim == 2:\n            a2 = (-a1[1], a1[0])\n            basis = (a1, a2)\n            radii = (r1, r_other)\n        else:\n            ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = self._normalize(self._cross(a1, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._normalize(self._cross(a1, ref))\n            b3 = self._cross(a1, b2)\n            basis = (a1, b2, b3)\n            radii = (r1, r_other, r_other)\n        u = self._sample_unit_ball(dim)\n        mapped = []\n        for d in range(dim):\n            val = center[d]\n            for i in range(dim):\n                val += basis[i][d] * radii[i] * u[i]\n            # Clamp to bounds\n            val = min(max(val, 0.0), bounds[d])\n            mapped.append(val)\n        return tuple(mapped)\n\n    def _sample_unit_ball(self, dim):\n        # Gaussian direction + radius^(1/d)\n        while True:\n            v = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(x * x for x in v))\n            if n > 1e-12:\n                v = [x / n for x in v]\n                r = random.random() ** (1.0 / dim)\n                return tuple(v[i] * r for i in range(dim))\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for x, y, z, w, h, d in obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for x, y, w, h in obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        # Direction-agnostic key with rounding to reduce duplicates\n        ra = tuple(round(c, 2) for c in a)\n        rb = tuple(round(c, 2) for c in b)\n        return (ra, rb) if ra <= rb else (rb, ra)\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        key = self._edge_key(from_pos, to_pos)\n        hit = self._edge_cache.get(key, None)\n        if hit is not None:\n            return hit\n        distance = self._dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                self._edge_cache[key] = True\n                if len(self._edge_cache) > self._edge_cache_limit:\n                    self._edge_cache.clear()\n                return True\n        self._edge_cache[key] = False\n        if len(self._edge_cache) > self._edge_cache_limit:\n            self._edge_cache.clear()\n        return False\n\n    # ---------- Smoothing ----------\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d):\n                # Shortcut\n                new_pts = pts[:i + 1] + pts[j:]\n                pts = new_pts\n                n = len(pts)\n        return pts",
          "objective": 23.10764,
          "time_improvement": -139.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1239.0,
          "node_improvement": 31.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.13042638301849366,
                    "num_nodes_avg": 488.2,
                    "path_length_avg": 150.21700760008898,
                    "smoothness_avg": 0.03945954965394641,
                    "success_improvement": 0.0,
                    "time_improvement": -411.50017251100286,
                    "node_improvement": -22.941324603374454,
                    "length_improvement": 17.663677793580806,
                    "smoothness_improvement": 517.6276398678153,
                    "objective_score": -110.2637068778133
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08705599308013916,
                    "num_nodes_avg": 504.4,
                    "path_length_avg": 233.63485048296306,
                    "smoothness_avg": 0.08420769273445602,
                    "success_improvement": 0.0,
                    "time_improvement": 45.6570260313673,
                    "node_improvement": 66.10898340388363,
                    "length_improvement": 22.005962102482787,
                    "smoothness_improvement": 2066.7245864070437,
                    "objective_score": 37.23430800293508
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07347123622894287,
                    "num_nodes_avg": 396.5,
                    "path_length_avg": 117.99846302312123,
                    "smoothness_avg": 0.09690125523828255,
                    "success_improvement": 0.0,
                    "time_improvement": -49.783437632906015,
                    "node_improvement": 49.586776859504134,
                    "length_improvement": 21.63103934304284,
                    "smoothness_improvement": 1132.5768141243043,
                    "objective_score": 3.7064763865754218
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "HF-IRRT#-OS: Heuristic-Filtered Informed RRT# with Online Shortcuts \u2014 a single-tree, cost-optimal planner that uses grid-accelerated neighbors, admissible cost+heuristic pruning, correct-cost rewiring with queued propagation, per-cell best-cost duplicate suppression, aggressive informed sampling after the first solution, and incremental shortcutting to continuously reduce path length.",
          "planning_mechanism": "At each iteration, sample (goal/line/ellipse-biased), steer a bounded step, validate node and edge, select the lowest-cost valid parent within an adaptive radius, commit the node, and rewire cheaper neighbors with proper subtree cost updates. When near the goal, connect via the best valid parent to update the incumbent path. After any improvement, perform bounded shortcuts on the current best path to tighten c_best and focus the informed set. Terminate on post-optimization or no-improvement budgets and return a compressed, smoothed path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=4.0,\n                 gamma_radius=60.0,\n                 min_radius_factor=1.0,\n                 goal_bias=0.15,\n                 line_bias=0.35,\n                 connect_radius_factor=2.5,\n                 near_cap=72,\n                 post_opt_iters=600,\n                 max_no_improve=240,\n                 smoothing_iters=220,\n                 ellipse_tries=220,\n                 occ_gain_ratio=0.985,\n                 prune_margin=1.0005,\n                 online_shortcuts_per_improve=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_radius = gamma_radius\n        self.min_radius_factor = min_radius_factor\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.connect_radius_factor = connect_radius_factor\n        self.near_cap = near_cap\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n        self.ellipse_tries = ellipse_tries\n        self.occ_gain_ratio = occ_gain_ratio\n        self.prune_margin = prune_margin\n        self.online_shortcuts_per_improve = online_shortcuts_per_improve\n\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Early feasibility: straight line\n        if self._in_bounds(start) and self._in_bounds(goal):\n            if (not self._is_in_obstacle(start, obstacles, is_3d)) and (not self._is_in_obstacle(goal, obstacles, is_3d)):\n                if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d):\n                    s = Node(start, None, 0.0)\n                    g = Node(goal, None, self._dist(start, goal))\n                    g.attach(s)\n                    nodes = [s, g]\n                    edges = [(s, g)]\n                    path = [start, goal]\n                    return PlannerResult(success=True, path=path, nodes=nodes, edges=edges)\n\n        # Initialize\n        root = Node(start, None, 0.0)\n        nodes = [root]\n\n        # Spatial hash grid for NN queries\n        cell = max(1.0, 0.8 * self.step_size)\n        grid = {}\n        self._grid_add(grid, root, cell)\n\n        # Per-cell best-cost ledger to suppress duplicates\n        occ_cell = max(0.5, 0.6 * self.step_size)\n        occ_best_cost = {self._occ_key(start, occ_cell): 0.0}\n\n        success = False\n        goal_node = None\n        best_cost = float('inf')\n        best_path_pts = None\n\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            # Sampling\n            if self._rand() < self.goal_bias:\n                x_rand = goal\n            else:\n                x_rand = self._sample(start, goal, best_cost)\n\n            # Nearest\n            n_near = self._nearest(grid, nodes, x_rand, cell)\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n\n            # Bounds and node collision\n            if not self._in_bounds(x_new_pos):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Parent selection within adaptive radius\n            r_near = self._rrtstar_radius(max(2, len(nodes)))\n            near_nodes = self._near(grid, x_new_pos, r_near, cell)\n            if near_nodes:\n                near_nodes = self._k_nearest_limit(near_nodes, x_new_pos, self.near_cap)\n            # Ensure nearest is considered\n            if n_near not in near_nodes:\n                near_nodes.append(n_near)\n\n            best_parent = None\n            best_pc = float('inf')\n\n            for nn in near_nodes:\n                base_cost = nn.cost + self._dist(nn.position, x_new_pos)\n                if base_cost + 1e-12 < best_pc:\n                    # Edge collision check for candidate parent\n                    if not self._is_edge_in_obstacle(nn.position, x_new_pos, obstacles, is_3d):\n                        best_parent = nn\n                        best_pc = base_cost\n\n            if best_parent is None:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Duplicate suppression using per-cell best cost\n            k_occ = self._occ_key(x_new_pos, occ_cell)\n            prev_best = occ_best_cost.get(k_occ, float('inf'))\n            if best_pc >= prev_best * self.occ_gain_ratio:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Commit new node (both checks already validated for chosen parent)\n            x_new = Node(x_new_pos, None, best_pc)\n            x_new.attach(best_parent)\n            nodes.append(x_new)\n            self._grid_add(grid, x_new, cell)\n            if best_pc < prev_best:\n                occ_best_cost[k_occ] = best_pc\n\n            # Rewire neighbors with admissible pruning toward path-length improvement\n            for nn in near_nodes:\n                if nn is x_new or nn is best_parent:\n                    continue\n                alt = x_new.cost + self._dist(x_new.position, nn.position)\n                if alt + 1e-12 < nn.cost:\n                    # If we already have a solution, skip rewires that cannot possibly lead to improving it\n                    if best_cost < float('inf'):\n                        h = self._dist(nn.position, goal)\n                        if alt + h >= best_cost * self.prune_margin:\n                            continue\n                    if not self._is_edge_in_obstacle(x_new.position, nn.position, obstacles, is_3d):\n                        nn.attach(x_new)\n                        nn.cost = alt\n                        self._propagate_costs_from(nn)\n\n            # Try connecting to the goal using best available parent within connection range\n            improved = False\n            r_conn = max(r_near, self.connect_radius_factor * self.step_size)\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                cand = self._near(grid, goal, r_conn, cell)\n                if x_new not in cand:\n                    cand.append(x_new)\n                best_parent_goal = None\n                best_goal_cost = best_cost\n                for p in cand:\n                    ctot = p.cost + self._dist(p.position, goal)\n                    if ctot + 1e-12 < best_goal_cost:\n                        if not self._is_edge_in_obstacle(p.position, goal, obstacles, is_3d):\n                            best_goal_cost = ctot\n                            best_parent_goal = p\n                if best_parent_goal is not None:\n                    if goal_node is None:\n                        goal_node = Node(goal, None, best_goal_cost)\n                        goal_node.attach(best_parent_goal)\n                        nodes.append(goal_node)\n                    else:\n                        goal_node.attach(best_parent_goal)\n                        goal_node.cost = best_goal_cost\n                    best_cost = best_goal_cost\n                    success = True\n                    found_first = True\n                    improved = True\n\n            # After improvement, do bounded online shortcuts to tighten c_best and focus sampling\n            if improved and goal_node is not None:\n                cur_path = self._extract_path(goal_node)\n                cur_path = self._compress(cur_path, obstacles, is_3d)\n                cur_path = self._shortcuts(cur_path, obstacles, is_3d, self.online_shortcuts_per_improve)\n                path_len = self._path_length(cur_path)\n                if path_len + 1e-12 < best_cost:\n                    best_cost = path_len\n                best_path_pts = cur_path\n                post_iters = 0\n                no_improve = 0\n            else:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        # Build final path\n        path = []\n        if success and goal_node is not None:\n            if best_path_pts is None:\n                path = self._extract_path(goal_node)\n                path = self._compress(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n            else:\n                # Final polishing\n                path = self._shortcuts(best_path_pts, obstacles, is_3d, self.smoothing_iters)\n\n        # Build edges from parent pointers\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # ---------- Utilities ----------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        # 32-bit LCG (Numerical Recipes variant)\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim))\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = min(1.0, 0.5 * self.step_size)\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _rrtstar_radius(self, n):\n        r = self.gamma_radius\n        if n > 2:\n            expo = 1.0 / float(max(2, self.dim))\n            r = self.gamma_radius * ((self._log_approx(n) / float(n)) ** expo)\n        rmin = max(self.min_radius_factor * self.step_size, 1e-6)\n        if r < rmin:\n            r = rmin\n        return r\n\n    def _log_approx(self, n):\n        if n <= 1:\n            return 0.0\n        # rough ln via bit_length\n        return (int(n).bit_length()) * 0.6931471805599453\n\n    # Spatial hashing\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest(self, grid, nodes, pos, cell):\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        # limit expansion\n        max_span = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > max_span:\n                max_span = self.bounds[i]\n        limit = max_span * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        # fallback\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _k_nearest_limit(self, nodes, center, k):\n        if len(nodes) <= k:\n            return nodes\n        # partial selection without full sort when large\n        idx = []\n        for i, n in enumerate(nodes):\n            idx.append((self._dist(n.position, center), i))\n        if len(nodes) <= 4 * k:\n            idx.sort(key=lambda t: t[0])\n            return [nodes[t[1]] for t in idx[:k]]\n        # approximate selection\n        sel = []\n        used = [False] * len(nodes)\n        for _ in range(k):\n            best = -1\n            bestd = float('inf')\n            for j, (d, i) in enumerate(idx):\n                if not used[j] and d < bestd:\n                    bestd = d\n                    best = j\n            if best == -1:\n                break\n            used[best] = True\n            sel.append(nodes[idx[best][1]])\n        return sel\n\n    def _occ_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _heuristic(self, a, b):\n        return self._dist(a, b)\n\n    def _sample(self, start, goal, c_best):\n        # Informed ellipsoidal rejection after first solution; else line/uniform mix\n        if c_best < float('inf'):\n            # accept points satisfying triangle inequality gate; try more to avoid fallback\n            tries = self.ellipse_tries\n            for _ in range(tries):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._in_bounds(p):\n                    if self._dist(p, start) + self._dist(p, goal) <= c_best:\n                        return p\n        # Line-biased sampling with jitter\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jitter = 0.5 * self.step_size\n            p = tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n            return p\n        # Uniform\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _propagate_costs_from(self, node):\n        # node.cost already set correctly by caller\n        stack = []\n        for c in node.children:\n            stack.append(c)\n        while stack:\n            u = stack.pop()\n            if u.parent is not None:\n                newc = u.parent.cost + self._dist(u.parent.position, u.position)\n                if abs(newc - u.cost) > 1e-12:\n                    u.cost = newc\n            for c in u.children:\n                stack.append(c)\n\n    def _extract_path(self, goal_node):\n        seq = []\n        cur = goal_node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
          "objective": 26.9043,
          "time_improvement": -154.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1520.0,
          "node_improvement": 44.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.10562500953674317,
                    "num_nodes_avg": 293.8,
                    "path_length_avg": 154.45237735825782,
                    "smoothness_avg": 0.04984145985356507,
                    "success_improvement": 0.0,
                    "time_improvement": -314.23529004756443,
                    "node_improvement": 26.013598589775878,
                    "length_improvement": 15.34220451539984,
                    "smoothness_improvement": 680.1270791706859,
                    "objective_score": -81.66462890917599
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.2455054998397827,
                    "num_nodes_avg": 623.2,
                    "path_length_avg": 228.05708400641493,
                    "smoothness_avg": 0.10153044277454511,
                    "success_improvement": 0.0,
                    "time_improvement": -53.25193033715656,
                    "node_improvement": 58.1267217630854,
                    "length_improvement": 23.867981099460806,
                    "smoothness_improvement": 2512.4514220110627,
                    "objective_score": 10.90746666858483
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09506032466888428,
                    "num_nodes_avg": 407.5,
                    "path_length_avg": 122.10575352004132,
                    "smoothness_avg": 0.1154296410531563,
                    "success_improvement": 0.0,
                    "time_improvement": -93.79641533507504,
                    "node_improvement": 48.188175460902734,
                    "length_improvement": 18.903172563144594,
                    "smoothness_improvement": 1368.2565140663191,
                    "objective_score": -9.95573849230416
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is an optimal variant of RRT that improves path quality over time by rewiring the tree to minimize path cost. It incrementally builds a space-filling tree from start toward the goal while performing local optimizations by choosing better parents and rewiring nearby nodes.",
          "planning_mechanism": "The planner samples a point, extends the nearest node toward it, finds nearby nodes within a radius, selects the node offering the lowest-cost path as the parent, and rewires suboptimal neighbors to the new node if a shorter path through it is possible and valid.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 40.329779996976704,
          "time_improvement": -177.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 159.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.07894549369812012,
                    "num_nodes_avg": 472.0,
                    "path_length_avg": 157.32038918113068,
                    "smoothness_avg": 0.014606659642752063,
                    "success_improvement": 0.0,
                    "time_improvement": -209.60479552537316,
                    "node_improvement": -18.86174767061193,
                    "length_improvement": 13.770201788727634,
                    "smoothness_improvement": 128.6259422781621,
                    "objective_score": -53.97618787298455
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.46640329360961913,
                    "num_nodes_avg": 1739.6,
                    "path_length_avg": 225.40943011339232,
                    "smoothness_avg": 0.011026273197920444,
                    "success_improvement": 0.0,
                    "time_improvement": -191.14298908956366,
                    "node_improvement": -16.885036618961227,
                    "length_improvement": 24.75184417744357,
                    "smoothness_improvement": 183.71395128606335,
                    "objective_score": -41.57322046397263
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.11344788074493409,
                    "num_nodes_avg": 800.3,
                    "path_length_avg": 117.65534395554543,
                    "smoothness_avg": 0.020903807431829922,
                    "success_improvement": 0.0,
                    "time_improvement": -131.28253235311988,
                    "node_improvement": -1.7546090273362944,
                    "length_improvement": 21.85892269015246,
                    "smoothness_improvement": 165.8948875743123,
                    "objective_score": -25.439931653972927
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Beam-guided BiRRT*-Lite with k-nearest parent selection, ancestor line-of-sight compression, duplicate suppression, minimal-connect bridging, and shortcut smoothing to yield shorter, smoother paths with fewer samples",
          "planning_mechanism": "Alternate growing two optimized trees from start and goal; sample uniformly with goal bias, then restrict to an informed ellipse after the first solution. For each sample, steer one step, reject near-duplicates, choose a low-cost parent among k-nearest neighbors and visible ancestors, rewire locally, and attempt a minimal-connect join to the opposite tree (direct bridge or at most one assisted step). Maintain the best path online and terminate after a post-optimization budget. Return the best path after shortcut smoothing and corner culling.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=7.0,\n                 k_near=15,\n                 goal_bias=0.12,\n                 min_sep=1.2,\n                 collision_step=1.0,\n                 post_opt_iters=700,\n                 no_improve_limit=220,\n                 smooth_iters=220):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.k_near = k_near\n        self.goal_bias = goal_bias\n        self.min_sep = min_sep\n        self.collision_step = collision_step\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit\n        self.smooth_iters = smooth_iters\n        self.dim = 2\n        self.bounds = None\n        self._lcg_state = 123456789\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(success=False, path=[], nodes=[], edges=[])\n\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        tree_s = [start_root]\n        tree_g = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        meet_s = None\n        meet_g = None\n        success = False\n        found_first = False\n        since_improve = 0\n        post_iters = 0\n\n        for it in range(self.max_iter):\n            grow_s = (it % 2 == 0)\n            tree_a = tree_s if grow_s else tree_g\n            tree_b = tree_g if grow_s else tree_s\n            anchor_a = start if grow_s else goal\n            anchor_b = goal if grow_s else start\n\n            x_rand = self._sample(anchor_a, anchor_b, best_cost)\n            if self._rand() < self.goal_bias:\n                x_rand = anchor_b\n\n            x_near = self._nearest(tree_a, x_rand)\n            x_new_pos = self._steer(x_near.position, x_rand, self.step_size)\n\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    since_improve += 1\n                continue\n            if self._is_edge_in_obstacle(x_near.position, x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    since_improve += 1\n                continue\n\n            dmin = self._dist(x_near.position, x_new_pos)\n            if dmin < self.min_sep:\n                if found_first:\n                    post_iters += 1\n                    since_improve += 1\n                continue\n\n            neigh = self._k_nearest(tree_a, x_new_pos, self.k_near)\n            best_parent = x_near\n            best_pc = x_near.cost + self._dist(x_near.position, x_new_pos)\n            for n in neigh:\n                c = n.cost + self._dist(n.position, x_new_pos)\n                if c + 1e-12 < best_pc and not self._is_edge_in_obstacle(n.position, x_new_pos, obstacles, is_3d):\n                    best_parent = n\n                    best_pc = c\n            anc = best_parent\n            steps_up = 0\n            while anc is not None and steps_up < 4:\n                c = anc.cost + self._dist(anc.position, x_new_pos)\n                if c + 1e-12 < best_pc and not self._is_edge_in_obstacle(anc.position, x_new_pos, obstacles, is_3d):\n                    best_parent = anc\n                    best_pc = c\n                anc = anc.parent\n                steps_up += 1\n\n            if self._is_edge_in_obstacle(best_parent.position, x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    since_improve += 1\n                continue\n\n            x_new = Node(x_new_pos)\n            best_parent.add_child(x_new)\n            x_new.cost = best_pc\n            tree_a.append(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            for n in neigh:\n                alt = x_new.cost + self._dist(x_new.position, n.position)\n                if alt + 1e-12 < n.cost and not self._is_edge_in_obstacle(x_new.position, n.position, obstacles, is_3d):\n                    op = n.parent\n                    if op is not None:\n                        self._remove_edge(edges, op, n)\n                        try:\n                            op.children.remove(n)\n                        except:\n                            pass\n                    x_new.add_child(n)\n                    n.cost = alt\n                    edges.append((x_new, n))\n                    self._propagate_costs(n, edges)\n\n            b_near = self._nearest(tree_b, x_new.position)\n            improved = False\n\n            if not self._is_edge_in_obstacle(x_new.position, b_near.position, obstacles, is_3d):\n                cand_cost = x_new.cost + self._dist(x_new.position, b_near.position) + b_near.cost\n                if cand_cost + 1e-12 < best_cost:\n                    best_cost = cand_cost\n                    meet_s = x_new if grow_s else b_near\n                    meet_g = b_near if grow_s else x_new\n                    success = True\n                    found_first = True\n                    since_improve = 0\n                    post_iters = 0\n                    improved = True\n            else:\n                near_b = self._k_nearest(tree_b, x_new.position, min(5, len(tree_b)))\n                for nb in near_b:\n                    if not self._is_edge_in_obstacle(x_new.position, nb.position, obstacles, is_3d):\n                        cand_cost = x_new.cost + self._dist(x_new.position, nb.position) + nb.cost\n                        if cand_cost + 1e-12 < best_cost:\n                            best_cost = cand_cost\n                            meet_s = x_new if grow_s else nb\n                            meet_g = nb if grow_s else x_new\n                            success = True\n                            found_first = True\n                            since_improve = 0\n                            post_iters = 0\n                            improved = True\n                if not improved:\n                    step_b_pos = self._steer(b_near.position, x_new.position, self.step_size)\n                    if (not self._is_in_obstacle(step_b_pos, obstacles, is_3d) and\n                        not self._is_edge_in_obstacle(b_near.position, step_b_pos, obstacles, is_3d) and\n                        self._dist(step_b_pos, x_new.position) + 1e-12 < self._dist(b_near.position, x_new.position)):\n                        b_new = Node(step_b_pos)\n                        b_new.cost = b_near.cost + self._dist(b_near.position, step_b_pos)\n                        b_near.add_child(b_new)\n                        tree_b.append(b_new)\n                        nodes.append(b_new)\n                        edges.append((b_near, b_new))\n                        if not self._is_edge_in_obstacle(x_new.position, b_new.position, obstacles, is_3d):\n                            cand_cost = x_new.cost + self._dist(x_new.position, b_new.position) + b_new.cost\n                            if cand_cost + 1e-12 < best_cost:\n                                best_cost = cand_cost\n                                meet_s = x_new if grow_s else b_new\n                                meet_g = b_new if grow_s else x_new\n                                success = True\n                                found_first = True\n                                since_improve = 0\n                                post_iters = 0\n                                improved = True\n\n            if found_first and not improved:\n                post_iters += 1\n                since_improve += 1\n\n            if found_first and (post_iters >= self.post_opt_iters or since_improve >= self.no_improve_limit):\n                break\n\n        path = []\n        if success and meet_s is not None and meet_g is not None:\n            path_s = self._path_to_root(meet_s if self._is_rooted(meet_s, start) else meet_g)\n            path_g = self._path_to_root(meet_g if self._is_rooted(meet_g, goal) else meet_s)\n            if path_s and path_g:\n                if path_s[-1] != meet_s.position:\n                    path_s = self._path_to_root(meet_s)\n                if path_g[-1] != meet_g.position:\n                    path_g = self._path_to_root(meet_g)\n                path = list(path_s)\n                if path and path[-1] != meet_g.position:\n                    path.append(meet_g.position)\n                for i in range(len(path_g) - 2, -1, -1):\n                    path.append(path_g[i])\n            path = self._shortcut_smooth(path, obstacles, (self.dim == 3), self.smooth_iters)\n            path = self._corner_cull(path, obstacles, (self.dim == 3))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 31)\n        return (self._lcg_state / float(1 << 31))\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        res = self.collision_step\n        if res <= 0.0:\n            res = 1.0\n        steps = int(d / res)\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _nearest(self, tree, pos):\n        best = tree[0]\n        bd = self._dist(best.position, pos)\n        for n in tree[1:]:\n            d = self._dist(n.position, pos)\n            if d < bd:\n                bd = d\n                best = n\n        return best\n\n    def _k_nearest(self, tree, pos, k):\n        k = min(k, len(tree))\n        best_nodes = []\n        best_d = []\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if len(best_nodes) < k:\n                best_nodes.append(n)\n                best_d.append(d)\n            else:\n                mi = 0\n                md = best_d[0]\n                for i in range(1, k):\n                    if best_d[i] > md:\n                        md = best_d[i]\n                        mi = i\n                if d < md:\n                    best_nodes[mi] = n\n                    best_d[mi] = d\n        return best_nodes\n\n    def _propagate_costs(self, node, edges):\n        q = []\n        for c in node.children:\n            q.append(c)\n        while q:\n            u = q.pop(0)\n            if u.parent is not None:\n                u.cost = u.parent.cost + self._dist(u.parent.position, u.position)\n            for c in u.children:\n                q.append(c)\n\n    def _remove_edge(self, edges, a, b):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is a and e[1] is b:\n                edges.pop(i)\n                return\n\n    def _sample(self, start, goal, c_best):\n        if c_best < float('inf'):\n            for _ in range(40):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._in_bounds(p):\n                    if self._dist(p, start) + self._dist(p, goal) <= c_best + 1e-12:\n                        return p\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _path_to_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        path.reverse()\n        return path\n\n    def _is_rooted(self, node, root_pos):\n        cur = node\n        while cur is not None:\n            if cur.parent is None:\n                return cur.position == root_pos\n            cur = cur.parent\n        return False\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts\n\n    def _corner_cull(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return path\n        pts = list(path)\n        i = 0\n        while i + 2 < len(pts):\n            if not self._is_edge_in_obstacle(pts[i], pts[i + 2], obstacles, is_3d):\n                pts.pop(i + 1)\n                if i > 0:\n                    i -= 1\n            else:\n                i += 1\n        return pts",
          "objective": 46.86581,
          "time_improvement": -222.0,
          "length_improvement": 21.0,
          "smoothness_improvement": 1350.0,
          "node_improvement": 56.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.12672626972198486,
                    "num_nodes_avg": 224.0,
                    "path_length_avg": 151.04604638266187,
                    "smoothness_avg": 0.04539272095459672,
                    "success_improvement": 0.0,
                    "time_improvement": -396.9892388664952,
                    "node_improvement": 43.59103500377739,
                    "length_improvement": 17.20926849989242,
                    "smoothness_improvement": 610.494654810689,
                    "objective_score": -105.71873728595966
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.23903167247772217,
                    "num_nodes_avg": 458.1,
                    "path_length_avg": 224.6084593129665,
                    "smoothness_avg": 0.08165490678798919,
                    "success_improvement": 0.0,
                    "time_improvement": -49.21077223457742,
                    "node_improvement": 69.21991533964925,
                    "length_improvement": 25.019231285291898,
                    "smoothness_improvement": 2001.0395653070552,
                    "objective_score": 10.25350492733719
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1562047243118286,
                    "num_nodes_avg": 356.3,
                    "path_length_avg": 117.41298133837836,
                    "smoothness_avg": 0.12092396219800525,
                    "success_improvement": 0.0,
                    "time_improvement": -218.44952913299713,
                    "node_improvement": 54.698029243483795,
                    "length_improvement": 22.019888400407194,
                    "smoothness_improvement": 1438.1438734801966,
                    "objective_score": -45.13220633225384
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "Fast Informed BiRRT*-Connect (FIBRC-Lite): a time-focused bidirectional planner that mixes cheap RRT-Connect growth with light RRT* improvements and informed sampling. It accelerates nearest/near queries with a fine spatial hash, selects best parents within a small adaptive neighborhood, performs capped local rewires, and attempts short greedy bridges to the opposite tree. Upon first feasible join it extracts and quickly shortens the path with bounded shortcutting and a final line-of-sight collapse, returning early to minimize compute.",
          "planning_mechanism": "Alternate expanding start/goal trees; sample with goal and informed biases; find nearest via grid; steer once; validate node and edge; choose best parent among near neighbors; insert and perform small-budget rewires; try greedy connect to the other tree (few steps); if join succeeds, extract [start\u2192...\u2192A, B\u2192...\u2192goal], run bounded shortcut smoothing and return; otherwise loop up to iteration budget.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=6.0,\n                 goal_bias=0.25,\n                 informed_bias=0.6,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=60,\n                 rewire_budget=6,\n                 connect_steps=8,\n                 min_sep_ratio=0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.informed_bias = informed_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n        self.rewire_budget = rewire_budget\n        self.connect_steps = connect_steps\n        self.min_sep_ratio = min_sep_ratio\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.start = None\n        self.goal = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size)\n        self.edge_res = max(0.5, min(self.collision_step, self.step_size * 0.5))\n\n        # Validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._is_edge_in_obstacle(self.start, self.goal, obstacles, is_3d, self.edge_res):\n            path = [self.start, self.goal]\n            nodes = [Node(self.start), Node(self.goal)]\n            return PlannerResult(True, path, nodes, [])\n\n        # Initialize trees, grids, edges\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes_all = [start_root, goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Best-so-far path length for informed sampling\n        c_best = float('inf')\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = self.goal if active_start else self.start\n\n            # Sampling with goal bias and informed bias (if an incumbent path exists)\n            r = self._rand()\n            if c_best < float('inf') and r < self.informed_bias:\n                x_rand = self._sample_informed(c_best, obstacles, is_3d)\n            elif r < self.informed_bias + self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest and steer\n            nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._dist(nearest.position, new_pos) < self.step_size * self.min_sep_ratio:\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                continue\n\n            # Best-parent selection in a compact neighborhood\n            r_near = self._neighbor_radius(len(tree_a))\n            candidates = self._nearby_nodes(grid_a, tree_a, new_pos, r_near)\n            best_parent = None\n            best_cost = float('inf')\n            for q in candidates:\n                edge_len = self._dist(q.position, new_pos)\n                cand_cost = q.cost + edge_len\n                if cand_cost < best_cost:\n                    if not self._is_edge_in_obstacle(q.position, new_pos, obstacles, is_3d, self.edge_res):\n                        best_cost = cand_cost\n                        best_parent = q\n            if best_parent is None:\n                best_parent = nearest\n                best_cost = nearest.cost + self._dist(nearest.position, new_pos)\n\n            # Insert node (both node and parent->child edge validated)\n            new_node = Node(new_pos, parent=best_parent, cost=best_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes_all.append(new_node)\n            self._edges_add(edges, best_parent, new_node)\n            self._grid_add(grid_a, new_node)\n\n            # Limited rewiring to improve local path quality\n            rewired = 0\n            for q in candidates:\n                if rewired >= self.rewire_budget or q is best_parent or q is new_node:\n                    continue\n                alt_cost = new_node.cost + self._dist(new_node.position, q.position)\n                if alt_cost + 1e-9 < q.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, q.position, obstacles, is_3d, self.edge_res):\n                        old_parent = q.parent\n                        if old_parent is not None:\n                            old_parent.remove_child(q)\n                            self._edges_remove(edges, old_parent, q)\n                        new_node.add_child(q)\n                        cost_delta = alt_cost - q.cost\n                        q.cost = alt_cost\n                        self._edges_add(edges, new_node, q)\n                        self._propagate_cost_from(q, cost_delta)\n                        rewired += 1\n\n            # Try commit-only direct connection to the other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None and not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                path = self._extract_path(new_node, other_near)\n                c_best = self._path_length(path)\n                path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Greedy short connect from the other tree toward new_node\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, new_node.position, self.step_size)\n                if self._dist(p.position, to_pos) < self.step_size * self.min_sep_ratio:\n                    break\n                if not self._in_bounds(to_pos):\n                    break\n                if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(p.position, to_pos, obstacles, is_3d, self.edge_res):\n                    break\n                # Attach greedily to p (node and edge validated)\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                nodes_all.append(q)\n                self._edges_add(edges, p, q)\n                self._grid_add(grid_b, q)\n                p = q\n                steps += 1\n\n                # Check if we can bridge now\n                if not self._is_edge_in_obstacle(new_node.position, p.position, obstacles, is_3d, self.edge_res):\n                    path = self._extract_path(new_node, p)\n                    c_best = self._path_length(path)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- Random ----------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Sampling ----------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_informed(self, c_best, obstacles, is_3d):\n        # Axis-aligned bounding box enclosing start-goal with margin proportional to current best\n        dsg = self._dist(self.start, self.goal)\n        margin = max(0.0, (c_best - dsg)) * 0.5 + self.step_size\n        low = []\n        high = []\n        for i in range(self.dim):\n            a = self.start[i]\n            b = self.goal[i]\n            lo = min(a, b) - margin\n            hi = max(a, b) + margin\n            lo = 0.0 if lo < 0.0 else lo\n            hi = self.bounds[i] if hi > self.bounds[i] else hi\n            low.append(lo)\n            high.append(hi)\n        # Rejection sample inside the AABB\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(low[0], high[0]),\n                     self._uniform(low[1], high[1]),\n                     self._uniform(low[2], high[2]))\n            else:\n                p = (self._uniform(low[0], high[0]),\n                     self._uniform(low[1], high[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ---------- Grid and neighbor queries ----------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # expand rings until at least one candidate found or capped radius\n        for r in range(0, 5):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _nearby_nodes(self, grid, tree, pos, radius):\n        key = self._grid_key(pos)\n        # Convert radius to grid cells (ceil approx)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        res = []\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                res.append(n)\n        if not res:\n            # ensure at least nearest is considered\n            res = [self._nearest_grid(grid, tree, pos)]\n        return res\n\n    def _neighbor_radius(self, n_nodes):\n        # Compact adaptive radius in [1.5, 3.0] * step_size shrinking with growth\n        base = 3.0 * self.step_size / (1.0 + 0.01 * max(1, n_nodes))\n        r = base if base > 1.5 * self.step_size else 1.5 * self.step_size\n        if r > 3.0 * self.step_size:\n            r = 3.0 * self.step_size\n        return r\n\n    # ---------- Edges and costs ----------\n    def _edges_add(self, edges, parent, child):\n        edges.append((parent, child))\n\n    def _edges_remove(self, edges, parent, child):\n        # remove first occurrence\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_cost_from(self, node, delta):\n        if delta == 0.0:\n            return\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    # ---------- Path ----------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)  # start -> ... -> meet_a (or goal side if swapped)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # path_a already ends at meet_a; append meet_b->...->root_other\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        nstall = 0\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n                nstall = 0\n            else:\n                nstall += 1\n                if nstall > 12:\n                    break\n        # Final pass: line-of-sight collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            for k in range(1, len(pts) - 1):\n                nxt = pts[k + 1]\n                if not self._is_edge_in_obstacle(last, nxt, obstacles, is_3d, self.edge_res):\n                    continue\n                else:\n                    collapsed.append(pts[k])\n                    last = pts[k]\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
          "objective": 54.38004,
          "time_improvement": -43.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 3325.0,
          "node_improvement": 81.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0447272777557373,
                    "num_nodes_avg": 62.9,
                    "path_length_avg": 172.72321740556453,
                    "smoothness_avg": 0.04175474386966843,
                    "success_improvement": 0.0,
                    "time_improvement": -75.40937468735302,
                    "node_improvement": 84.16016116847143,
                    "length_improvement": 5.32766756548325,
                    "smoothness_improvement": 553.5524134378776,
                    "objective_score": -16.65844979972657
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.13959274291992188,
                    "num_nodes_avg": 188.6,
                    "path_length_avg": 237.8767141690268,
                    "smoothness_avg": 0.18878187016499196,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 12.862003794222588,
                    "node_improvement": 87.32782369146005,
                    "length_improvement": 20.589905908798265,
                    "smoothness_improvement": 4757.493493430209,
                    "objective_score": -9.99998784930321
               },
               {
                    "map_id": 2,
                    "success_rate": 0.7,
                    "time_avg": 0.0813495397567749,
                    "num_nodes_avg": 220.3,
                    "path_length_avg": 125.59197842186634,
                    "smoothness_avg": 0.37451567120397955,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": -65.84468072179355,
                    "node_improvement": 71.98982835346473,
                    "length_improvement": 16.587787979542895,
                    "smoothness_improvement": 4663.811693843319,
                    "objective_score": -136.48167295959576
               }
          ],
          "success_rate": 0.8666666666666666
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm with post-optimization: a bidirectional RRT*-Connect that, after finding a first feasible \u201cbest shot\u201d path, keeps optimizing for only a user-defined number of extra iterations (or until no further improvements occur), then terminates\u2014while maintaining strict collision checks and a 30 s time cap.",
          "planning_mechanism": "Mechanism: Alternate tree growth with RRT* best-parent selection and local rewiring; greedily connect the opposite tree; upon the first connection, record the best path and continue only N additional iterations (or until M consecutive non-improving attempts), always staying within bounds and validating node and edge collisions; stop early on time limit and return the best path so far.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from its tree root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        post_opt_iters: int = 400,   # extra iterations after first solution\n        max_no_improve: int = 150,   # early stop if no improvement for this many iterations\n        improve_tol: float = 1e-6,   # minimal cost drop to count as improvement\n        goal_sample_rate: float = 0.05,   # mild goal bias\n        bridge_bias_rate: float = 0.15,   # bias toward the opposite tree root\n        neighbor_gamma: float = 60.0,     # RRT* radius coefficient\n        time_limit_sec: float = 30.0      # hard wall time limit\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.goal_sample_rate = goal_sample_rate\n        self.bridge_bias_rate = bridge_bias_rate\n        self.neighbor_gamma = neighbor_gamma\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map: Map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Core data\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        # Initialize bidirectional trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root  = Node(goal_position,  cost=0.0)\n        tree_start: List[Node] = [start_root]\n        tree_goal:  List[Node] = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Practical RRT* neighborhood clamps\n        max_radius = max(bounds) * 0.30\n        min_radius = max(10.0, self.step_size * 2.0)\n\n        # Best solution tracking + post-optimization control\n        best_cost = float(\"inf\")\n        best_path: List[Tuple[float, ...]] = []\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        # Hard time limit\n        start_time = time.time()\n\n        # ----------------- Helper functions -----------------\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def clamp_bounds(p):\n            return tuple(min(max(p[d], 0.0), bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = math.dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return clamp_bounds(to_pos)\n            r = self.step_size / d\n            return clamp_bounds(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(dim)))\n\n        def nearest(tree, pt):\n            return min(tree, key=lambda n: math.dist(n.position, pt))\n\n        def neighbor_radius(n_nodes: int) -> float:\n            if n_nodes < 2:\n                return min_radius\n            r_theory = self.neighbor_gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(min_radius, min(max_radius, r_theory))\n\n        def near_nodes(tree, pos, radius):\n            return [nd for nd in tree if math.dist(nd.position, pos) <= radius]\n\n        def uniform_sample():\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def sample_free(active_tree, other_tree):\n            # Goal bias toward the global goal or start depending on active tree\n            if random.random() < self.goal_sample_rate:\n                return goal_position if active_tree is tree_start else start_position\n            # Bridge bias: sample around the opposite root to encourage meeting\n            if random.random() < self.bridge_bias_rate:\n                anchor = other_tree[0].position\n                jitter = tuple(random.uniform(-2.0*self.step_size, 2.0*self.step_size) for _ in range(dim))\n                s = clamp_bounds(tuple(anchor[i] + jitter[i] for i in range(dim)))\n                return s if not self._is_in_obstacle(s, obstacles, is_3d) else uniform_sample()\n            # Uniform fallback\n            return uniform_sample()\n\n        def add_with_best_parent(tree, new_pos):\n            \"\"\"Insert new_pos with RRT* best-parent selection; returns (new_node, neighbors) or (None, []).\"\"\"\n            r = neighbor_radius(len(tree))\n            neigh = near_nodes(tree, new_pos, r)\n            if not neigh:\n                parent = nearest(tree, new_pos)\n                if self._is_edge_in_obstacle(parent.position, new_pos, obstacles, is_3d):\n                    return None, []\n            else:\n                candidates = [nb for nb in neigh if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d)]\n                if not candidates:\n                    return None, []\n                parent = min(candidates, key=lambda nb: nb.cost + math.dist(nb.position, new_pos))\n\n            new_node = Node(new_pos, parent=None, cost=parent.cost + math.dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neigh\n\n        def rewire_from(pivot: Node, neigh: List[Node]):\n            \"\"\"Local RRT* rewiring around pivot (edge and cost validated).\"\"\"\n            for nb in neigh:\n                if nb is pivot:\n                    continue\n                if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                    continue\n                new_c = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_c + 1e-12 < nb.cost:\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_c\n                    edges.append((pivot, nb))\n\n        def stitch_paths(a_node: Node, b_node: Node, a_is_start_side: bool) -> List[Tuple[float, ...]]:\n            \"\"\"Combine root\u2192a_node and root\u2192b_node into a single start\u2192goal path.\"\"\"\n            pa = a_node.path_from_root()\n            pb = b_node.path_from_root()\n            if pa and pb and pa[-1] == pb[-1]:\n                merged = pa + pb[-2::-1]\n            else:\n                merged = pa + pb[::-1]\n            return merged if a_is_start_side else merged[::-1]\n\n        def path_cost(path: List[Tuple[float, ...]]) -> float:\n            return sum(math.dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        # ----------------- Main loop -----------------\n        for it in range(self.max_iter):\n            # Enforce 30s time limit (return best so far)\n            if time.time() - start_time > self.time_limit_sec:\n                return PlannerResult(\n                    success=(len(best_path) > 0),\n                    path=best_path if best_path else [],\n                    nodes=nodes,\n                    edges=edges\n                )\n\n            # Alternate trees\n            if it % 2 == 0:\n                grow_tree, other_tree = tree_start, tree_goal\n                a_is_start_side = True\n            else:\n                grow_tree, other_tree = tree_goal, tree_start\n                a_is_start_side = False\n\n            # Sampling\n            s = sample_free(grow_tree, other_tree)\n\n            # Extend grow_tree toward sample\n            a_near = nearest(grow_tree, s)\n            a_new_pos = steer(a_near.position, s)\n\n            # Node & edge validity\n            if not within_bounds(a_new_pos) or self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            if self._is_edge_in_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            a_new, a_neigh = add_with_best_parent(grow_tree, a_new_pos)\n            if a_new is None:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            rewire_from(a_new, a_neigh)\n\n            # Greedy connect the other tree toward a_new with stepwise rewiring\n            b_near = nearest(other_tree, a_new.position)\n            current = b_near\n            connected_b = None\n\n            while True:\n                step_pos = steer(current.position, a_new.position)\n                if not within_bounds(step_pos) or self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                    break\n\n                b_new, b_neigh = add_with_best_parent(other_tree, step_pos)\n                if b_new is None:\n                    break\n                rewire_from(b_new, b_neigh)\n                current = b_new\n\n                # Try to close the final short bridge exactly to a_new\n                if math.dist(current.position, a_new.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(current.position, a_new.position, obstacles, is_3d) and a_new.valid:\n                        final_b = Node(\n                            a_new.position,\n                            parent=None,\n                            cost=current.cost + math.dist(current.position, a_new.position)\n                        )\n                        current.add_child(final_b)\n                        other_tree.append(final_b)\n                        nodes.append(final_b)\n                        edges.append((current, final_b))\n                        connected_b = final_b\n                    break\n\n            # If a connection was made, evaluate candidate and manage post-optimization counters\n            if connected_b is not None:\n                candidate = stitch_paths(a_new, connected_b, a_is_start_side)\n                cand_cost = path_cost(candidate)\n\n                if cand_cost + self.improve_tol < best_cost:\n                    best_cost = cand_cost\n                    best_path = candidate\n                    success_state = True\n                    no_improve_streak = 0\n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0\n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                # No successful connection this iteration\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        extracted_path = best_path if success_state else []\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ----------------- Collision utilities -----------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": 61.276875445186825,
          "time_improvement": -249.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 396.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.1527228832244873,
                    "num_nodes_avg": 353.2,
                    "path_length_avg": 154.84589437556275,
                    "smoothness_avg": 0.036504670776118395,
                    "success_improvement": 0.0,
                    "time_improvement": -498.94155850834557,
                    "node_improvement": 11.055149836313278,
                    "length_improvement": 15.12651160253883,
                    "smoothness_improvement": 471.37736880762213,
                    "objective_score": -138.24967374694225
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.14496326446533203,
                    "num_nodes_avg": 649.1,
                    "path_length_avg": 236.19902822185213,
                    "smoothness_avg": 0.016202565568581816,
                    "success_improvement": 0.0,
                    "time_improvement": 9.509562426153382,
                    "node_improvement": 56.3864812201841,
                    "length_improvement": 21.14996576747767,
                    "smoothness_improvement": 316.90368231587473,
                    "objective_score": 17.12736659991199
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.17532651424407958,
                    "num_nodes_avg": 731.9,
                    "path_length_avg": 119.13487163387659,
                    "smoothness_avg": 0.03924013026708708,
                    "success_improvement": 0.0,
                    "time_improvement": -257.4325050124552,
                    "node_improvement": 6.942148760330581,
                    "length_improvement": 20.87629085374207,
                    "smoothness_improvement": 399.1315605922187,
                    "objective_score": -62.708319188530226
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm with post-optimization limits: a two-tree, asymptotically optimal planner that, after finding a first feasible path, continues improving within the start\u2013goal ellipsoid for only a user-defined number of extra iterations (or until no improvement is observed), then stops.",
          "planning_mechanism": "Mechanism: Alternate expanding start/goal trees with RRT* best-parent selection and local rewiring; greedily connect the opposite tree; upon first connection, switch to informed (ellipsoidal) sampling and keep optimizing for N additional iterations (or until M consecutive non-improvements), always enforcing node and edge collision checks, bounds, and a strict 30 s time limit that returns the best path so far.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        neighbor_radius: float = 25.0,\n        post_opt_iters: int = 400,    # extra iterations after first solution\n        max_no_improve: int = 150,    # stop early if this many consecutive iterations show no improvement\n        improve_tol: float = 1e-6,    # minimal cost drop to count as improvement\n        time_limit_sec: float = 30.0  # hard wall time limit\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map: Map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks / boxes\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Core data\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        # Initialize two trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root  = Node(goal_position,  cost=0.0)\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # RRT* neighborhood (practical clamp)\n        gamma_rrt_star = 60.0\n        max_radius = max(bounds) * 0.30\n        min_radius = max(10.0, self.step_size * 2.0)\n\n        # Best solution & informed sampling params\n        best_cost = float(\"inf\")\n        best_path: List[Tuple[float, ...]] = []\n        c_min = math.dist(start_position, goal_position)\n\n        # Post-optimization control\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        # Time guard\n        start_time = time.time()\n\n        # ---------- Helpers ----------\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def nearest(tree, pt):\n            return min(tree, key=lambda n: math.dist(n.position, pt))\n\n        def steer(from_pos, to_pos):\n            d = math.dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            r = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(dim))\n\n        def neighbor_radius_fn(n_nodes: int) -> float:\n            if n_nodes < 2:\n                return min_radius\n            r_theory = gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(min_radius, min(max_radius, r_theory))\n\n        def near_nodes(tree, pos, radius):\n            return [nd for nd in tree if math.dist(nd.position, pos) <= radius]\n\n        def add_with_best_parent(tree, new_pos):\n            \"\"\"Insert new_pos using RRT* best-parent selection; return (new_node, neighbors) or (None, []).\"\"\"\n            r = neighbor_radius_fn(len(tree))\n            neigh = near_nodes(tree, new_pos, r)\n            parent_candidates = neigh if neigh else [nearest(tree, new_pos)]\n            parent_candidates = [nb for nb in parent_candidates\n                                 if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d)]\n            if not parent_candidates:\n                return None, []\n            parent = min(parent_candidates, key=lambda nb: nb.cost + math.dist(nb.position, new_pos))\n            new_node = Node(new_pos, parent=None, cost=parent.cost + math.dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neigh\n\n        def rewire_from(pivot: Node, neigh: List[Node]):\n            for nb in neigh:\n                if nb is pivot:\n                    continue\n                if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                    continue\n                new_c = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_c + 1e-12 < nb.cost:\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_c\n                    edges.append((pivot, nb))\n\n        def stitch_paths(meet_a: Node, meet_b: Node, a_is_start_side: bool) -> List[Tuple[float, ...]]:\n            \"\"\"Create full path from start to goal using meeting nodes from both trees.\"\"\"\n            path_a = meet_a.path_from_root()\n            path_b = meet_b.path_from_root()\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start_side else merged[::-1]\n\n        def path_cost(path):\n            return sum(math.dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        # ---------- Main loop ----------\n        for it in range(self.max_iter):\n            # Hard time limit\n            if time.time() - start_time > self.time_limit_sec:\n                return PlannerResult(\n                    success=(len(best_path) > 0),\n                    path=best_path if best_path else [],\n                    nodes=nodes,\n                    edges=edges\n                )\n\n            # Choose expansion/connection sides\n            if it % 2 == 0:\n                grow_tree, other_tree = tree_a, tree_b\n                a_is_start_side = True\n            else:\n                grow_tree, other_tree = tree_b, tree_a\n                a_is_start_side = False\n\n            # Informed sampling (uniform before first solution; ellipsoid after)\n            sample = self._sample_informed(start_position, goal_position, best_cost, c_min, bounds)\n\n            # Extend grow_tree toward sample\n            a_near = nearest(grow_tree, sample)\n            a_new_pos = steer(a_near.position, sample)\n\n            if (not within_bounds(a_new_pos)) or self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                # count post-optimization iterations if already in post phase\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            if self._is_edge_in_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            a_new, a_neigh = add_with_best_parent(grow_tree, a_new_pos)\n            if a_new is None:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            rewire_from(a_new, a_neigh)\n\n            # Greedy connect other_tree toward a_new, with local rewiring each step\n            b_near = nearest(other_tree, a_new.position)\n            current = b_near\n            connected_b = None\n\n            while True:\n                step_pos = steer(current.position, a_new.position)\n                if (not within_bounds(step_pos)) or self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                    break\n\n                b_new, b_neigh = add_with_best_parent(other_tree, step_pos)\n                if b_new is None:\n                    break\n                rewire_from(b_new, b_neigh)\n                current = b_new\n\n                # Try a final short bridge\n                if math.dist(current.position, a_new.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(current.position, a_new.position, obstacles, is_3d) and a_new.valid:\n                        final_b = Node(\n                            a_new.position,\n                            parent=None,\n                            cost=current.cost + math.dist(current.position, a_new.position)\n                        )\n                        current.add_child(final_b)\n                        other_tree.append(final_b)\n                        nodes.append(final_b)\n                        edges.append((current, final_b))\n                        connected_b = final_b\n                    break\n\n            # If a connection was made, evaluate and manage post-optimization counters\n            if connected_b is not None:\n                candidate_path = stitch_paths(a_new, connected_b, a_is_start_side)\n                cand_cost = path_cost(candidate_path)\n\n                if cand_cost + self.improve_tol < best_cost:\n                    best_cost = cand_cost\n                    best_path = candidate_path\n                    success_state = True\n                    no_improve_streak = 0\n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0\n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                # No successful connection this iteration\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        extracted_path = best_path if success_state else []\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ---------------- Informed Sampling ----------------\n    def _sample_informed(self, start, goal, c_best, c_min, bounds):\n        \"\"\"Uniform in bounds if no solution; otherwise sample within the start\u2013goal ellipsoid.\"\"\"\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_min <= 1e-12:\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        # Ellipsoid radii\n        r1 = c_best / 2.0\n        r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n        r_other = math.sqrt(r_other_sq) / 2.0\n\n        # Center and first axis (unit)\n        center = tuple((s + g) / 2.0 for s, g in zip(start, goal))\n        a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n        # Orthonormal basis aligned with a1\n        if dim == 2:\n            a2 = (-a1[1], a1[0])\n            basis = (a1, a2)\n            radii = (r1, r_other)\n        else:  # 3D\n            ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = self._normalize(self._cross(a1, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._normalize(self._cross(a1, ref))\n            b3 = self._cross(a1, b2)\n            basis = (a1, b2, b3)\n            radii = (r1, r_other, r_other)\n\n        u = self._sample_unit_ball(dim)\n\n        mapped = []\n        for d in range(dim):\n            val = center[d]\n            for i in range(dim):\n                val += basis[i][d] * radii[i] * u[i]\n            mapped.append(val)\n\n        mapped = tuple(min(max(mapped[d], 0.0), bounds[d]) for d in range(dim))\n        return mapped\n\n    def _sample_unit_ball(self, dim):\n        while True:\n            v = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(x * x for x in v))\n            if n > 1e-12:\n                v = [x / n for x in v]\n                r = random.random() ** (1.0 / dim)\n                return tuple(v[i] * r for i in range(dim))\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)\n\n    # ---------------- Collision Utilities ----------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": 69.74757337278861,
          "time_improvement": -274.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 381.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.20740196704864503,
                    "num_nodes_avg": 464.8,
                    "path_length_avg": 153.4709982687105,
                    "smoothness_avg": 0.03085475415564487,
                    "success_improvement": 0.0,
                    "time_improvement": -713.3794671700809,
                    "node_improvement": -17.04860236716192,
                    "length_improvement": 15.880113945327547,
                    "smoothness_improvement": 382.94390470689814,
                    "objective_score": -202.57105226029324
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08997392654418945,
                    "num_nodes_avg": 441.1,
                    "path_length_avg": 251.56015784219002,
                    "smoothness_avg": 0.017353540123566623,
                    "success_improvement": 0.0,
                    "time_improvement": 43.83556404272378,
                    "node_improvement": 70.3621581670362,
                    "length_improvement": 16.02197855460819,
                    "smoothness_improvement": 346.51908662909676,
                    "objective_score": 24.496451778727533
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.12373163700103759,
                    "num_nodes_avg": 510.6,
                    "path_length_avg": 119.34242112432332,
                    "smoothness_avg": 0.04030087577217426,
                    "success_improvement": 0.0,
                    "time_improvement": -152.24769427061182,
                    "node_improvement": 35.0794659885569,
                    "length_improvement": 20.738446364632033,
                    "smoothness_improvement": 412.6241651208389,
                    "objective_score": -31.168119636800128
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "Cross-Tree Rewired Informed RRT* (CTR-iRRT*): a bidirectional, cost-guided planner that minimizes path length by informed sampling, logarithmic-neighborhood RRT* rewiring, and low-overhead cross-tree connections. It avoids long connection chains by testing best-cost direct links to the opposite tree and, if needed, adds at most one assistance step there. Edges and costs are kept coherent with fast, stack-based propagation, and the final path is greedily compressed and shortcut-smoothed.",
          "planning_mechanism": "Mechanism: alternate tree growth with ellipse- and line-corridor-biased sampling; steer one step, validate node and edge, pick the cheapest parent among logarithmic-radius neighbors, then rewire cheaper neighbors; attempt a direct best-cost connection to the other tree within an adaptive radius, else create a single assist step toward the meeting point and retry; upon any improvement, restrict sampling to a prolate hyperspheroid of the incumbent cost; terminate after a focused post-optimization budget or stagnation and return a smoothed path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=4.0,\n                 gamma_radius=80.0,\n                 min_radius=4.0,\n                 goal_bias=0.08,\n                 line_bias=0.28,\n                 r_connect_factor=1.6,\n                 post_opt_iters=700,\n                 max_no_improve=260,\n                 smoothing_iters=200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_radius = gamma_radius\n        self.min_radius = min_radius\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.r_connect_factor = r_connect_factor\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n\n        # Spatial hash grids for fast NN and near queries\n        cell = max(1.0, self.step_size)\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root, cell)\n        self._grid_add(grid_goal, goal_root, cell)\n\n        success = False\n        best_cost = float('inf')\n        best_pair = (None, None)\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            active_first = (it % 2 == 0)\n            for which in (0, 1):\n                tree_a = start_tree if (active_first ^ (which == 1)) else goal_tree\n                tree_b = goal_tree if (tree_a is start_tree) else start_tree\n                grid_a = grid_start if (tree_a is start_tree) else grid_goal\n                grid_b = grid_goal if (tree_b is goal_tree) else grid_start\n\n                # Sample\n                x_rand = self._sample_biased(start, goal, best_cost)\n                if self._rand() < self.goal_bias:\n                    x_rand = goal if (tree_a is start_tree) else start\n\n                # Nearest and steer\n                n_near = self._nearest_grid(grid_a, tree_a, x_rand, cell)\n                x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n\n                # Validate node and incoming edge\n                if not self._in_bounds(x_new_pos):\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n                    continue\n                if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n                    continue\n                if self._is_edge_in_obstacle(n_near.position, x_new_pos, obstacles, is_3d):\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n                    continue\n\n                x_new = Node(x_new_pos)\n                # Choose best parent within adaptive RRT* radius\n                n_nodes = max(2, len(tree_a) + len(tree_b))\n                r_near = self._rrtstar_radius(n_nodes)\n                near_nodes = self._near_grid(grid_a, x_new_pos, r_near, cell)\n\n                best_parent = n_near\n                best_pc = n_near.cost + self._dist(n_near.position, x_new_pos)\n                for nn in near_nodes:\n                    cand = nn.cost + self._dist(nn.position, x_new_pos)\n                    if cand + 1e-12 < best_pc and not self._is_edge_in_obstacle(nn.position, x_new_pos, obstacles, is_3d):\n                        best_parent = nn\n                        best_pc = cand\n\n                # Commit new node (checks again were done above for the chosen parent edge)\n                best_parent.add_child(x_new)\n                x_new.cost = best_pc\n                tree_a.append(x_new)\n                nodes.append(x_new)\n                self._grid_add(grid_a, x_new, cell)\n\n                # Rewire\n                for nn in near_nodes:\n                    alt = x_new.cost + self._dist(x_new.position, nn.position)\n                    if alt + 1e-12 < nn.cost and not self._is_edge_in_obstacle(x_new.position, nn.position, obstacles, is_3d):\n                        op = nn.parent\n                        if op is not None:\n                            # update child lists\n                            try:\n                                op.children.remove(nn)\n                            except:\n                                pass\n                        x_new.add_child(nn)\n                        nn.cost = alt\n                        self._propagate_costs_from(nn)\n\n                # Cross-tree connection: direct best-cost within radius; else single assist step\n                improved = False\n                r_conn = max(r_near, self.step_size * self.r_connect_factor)\n                # 1) Try direct links to best-cost neighbor(s) in the other tree\n                cand_b = self._near_grid(grid_b, x_new_pos, r_conn, cell)\n                meet = None\n                best_join_cost = best_cost\n                for nb in cand_b:\n                    if not self._is_edge_in_obstacle(x_new_pos, nb.position, obstacles, is_3d):\n                        path_cost = x_new.cost + self._dist(x_new_pos, nb.position) + nb.cost\n                        if path_cost + 1e-12 < best_join_cost:\n                            best_join_cost = path_cost\n                            meet = nb\n                if meet is not None:\n                    best_cost = best_join_cost\n                    best_pair = (x_new, meet)\n                    success = True\n                    found_first = True\n                    post_iters = 0\n                    no_improve = 0\n                    improved = True\n                else:\n                    # 2) Single assist step from the other tree toward x_new\n                    nb_near = self._nearest_grid(grid_b, tree_b, x_new_pos, cell)\n                    assist_pos = self._steer(nb_near.position, x_new_pos, self.step_size)\n                    if self._in_bounds(assist_pos) and not self._is_in_obstacle(assist_pos, obstacles, is_3d):\n                        if not self._is_edge_in_obstacle(nb_near.position, assist_pos, obstacles, is_3d):\n                            assist = Node(assist_pos)\n                            # local best parent in tree_b for assist\n                            near_b = self._near_grid(grid_b, assist_pos, r_near, cell)\n                            best_pb = nb_near\n                            best_bc = nb_near.cost + self._dist(nb_near.position, assist_pos)\n                            for nb in near_b:\n                                cbc = nb.cost + self._dist(nb.position, assist_pos)\n                                if cbc + 1e-12 < best_bc and not self._is_edge_in_obstacle(nb.position, assist_pos, obstacles, is_3d):\n                                    best_pb = nb\n                                    best_bc = cbc\n                            best_pb.add_child(assist)\n                            assist.cost = best_bc\n                            tree_b.append(assist)\n                            nodes.append(assist)\n                            self._grid_add(grid_b, assist, cell)\n\n                            # local rewire around assist (limited to near_b)\n                            for nb in near_b:\n                                altb = assist.cost + self._dist(assist.position, nb.position)\n                                if altb + 1e-12 < nb.cost and not self._is_edge_in_obstacle(assist.position, nb.position, obstacles, is_3d):\n                                    obp = nb.parent\n                                    if obp is not None:\n                                        try:\n                                            obp.children.remove(nb)\n                                        except:\n                                            pass\n                                    assist.add_child(nb)\n                                    nb.cost = altb\n                                    self._propagate_costs_from(nb)\n\n                            # retry direct connect with the new assist node considered\n                            cand2 = self._near_grid(grid_b, x_new_pos, r_conn, cell)\n                            meet2 = None\n                            best_join_cost2 = best_cost\n                            for nb in cand2:\n                                if not self._is_edge_in_obstacle(x_new_pos, nb.position, obstacles, is_3d):\n                                    path_cost = x_new.cost + self._dist(x_new_pos, nb.position) + nb.cost\n                                    if path_cost + 1e-12 < best_join_cost2:\n                                        best_join_cost2 = path_cost\n                                        meet2 = nb\n                            if meet2 is not None:\n                                best_cost = best_join_cost2\n                                best_pair = (x_new, meet2)\n                                success = True\n                                found_first = True\n                                post_iters = 0\n                                no_improve = 0\n                                improved = True\n\n                if found_first and not improved:\n                    post_iters += 1\n                    no_improve += 1\n\n                if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                    break\n\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        path = []\n        if success and best_pair[0] is not None:\n            path = self._extract_path(best_pair[0], best_pair[1])\n            path = self._greedy_compress(path, obstacles, is_3d)\n            path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n\n        # materialize edges coherently from parent/children\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # ---------- Utilities ----------\n    def _rand(self):\n        try:\n            return random.random()\n        except:\n            if not hasattr(self, \"_lcg_state\"):\n                self._lcg_state = 2463534242\n            self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n            return (self._lcg_state / float(1 << 32))\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = (a[i] - b[i])\n            s += d * d\n        return s ** 0.5\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = min(1.0, 0.5 * self.step_size)\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _log_approx(self, n):\n        if n <= 1:\n            return 0.0\n        # ln(n) \u2248 bit_length(n) * ln(2)\n        return (int(n).bit_length()) * 0.6931471805599453\n\n    def _rrtstar_radius(self, n):\n        if n <= 2:\n            return max(self.min_radius, self.step_size)\n        r = self.gamma_radius * ((self._log_approx(n) / float(n)) ** (1.0 / max(2, self.dim)))\n        if r < self.min_radius:\n            r = self.min_radius\n        return r\n\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _grid_gather(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos, cell):\n        best = None\n        bestd = float('inf')\n        # Expand rings up to a safe bound\n        max_rings = int((max(self.bounds) / cell)) + 2\n        for ring in range(1, max_rings + 1):\n            cand = self._grid_gather(grid, pos, ring * cell, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                return best\n        # Fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_grid(self, grid, pos, radius, cell):\n        cand = self._grid_gather(grid, pos, radius, cell)\n        out = []\n        r2 = radius\n        for n in cand:\n            if self._dist(n.position, pos) <= r2:\n                out.append(n)\n        return out\n\n    def _sample_biased(self, start, goal, c_best):\n        # Informed rejection inside prolate hyperspheroid after first solution; else mixture of uniform and line-corridor\n        use_line = (self._rand() < self.line_bias)\n        if c_best < float('inf'):\n            # informed rejection: accept if within start-goal ellipse\n            for _ in range(60):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._dist(p, start) + self._dist(p, goal) <= c_best and self._in_bounds(p):\n                    return p\n        if use_line:\n            # sample along the start-goal line with small jitter to favor short paths\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jitter = 0.5 * self.step_size\n            p = tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n            return p\n        # uniform fallback\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _path_to_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        path.reverse()\n        return path\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)  # start -> meet_a\n        # meet_b to goal along its tree (goal-rooted)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # Concatenate; edge between meet_a and meet_b is implicit\n        return path_a + path_b\n\n    def _propagate_costs_from(self, node):\n        stack = []\n        for c in node.children:\n            stack.append(c)\n        while stack:\n            u = stack.pop()\n            if u.parent is not None:\n                u.cost = u.parent.cost + self._dist(u.parent.position, u.position)\n            for c in u.children:\n                stack.append(c)\n\n    def _greedy_compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            # try the farthest reachable\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
          "objective": 139.64039,
          "time_improvement": -532.0,
          "length_improvement": 22.0,
          "smoothness_improvement": 1266.0,
          "node_improvement": -22.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.3195624828338623,
                    "num_nodes_avg": 602.0,
                    "path_length_avg": 147.59826910995267,
                    "smoothness_avg": 0.04229611616050018,
                    "success_improvement": 0.0,
                    "time_improvement": -1153.2454041479311,
                    "node_improvement": -51.599093427348265,
                    "length_improvement": 19.099049856591378,
                    "smoothness_improvement": 562.0260653981402,
                    "objective_score": -331.7040610034338
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.39352576732635497,
                    "num_nodes_avg": 1492.2,
                    "path_length_avg": 223.7879408686806,
                    "smoothness_avg": 0.0890195817850141,
                    "success_improvement": 0.0,
                    "time_improvement": -145.6506413075557,
                    "node_improvement": -0.2620439427534832,
                    "length_improvement": 25.293143959308452,
                    "smoothness_improvement": 2190.537957541495,
                    "objective_score": -17.566616228974162
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1941249132156372,
                    "num_nodes_avg": 898.0,
                    "path_length_avg": 115.8304308545075,
                    "smoothness_avg": 0.09015448143133267,
                    "success_improvement": 0.0,
                    "time_improvement": -295.75619417947627,
                    "node_improvement": -14.17673235855054,
                    "length_improvement": 23.070943078838237,
                    "smoothness_improvement": 1046.7583492949423,
                    "objective_score": -69.65050066006523
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm with post-optimization: a single-tree, asymptotically optimal sampler that, after the first feasible path, restricts sampling to a start\u2013goal prolate hyperspheroid to accelerate convergence while continuing local rewiring to reduce path cost.",
          "planning_mechanism": "Mechanism: (1) Grow one tree from the start using uniform sampling; (2) when a goal-connecting edge is found, record the best cost and switch to informed sampling inside the ellipsoid defined by start, goal, and current best path length; (3) for each sample, steer a step from the nearest node, then select the lowest-cost parent among nearby nodes and rewire neighbors if the new node offers cheaper paths; (4) whenever the new node lies within one step of the goal and the edge is collision-free, connect and update the best path; (5) after the first solution, continue only a limited number of additional iterations or until no further improvements occur; (6) every candidate node and edge is validated against obstacle occupancy and line-segment collisions, and results include the best path found within the iteration budget.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 post_opt_iters: int = 500, max_no_improve: int = 150,\n                 improve_tol: float = 1e-6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start)\n        goal_node = Node(goal)\n        nodes.append(root)\n        tree = [root]\n\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        c_min = math.dist(start, goal)\n\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        for _ in range(self.max_iter):\n            x_rand = self._sample(start, goal, best_cost, c_min, is_3d, bounds)\n\n            x_nearest = min(tree, key=lambda n: math.dist(n.position, x_rand))\n            x_new_pos = self._steer(x_nearest.position, x_rand)\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            x_new = Node(x_new_pos)\n            near_nodes = [n for n in tree if math.dist(n.position, x_new_pos) <= 20.0]\n\n            min_cost = x_nearest.cost + math.dist(x_nearest.position, x_new_pos)\n            best_parent = x_nearest\n            for n in near_nodes:\n                new_cost = n.cost + math.dist(n.position, x_new_pos)\n                if new_cost < min_cost and not self._is_edge_in_obstacle(n.position, x_new_pos, obstacles, is_3d):\n                    best_parent = n\n                    min_cost = new_cost\n\n            best_parent.add_child(x_new)\n            x_new.cost = min_cost\n            x_new.parent = best_parent\n            tree.append(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            for n in near_nodes:\n                alt_cost = x_new.cost + math.dist(x_new.position, n.position)\n                if alt_cost + 1e-12 < n.cost and not self._is_edge_in_obstacle(x_new.position, n.position, obstacles, is_3d):\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                        if n in n.parent.children:\n                            n.parent.children.remove(n)\n                    n.parent = x_new\n                    n.cost = alt_cost\n                    x_new.add_child(n)\n                    edges.append((x_new, n))\n\n            if math.dist(x_new.position, goal) < self.step_size and                not self._is_edge_in_obstacle(x_new.position, goal, obstacles, is_3d):\n                # \uc0c8 \ud574 \ud6c4\ubcf4\n                goal_node = Node(goal)  # \ubaa9\ud45c \ub178\ub4dc\ub294 \uc0c8\ub85c \ub9cc\ub4e4\uc5b4 \uba85\ud655\ud788 \uc5f0\uacb0\n                goal_node.parent = x_new\n                goal_node.cost = x_new.cost + math.dist(x_new.position, goal)\n                nodes.append(goal_node)\n                edges.append((x_new, goal_node))\n\n                if goal_node.cost + self.improve_tol < best_cost:\n                    best_cost = goal_node.cost\n                    best_goal_node = goal_node\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    no_improve_streak = 0  \n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0  \n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        if success_state and best_goal_node is not None:\n            extracted_path = best_goal_node.path_from_root()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample(self, start, goal, c_best, c_min, is_3d, bounds):\n        import numpy as np\n        import math, random\n\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        dim = len(start)\n        L = np.diag([c_best / 2] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim - 1))\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        a1 = a1 / np.linalg.norm(a1)\n        I = np.eye(dim)\n        M = np.outer(a1, I[:, 0])\n        U, _, Vt = np.linalg.svd(M)\n        C = np.dot(U, np.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]), Vt))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm = np.linalg.norm(x_ball)\n            if norm > 1e-6:\n                x_ball = x_ball / norm * random.random() ** (1.0 / dim)\n            x_rand = np.dot(C, np.dot(L, x_ball)) + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * self.step_size / dist for d in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    \n",
          "objective": 235.19094231666816,
          "time_improvement": -789.0,
          "length_improvement": 22.0,
          "smoothness_improvement": 930.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.5344432830810547,
                    "num_nodes_avg": 947.3,
                    "path_length_avg": 150.99345481570086,
                    "smoothness_avg": 0.12670700736095167,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -1995.9550143665665,
                    "node_improvement": -138.55452027197177,
                    "length_improvement": 17.23809477111046,
                    "smoothness_improvement": 1883.2398138692852,
                    "objective_score": -629.0274483779572
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.324963641166687,
                    "num_nodes_avg": 1167.4,
                    "path_length_avg": 222.04248618414317,
                    "smoothness_avg": 0.02144857764536279,
                    "success_improvement": 0.0,
                    "time_improvement": -102.85209631021006,
                    "node_improvement": 21.561513135792506,
                    "length_improvement": 25.875826973134497,
                    "smoothness_improvement": 451.887351601218,
                    "objective_score": -13.07069595117623
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1799778699874878,
                    "num_nodes_avg": 857.0,
                    "path_length_avg": 114.63448492005905,
                    "smoothness_avg": 0.04372194350556986,
                    "success_improvement": 0.0,
                    "time_improvement": -266.91507381979466,
                    "node_improvement": -8.963763509218055,
                    "length_improvement": 23.865233423673267,
                    "smoothness_improvement": 456.139894172678,
                    "objective_score": -63.47468262087104
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "path_expert",
          "algorithm_description": "CoRe-BiRRT*: Cost-Refined Informed Bidirectional RRT with bounded rewiring, best-of-k local batching, spatial-hash neighbors, and cost-minimizing bridges for shorter, smoother paths with low overhead.",
          "planning_mechanism": "Alternate tree growth with a small beam of biased targets; steer and pick the lowest-cost parent from local neighbors; validate node and edge, insert, and perform bounded local rewiring; attempt a k-near, cost-minimizing bridge to the opposite tree; after the first solution, switch to informed sampling and continue briefly to improve length; finally compress and shortcut the path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=5.0,\n                 beam_k=4,\n                 goal_bias=0.15,\n                 line_bias=0.30,\n                 connect_radius_factor=2.5,\n                 parent_radius_factor=2.0,\n                 k_near_max=24,\n                 k_rewire=10,\n                 k_bridge=12,\n                 occ_gain_ratio=0.95,\n                 smoothing_iters=120,\n                 ellipse_tries=80,\n                 plateau_after_solution=250,\n                 switch_fail_thresh=6,\n                 grid_cell=None):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.connect_radius_factor = connect_radius_factor\n        self.parent_radius_factor = parent_radius_factor\n        self.k_near_max = k_near_max\n        self.k_rewire = k_rewire\n        self.k_bridge = k_bridge\n        self.occ_gain_ratio = occ_gain_ratio\n        self.smoothing_iters = smoothing_iters\n        self.ellipse_tries = ellipse_tries\n        self.plateau_after_solution = plateau_after_solution\n        self.switch_fail_thresh = switch_fail_thresh\n        self.grid_cell = grid_cell\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Grid/edge parameters\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.9 * self.step_size)\n        self.edge_res = max(0.4, min(1.0, 0.5 * self.step_size))\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line check\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_res):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.append(g)\n            nodes = [s, g]\n            edges = [(s, g)]\n            return PlannerResult(True, [start, goal], nodes, edges)\n\n        # Initialize trees\n        s_root = Node(start, None, 0.0)\n        g_root = Node(goal, None, 0.0)\n        start_tree = [s_root]\n        goal_tree = [g_root]\n        edges = []\n\n        grid_s = {}\n        grid_g = {}\n        self._grid_add(grid_s, s_root, self.grid_cell)\n        self._grid_add(grid_g, g_root, self.grid_cell)\n\n        occ_cell = max(0.5, 0.7 * self.step_size)\n        occ_s = {self._occ_key(start, occ_cell): 0.0}\n        occ_g = {self._occ_key(goal, occ_cell): 0.0}\n\n        failed_s = 0\n        failed_g = 0\n\n        best_path = None\n        best_len = float('inf')\n        since_improve = 0\n        have_solution = False\n\n        for it in range(self.max_iter):\n            # Alternate expansion with simple failure-based switch\n            active_start = (it % 2 == 0)\n            if (active_start and failed_s >= self.switch_fail_thresh) or ((not active_start) and failed_g >= self.switch_fail_thresh):\n                active_start = not active_start\n\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_s if active_start else grid_g\n            grid_b = grid_g if active_start else grid_s\n            occ_a = occ_s if active_start else occ_g\n            root_other = goal if active_start else start\n\n            # Beam sampling and best-of-k selection\n            candidates = []\n            for _ in range(self.beam_k):\n                x_rand = None\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = root_other\n                else:\n                    if have_solution:\n                        # Informed sampling inside prolate ellipse\n                        got = False\n                        for _t in range(self.ellipse_tries):\n                            p = self._uniform_point()\n                            if self._in_bounds(p) and (self._dist(p, start) + self._dist(p, goal) <= best_len + 1e-9):\n                                x_rand = p\n                                got = True\n                                break\n                        if not got:\n                            x_rand = self._uniform_point()\n                    else:\n                        # Line-biased with jitter vs uniform\n                        if self._rand() < self.line_bias:\n                            t = self._uniform(0.0, 1.0)\n                            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n                            jit = 0.5 * self.step_size\n                            x_rand = tuple(self._clip(base[i] + self._uniform(-jit, jit), 0.0, self.bounds[i]) for i in range(self.dim))\n                        else:\n                            x_rand = self._uniform_point()\n\n                # Nearest, steer\n                n_near = self._nearest(grid_a, tree_a, x_rand, self.grid_cell)\n                x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n                if not self._in_bounds(x_new_pos):\n                    continue\n                if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                    continue\n\n                # Parent selection among local neighbors (bounded)\n                r_parent = max(self.parent_radius_factor * self.step_size, self.step_size)\n                near_set = self._near(grid_a, x_new_pos, r_parent, self.grid_cell)\n                if not near_set:\n                    near_set = [n_near]\n                else:\n                    # Cap by closest K\n                    if len(near_set) > self.k_near_max:\n                        dist_idx = [(self._dist(n.position, x_new_pos), i) for i, n in enumerate(near_set)]\n                        dist_idx.sort(key=lambda t: t[0])\n                        near_set = [near_set[i] for (_, i) in dist_idx[:self.k_near_max]]\n\n                best_parent = None\n                best_cost = float('inf')\n                for cand_p in near_set:\n                    # Edge collision (parent -> new)\n                    if self._is_edge_in_obstacle(cand_p.position, x_new_pos, obstacles, is_3d, self.edge_res):\n                        continue\n                    c = cand_p.cost + self._dist(cand_p.position, x_new_pos)\n                    if c < best_cost:\n                        best_cost = c\n                        best_parent = cand_p\n\n                if best_parent is None:\n                    continue\n\n                # Duplicate/near-duplicate suppression\n                k_occ = self._occ_key(x_new_pos, occ_cell)\n                prev_best = occ_a.get(k_occ, float('inf'))\n                if best_cost >= prev_best * self.occ_gain_ratio:\n                    continue\n\n                # Progress score: cost-to-come + heuristic to opposite tree\n                other_near = self._nearest(grid_b, tree_b, x_new_pos, self.grid_cell)\n                h = self._dist(x_new_pos, other_near.position) if other_near is not None else self._dist(x_new_pos, root_other)\n                score = best_cost + 0.7 * h\n                candidates.append((score, x_new_pos, best_parent, best_cost))\n\n            if not candidates:\n                if active_start:\n                    failed_s += 1\n                else:\n                    failed_g += 1\n                if have_solution:\n                    since_improve += 1\n                    if since_improve > self.plateau_after_solution:\n                        break\n                continue\n\n            # Choose best candidate and commit\n            candidates.sort(key=lambda t: t[0])\n            _, new_pos, parent, new_cost = candidates[0]\n\n            # Node+edge check before insertion\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                if active_start:\n                    failed_s += 1\n                else:\n                    failed_g += 1\n                continue\n            if self._is_edge_in_obstacle(parent.position, new_pos, obstacles, is_3d, self.edge_res):\n                if active_start:\n                    failed_s += 1\n                else:\n                    failed_g += 1\n                continue\n\n            new_node = Node(new_pos, None, new_cost)\n            new_node.attach(parent)\n            tree_a.append(new_node)\n            self._add_edge(edges, parent, new_node)\n            self._grid_add(grid_a, new_node, self.grid_cell)\n            k_occ_new = self._occ_key(new_pos, occ_cell)\n            if new_cost < occ_a.get(k_occ_new, float('inf')):\n                occ_a[k_occ_new] = new_cost\n\n            if active_start:\n                failed_s = 0\n            else:\n                failed_g = 0\n\n            # Bounded local rewiring (RRT* light)\n            r_rewire = r_parent\n            neigh = self._near(grid_a, new_pos, r_rewire, self.grid_cell)\n            # Exclude the new_node itself if present\n            neigh = [n for n in neigh if n is not new_node]\n            # Cap number of rewires by closest distance\n            if len(neigh) > self.k_near_max:\n                dist_idx = [(self._dist(n.position, new_pos), i) for i, n in enumerate(neigh)]\n                dist_idx.sort(key=lambda t: t[0])\n                neigh = [neigh[i] for (_, i) in dist_idx[:self.k_near_max]]\n            rewired = 0\n            for nb in neigh:\n                if rewired >= self.k_rewire:\n                    break\n                # New potential cost via new_node\n                e_ok = not self._is_edge_in_obstacle(new_pos, nb.position, obstacles, is_3d, self.edge_res)\n                if not e_ok:\n                    continue\n                alt = new_node.cost + self._dist(new_pos, nb.position)\n                if alt + 1e-12 < nb.cost:\n                    # Before rewiring, ensure node+edge validity holds (node already valid)\n                    old_parent = nb.parent\n                    if old_parent is not None:\n                        # Rewire\n                        nb.attach(new_node)\n                        self._remove_edge(edges, old_parent, nb)\n                        self._add_edge(edges, new_node, nb)\n                        # Update costs of the subtree of nb\n                        self._propagate_costs(nb)\n                        rewired += 1\n\n            # Attempt cost-minimizing bridge to the other tree\n            r_conn = max(self.connect_radius_factor * self.step_size, self.step_size)\n            near_b = self._near(grid_b, new_pos, r_conn, self.grid_cell)\n            if not near_b:\n                nn_b = self._nearest(grid_b, tree_b, new_pos, self.grid_cell)\n                if nn_b is not None:\n                    near_b = [nn_b]\n\n            if len(near_b) > self.k_bridge:\n                dist_idx = [(self._dist(n.position, new_pos), i) for i, n in enumerate(near_b)]\n                dist_idx.sort(key=lambda t: t[0])\n                near_b = [near_b[i] for (_, i) in dist_idx[:self.k_bridge]]\n\n            best_bridge = None\n            best_total = best_len\n            for nb in near_b:\n                # Edge check for bridge\n                if self._is_edge_in_obstacle(new_pos, nb.position, obstacles, is_3d, self.edge_res):\n                    continue\n                total = new_node.cost + self._dist(new_pos, nb.position) + nb.cost\n                if total + 1e-12 < best_total:\n                    best_total = total\n                    best_bridge = nb\n\n            if best_bridge is not None:\n                # Determine meet nodes so that meet_a is on start side\n                if active_start:\n                    meet_a = new_node\n                    meet_b = best_bridge\n                else:\n                    meet_a = best_bridge\n                    meet_b = new_node\n\n                path = self._extract_path(meet_a, meet_b)\n                path = self._compress(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n                plen = self._path_length(path)\n                if plen + 1e-12 < best_len:\n                    best_len = plen\n                    best_path = path\n                    have_solution = True\n                    since_improve = 0\n                else:\n                    since_improve += 1\n            else:\n                if have_solution:\n                    since_improve += 1\n\n            # If we have a solution and no recent improvement, allow early finish\n            if have_solution and since_improve > self.plateau_after_solution:\n                break\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- Random ----------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _uniform_point(self):\n        if self.dim == 3:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]),\n                    self._uniform(0.0, self.bounds[2]))\n        else:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]))\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return tuple(self._clip(to_pos[i], 0.0, self.bounds[i]) for i in range(self.dim))\n        r = step / d\n        return tuple(self._clip(from_pos[i] + (to_pos[i] - from_pos[i]) * r, 0.0, self.bounds[i]) for i in range(self.dim))\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Spatial hash ----------\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest(self, grid, nodes, pos, cell):\n        # Expand a few rings; fall back if empty\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        limit = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > limit:\n                limit = self.bounds[i]\n        limit = limit * 2.0 + 1.0\n        attempts = 0\n        while r <= limit and attempts < 6:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n            attempts += 1\n        # Fallback\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _occ_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    # ---------- Path utilities ----------\n    def _path_to_root(self, node):\n        seq = []\n        cur = node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _extract_path(self, meet_a, meet_b):\n        # meet_a is in start-tree side, meet_b is in goal-tree side\n        path_a = self._path_to_root(meet_a)\n        tail = []\n        cur = meet_b\n        while cur is not None:\n            tail.append(cur.position)\n            cur = cur.parent\n        return path_a + tail\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.edge_res):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0.0, n - 2))\n            j = int(self._uniform(i + 1.0, n - 1.0))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts\n\n    # ---------- Cost propagation and edge bookkeeping ----------\n    def _propagate_costs(self, node):\n        # After parent change, update cost for node and its descendants\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _add_edge(self, edges, parent, child):\n        edges.append((parent, child))\n\n    def _remove_edge(self, edges, parent, child):\n        # Remove the first matching (parent, child)\n        for i in range(len(edges) - 1, -1, -1):\n            p, c = edges[i]\n            if p is parent and c is child:\n                edges.pop(i)\n                break",
          "objective": 296.97774,
          "time_improvement": -1058.0,
          "length_improvement": 22.0,
          "smoothness_improvement": 1374.0,
          "node_improvement": 23.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.5164424896240234,
                    "num_nodes_avg": 429.5,
                    "path_length_avg": 147.20370912647132,
                    "smoothness_avg": 0.041962438976778024,
                    "success_improvement": 0.0,
                    "time_improvement": -1925.3603329415605,
                    "node_improvement": -8.15915386552505,
                    "length_improvement": 19.31531443574054,
                    "smoothness_improvement": 556.8032928812867,
                    "objective_score": -563.2348947566173
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.500286602973938,
                    "num_nodes_avg": 549.6,
                    "path_length_avg": 228.3261360832077,
                    "smoothness_avg": 0.09321244481651231,
                    "success_improvement": 0.0,
                    "time_improvement": -212.29397173427702,
                    "node_improvement": 63.07196129812538,
                    "length_improvement": 23.778163771992737,
                    "smoothness_improvement": 2298.423343339116,
                    "objective_score": -37.92917654039188
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.5567996501922607,
                    "num_nodes_avg": 677.5,
                    "path_length_avg": 114.36019906426846,
                    "smoothness_avg": 0.10756761717488572,
                    "success_improvement": 0.0,
                    "time_improvement": -1035.1294732365272,
                    "node_improvement": 13.85886840432295,
                    "length_improvement": 24.04740102900047,
                    "smoothness_improvement": 1268.2521506489554,
                    "objective_score": -289.7691406003131
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "IBP-Lite: Informed Bidirectional Pathfinder with predictive scoring and on-the-fly LOS compression for shorter paths and fast convergence",
          "planning_mechanism": "Grow two trees toward each other using a small beam of biased samples. For each sample, steer from the locally best parent (bounded neighbor set) minimizing cost-to-come; apply immediate line-of-sight compression to a higher ancestor if it reduces cost. Insert only if node and edge are collision-free and not a near-duplicate. Score candidates by predicted total path length via the opposite tree (cost-to-come + bridge + opposite cost) and commit the best. Attempt a short-radius, k-near bridge each step; once a solution appears, switch to informed sampling inside the current best-path ellipse and continue briefly to improve length. Return the best path after greedy compression and bounded random shortcuts.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=7000,\n                 step_size=6.0,\n                 beam_k=4,\n                 goal_bias=0.12,\n                 line_bias=0.40,\n                 parent_radius_factor=2.2,\n                 k_parent_max=8,\n                 connect_radius_factor=2.8,\n                 k_bridge=10,\n                 occ_gain_ratio=0.997,\n                 compress_ancestors=2,\n                 smoothing_iters=100,\n                 ellipse_tries=60,\n                 plateau_after_solution=300,\n                 switch_fail_thresh=6,\n                 grid_cell=None):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.parent_radius_factor = parent_radius_factor\n        self.k_parent_max = k_parent_max\n        self.connect_radius_factor = connect_radius_factor\n        self.k_bridge = k_bridge\n        self.occ_gain_ratio = occ_gain_ratio\n        self.compress_ancestors = compress_ancestors\n        self.smoothing_iters = smoothing_iters\n        self.ellipse_tries = ellipse_tries\n        self.plateau_after_solution = plateau_after_solution\n        self.switch_fail_thresh = switch_fail_thresh\n        self.grid_cell = grid_cell\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        if self.grid_cell is None:\n            self.grid_cell = max(0.8 * self.step_size, 1.0)\n        self.edge_res = max(0.5, min(1.0, 0.6 * self.step_size))\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line check\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_res):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.append(g)\n            nodes = [s, g]\n            edges = [(s, g)]\n            return PlannerResult(True, [start, goal], nodes, edges)\n\n        # Initialize trees and spatial hashes\n        s_root = Node(start, None, 0.0)\n        g_root = Node(goal, None, 0.0)\n        start_tree = [s_root]\n        goal_tree = [g_root]\n        edges = []\n        grid_s = {}\n        grid_g = {}\n        self._grid_add(grid_s, s_root, self.grid_cell)\n        self._grid_add(grid_g, g_root, self.grid_cell)\n\n        # Near-duplicate suppression grids\n        occ_cell = max(0.6 * self.step_size, 0.8)\n        occ_s = {self._occ_key(start, occ_cell): 0.0}\n        occ_g = {self._occ_key(goal, occ_cell): 0.0}\n\n        best_path = None\n        best_len = float('inf')\n        have_solution = False\n        since_improve = 0\n        failed_s = 0\n        failed_g = 0\n\n        for it in range(self.max_iter):\n            # Alternate trees; switch if current side is failing\n            active_start = (it % 2 == 0)\n            if (active_start and failed_s >= self.switch_fail_thresh) or ((not active_start) and failed_g >= self.switch_fail_thresh):\n                active_start = not active_start\n\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_s if active_start else grid_g\n            grid_b = grid_g if active_start else grid_s\n            occ_a = occ_s if active_start else occ_g\n            root_other = goal if active_start else start\n\n            # Beam of candidate targets\n            cand_batch = []\n            for _ in range(self.beam_k):\n                # Target sampling\n                if self._rand() < self.goal_bias:\n                    x_rand = root_other\n                else:\n                    if have_solution:\n                        # Informed rejection sampling inside best-length ellipse\n                        x_rand = None\n                        ok = False\n                        for _t in range(self.ellipse_tries):\n                            p = self._uniform_point()\n                            if (self._dist(p, start) + self._dist(p, goal)) <= best_len + 1e-9 and self._in_bounds(p):\n                                x_rand = p\n                                ok = True\n                                break\n                        if not ok:\n                            x_rand = self._uniform_point()\n                    else:\n                        if self._rand() < self.line_bias:\n                            t = self._uniform(0.0, 1.0)\n                            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n                            jit = 0.5 * self.step_size\n                            x_rand = tuple(self._clip(base[i] + self._uniform(-jit, jit), 0.0, self.bounds[i]) for i in range(self.dim))\n                        else:\n                            x_rand = self._uniform_point()\n\n                # Nearest and steer\n                n_near = self._nearest(grid_a, tree_a, x_rand, self.grid_cell)\n                x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n                if not self._in_bounds(x_new_pos):\n                    continue\n                if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                    continue\n\n                # Bounded parent selection minimizing cost-to-come\n                r_parent = max(self.parent_radius_factor * self.step_size, self.step_size)\n                near_set = self._near(grid_a, x_new_pos, r_parent, self.grid_cell)\n                if not near_set:\n                    near_set = [n_near]\n                else:\n                    # Cap by closest K\n                    if len(near_set) > self.k_parent_max:\n                        dist_idx = [(self._dist(n.position, x_new_pos), i) for i, n in enumerate(near_set)]\n                        dist_idx.sort(key=lambda t: t[0])\n                        near_set = [near_set[i] for (_, i) in dist_idx[:self.k_parent_max]]\n\n                best_parent = None\n                best_new_cost = float('inf')\n                for pnode in near_set:\n                    if self._is_edge_in_obstacle(pnode.position, x_new_pos, obstacles, is_3d, self.edge_res):\n                        continue\n                    c = pnode.cost + self._dist(pnode.position, x_new_pos)\n                    if c < best_new_cost:\n                        best_new_cost = c\n                        best_parent = pnode\n                if best_parent is None:\n                    continue\n\n                # On-the-fly LOS compression to higher ancestors (bounded depth)\n                parent_choice = best_parent\n                parent_cost = best_new_cost\n                anc = best_parent.parent\n                depth = 0\n                while anc is not None and depth < self.compress_ancestors:\n                    if not self._is_edge_in_obstacle(anc.position, x_new_pos, obstacles, is_3d, self.edge_res):\n                        alt_cost = anc.cost + self._dist(anc.position, x_new_pos)\n                        if alt_cost + 1e-12 < parent_cost:\n                            parent_choice = anc\n                            parent_cost = alt_cost\n                    anc = anc.parent\n                    depth += 1\n\n                # Duplicate suppression\n                key = self._occ_key(x_new_pos, occ_cell)\n                prev = occ_a.get(key, float('inf'))\n                if parent_cost >= prev * self.occ_gain_ratio:\n                    continue\n\n                # Predictive scoring using nearest opposite-tree node\n                nb_other = self._nearest(grid_b, tree_b, x_new_pos, self.grid_cell)\n                bridge_h = self._dist(x_new_pos, nb_other.position) + (nb_other.cost if nb_other is not None else 0.0)\n                score = parent_cost + bridge_h\n\n                cand_batch.append((score, x_new_pos, parent_choice, parent_cost))\n\n            if not cand_batch:\n                if active_start:\n                    failed_s += 1\n                else:\n                    failed_g += 1\n                if have_solution:\n                    since_improve += 1\n                    if since_improve > self.plateau_after_solution:\n                        break\n                continue\n\n            # Commit best candidate in batch\n            cand_batch.sort(key=lambda t: t[0])\n            _, new_pos, parent, new_cost = cand_batch[0]\n\n            # Both checks before insertion\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                if active_start:\n                    failed_s += 1\n                else:\n                    failed_g += 1\n                continue\n            if self._is_edge_in_obstacle(parent.position, new_pos, obstacles, is_3d, self.edge_res):\n                if active_start:\n                    failed_s += 1\n                else:\n                    failed_g += 1\n                continue\n\n            new_node = Node(new_pos, None, new_cost)\n            new_node.attach(parent)\n            tree_a.append(new_node)\n            self._grid_add(grid_a, new_node, self.grid_cell)\n            self._add_edge(edges, parent, new_node)\n            k = self._occ_key(new_pos, occ_cell)\n            if new_cost < occ_a.get(k, float('inf')):\n                occ_a[k] = new_cost\n            if active_start:\n                failed_s = 0\n            else:\n                failed_g = 0\n\n            # Attempt a short, cost-minimizing bridge to the other tree\n            r_conn = max(self.connect_radius_factor * self.step_size, self.step_size)\n            near_b = self._near(grid_b, new_pos, r_conn, self.grid_cell)\n            if not near_b:\n                nb = self._nearest(grid_b, tree_b, new_pos, self.grid_cell)\n                if nb is not None:\n                    near_b = [nb]\n\n            if len(near_b) > self.k_bridge:\n                dist_idx = [(self._dist(n.position, new_pos), i) for i, n in enumerate(near_b)]\n                dist_idx.sort(key=lambda t: t[0])\n                near_b = [near_b[i] for (_, i) in dist_idx[:self.k_bridge]]\n\n            best_bridge = None\n            best_total = best_len\n            for nb in near_b:\n                if self._is_edge_in_obstacle(new_pos, nb.position, obstacles, is_3d, self.edge_res):\n                    continue\n                total = new_node.cost + self._dist(new_pos, nb.position) + nb.cost\n                if total + 1e-12 < best_total:\n                    best_total = total\n                    best_bridge = nb\n\n            if best_bridge is not None:\n                if active_start:\n                    meet_a = new_node\n                    meet_b = best_bridge\n                else:\n                    meet_a = best_bridge\n                    meet_b = new_node\n                path = self._extract_path(meet_a, meet_b)\n                path = self._compress(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, int(0.5 * self.smoothing_iters))\n                plen = self._path_length(path)\n                if plen + 1e-12 < best_len:\n                    best_len = plen\n                    best_path = path\n                    have_solution = True\n                    since_improve = 0\n                else:\n                    since_improve += 1\n            else:\n                if have_solution:\n                    since_improve += 1\n\n            if have_solution and since_improve > self.plateau_after_solution:\n                break\n\n        if best_path is not None:\n            # Final bounded smoothing for length minimization\n            best_path = self._compress(best_path, obstacles, is_3d)\n            best_path = self._shortcuts(best_path, obstacles, is_3d, self.smoothing_iters)\n            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- Random ----------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _uniform_point(self):\n        if self.dim == 3:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]),\n                    self._uniform(0.0, self.bounds[2]))\n        else:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]))\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return tuple(self._clip(to_pos[i], 0.0, self.bounds[i]) for i in range(self.dim))\n        r = step / d\n        return tuple(self._clip(from_pos[i] + (to_pos[i] - from_pos[i]) * r, 0.0, self.bounds[i]) for i in range(self.dim))\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Spatial hash ----------\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest(self, grid, nodes, pos, cell):\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        limit = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > limit:\n                limit = self.bounds[i]\n        limit = limit * 2.0 + 1.0\n        attempts = 0\n        while r <= limit and attempts < 6:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n            attempts += 1\n        # Fallback scan\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _occ_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    # ---------- Path utilities ----------\n    def _path_to_root(self, node):\n        seq = []\n        cur = node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _extract_path(self, meet_a, meet_b):\n        # meet_a is on start-tree side\n        path_a = self._path_to_root(meet_a)\n        tail = []\n        cur = meet_b\n        while cur is not None:\n            tail.append(cur.position)\n            cur = cur.parent\n        return path_a + tail\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.edge_res):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0.0, n - 2))\n            j = int(self._uniform(i + 1.0, n - 1.0))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts\n\n    # ---------- Edge bookkeeping ----------\n    def _add_edge(self, edges, parent, child):\n        edges.append((parent, child))",
          "objective": 330.31714,
          "time_improvement": -1112.0,
          "length_improvement": 22.0,
          "smoothness_improvement": 1366.0,
          "node_improvement": 9.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.5325486421585083,
                    "num_nodes_avg": 489.6,
                    "path_length_avg": 149.39540828052662,
                    "smoothness_avg": 0.04474651082156199,
                    "success_improvement": 0.0,
                    "time_improvement": -1988.5246989940129,
                    "node_improvement": -23.293880634600857,
                    "length_improvement": 18.114009399707278,
                    "smoothness_improvement": 600.3800629609315,
                    "objective_score": -582.6871037435749
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.7692343235015869,
                    "num_nodes_avg": 834.2,
                    "path_length_avg": 231.763403837814,
                    "smoothness_avg": 0.0966786114696724,
                    "success_improvement": 0.0,
                    "time_improvement": -380.1792425633966,
                    "node_improvement": 43.949472552576765,
                    "length_improvement": 22.63070485923851,
                    "smoothness_improvement": 2387.610307903853,
                    "objective_score": -88.53729831395661
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.5227906227111816,
                    "num_nodes_avg": 726.6,
                    "path_length_avg": 114.27419469582301,
                    "smoothness_avg": 0.09511363466658777,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -965.7963667294489,
                    "node_improvement": 7.6160203432930675,
                    "length_improvement": 24.104521035434,
                    "smoothness_improvement": 1109.8384124007716,
                    "objective_score": -319.7270053355704
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional, asymptotically optimal planner that blends RRT-Connect\u2019s fast greedy tree-connection with RRT*\u2019s cost-optimal rewiring, and\u2014after an initial solution\u2014focuses sampling within the prolate hyperspheroid (ellipsoid) defined by the start, goal, and current best path length to accelerate convergence.",
          "planning_mechanism": "The planner grows two trees from start and goal. Each iteration: (1) sample uniformly until a first solution is found, then sample inside the informed ellipsoid; (2) extend one tree toward the sample using RRT*-style best-parent selection and local rewiring; (3) greedily \u201cconnect\u201d the opposite tree toward the new node, also rewiring locally; (4) if trees meet, update the best path and continue only a limited number of post-optimization iterations (user-tunable). Every node and edge is checked for point-in-obstacle and edge-obstacle collisions, positions are clamped to bounds, and a hard 30-second time limit halts the search and returns the best path found so far.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cumulative path cost from the root of its tree\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        neighbor_radius: float = 25.0,\n        post_opt_iters: int = 400,      # extra iterations after first solution\n        max_no_improve: int = 150,      # stop early if no improvement for this many iters\n        improve_tol: float = 1e-6,      # minimal improvement to count\n        time_limit_sec: float = 30.0,   # hard wall time limit\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Core data\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_cost = float('inf')\n        best_path = []\n        c_min = math.dist(start_position, goal_position)\n\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            # Enforce 30s time limit\n            if time.time() - start_time > self.time_limit_sec:\n                return PlannerResult(\n                    success=success_state,\n                    path=best_path if success_state else [],\n                    nodes=nodes,\n                    edges=edges\n                )\n\n            # Alternate trees (RRT-Connect style)\n            tree_a, tree_b = (start_tree, goal_tree) if (it % 2 == 0) else (goal_tree, start_tree)\n\n            # Informed sampling: uniform before first solution; ellipsoid after\n            x_rand = self._sample_informed(start_position, goal_position, best_cost, c_min, bounds)\n\n            # Extend tree_a one step with RRT* best-parent + local rewire\n            a_nearest = self._nearest(tree_a, x_rand)\n            a_new_pos = self._steer(a_nearest.position, x_rand)\n\n            if not self._within_bounds(a_new_pos, bounds):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                if found_first_solution and (post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve):\n                    break\n                continue\n\n            if self._is_in_obstacle(a_new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(a_nearest.position, a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                if found_first_solution and (post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve):\n                    break\n                continue\n\n            a_new, a_neighbors = self._add_with_best_parent(tree_a, a_new_pos, obstacles, is_3d, nodes, edges)\n            self._rewire_from(a_new, a_neighbors, obstacles, is_3d, edges)\n\n            # Greedy connect tree_b toward a_new (RRT-Connect) with local RRT* rewiring\n            b_meet = self._connect_with_rewire(tree_b, a_new, obstacles, is_3d, nodes, edges, bounds)\n\n            if b_meet is not None:\n                # Build full path depending on which side expanded\n                if it % 2 == 0:\n                    path_a = a_new.path_from_root()       # start side\n                    path_b = b_meet.path_from_root()      # goal side\n                else:\n                    path_a = b_meet.path_from_root()       # start side\n                    path_b = a_new.path_from_root()        # goal side\n\n                # Merge (avoid double-counting the joint if equal)\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged = path_a + path_b[-2::-1]\n                else:\n                    merged = path_a + path_b[::-1]\n\n                cost = self._path_cost(merged)\n\n                if cost + self.improve_tol < best_cost:\n                    best_cost = cost\n                    best_path = merged\n                    success_state = True\n                    no_improve_streak = 0\n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0\n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        extracted_path = best_path if success_state else []\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ---------------------- Helpers ----------------------\n    def _within_bounds(self, pos, bounds):\n        return all(0.0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _path_cost(self, path):\n        return sum(math.dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda n: math.dist(n.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _neighbors(self, tree, pos):\n        return [n for n in tree if math.dist(n.position, pos) <= self.neighbor_radius]\n\n    def _add_with_best_parent(self, tree, new_pos, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, new_pos)\n        candidates = self._neighbors(tree, new_pos)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in candidates:\n            if self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                continue\n            cand_cost = nb.cost + math.dist(nb.position, new_pos)\n            if cand_cost < min_cost:\n                min_cost = cand_cost\n                best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, candidates\n\n    def _rewire_from(self, pivot: Node, neighbors, obstacles, is_3d, edges):\n        for nb in neighbors:\n            if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                continue\n            new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n            if new_cost + 1e-12 < nb.cost:\n                if nb.parent is not None:\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except ValueError:\n                        pass\n                    if nb in nb.parent.children:\n                        nb.parent.children.remove(nb)\n                pivot.add_child(nb)\n                nb.cost = new_cost\n                edges.append((pivot, nb))\n\n    def _connect_with_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        \"\"\"\n        Greedily advance 'tree' toward 'target_node' like RRT-Connect.\n        At each step, insert with best parent and locally rewire.\n        Return the final node in 'tree' placed at target_node.position (if reached), else None.\n        \"\"\"\n        current = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(current.position, target_node.position)\n\n            if not self._within_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node, neighbors = self._add_with_best_parent(tree, new_pos, obstacles, is_3d, nodes, edges)\n            self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(new_node.position, target_node.position) <= self.step_size:\n                # final short edge\n                if not self._is_edge_in_obstacle(new_node.position, target_node.position, obstacles, is_3d) and target_node.valid:\n                    final_node = Node(\n                        target_node.position,\n                        parent=None,\n                        cost=new_node.cost + math.dist(new_node.position, target_node.position)\n                    )\n                    new_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                return None\n\n            current = new_node\n\n    # ------------------ Informed Sampling ------------------\n    def _sample_informed(self, start, goal, c_best, c_min, bounds):\n        \"\"\"Uniform before first solution; prolate hyperspheroid after (supports 2D/3D).\"\"\"\n        dim = len(bounds)\n        if c_best == float('inf') or c_min <= 1e-12:\n            # uniform in bounds\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        # radii along orthonormal basis aligned with start->goal\n        r1 = c_best / 2.0\n        r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n        r_other = math.sqrt(r_other_sq) / 2.0\n\n        # center\n        center = tuple((s + g) / 2.0 for s, g in zip(start, goal))\n        # first axis (unit)\n        a1_vec = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n        # orthonormal basis\n        if dim == 2:\n            a2_vec = (-a1_vec[1], a1_vec[0])\n            basis = (a1_vec, a2_vec)\n            radii = (r1, r_other)\n        else:  # dim == 3\n            # pick any non-parallel vector\n            ref = (1.0, 0.0, 0.0) if abs(a1_vec[0]) < 0.9 else (0.0, 1.0, 0.0)\n            # b2 = normalize(cross(a1, ref)), b3 = cross(a1, b2)\n            b2 = self._normalize(self._cross(a1_vec, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._normalize(self._cross(a1_vec, ref))\n            b3 = self._cross(a1_vec, b2)\n            basis = (a1_vec, b2, b3)\n            radii = (r1, r_other, r_other)\n\n        # sample unit ball\n        u = self._sample_unit_ball(dim)\n\n        # map: x = center + sum_i (basis_i * radii_i * u_i)\n        mapped = []\n        for d in range(dim):\n            val = center[d]\n            for i in range(dim):\n                val += basis[i][d] * radii[i] * u[i]\n            mapped.append(val)\n\n        # clamp to bounds to be safe\n        mapped = tuple(min(max(mapped[d], 0.0), bounds[d]) for d in range(dim))\n        return mapped\n\n    def _sample_unit_ball(self, dim):\n        # Draw direction from normal distribution and radius with correct PDF\n        while True:\n            vec = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(v * v for v in vec))\n            if n > 1e-12:\n                vec = [v / n for v in vec]\n                r = random.random() ** (1.0 / dim)\n                return tuple(vec[i] * r for i in range(dim))\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)\n\n    # ------------------ Collision Utilities ------------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": 518.1211228589663,
          "time_improvement": -1783.0,
          "length_improvement": 22.0,
          "smoothness_improvement": 648.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.9512754917144776,
                    "num_nodes_avg": 539.7,
                    "path_length_avg": 146.95278540397857,
                    "smoothness_avg": 0.035670720596744435,
                    "success_improvement": 0.0,
                    "time_improvement": -3630.668342220689,
                    "node_improvement": -35.91035003777387,
                    "length_improvement": 19.45284970417965,
                    "smoothness_improvement": 458.32423754861986,
                    "objective_score": -1075.2371716559555
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.4313333034515381,
                    "num_nodes_avg": 595.7,
                    "path_length_avg": 229.86311266595635,
                    "smoothness_avg": 0.028909493641293648,
                    "success_improvement": 0.0,
                    "time_improvement": -169.25124453745204,
                    "node_improvement": 59.97446751327017,
                    "length_improvement": 23.265076749253225,
                    "smoothness_improvement": 643.8620940570969,
                    "objective_score": -33.59701684139819
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.8084268569946289,
                    "num_nodes_avg": 639.6,
                    "path_length_avg": 113.69137900509236,
                    "smoothness_avg": 0.07405674090515976,
                    "success_improvement": 0.0,
                    "time_improvement": -1548.1137371650768,
                    "node_improvement": 18.67768595041322,
                    "length_improvement": 24.491599466516433,
                    "smoothness_improvement": 841.9962780136293,
                    "objective_score": -445.52918007954503
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "RIBA*-Beam: Robust Informed BiRRT-A* \u2014 a bidirectional planner that couples beam-guided best-first expansion (cost-to-come + heuristic-to-goal), spatial-hash nearest/near queries, dual outcome edge-collision caching (blocked and free), per-cell cost dominance pruning, and limited line-of-sight ancestor compression. It maintains an anytime best path with informed-ellipse sampling for rapid refinement, bounded greedy connects, and fast shortcut+LOS smoothing for short, smooth solutions at low runtime.",
          "planning_mechanism": "Mechanism: Alternate tree growth; for each side, sample a small beam (goal/corridor/informed); for each sample, steer, validate node+edge, compress parent via LOS to ancestors, and score by estimated full path cost through the opposite tree. Commit the lowest-score candidate, update grids/caches, then attempt a k-near bridge minimizing total cost; if connected, record/shorten the path and continue a limited number of informed refinements before returning the best found. Spatial hashing, duplicate suppression, and dual collision caches cut repeated work and bound branching.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=6.5,\n                 beam_k=3,\n                 goal_bias=0.22,\n                 corridor_bias=0.38,\n                 connect_radius_factor=3.5,\n                 connect_k=8,\n                 grid_cell=None,\n                 edge_res=None,\n                 compress_depth=4,\n                 dupe_radius_ratio=0.45,\n                 occ_gain_ratio=0.98,\n                 smoothing_iters=80,\n                 improve_iters=500,\n                 switch_fail_thresh=8):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.connect_radius_factor = connect_radius_factor\n        self.connect_k = connect_k\n        self.grid_cell = grid_cell\n        self.edge_res = edge_res\n        self.compress_depth = compress_depth\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.occ_gain_ratio = occ_gain_ratio\n        self.smoothing_iters = smoothing_iters\n        self.improve_iters = improve_iters\n        self.switch_fail_thresh = switch_fail_thresh\n\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.9 * self.step_size)\n        if self.edge_res is None:\n            self.edge_res = max(0.6, min(1.0, 0.5 * self.step_size))\n\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_res):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.append(g)\n            return PlannerResult(True, [start, goal], [s, g], [(s, g)])\n\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_s, grid_g = {}, {}\n        self._grid_add(grid_s, start_root)\n        self._grid_add(grid_g, goal_root)\n\n        # Per-cell best costs to prune dominated insertions\n        occ_cell = max(0.6, 0.7 * self.step_size)\n        occ_s = {self._occ_key(start, occ_cell): 0.0}\n        occ_g = {self._occ_key(goal, occ_cell): 0.0}\n\n        # Edge collision caches (quantized)\n        self.cache_bin = max(1.0, self.edge_res)\n        blocked_edge_cache = set()\n        free_edge_cache = set()\n\n        best_path = None\n        best_len = float('inf')\n        improve_left = 0\n        no_improve_streak = 0\n\n        base_d = self._dist(start, goal)\n        corridor_w = max(self.step_size, 0.15 * base_d)\n\n        failed_s = 0\n        failed_g = 0\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            if active_start and failed_s >= self.switch_fail_thresh:\n                active_start = False\n                failed_s = 0\n            elif (not active_start) and failed_g >= self.switch_fail_thresh:\n                active_start = True\n                failed_g = 0\n\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_s if active_start else grid_g\n            grid_b = grid_g if active_start else grid_s\n            occ_a = occ_s if active_start else occ_g\n            root_other = goal if active_start else start\n            root_self = start if active_start else goal\n\n            # Beam: choose the candidate with minimum estimated total path cost via other tree\n            best_parent = None\n            best_newpos = None\n            best_newcost = None\n            best_est = float('inf')\n\n            for _ in range(self.beam_k):\n                x_rand = None\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = root_other\n                elif r < self.goal_bias + self.corridor_bias:\n                    x_rand = self._sample_corridor(root_self, root_other, corridor_w, obstacles, is_3d)\n                else:\n                    if best_len < float('inf'):\n                        x_rand = self._sample_informed(start, goal, best_len, obstacles, is_3d)\n                    else:\n                        x_rand = self._sample_free(obstacles, is_3d)\n\n                n_near = self._nearest_hashed(grid_a, tree_a, x_rand)\n                if n_near is None:\n                    continue\n\n                x_new = self._steer(n_near.position, x_rand, self.step_size)\n                if not self._in_bounds(x_new):\n                    continue\n                if self._is_in_obstacle(x_new, obstacles, is_3d):\n                    continue\n                if not self._edge_free_cached(n_near.position, x_new, obstacles, is_3d, blocked_edge_cache, free_edge_cache):\n                    continue\n\n                # Limited LOS ancestor compression\n                parent = n_near\n                new_cost = parent.cost + self._dist(parent.position, x_new)\n                anc = parent.parent\n                depth = 0\n                while anc is not None and depth < self.compress_depth:\n                    if self._edge_free_cached(anc.position, x_new, obstacles, is_3d, blocked_edge_cache, free_edge_cache):\n                        alt = anc.cost + self._dist(anc.position, x_new)\n                        if alt + 1e-12 < new_cost:\n                            new_cost = alt\n                            parent = anc\n                    anc = anc.parent\n                    depth += 1\n\n                # Duplicate suppression via occupancy cost dominance and local radius\n                if self._exists_close(grid_a, x_new, self.step_size * self.dupe_radius_ratio):\n                    continue\n                ok = self._occ_key(x_new, occ_cell)\n                prev = occ_a.get(ok, float('inf'))\n                if new_cost >= prev * self.occ_gain_ratio:\n                    continue\n\n                # Heuristic: estimate full path cost via opposite tree (nearest)\n                other_near = self._nearest_hashed(grid_b, tree_b, x_new)\n                if other_near is not None:\n                    est_total = new_cost + self._dist(x_new, other_near.position) + other_near.cost\n                else:\n                    est_total = new_cost + self._dist(x_new, root_other)\n\n                if est_total < best_est:\n                    best_est = est_total\n                    best_parent = parent\n                    best_newpos = x_new\n                    best_newcost = new_cost\n\n            if best_parent is None:\n                if active_start:\n                    failed_s += 1\n                else:\n                    failed_g += 1\n                continue\n\n            # Final checks before adding node/edge (both required)\n            if self._is_in_obstacle(best_newpos, obstacles, is_3d):\n                if active_start:\n                    failed_s += 1\n                else:\n                    failed_g += 1\n                continue\n            if not self._edge_free_cached(best_parent.position, best_newpos, obstacles, is_3d, blocked_edge_cache, free_edge_cache):\n                if active_start:\n                    failed_s += 1\n                else:\n                    failed_g += 1\n                continue\n\n            # Insert node\n            new_node = Node(best_newpos, None, best_newcost)\n            new_node.attach(best_parent)\n            tree_a.append(new_node)\n            edges.append((best_parent, new_node))\n            self._grid_add(grid_a, new_node)\n            k_occ = self._occ_key(best_newpos, occ_cell)\n            if best_newcost < occ_a.get(k_occ, float('inf')):\n                occ_a[k_occ] = best_newcost\n            if active_start:\n                failed_s = 0\n            else:\n                failed_g = 0\n\n            # Attempt k-near bridge\n            r_conn = max(self.connect_radius_factor * self.step_size, self.step_size)\n            near_b = self._near_hashed(grid_b, new_node.position, r_conn)\n            if not near_b:\n                nb = self._nearest_hashed(grid_b, tree_b, new_node.position)\n                if nb is not None:\n                    near_b = [nb]\n            if len(near_b) > self.connect_k:\n                # keep the closest connect_k by Euclidean distance\n                ds = [(self._dist(n.position, new_node.position), n) for n in near_b]\n                ds.sort(key=lambda t: t[0])\n                near_b = [t[1] for t in ds[:self.connect_k]]\n\n            improved = False\n            best_bridge = None\n            best_total = best_len\n            for nb in near_b:\n                if self._edge_free_cached(new_node.position, nb.position, obstacles, is_3d, blocked_edge_cache, free_edge_cache):\n                    total = new_node.cost + self._dist(new_node.position, nb.position) + nb.cost\n                    if best_path is None or total + 1e-12 < best_total:\n                        best_total = total\n                        best_bridge = nb\n\n            if best_bridge is not None:\n                if active_start:\n                    meet_a, meet_b = new_node, best_bridge\n                else:\n                    meet_a, meet_b = best_bridge, new_node\n                raw = self._extract_path(meet_a, meet_b)\n                raw = self._compress(raw, obstacles, is_3d)\n                raw = self._shortcuts(raw, obstacles, is_3d, self.smoothing_iters)\n                plen = self._path_length(raw)\n                if plen + 1e-12 < best_len:\n                    best_len = plen\n                    best_path = raw\n                    improved = True\n                    no_improve_streak = 0\n                    if improve_left == 0:\n                        improve_left = max(50, min(self.improve_iters, int(0.25 * self.max_iter)))\n\n            # Bounded greedy connect (micro-steps) if not bridged\n            if best_bridge is None:\n                other_near = self._nearest_hashed(grid_b, tree_b, new_node.position)\n                p = other_near\n                steps = 0\n                max_steps = 3\n                while p is not None and steps < max_steps:\n                    to_pos = self._steer(p.position, new_node.position, self.step_size)\n                    if not self._in_bounds(to_pos):\n                        break\n                    if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                        break\n                    if not self._edge_free_cached(p.position, to_pos, obstacles, is_3d, blocked_edge_cache, free_edge_cache):\n                        break\n                    if self._exists_close(grid_b, to_pos, self.step_size * self.dupe_radius_ratio):\n                        break\n\n                    # Both checks satisfied; insert connect step\n                    q = Node(to_pos, None, p.cost + self._dist(p.position, to_pos))\n                    q.attach(p)\n                    tree_b.append(q)\n                    edges.append((p, q))\n                    self._grid_add(grid_b, q)\n\n                    # Try bridging now\n                    if self._edge_free_cached(new_node.position, q.position, obstacles, is_3d, blocked_edge_cache, free_edge_cache):\n                        if active_start:\n                            meet_a, meet_b = new_node, q\n                        else:\n                            meet_a, meet_b = q, new_node\n                        raw = self._extract_path(meet_a, meet_b)\n                        raw = self._compress(raw, obstacles, is_3d)\n                        raw = self._shortcuts(raw, obstacles, is_3d, self.smoothing_iters)\n                        plen = self._path_length(raw)\n                        if plen + 1e-12 < best_len:\n                            best_len = plen\n                            best_path = raw\n                            improved = True\n                            no_improve_streak = 0\n                            if improve_left == 0:\n                                improve_left = max(50, min(self.improve_iters, int(0.25 * self.max_iter)))\n                        break\n\n                    p = q\n                    steps += 1\n\n            # Early return if we have a solution and improvement budget exhausted or stagnation\n            if best_path is not None:\n                if not improved:\n                    no_improve_streak += 1\n                if improve_left > 0:\n                    improve_left -= 1\n                if improve_left == 0 or no_improve_streak > max(60, int(0.05 * self.max_iter)):\n                    return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # RNG\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 1103515245\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return tuple(self._clip(to_pos[i], 0.0, self.bounds[i]) for i in range(self.dim))\n        r = step / d\n        return tuple(self._clip(from_pos[i] + (to_pos[i] - from_pos[i]) * r, 0.0, self.bounds[i]) for i in range(self.dim))\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_free_cached(self, a, b, obstacles, is_3d, blocked_cache, free_cache):\n        key = self._edge_key_q(a, b)\n        if key in free_cache:\n            return True\n        if key in blocked_cache:\n            return False\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res)\n        if blocked:\n            blocked_cache.add(key)\n            return False\n        else:\n            free_cache.add(key)\n            return True\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, a, b, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(a[i] + t * (b[i] - a[i]) for i in range(self.dim))\n        if self.dim == 3:\n            p = (self._clip(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clip(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clip(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clip(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clip(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, s, g, best_len, obstacles, is_3d):\n        # Rejection sample inside prolate ellipse (2D) / ellipsoid (3D) with foci s,g and sum of distances <= best_len\n        tries = 32\n        for _ in range(tries):\n            p = self._sample_free(obstacles, is_3d)\n            if self._dist(p, s) + self._dist(p, g) <= best_len + 1e-9:\n                return p\n        return self._sample_free(obstacles, is_3d)\n\n    # Spatial hash\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        cand.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            cand.extend(lst)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, pos):\n        k = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, k, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan (rare)\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_hashed(self, grid, pos, radius):\n        r_cells = int(radius / self.grid_cell) + 1\n        k = self._grid_key(pos)\n        cand = self._grid_ring_collect(grid, k, r_cells)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            dd = 0.0\n            for i in range(self.dim):\n                di = n.position[i] - pos[i]\n                dd += di * di\n            if dd <= r2:\n                out.append(n)\n        return out\n\n    def _exists_close(self, grid, pos, radius):\n        r_cells = int(radius / self.grid_cell) + 1\n        k = self._grid_key(pos)\n        cand = self._grid_ring_collect(grid, k, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            dd = 0.0\n            for i in range(self.dim):\n                di = n.position[i] - pos[i]\n                dd += di * di\n            if dd <= r2:\n                return True\n        return False\n\n    def _occ_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    # Paths\n    def _path_to_root(self, node):\n        seq = []\n        cur = node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        tail = []\n        cur = meet_b\n        while cur is not None:\n            tail.append(cur.position)\n            cur = cur.parent\n        return path_a + tail\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.edge_res):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        # Forward LOS collapse\n        if n >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            for k in range(1, len(pts) - 1):\n                nxt = pts[k + 1]\n                if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d, self.edge_res):\n                    collapsed.append(pts[k])\n                    last = pts[k]\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
          "objective": 542.46447,
          "time_improvement": -1878.0,
          "length_improvement": 21.0,
          "smoothness_improvement": 1639.0,
          "node_improvement": 6.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 1.2183320760726928,
                    "num_nodes_avg": 612.2,
                    "path_length_avg": 150.98409521399245,
                    "smoothness_avg": 0.04530958640644099,
                    "success_improvement": 0.0,
                    "time_improvement": -4677.998535760268,
                    "node_improvement": -54.167715940569124,
                    "length_improvement": 17.24322491711922,
                    "smoothness_improvement": 609.1934186024911,
                    "objective_score": -1390.0076586847963
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.5740199327468872,
                    "num_nodes_avg": 691.2,
                    "path_length_avg": 227.95703793517796,
                    "smoothness_avg": 0.10995267913297921,
                    "success_improvement": 0.0,
                    "time_improvement": -258.3205378407995,
                    "node_improvement": 53.55775045353759,
                    "length_improvement": 23.901379357706194,
                    "smoothness_improvement": 2729.16162980522,
                    "objective_score": -49.509525588590016
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.39061861038208007,
                    "num_nodes_avg": 644.6,
                    "path_length_avg": 117.62417583399774,
                    "smoothness_avg": 0.13205233911682865,
                    "success_improvement": 0.0,
                    "time_improvement": -696.3415517346133,
                    "node_improvement": 18.04195804195804,
                    "length_improvement": 21.87962307241798,
                    "smoothness_improvement": 1579.6960064762902,
                    "objective_score": -187.87621164455172
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "Bi-Directed kNN RRT* with Cross-Tree Optimal Bridges and Corridor Refinement: a bidirectional, k-nearest rewiring planner that grows two optimized trees from start and goal, connects them via collision-free single-edge bridges evaluated for true path cost, uses informed and corridor-biased sampling after the first solution, and applies greedy plus randomized shortcut smoothing to minimize path length.",
          "planning_mechanism": "Mechanism: alternate expansions of start/goal trees; for each sample, steer from the nearest, select the best parent among k-nearest neighbors, and rewire neighbors if improved; at each insertion, evaluate multiple cross-tree bridge candidates and keep the best-cost feasible join without spawning chains; once a solution exists, restrict sampling to the prolate hyperspheroid and the current path corridor to accelerate shortening; terminate on budget or stagnation, then rebuild edges from parent links and perform deterministic then randomized shortcut smoothing.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def reparent(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        if new_parent is not None:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=7000,\n                 step_size=5.0,\n                 goal_bias=0.10,\n                 k_coeff=2.5,\n                 k_min=6,\n                 post_opt_iters=1000,\n                 max_no_improve=300,\n                 edge_check_step=1.0,\n                 corridor_bias=0.55,\n                 smoothing_iters=160):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.k_coeff = k_coeff\n        self.k_min = k_min\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.edge_check_step = edge_check_step\n        self.corridor_bias = corridor_bias\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        tree_s = [start_root]\n        tree_g = [goal_root]\n\n        nodes = [start_root, goal_root]\n\n        cell = max(1.0, self.step_size)  # spatial hash cell\n        grid_s = {}\n        grid_g = {}\n        self._grid_add(grid_s, start_root, cell)\n        self._grid_add(grid_g, goal_root, cell)\n\n        best_cost = float('inf')\n        best_bridge = (None, None)  # (node_from_start_tree, node_from_goal_tree)\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n        best_path = []\n\n        for it in range(self.max_iter):\n            # Alternate which tree expands first each outer iteration\n            for phase in (0, 1):\n                expand_start = ((it + phase) % 2 == 0)\n                Ta = tree_s if expand_start else tree_g\n                Tb = tree_g if expand_start else tree_s\n                Ga = grid_s if expand_start else grid_g\n                Gb = grid_g if expand_start else grid_s\n                root_a = start if expand_start else goal\n                root_b = goal if expand_start else start\n                is_a_start = expand_start\n\n                # Sampling\n                sample = None\n                if found_first and self._rand() < self.corridor_bias:\n                    # Corridor-biased sample near current best path\n                    sample = self._sample_corridor(best_path)\n                else:\n                    # Informed ellipse sampling after first solution, else uniform\n                    sample = self._sample_informed(start, goal, best_cost)\n\n                # Occasional direct bias towards opposite root\n                if self._rand() < self.goal_bias:\n                    sample = root_b\n\n                # Find nearest in Ta and steer\n                nearest = self._nearest_grid(Ga, Ta, sample, cell)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n\n                # Bounds and collision checks for node and edge\n                if (not self._in_bounds(new_pos)) or self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_check_step):\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n                    continue\n\n                # k-nearest candidate parents\n                k = self._k_near(len(Ta))\n                near_nodes = self._knn_grid(Ga, new_pos, k, cell, Ta)\n\n                # Choose best parent\n                best_parent = nearest\n                best_pc = nearest.cost + self._dist(nearest.position, new_pos)\n                for nn in near_nodes:\n                    if nn is nearest:\n                        continue\n                    # Edge collision check for candidate parent\n                    if self._is_edge_in_obstacle(nn.position, new_pos, obstacles, is_3d, self.edge_check_step):\n                        continue\n                    cc = nn.cost + self._dist(nn.position, new_pos)\n                    if cc + 1e-12 < best_pc:\n                        best_pc = cc\n                        best_parent = nn\n\n                # Create and insert node\n                x_new = Node(new_pos)\n                best_parent.add_child(x_new)\n                x_new.cost = best_pc\n                Ta.append(x_new)\n                nodes.append(x_new)\n                self._grid_add(Ga, x_new, cell)\n\n                # Rewire neighbors to x_new if beneficial\n                for nn in near_nodes:\n                    if nn is x_new:\n                        continue\n                    # Only consider rewiring if going through x_new reduces cost\n                    alt = x_new.cost + self._dist(x_new.position, nn.position)\n                    if alt + 1e-12 < nn.cost:\n                        # Check collision for the potential new edge\n                        if self._is_edge_in_obstacle(x_new.position, nn.position, obstacles, is_3d, self.edge_check_step):\n                            continue\n                        # Reparent and propagate cost changes\n                        nn.reparent(x_new)\n                        self._propagate_costs_from(nn)\n\n                # Evaluate cross-tree bridges (single-edge connect to multiple near candidates)\n                # Try the nearest(s) in Tb\n                k_bridge = max(6, min(16, self._k_near(len(Tb))))\n                bridge_cands = self._knn_grid(Gb, x_new.position, k_bridge, cell, Tb)\n                improved = False\n                for bn in bridge_cands:\n                    # Must ensure the bridging edge is collision-free\n                    if self._is_edge_in_obstacle(x_new.position, bn.position, obstacles, is_3d, self.edge_check_step):\n                        continue\n                    # Compute full path cost via this bridge\n                    if is_a_start:\n                        # Ta is from start; Tb from goal\n                        path_c = x_new.cost + self._dist(x_new.position, bn.position) + bn.cost\n                        a_node, g_node = x_new, bn\n                    else:\n                        # Ta is from goal; Tb from start\n                        path_c = bn.cost + self._dist(x_new.position, bn.position) + x_new.cost\n                        a_node, g_node = bn, x_new  # a_node is from start tree\n                    if path_c + 1e-12 < best_cost:\n                        best_cost = path_c\n                        best_bridge = (a_node, g_node)\n                        found_first = True\n                        improved = True\n                        no_improve = 0\n                        post_iters = 0\n                        best_path = self._assemble_path(best_bridge[0], best_bridge[1])\n                if found_first and not improved:\n                    post_iters += 1\n                    no_improve += 1\n\n                if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                    break\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        success = (best_cost < float('inf') and best_bridge[0] is not None)\n        path = []\n        if success:\n            path = self._assemble_path(best_bridge[0], best_bridge[1])\n            # Greedy deterministic pruning then randomized shortcuts\n            path = self._greedy_prune(path, obstacles, is_3d)\n            path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n\n        # Rebuild coherent edges from parent pointers to avoid duplicates\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # ---------- Utilities ----------\n    def _rand(self):\n        try:\n            return random.random()\n        except:\n            if not hasattr(self, \"_lcg_state\"):\n                self._lcg_state = 2463534242\n            # xorshift32\n            x = self._lcg_state & 0xFFFFFFFF\n            x ^= (x << 13) & 0xFFFFFFFF\n            x ^= (x >> 17) & 0xFFFFFFFF\n            x ^= (x << 5) & 0xFFFFFFFF\n            self._lcg_state = x\n            return (x & 0xFFFFFFFF) / float(0x100000000)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = (a[i] - b[i])\n            s += d * d\n        return s ** 0.5\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        ratio = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(self.dim))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-6, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Sampling ----------\n    def _sample_informed(self, start, goal, c_best):\n        # Rejection from the bounding box; if no solution yet, pure uniform\n        tries = 40\n        if c_best == float('inf'):\n            # Uniform free bounds\n            return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n        else:\n            # Informed prolate hyperspheroid: ||p-s|| + ||p-g|| <= c_best\n            for _ in range(tries):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._dist(p, start) + self._dist(p, goal) <= c_best and self._in_bounds(p):\n                    return p\n            # Fallback to uniform\n            return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _sample_corridor(self, path):\n        if not path or len(path) < 2:\n            return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n        # Pick a random segment\n        n = len(path)\n        i = int(self._uniform(0, n - 1))\n        if i >= n - 1:\n            i = n - 2\n        a = path[i]\n        b = path[i + 1]\n        t = self._rand()\n        base = tuple(a[d] + (b[d] - a[d]) * t for d in range(self.dim))\n        # Jitter within a small ball to explore nearby shortcuts\n        r = self.step_size * 2.0\n        if self.dim == 2:\n            # uniform disk via rejection\n            for _ in range(10):\n                dx = self._uniform(-r, r)\n                dy = self._uniform(-r, r)\n                if dx * dx + dy * dy <= r * r:\n                    p = (base[0] + dx, base[1] + dy)\n                    if self._in_bounds(p):\n                        return p\n        else:\n            for _ in range(10):\n                dx = self._uniform(-r, r)\n                dy = self._uniform(-r, r)\n                dz = self._uniform(-r, r)\n                if dx * dx + dy * dy + dz * dz <= r * r:\n                    p = (base[0] + dx, base[1] + dy, base[2] + dz)\n                    if self._in_bounds(p):\n                        return p\n        return base\n\n    # ---------- Neighbor search via spatial hash ----------\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        key = self._grid_key(node.position, cell)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _gather_ring(self, grid, center_pos, ring, cell):\n        # Gather nodes from cells within 'ring' Chebyshev distance\n        k0 = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-ring, ring + 1):\n                for dy in range(-ring, ring + 1):\n                    k = (k0[0] + dx, k0[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-ring, ring + 1):\n                for dy in range(-ring, ring + 1):\n                    for dz in range(-ring, ring + 1):\n                        k = (k0[0] + dx, k0[1] + dy, k0[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos, cell):\n        best = None\n        bestd = float('inf')\n        # Expand rings up to limited radius\n        for ring in range(0, 4):\n            cand = self._gather_ring(grid, pos, ring, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                return best\n        # Fallback approximate nearest via random subset scan\n        if tree:\n            tries = min(64, len(tree))\n            stride = max(1, len(tree) // tries)\n            for i in range(0, len(tree), stride):\n                n = tree[i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best if best is not None else (tree[0] if tree else None)\n\n    def _knn_grid(self, grid, pos, k, cell, tree):\n        # Expand rings until at least k candidates found, then take k nearest\n        collected = []\n        for ring in range(0, 6):\n            cand = self._gather_ring(grid, pos, ring, cell)\n            if cand:\n                collected.extend(cand)\n            if len(collected) >= k:\n                break\n        if len(collected) < k:\n            # If sparse grid, add a light scan over tree with stride\n            stride = max(1, max(1, len(tree)) // max(1, (k - len(collected) + 1)))\n            for i in range(0, len(tree), stride):\n                collected.append(tree[i])\n        # Deduplicate\n        seen = {}\n        uniq = []\n        for n in collected:\n            nid = id(n)\n            if nid not in seen:\n                seen[nid] = True\n                uniq.append(n)\n        # Sort by distance\n        uniq.sort(key=lambda n: self._dist(n.position, pos))\n        if len(uniq) > k:\n            uniq = uniq[:k]\n        return uniq\n\n    def _k_near(self, n):\n        if n <= 1:\n            return 1\n        # Monotone sublinear growth; avoids huge neighborhoods while improving quality\n        k = int(self.k_coeff * (n ** 0.5))\n        if k < self.k_min:\n            k = self.k_min\n        if k >= n:\n            k = n - 1\n        if k < 1:\n            k = 1\n        return k\n\n    # ---------- Cost propagation ----------\n    def _propagate_costs_from(self, node):\n        # Recompute costs for subtree rooted at node using DFS stack\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            if u.parent is not None:\n                u.cost = u.parent.cost + self._dist(u.parent.position, u.position)\n            for c in u.children:\n                stack.append(c)\n\n    # ---------- Path assembly and smoothing ----------\n    def _path_to_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        path.reverse()\n        return path\n\n    def _assemble_path(self, start_tree_node, goal_tree_node):\n        # start_tree_node is from tree rooted at start; goal_tree_node from tree rooted at goal\n        path_a = self._path_to_root(start_tree_node)\n        # From goal node up to goal root (goal is the root)\n        path_b = []\n        cur = goal_tree_node\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # Connection edge between path_a[-1] and path_b[0] is implicit\n        return path_a + path_b\n\n    def _greedy_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        pruned = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            # find furthest j that is directly visible\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.edge_check_step):\n                    break\n                j -= 1\n            pruned.append(path[j])\n            i = j\n        # Make sure last point is goal\n        if pruned[-1] != path[-1]:\n            pruned.append(path[-1])\n        return pruned\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d, self.edge_check_step):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
          "objective": 795.61338,
          "time_improvement": -2719.0,
          "length_improvement": 24.0,
          "smoothness_improvement": 1102.0,
          "node_improvement": -74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 1.698044753074646,
                    "num_nodes_avg": 1329.2,
                    "path_length_avg": 145.45536099177093,
                    "smoothness_avg": 0.03591051740133288,
                    "success_improvement": 0.0,
                    "time_improvement": -6559.313583862321,
                    "node_improvement": -234.72676907579952,
                    "length_improvement": 20.273611752718903,
                    "smoothness_improvement": 462.07757826752476,
                    "objective_score": -1953.3195202157274
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.8028737783432007,
                    "num_nodes_avg": 1061.4,
                    "path_length_avg": 217.15017840891545,
                    "smoothness_avg": 0.07070058449433494,
                    "success_improvement": 0.0,
                    "time_improvement": -401.178003867446,
                    "node_improvement": 28.683733118322913,
                    "length_improvement": 27.509020125776996,
                    "smoothness_improvement": 1719.176962611903,
                    "objective_score": -95.25210427170809
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.6364996194839477,
                    "num_nodes_avg": 901.9,
                    "path_length_avg": 111.96093461697778,
                    "smoothness_avg": 0.09638937487871334,
                    "success_improvement": 0.0,
                    "time_improvement": -1197.6112278996293,
                    "node_improvement": -14.67260012714558,
                    "length_improvement": 25.64087823419522,
                    "smoothness_improvement": 1126.0657337336618,
                    "objective_score": -338.26851276070335
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "Informed Dual-Tree RRT* with Commit-Only Connect and Grandparent Line-of-Sight Rewiring (IDT-RRT*++): a bidirectional, asymptotically optimal planner focused on minimizing path length. It uses an r(n) \u221d (log n / n)^(1/d) neighborhood for high-quality parent selection and rewiring, performs zero-bloat \u201ccommit-only\u201d tree connection (adds no nodes on failed connects), prunes expansions with an admissible cost-to-go bound once a path exists, and applies grandparent line-of-sight rewiring to remove zig-zags. Informed rejection sampling inside the prolate hyperspheroid rapidly tightens the incumbent cost, while anytime shortcut smoothing further reduces length during and after planning.",
          "planning_mechanism": "Mechanism: alternate growing start/goal trees with informed sampling; steer, validate node and edge, choose the least-cost parent among r(n) neighbors, apply LOS-to-grandparent improvement and rewire; attempt direct, collision-free joining to the opposite tree without committing nodes unless the join succeeds; upon any improvement, prune by cost-to-go and restrict future samples to the hyperspheroid; periodically perform shortcut attempts on the current best path; terminate on budget or stagnation and return the shortest smoothed path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=7000,\n                 step_size=5.0,\n                 goal_bias=0.15,\n                 base_radius=30.0,\n                 min_radius=6.0,\n                 collision_step=1.0,\n                 post_opt_iters=1000,\n                 max_no_improve=300,\n                 smoothing_iters=180,\n                 min_separation_ratio=0.35,\n                 per_iter_shortcuts=2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.collision_step = collision_step\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n        self.min_separation_ratio = min_separation_ratio\n        self.per_iter_shortcuts = per_iter_shortcuts\n\n        self.dim = 2\n        self.bounds = None\n\n    # ------------- Core planning -------------\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Space scale estimates\n        self.space_diam = self._dist(tuple(0.0 for _ in range(self.dim)), tuple(self.bounds[i] for i in range(self.dim)))\n        r_max = max(self.min_radius, self.base_radius)\n        self.grid_cell = max(self.step_size * 1.25, r_max * 0.5)\n        self.min_separation = max(1.0, self.step_size * self.min_separation_ratio)\n        self.edge_res = max(0.5, min(self.collision_step, self.step_size / 4.0))\n\n        # Trees, grids, and edge maps (child -> parent)\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        parent_of = {start_root: None, goal_root: None}\n\n        # Planning state\n        success = False\n        best_cost = float('inf')\n        best_join = (None, None)\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n        incumbent_path = []\n\n        # Alternate expansion\n        for it in range(self.max_iter):\n            for which in (0, 1):\n                active_start = ((it + which) % 2 == 0)\n                tree_a = start_tree if active_start else goal_tree\n                tree_b = goal_tree if active_start else start_tree\n                grid_a = grid_start if active_start else grid_goal\n                grid_b = grid_goal if active_start else grid_start\n                root_other = goal if active_start else start\n\n                # Sample (informed if path known), with occasional bias to the opposite root\n                if self._rand() < self.goal_bias:\n                    x_rand = root_other\n                else:\n                    x_rand = self._sample(start, goal, best_cost, obstacles, is_3d)\n\n                # Nearest and steer\n                x_nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n                x_new_pos = self._steer(x_nearest.position, x_rand, self.step_size)\n                if not self._in_bounds(x_new_pos):\n                    continue\n                if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d, self.edge_res):\n                    continue\n\n                # Separation: avoid adding nodes too close to existing ones\n                if self._dist(x_nearest.position, x_new_pos) < self.min_separation:\n                    continue\n\n                # Choose best parent among near neighbors with RRT* radius\n                n_nodes = len(tree_a) + 1\n                r_near = self._rrtstar_radius(n_nodes)\n                near_nodes = self._near_grid(grid_a, x_new_pos, r_near)\n                if x_nearest not in near_nodes:\n                    near_nodes.append(x_nearest)\n\n                best_parent = None\n                best_pc = float('inf')\n                for nn in near_nodes:\n                    # Prune by admissible bound once a path exists\n                    if found_first:\n                        # Active tree cost-to-go to opposite root (start-tree -> goal, goal-tree -> start)\n                        if nn.cost + self._dist(nn.position, root_other) >= best_cost - 1e-9:\n                            continue\n                    cand_cost = nn.cost + self._dist(nn.position, x_new_pos)\n                    if cand_cost < best_pc and not self._is_edge_in_obstacle(nn.position, x_new_pos, obstacles, is_3d, self.edge_res):\n                        best_parent = nn\n                        best_pc = cand_cost\n\n                if best_parent is None:\n                    continue\n\n                # Grandparent line-of-sight (LOS) shortcut: try to reduce zig-zag and path length\n                improved = True\n                gp_parent = best_parent.parent\n                cur_parent = best_parent\n                cur_cost = best_pc\n                while improved and gp_parent is not None:\n                    gp_cost = gp_parent.cost + self._dist(gp_parent.position, x_new_pos)\n                    if gp_cost + 1e-12 < cur_cost and not self._is_edge_in_obstacle(gp_parent.position, x_new_pos, obstacles, is_3d, self.edge_res):\n                        cur_parent = gp_parent\n                        cur_cost = gp_cost\n                        gp_parent = cur_parent.parent\n                    else:\n                        improved = False\n                best_parent = cur_parent\n                best_pc = cur_cost\n\n                # Create and insert node\n                x_new = Node(x_new_pos)\n                x_new.cost = best_pc\n                best_parent.add_child(x_new)\n                tree_a.append(x_new)\n                nodes.append(x_new)\n                parent_of[x_new] = best_parent\n                self._grid_add(grid_a, x_new)\n\n                # Rewire neighbors through x_new\n                for nn in near_nodes:\n                    if nn is best_parent or nn is x_new:\n                        continue\n                    # Prune by admissible bound once a path exists\n                    if found_first:\n                        if x_new.cost + self._dist(x_new.position, root_other) >= best_cost - 1e-9:\n                            continue\n                    alt = x_new.cost + self._dist(x_new.position, nn.position)\n                    if alt + 1e-12 < nn.cost and not self._is_edge_in_obstacle(x_new.position, nn.position, obstacles, is_3d, self.edge_res):\n                        oldp = parent_of.get(nn, nn.parent)\n                        if oldp is not None:\n                            # Detach from old parent\n                            try:\n                                oldp.children.remove(nn)\n                            except:\n                                pass\n                        x_new.add_child(nn)\n                        nn.cost = alt\n                        parent_of[nn] = x_new\n                        self._propagate_costs_from(nn)\n\n                # Try commit-only direct connection to closest node in the opposite tree\n                nnear_b = self._nearest_grid(grid_b, tree_b, x_new.position)\n                if nnear_b is not None:\n                    if not self._is_edge_in_obstacle(x_new.position, nnear_b.position, obstacles, is_3d, self.edge_res):\n                        path_cost = x_new.cost + self._dist(x_new.position, nnear_b.position) + nnear_b.cost\n                        if path_cost + 1e-12 < best_cost:\n                            best_cost = path_cost\n                            best_join = (x_new, nnear_b)\n                            success = True\n                            found_first = True\n                            post_iters = 0\n                            no_improve = 0\n                            incumbent_path = self._extract_path(best_join[0], best_join[1])\n                        else:\n                            no_improve += 1\n                        post_iters += 1\n                    else:\n                        if found_first:\n                            post_iters += 1\n                            no_improve += 1\n                else:\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n\n                # Anytime shortcut attempts to shave length during planning\n                if found_first and incumbent_path:\n                    for _ in range(self.per_iter_shortcuts):\n                        incumbent_path = self._shortcut_once(incumbent_path, obstacles, is_3d)\n                    new_len = self._path_length(incumbent_path)\n                    if new_len + 1e-12 < best_cost:\n                        best_cost = new_len\n                        no_improve = 0\n                        post_iters = 0\n\n                # Early termination on post-optimization budget or stagnation\n                if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                    break\n\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        # Final path and smoothing\n        path = []\n        if success and best_join[0] is not None:\n            path = self._extract_path(best_join[0], best_join[1])\n            path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n\n        # Build coherent edges list from parent map\n        edges = []\n        for n, p in list(parent_of.items()):\n            if p is not None:\n                edges.append((p, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # ------------- Utilities -------------\n    def _rand(self):\n        try:\n            return random.random()\n        except:\n            if not hasattr(self, \"_lcg_state\"):\n                self._lcg_state = 2463534242\n            self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n            return (self._lcg_state / float(1 << 32))\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = (a[i] - b[i])\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        ratio = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(self.dim)))\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # ------------- Collision checks -------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-6, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ------------- Sampling -------------\n    def _sample(self, start, goal, c_best, obstacles, is_3d):\n        # Informed rejection sampling inside prolate hyperspheroid via distance-sum <= c_best\n        # Avoid obstacles with a few retries; fall back to uniform in-bounds\n        attempts = 0\n        max_attempts = 200\n        while attempts < max_attempts:\n            attempts += 1\n            p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n            if not self._in_bounds(p):\n                continue\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                continue\n            if c_best < float('inf'):\n                if self._dist(p, start) + self._dist(p, goal) <= c_best + 1e-9:\n                    return p\n            else:\n                return p\n        # Fallback uniform valid point\n        while True:\n            p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ------------- Neighborhoods -------------\n    def _rrtstar_radius(self, n):\n        if n <= 2:\n            return max(self.min_radius, self.base_radius)\n        # ln(n) via log2 approximation: ln(n) = log2(n) * ln(2)\n        log2n = max(1.0, float(n.bit_length() - 1))\n        ln2 = 0.6931471805599453\n        ln_n = log2n * ln2\n        dim = max(2, self.dim)\n        gamma = 1.5 * (self.space_diam)  # scale with space size\n        r = gamma * ((ln_n / float(n)) ** (1.0 / dim))\n        r = max(self.min_radius, min(self.base_radius, r))\n        return r\n\n    # ------------- Grid indexing -------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        key = self._grid_key(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_gather(self, grid, center_pos, radius):\n        rng = int(radius // self.grid_cell) + 1\n        key = self._grid_key(center_pos)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    b = grid.get(k)\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        b = grid.get(k)\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        # expand a few rings; fallback scan if needed\n        best = None\n        bestd = float('inf')\n        for rng in range(1, 5):\n            cand = self._grid_gather(grid, pos, rng * self.grid_cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                return best\n        # fallback\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_grid(self, grid, pos, radius):\n        cand = self._grid_gather(grid, pos, radius)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                di = (n.position[i] - pos[i])\n                d += di * di\n            if d <= r2:\n                out.append(n)\n        return out\n\n    # ------------- Path utilities -------------\n    def _propagate_costs_from(self, node):\n        stack = []\n        for c in node.children:\n            stack.append(c)\n        while stack:\n            u = stack.pop()\n            if u.parent is not None:\n                u.cost = u.parent.cost + self._dist(u.parent.position, u.position)\n            for c in u.children:\n                stack.append(c)\n\n    def _path_to_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        path.reverse()\n        return path\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        # meet_b belongs to opposite tree whose root is goal; climb to its root\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut_once(self, path, obstacles, is_3d):\n        n = len(path)\n        if n < 3:\n            return path\n        i = int(self._uniform(0, n - 2))\n        j = int(self._uniform(i + 1, n - 1))\n        if j <= i + 1:\n            return path\n        a = path[i]\n        b = path[j]\n        if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n            return path[:i + 1] + path[j:]\n        return path\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            new_pts = self._shortcut_once(pts, obstacles, is_3d)\n            if len(new_pts) == len(pts):\n                # try small local smoothing by greedily removing a middle point\n                k = int(self._uniform(1, max(2, len(pts) - 1)))\n                i = k - 1\n                j = k + 1 if k + 1 < len(pts) else k\n                if j < len(pts) and i >= 0 and j > i and not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d, self.edge_res):\n                    pts = pts[:i + 1] + pts[j:]\n            else:\n                pts = new_pts\n            if len(pts) < 3:\n                break\n        return pts",
          "objective": 903.65932,
          "time_improvement": -3080.0,
          "length_improvement": 24.0,
          "smoothness_improvement": 1125.0,
          "node_improvement": -60.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 1.9191562414169312,
                    "num_nodes_avg": 1078.5,
                    "path_length_avg": 144.84467816258504,
                    "smoothness_avg": 0.04086584566813316,
                    "success_improvement": 0.0,
                    "time_improvement": -7426.4584192382035,
                    "node_improvement": -171.59405691261645,
                    "length_improvement": 20.60833668828437,
                    "smoothness_improvement": 539.6392263105108,
                    "objective_score": -2212.8743276269374
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.919565224647522,
                    "num_nodes_avg": 1254.0,
                    "path_length_avg": 217.8194732486166,
                    "smoothness_avg": 0.07114963536651986,
                    "success_improvement": 0.0,
                    "time_improvement": -474.02032068577586,
                    "node_improvement": 15.742793791574277,
                    "length_improvement": 27.285590243700952,
                    "smoothness_improvement": 1730.7313649914906,
                    "objective_score": -117.18108523455474
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.7055335283279419,
                    "num_nodes_avg": 971.1,
                    "path_length_avg": 112.77685375486826,
                    "smoothness_avg": 0.09469551316670241,
                    "success_improvement": 0.0,
                    "time_improvement": -1338.3484294307068,
                    "node_improvement": -23.47107438016529,
                    "length_improvement": 25.098983592702577,
                    "smoothness_improvement": 1104.519937784749,
                    "objective_score": -380.92253898466674
               }
          ],
          "success_rate": 1.0
     }
]