[
     {
          "operator": "m3",
          "algorithm_description": "SIMPLE-BiRRT-i: a simplified informed bi-directional RRT with spatial hashing and ghost-connect. It grows two trees from start and goal with small-step steering, hashed nearest search, light duplicate suppression, and early termination upon a valid bridge. It maintains coherence (node/edge checks before add), avoids heavy rewiring/compression, and performs greedy visibility pruning followed by bounded shortcut smoothing for shorter, smoother paths.",
          "planning_mechanism": "Alternate expanding start and goal trees. Each iteration: sample uniformly with goal-bias and optionally inside the informed ellipse if a path bound exists; choose a hashed-nearest parent; steer one step; validate node and edge; insert into the active tree. Try to connect to the opposite tree by direct line or a ghost (non-committal) short-step chain; if feasible, commit the chain, extract the bi-tree path, prune by visibility, shortcut, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        goal_bias=0.15,\n        informed_bias=0.5,\n        dupe_radius_ratio=0.35,\n        connect_radius_factor=3.0,\n        connect_steps=6,\n        smoothing_iters=60,\n        cell_factor=1.0\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.connect_radius_factor = float(connect_radius_factor)\n        self.connect_steps = int(connect_steps)\n        self.smoothing_iters = int(smoothing_iters)\n        self.cell_factor = float(cell_factor)\n        self._rng = 1234567\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_from_scene()\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Direct path early exit\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        self.cell_size = max(1.0, self.step_size * self.cell_factor)\n        self.dupe_radius = max(0.25, self.step_size * self.dupe_radius_ratio)\n        self.connect_radius = max(self.step_size, self.connect_radius_factor * self.step_size)\n\n        # Trees\n        nodes = []\n        edges = []\n\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        nodes.extend([root_a, root_b])\n        edges.extend([])\n\n        tree_a, tree_b = [root_a], [root_b]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, root_a)\n        self._grid_insert(grid_b, root_b)\n\n        best_len = float('inf')  # enables informed sampling when a bound appears\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            tree = tree_a if side_a else tree_b\n            other_tree = tree_b if side_a else tree_a\n            grid = grid_a if side_a else grid_b\n            other_grid = grid_b if side_a else grid_a\n            attractor = self.goal if side_a else self.start\n\n            s = self._sample(attractor, best_len)\n            if s is None:\n                continue\n\n            parent = self._nearest_hashed(grid, tree, s, 2)\n            if parent is None:\n                continue\n\n            new_pos = self._steer(parent.position, s)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n            if self._has_nearby(grid, new_pos, self.dupe_radius):\n                continue\n\n            new_node = Node(new_pos, parent, parent.cost + self._dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(grid, new_node)\n\n            # Try to connect directly to nearest in the opposite tree\n            near_other = self._nearest_hashed(other_grid, other_tree, new_node.position, 2)\n            if near_other is not None:\n                if self._dist(near_other.position, new_node.position) <= self.connect_radius and self._edge_free(near_other.position, new_node.position):\n                    path = self._extract_path(new_node, near_other, side_a)\n                    path = self._finalize_path(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n                # Ghost-connect: plan a short chain without committing, commit only if bridging succeeds\n                ok, chain_positions, last_pos = self._ghost_connect_positions(near_other.position, new_node.position, other_grid)\n                if ok and self._edge_free(last_pos, new_node.position):\n                    # Commit chain into the opposite tree\n                    prev = near_other\n                    for p in chain_positions:\n                        if self._has_nearby(other_grid, p, self.dupe_radius):\n                            prev = self._nearest_hashed(other_grid, other_tree, p, 1)\n                            if prev is None:\n                                prev = near_other\n                            continue\n                        if self._point_in_obstacles(p):\n                            ok = False\n                            break\n                        if not self._edge_free(prev.position, p):\n                            ok = False\n                            break\n                        q = Node(p, prev, prev.cost + self._dist(prev.position, p))\n                        prev.add_child(q)\n                        other_tree.append(q)\n                        nodes.append(q)\n                        edges.append((prev, q))\n                        self._grid_insert(other_grid, q)\n                        prev = q\n                    if ok and self._edge_free(prev.position, new_node.position):\n                        # We do not add a cross-tree edge; extract bi-tree path\n                        path = self._extract_path(new_node, prev, side_a)\n                        L = self._path_len(path)\n                        if L < best_len:\n                            best_len = L\n                        path = self._finalize_path(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1103515245 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 1) * 2654435761\n        if s == 0:\n            s = 1234567\n        self._rng = s & 0x7fffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0x7fffffff\n        return self._rng / float(1 << 31)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= self.step_size:\n            return tuple(b)\n        r = self.step_size / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n\n    # Obstacles\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            px, py, pz = p\n            for o in self.obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            px, py = p\n            for o in self.obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            for o in self.obstacles:\n                x, y, z, w, h, d = o\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            for o in self.obstacles:\n                x, y, w, h = o\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Spatial hashing\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, tree, pos, max_rings):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        any_found = False\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n                    any_found = True\n        if any_found:\n            return best\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n            if p and self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        if r < self.goal_bias:\n            p = attractor\n        else:\n            p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n        if self._in_bounds(p) and not self._point_in_obstacles(p):\n            return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [half] * self.dim\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dim))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # Ghost connect (non-committal)\n    def _ghost_connect_positions(self, from_pos, to_pos, other_grid):\n        chain = []\n        cur = from_pos\n        steps = 0\n        while steps < self.connect_steps:\n            nxt = self._steer(cur, to_pos)\n            if not self._in_bounds(nxt):\n                return False, None, None\n            if self._point_in_obstacles(nxt):\n                return False, None, None\n            if not self._edge_free(cur, nxt):\n                return False, None, None\n            if self._has_nearby(other_grid, nxt, self.dupe_radius):\n                return False, None, None\n            chain.append(nxt)\n            cur = nxt\n            if self._dist(cur, to_pos) <= self.step_size or self._edge_free(cur, to_pos):\n                return True, chain, cur\n            steps += 1\n        return False, None, None\n\n    # Paths and smoothing\n    def _path_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        return out[::-1]\n\n    def _extract_path(self, a_node, b_node, a_forward=True):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return (pa + pb[::-1]) if a_forward else (pb + pa[::-1])\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(pruned[-1], path[j]):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best_L = self._path_len(pts)\n        for _ in range(self.smoothing_iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                continue\n            a, b = pts[i], pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= best_L + 1e-12:\n                    pts = new_pts\n                    best_L = L\n        return pts\n\n    def _finalize_path(self, path):\n        if not path:\n            return []\n        p = self._visibility_prune(path)\n        p = self._shortcut(p)\n        return p",
          "objective": -40.79252,
          "time_improvement": 68.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 2580.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007870960235595702,
                    "num_nodes_avg": 48.0,
                    "path_length_avg": 179.5861954290845,
                    "smoothness_avg": 0.06548709066523807,
                    "success_improvement": 0.0,
                    "time_improvement": 68.09668444484818,
                    "node_improvement": 87.91236464366659,
                    "length_improvement": 1.565960559945877,
                    "smoothness_improvement": 925.0151764044653,
                    "objective_score": 25.993657551444304
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0211273193359375,
                    "num_nodes_avg": 158.0,
                    "path_length_avg": 237.3530114017347,
                    "smoothness_avg": 0.18862965381071545,
                    "success_improvement": 0.0,
                    "time_improvement": 87.36794088130645,
                    "node_improvement": 89.38386078075656,
                    "length_improvement": 20.764732966468724,
                    "smoothness_improvement": 4753.576856997666,
                    "objective_score": 62.437106329261496
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026227736473083497,
                    "num_nodes_avg": 250.0,
                    "path_length_avg": 127.39626037258856,
                    "smoothness_avg": 0.16982997215257256,
                    "success_improvement": 0.0,
                    "time_improvement": 48.039932985286335,
                    "node_improvement": 68.21360457724094,
                    "length_improvement": 15.389469818547017,
                    "smoothness_improvement": 2060.2247102361403,
                    "objective_score": 33.94678533789481
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "AURORA-BiRRT*: Adaptive Unified Rewire-Optimized Receding-Envelope BiRRT with Curvature-Aware Smoothing. It grows two trees with adaptive step sizing in clutter, dynamic-radius best-parent selection, bounded rewiring, and multi-step micro-bridging. Sampling blends goal, corridor, and informed prolate-ellipse regions using an incumbent path. A voxelized obstacle index accelerates exact slab-based segment-AABB checks. On connection, visibility compression, probabilistic shortcuts, and an angle-aware elastic smoother produce shorter, smoother paths quickly and robustly.",
          "planning_mechanism": "Alternate expanding start/goal trees. Each iteration: biased target sampling (goal/corridor/informed/uniform), ring-hash nearest, adaptive steer with local clutter feedback, and strict node+edge collision checks. Select a least-cost parent from radius-limited neighbors, insert, then leap to a visible ancestor and rewire a few cheaper neighbors. Attempt direct or multi-step micro-bridge to the opposite tree. Maintain an incumbent best length to focus informed sampling. On success, assemble and postprocess the path (visibility prune, bounded shortcuts, curvature-aware elastic smoothing) and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        pts = []\n        cur = self\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=7.0,\n        goal_bias=0.2,\n        corridor_bias=0.4,\n        informed_bias=0.5,\n        grid_cell_factor=1.25,\n        dupe_radius_factor=0.35,\n        connect_factor=2.75,\n        rewire_radius_mult=2.0,\n        neighbor_cap=48,\n        bridge_trials=2,\n        rewire_cap=8,\n        shortcut_trials=120,\n        smooth_iters=18\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dupe_radius_factor = float(dupe_radius_factor)\n        self.connect_factor = float(connect_factor)\n        self.rewire_radius_mult = float(rewire_radius_mult)\n        self.neighbor_cap = int(neighbor_cap)\n        self.bridge_trials = int(max(0, bridge_trials))\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.shortcut_trials = int(max(0, shortcut_trials))\n        self.smooth_iters = int(max(0, smooth_iters))\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if getattr(map, \"obstacles\", None) else []\n\n        # Validate endpoints\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_rng()\n        self._build_obs_index()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if self._segment_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Derived params\n        self.cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_r = max(0.5, self.step_size * self.dupe_radius_factor)\n        self.connect_dist = max(self.step_size, self.connect_factor * self.step_size)\n        self.corridor_w = max(self.step_size, 0.2 * self._dist(self.start, self.goal))\n\n        # Trees and grids\n        nodes = []\n        edges = []\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_put(Ga, a_root)\n        self._grid_put(Gb, b_root)\n\n        best_len = float('inf')\n        best_path = None\n\n        for it in range(self.max_iter):\n            grow_a = (it % 2 == 0)\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            attractor = self.goal if grow_a else self.start\n\n            target = self._sample_target(attractor, best_len)\n            if target is None:\n                continue\n\n            near = self._nearest(G, target, T)\n            if near is None:\n                continue\n\n            new_pos = self._steer_adaptive(near.position, target)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._point_blocked(new_pos):\n                continue\n            if self._has_duplicate(G, new_pos, self.dupe_r):\n                continue\n\n            parent, new_cost = self._choose_parent(G, T, new_pos)\n            if parent is None:\n                continue\n            if self._point_blocked(new_pos) or not self._segment_free(parent.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            T.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_put(G, new_node)\n\n            # Ancestor visibility leap\n            self._ancestor_leap(new_node, edges)\n\n            # Local bounded rewiring\n            self._rewire_local(G, new_node, edges)\n\n            # Try to connect to the opposite tree\n            other = self._nearest(Gopp, new_node.position, Topp)\n            connected = False\n            end_node = None\n            if other is not None:\n                if self._dist(new_node.position, other.position) <= self.connect_dist and self._segment_free(new_node.position, other.position):\n                    connected = True\n                    end_node = other\n                else:\n                    # Micro-bridge steps from the opposite tree\n                    head = other\n                    for _ in range(self.bridge_trials):\n                        step_p = self._steer_adaptive(head.position, new_node.position)\n                        if not self._in_bounds(step_p) or self._point_blocked(step_p):\n                            break\n                        if self._has_duplicate(Gopp, step_p, self.dupe_r):\n                            break\n                        if not self._segment_free(head.position, step_p):\n                            break\n                        q = Node(step_p, head, head.cost + self._dist(head.position, step_p))\n                        head.add_child(q)\n                        Topp.append(q)\n                        nodes.append(q)\n                        edges.append((head, q))\n                        self._grid_put(Gopp, q)\n                        self._ancestor_leap(q, edges)\n                        self._rewire_local(Gopp, q, edges)\n                        head = q\n                        if self._segment_free(new_node.position, head.position):\n                            connected = True\n                            end_node = head\n                            break\n\n            if connected and end_node is not None:\n                path = self._assemble(new_node, end_node, grow_a)\n                path = self._postprocess(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Maintain incumbent for informed sampling\n            if other is not None and self._segment_free(new_node.position, other.position):\n                tmp = self._assemble(new_node, other, grow_a)\n                L = self._path_len(tmp)\n                if L < best_len:\n                    best_len = L\n                    best_path = tmp\n\n        if best_path is not None:\n            best_path = self._postprocess(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            s = (s * 2654435761 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 13) * 1103515245\n        self._rng = s if s != 0 else 2463534242\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry and bounds\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer_adaptive(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        # Base step\n        step = self.step_size if d > self.step_size else d\n        # Estimate local clutter by obstacle index buckets overlapped by tentative step box\n        dirv = tuple((b[i] - a[i]) / d for i in range(self.dims))\n        trial = tuple(a[i] + dirv[i] * step for i in range(self.dims))\n        clutter = self._box_bucket_density(a, trial)\n        if clutter > 10 and step > 0.5 * self.step_size:\n            step *= 0.6\n            trial = tuple(a[i] + dirv[i] * step for i in range(self.dims))\n            clutter = self._box_bucket_density(a, trial)\n            if clutter > 14 and step > 0.3 * self.step_size:\n                step *= 0.6\n                trial = tuple(a[i] + dirv[i] * step for i in range(self.dims))\n        return self._clamp(trial)\n\n    # Sampling\n    def _sample_target(self, attractor, best_len):\n        for _ in range(16):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._sample_informed(best_len * 1.02)\n                if p is not None and not self._point_blocked(p):\n                    return p\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attractor\n            elif r < self.goal_bias + self.corridor_bias:\n                t = self._rand()\n                base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n                if self.dims == 3:\n                    p = (self._rand_range(base[0] - self.corridor_w, base[0] + self.corridor_w),\n                         self._rand_range(base[1] - self.corridor_w, base[1] + self.corridor_w),\n                         self._rand_range(base[2] - self.corridor_w, base[2] + self.corridor_w))\n                else:\n                    p = (self._rand_range(base[0] - self.corridor_w, base[0] + self.corridor_w),\n                         self._rand_range(base[1] - self.corridor_w, base[1] + self.corridor_w))\n            else:\n                if self.dims == 3:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n            p = self._clamp(p)\n            if not self._point_blocked(p):\n                return p\n        return None\n\n    def _sample_informed(self, max_sum):\n        c = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        # Axis-aligned rejection in prolate envelope\n        for _ in range(24):\n            if self.dims == 3:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half),\n                     self._rand_range(c[2] - half, c[2] + half))\n            else:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half))\n            if self._in_bounds(p) and (self._dist(p, self.start) + self._dist(p, self.goal)) <= max_sum:\n                return p\n        return None\n\n    # Node grid\n    def _cell_of(self, pos):\n        return tuple(int(pos[i] // self.cell) for i in range(self.dims))\n\n    def _grid_put(self, grid, node):\n        k = self._cell_of(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _ring_nodes(self, grid, key, r):\n        out = []\n        if self.dims == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos, tree):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        for r in range(0, 4):\n            cand = self._ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback limited scan\n        if not tree:\n            return None\n        step = max(1, len(tree) // 64)\n        for i in range(0, len(tree), step):\n            n = tree[i]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, cap):\n        key = self._cell_of(pos)\n        r = max(1, int(radius // self.cell) + 1)\n        cand = self._ring_nodes(grid, key, r)\n        out = []\n        rr = radius * radius\n        for n in cand:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= rr:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _has_duplicate(self, grid, pos, radius):\n        return len(self._neighbors(grid, pos, radius, self.neighbor_cap)) > 0\n\n    # Parent selection and optimization\n    def _choose_parent(self, grid, tree, new_pos):\n        n = max(1, len(tree))\n        # RRT* radius ~ (log(n)/n)^{1/d} scaled\n        base = (self.rewire_radius_mult * self.step_size)\n        dyn_r = max(self.step_size, base * ((1.0 + self._log1p(n)) / n) ** (1.0 / max(1, self.dims)))\n        neigh = self._neighbors(grid, new_pos, dyn_r, self.neighbor_cap)\n        if not neigh:\n            # fallback to nearest in tree\n            near = None\n            bestd = 1e100\n            for m in tree:\n                d = self._dist(m.position, new_pos)\n                if d < bestd:\n                    bestd = d\n                    near = m\n            neigh = [near] if near is not None else []\n        best_p = None\n        best_c = 1e100\n        for p in neigh:\n            d = self._dist(p.position, new_pos)\n            gc = p.cost + d\n            if gc + 1e-9 < best_c and self._segment_free(p.position, new_pos):\n                best_c = gc\n                best_p = p\n        if best_p is None:\n            return None, None\n        return best_p, best_c\n\n    def _log1p(self, x):\n        # simple series for small x; adequate for our integer n\n        return 0.5 if x <= 1.0 else self._fast_log(x + 1.0)\n\n    def _fast_log(self, x):\n        # crude monotonic approximation using change-of-base and piecewise\n        y = 0.0\n        t = x\n        while t > 2.718281828:\n            t *= 0.367879441  # divide by e\n            y += 1.0\n        # linear tail\n        return y + (t - 1.0) / 2.718281828\n\n    def _ancestor_leap(self, node, edges):\n        curp = node.parent\n        if curp is None:\n            return\n        bestp = curp\n        bestc = node.cost\n        anc = curp.parent\n        while anc is not None:\n            if self._segment_free(anc.position, node.position):\n                c = anc.cost + self._dist(anc.position, node.position)\n                if c + 1e-9 < bestc:\n                    bestc = c\n                    bestp = anc\n            anc = anc.parent\n        if bestp is not curp:\n            self._reparent(node, bestp, edges)\n\n    def _rewire_local(self, grid, node, edges):\n        radius = max(self.step_size, self.rewire_radius_mult * self.step_size)\n        neigh = self._neighbors(grid, node.position, radius, self.neighbor_cap)\n        improvements = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if node.cost + d + 1e-9 < nb.cost and self._segment_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n                improvements += 1\n                if improvements >= self.rewire_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        if child.parent is new_parent:\n            return\n        if not self._segment_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._remove_edge(edges, old, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        # propagate cost to subtree\n        stack = [child]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if abs(newc - ch.cost) > 1e-12:\n                    ch.cost = newc\n                    stack.append(ch)\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is p and e[1] is c:\n                edges.pop(i)\n                return\n\n    # Obstacles and collision\n    def _build_obs_index(self):\n        # Cell size for obstacle spatial index\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.dims == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obs_grid.get(key)\n                            if b is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obs_grid.get(key)\n                        if b is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_blocked(self, p):\n        if self.dims == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _segment_free(self, a, b):\n        return not self._segment_hits(a, b)\n\n    def _box_bucket_density(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            s = 0\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obs_grid.get((i, j, k))\n                        if bkt:\n                            s += len(bkt)\n            return s\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            s = 0\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obs_grid.get((i, j))\n                    if bkt:\n                        s += len(bkt)\n            return s\n\n    def _segment_hits(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obs_grid.get((i, j, k))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit3d(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obs_grid.get((i, j))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit2d(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit2d(self, p0, p1, bmin, bmax):\n        # Slab method\n        t0, t1 = 0.0, 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _seg_box_hit3d(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Path assembly and postprocess\n    def _assemble(self, u, v, a_side):\n        pu = u.path_from_root()\n        pv = v.path_from_root()\n        if a_side:\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _postprocess(self, path):\n        if len(path) < 2:\n            return path[:]\n        p = self._visibility_prune(path)\n        p = self._shortcut(p, self.shortcut_trials)\n        p = self._elastic_angle_smooth(p, self.smooth_iters)\n        return p\n\n    def _visibility_prune(self, path):\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._segment_free(out[-1], path[j]):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i + 1])\n                i += 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = list(path)\n        best = self._path_len(pts)\n        n = len(pts)\n        fail = 0\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1:\n                fail += 1\n                if fail > 24:\n                    break\n                continue\n            a, b = pts[i], pts[j - 1]\n            if self._segment_free(a, b):\n                cand = pts[:i + 1] + pts[j - 1:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    pts = cand\n                    best = L\n                    n = len(pts)\n                    fail = 0\n                else:\n                    fail += 1\n            else:\n                fail += 1\n            if fail > 48:\n                break\n        return pts\n\n    def _elastic_angle_smooth(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return path[:]\n        pts = list(path)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                b = pts[i]\n                c = pts[i + 1]\n                # Angle-aware midpoint pull\n                mid = tuple(0.25 * a[k] + 0.5 * b[k] + 0.25 * c[k] for k in range(self.dims))\n                if self._point_blocked(mid):\n                    continue\n                if self._segment_free(a, mid) and self._segment_free(mid, c):\n                    if mid != b:\n                        pts[i] = mid\n                        moved = True\n                # Try skip if possible\n                if self._segment_free(a, c):\n                    pts[i] = c  # will be removed next pass by neighbors\n                    moved = True\n            # Compact duplicates\n            comp = [pts[0]]\n            for p in pts[1:]:\n                if p != comp[-1]:\n                    comp.append(p)\n            pts = comp\n            if not moved:\n                break\n            if len(pts) < 3:\n                break\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        return pts",
          "objective": -39.0221,
          "time_improvement": 68.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1312.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009383320808410645,
                    "num_nodes_avg": 51.0,
                    "path_length_avg": 148.31907804876715,
                    "smoothness_avg": 0.03583382190014427,
                    "success_improvement": 0.0,
                    "time_improvement": 61.966642474939334,
                    "node_improvement": 87.15688743389575,
                    "length_improvement": 18.703963055278603,
                    "smoothness_improvement": 460.8771271269766,
                    "objective_score": 32.11675621128384
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.043584227561950684,
                    "num_nodes_avg": 172.0,
                    "path_length_avg": 228.72791182641134,
                    "smoothness_avg": 0.08818936081319215,
                    "success_improvement": 0.0,
                    "time_improvement": 73.9409183696743,
                    "node_improvement": 88.44319021702614,
                    "length_improvement": 23.644039464437803,
                    "smoothness_improvement": 2169.175773952521,
                    "objective_score": 47.21457805932758
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01668705940246582,
                    "num_nodes_avg": 82.0,
                    "path_length_avg": 122.67227871244054,
                    "smoothness_avg": 0.1106371606216832,
                    "success_improvement": 0.0,
                    "time_improvement": 66.9410768359495,
                    "node_improvement": 89.57406230133503,
                    "length_improvement": 18.526913505383728,
                    "smoothness_improvement": 1307.2965167220898,
                    "objective_score": 37.73495373762554
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "FLASH-Connect: a fast, low-dispersion, edge-cached BiRRT-Connect with hash-grid nearest search, per-cell caps, and one-shot limited connection. It minimizes planning time by deterministic Halton sampling, bounded tree growth without rewiring, immediate bridge attempts, and lightweight post-shortcutting.",
          "planning_mechanism": "Alternate expansion from start and goal trees toward a Halton-guided target. Each step inserts only if both the node and edge are collision-free and not too close to existing nodes. After insertion, attempt a direct bridge to the opposite tree; if blocked, perform at most a couple of connect steps on the other tree, again validating both node and edge per step. An LRU-like edge-collision cache accelerates repeated checks. On success, return immediately after quick line-of-sight collapse and a few shortcut passes.",
          "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = tuple(position)\n        self.parent = parent\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=9.0,\n        goal_bias=0.2,\n        grid_cell_factor=1.25,\n        per_cell_cap=8,\n        dupe_radius_ratio=0.5,\n        connect_steps=2,\n        edge_cache_capacity=30000,\n        edge_cache_quant=1.0,\n        smoothing_iters=20\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.per_cell_cap = int(per_cell_cap)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.connect_steps = int(connect_steps)\n        self.edge_cache_capacity = int(edge_cache_capacity)\n        self.edge_cache_quant = float(edge_cache_quant)\n        self.smoothing_iters = int(smoothing_iters)\n        # internal states\n        self._rnd_state = 2463534242\n        self._hidx = 1\n\n    def plan(self, map):\n        # Scene setup\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # seed RNG deterministically from scene\n        self._seed_from_scene()\n\n        # build spatial indices\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self._build_obstacle_grid()\n\n        # quick endpoint checks\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # edge cache\n        self._tick = 0\n        self._ecache = {}\n        self._ecache_last_prune = 0\n\n        # early straight line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None)\n            n1 = Node(self.goal, n0)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # trees and grids\n        nodes = []\n        edges = []\n\n        root_a = Node(self.start, None)\n        root_b = Node(self.goal, None)\n        nodes.extend([root_a, root_b])\n\n        tree_a = [root_a]\n        tree_b = [root_b]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, root_a)\n        self._grid_insert(grid_b, root_b)\n\n        # main loop\n        for it in range(self.max_iter):\n            grow_from_a = (it % 2 == 0)\n            source_tree = tree_a if grow_from_a else tree_b\n            source_grid = grid_a if grow_from_a else grid_b\n            target_tree = tree_b if grow_from_a else tree_a\n            target_grid = grid_b if grow_from_a else grid_a\n            attractor = self.goal if grow_from_a else self.start\n\n            q_rand = self._sample(attractor)\n            if q_rand is None:\n                continue\n\n            near = self._nearest(source_grid, q_rand)\n            if near is None:\n                continue\n\n            q_new = self._steer_valid(near.position, q_rand)\n            if q_new is None:\n                continue\n            if self._has_nearby(source_grid, q_new, self.dupe_radius):\n                continue\n\n            # per-cell cap\n            ckey = self._cell_of(q_new)\n            bucket = source_grid.get(ckey)\n            if bucket and len(bucket) >= self.per_cell_cap:\n                continue\n\n            # Insertion (both node and edge already validated in _steer_valid)\n            new_node = Node(q_new, near)\n            source_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((near, new_node))\n            self._grid_insert(source_grid, new_node)\n\n            # Try to connect to opposite tree\n            other_near = self._nearest(target_grid, new_node.position)\n            if other_near is not None:\n                # direct bridge\n                if self._edge_free(new_node.position, other_near.position):\n                    path = self._assemble_path(new_node, other_near)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # limited connect steps\n                p = other_near\n                steps = 0\n                while steps < self.connect_steps:\n                    step_pos = self._steer_once(p.position, new_node.position)\n                    if step_pos is None:\n                        break\n                    if self._has_nearby(target_grid, step_pos, self.dupe_radius):\n                        break\n                    cell2 = self._cell_of(step_pos)\n                    buck2 = target_grid.get(cell2)\n                    if buck2 and len(buck2) >= self.per_cell_cap:\n                        break\n                    q2 = Node(step_pos, p)\n                    target_tree.append(q2)\n                    nodes.append(q2)\n                    edges.append((p, q2))\n                    self._grid_insert(target_grid, q2)\n                    if self._edge_free(new_node.position, q2.position):\n                        path = self._assemble_path(new_node, q2)\n                        path = self._postprocess(path)\n                        return PlannerResult(True, path, nodes, edges)\n                    p = q2\n                    steps += 1\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG and Halton\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= len(self.obstacles) * 2654435761\n        s ^= int(self.step_size * 1000) & 0xffffffff\n        self._rnd_state = (s ^ 0x9E3779B9) & 0xffffffff\n        if self._rnd_state == 0:\n            self._rnd_state = 2463534242\n        self._hidx = 1\n\n    def _rand(self):\n        self._rnd_state = (1664525 * self._rnd_state + 1013904223) & 0xffffffff\n        return self._rnd_state / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _vdc(self, n, base):\n        v = 0.0\n        denom = 1.0\n        while n > 0:\n            n, r = divmod(n, base)\n            denom *= base\n            v += r / denom\n        return v\n\n    def _halton_point(self, idx):\n        bases = (2, 3, 5)\n        if self.dims == 2:\n            x = self._vdc(idx, bases[0]) * self.bounds[0]\n            y = self._vdc(idx, bases[1]) * self.bounds[1]\n            return (x, y)\n        else:\n            x = self._vdc(idx, bases[0]) * self.bounds[0]\n            y = self._vdc(idx, bases[1]) * self.bounds[1]\n            z = self._vdc(idx, bases[2]) * self.bounds[2]\n            return (x, y, z)\n\n    # Sampling with goal bias and Halton fallback\n    def _sample(self, attractor):\n        for _ in range(24):\n            if self._rand() < self.goal_bias:\n                p = attractor\n            else:\n                # Halton with tiny jitter to avoid grid alignment with obstacles\n                p = self._halton_point(self._hidx)\n                self._hidx += 1\n                jitter = 0.001 * self.cell_size\n                if self.dims == 2:\n                    p = (min(max(p[0] + self._rand_range(-jitter, jitter), 0.0), self.bounds[0]),\n                         min(max(p[1] + self._rand_range(-jitter, jitter), 0.0), self.bounds[1]))\n                else:\n                    p = (min(max(p[0] + self._rand_range(-jitter, jitter), 0.0), self.bounds[0]),\n                         min(max(p[1] + self._rand_range(-jitter, jitter), 0.0), self.bounds[1]),\n                         min(max(p[2] + self._rand_range(-jitter, jitter), 0.0), self.bounds[2]))\n            if self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer_once(self, a, b):\n        # Try to step toward b by at most step_size\n        d = self._dist(a, b)\n        if d < 1e-12:\n            return None\n        r = min(1.0, self.step_size / d)\n        q = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n        if not self._within_bounds(q):\n            return None\n        if self._point_in_obstacles(q):\n            return None\n        if not self._edge_free(a, q):\n            return None\n        return q\n\n    def _steer_valid(self, a, b):\n        # Fast attempt: if target within 1.5*step and edge is free, go there; else single step\n        d = self._dist(a, b)\n        max_jump = 1.5 * self.step_size\n        if d <= max_jump:\n            q = b\n            # clamp to bounds\n            q = tuple(min(max(q[i], 0.0), self.bounds[i]) for i in range(self.dims))\n            if not self._point_in_obstacles(q) and self._edge_free(a, q):\n                return q\n        # try normal step\n        q = self._steer_once(a, b)\n        if q is not None:\n            return q\n        # last attempt: slightly shorter step to sneak around grazing edges\n        if d > 1e-9:\n            r = min(1.0, (0.6 * self.step_size) / d)\n            q2 = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n            if self._within_bounds(q2) and (not self._point_in_obstacles(q2)) and self._edge_free(a, q2):\n                return q2\n        return None\n\n    # Node grid utilities\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_of(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 4):\n            cand = self._grid_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback: scan grid buckets\n        for b in grid.values():\n            for n in b:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    # Obstacle grid\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 2.0)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            x0, y0, z0 = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= x0 <= x + w and y <= y0 <= y + h and z <= z0 <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            x0, y0 = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= x0 <= x + w and y <= y0 <= y + h:\n                    return True\n            return False\n\n    # Edge collision with cache\n    def _edge_key(self, a, b):\n        q = max(0.25, self.edge_cache_quant)\n        qa = tuple(int(a[i] / q) for i in range(self.dims))\n        qb = tuple(int(b[i] / q) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self._ecache.get(key)\n        if hit is not None:\n            # refresh LRU tick\n            self._tick += 1\n            self._ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self._ecache[key] = (free, self._tick)\n        if len(self._ecache) - self._ecache_last_prune > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self._ecache:\n            return\n        cutoff = self._tick - 4000\n        to_del = []\n        for k, v in self._ecache.items():\n            if v[1] < cutoff:\n                to_del.append(k)\n        if not to_del:\n            i = 0\n            for k in list(self._ecache.keys()):\n                if (i % 3) == 0:\n                    to_del.append(k)\n                i += 1\n        for k in to_del:\n            if k in self._ecache:\n                del self._ecache[k]\n        self._ecache_last_prune = len(self._ecache)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x0, y0, z0, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x0, y0, z0), (x0 + w, y0 + h, z0 + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x0, y0, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x0, y0), (x0 + w, y0 + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect(self, p0, p1, bmin, bmax):\n        # slab intersection for 2D/3D segment vs AABB\n        tmin = 0.0\n        tmax = 1.0\n        n = self.dims\n        for i in range(n):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Path assembly and postprocess\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _assemble_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return pa + pb[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _los_collapse(self, path):\n        if len(path) < 3:\n            return path[:]\n        out = [path[0]]\n        last = 0\n        k = 1\n        while k < len(path) - 1:\n            if self._edge_free(path[last], path[k + 1]):\n                k += 1\n                continue\n            out.append(path[k])\n            last = k\n            k += 1\n        out.append(path[-1])\n        return out\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best = self._path_len(pts)\n        n = len(pts)\n        iters = min(self.smoothing_iters, max(1, n - 2))\n        for t in range(iters):\n            i = (t % (n - 2))\n            j = min(n - 1, i + 2 + (t % max(1, (n - i - 1))))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= best + 1e-12:\n                    pts = new_pts\n                    best = L\n                    n = len(pts)\n        return pts\n\n    def _postprocess(self, path):\n        p = self._los_collapse(path)\n        p = self._shortcut(p)\n        return p",
          "objective": -38.51088,
          "time_improvement": 67.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1919.0,
          "node_improvement": 85.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01389298439025879,
                    "num_nodes_avg": 79.0,
                    "path_length_avg": 164.28407730787757,
                    "smoothness_avg": 0.04754812951617681,
                    "success_improvement": 0.0,
                    "time_improvement": 43.68765033257988,
                    "node_improvement": 80.10576680936792,
                    "length_improvement": 9.953293979757886,
                    "smoothness_improvement": 644.2314793440236,
                    "objective_score": 22.299428884348814
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.015888690948486328,
                    "num_nodes_avg": 96.0,
                    "path_length_avg": 256.1129773273841,
                    "smoothness_avg": 0.12192815124399099,
                    "success_improvement": 0.0,
                    "time_improvement": 90.5001254447587,
                    "node_improvement": 93.54968756299134,
                    "length_improvement": 14.502116364807549,
                    "smoothness_improvement": 3037.299152805466,
                    "objective_score": 51.03780321633946
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016379070281982423,
                    "num_nodes_avg": 140.0,
                    "path_length_avg": 121.59420940833631,
                    "smoothness_avg": 0.17113765919663135,
                    "success_improvement": 0.0,
                    "time_improvement": 67.55123758529757,
                    "node_improvement": 82.19961856325493,
                    "length_improvement": 19.24291580502608,
                    "smoothness_improvement": 2076.858392913151,
                    "objective_score": 42.195412723170676
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "BASIL-RRT: Bi-directional Adaptive Simplified Informed Lite with Rewire and Visibility. Two trees grow toward each other with simple grid-accelerated nearest search, duplicate suppression, best-parent selection, visibility jumps to higher ancestors, and light local rewiring. Guided sampling uses corridor and informed-ellipse biases to shorten routes. On connection, deterministic visibility compression, shortcutting, and elastic smoothing yield short, smooth paths efficiently.",
          "planning_mechanism": "Initialize bidirectional trees and spatial hashes. Repeat: sample a biased target (goal/corridor/informed/uniform), pick the nearest via grid, steer by a fixed step, and validate both node and edge. Choose the least-cost feasible parent from nearby nodes, insert, then visibility-jump to a visible ancestor and locally rewire cheaper neighbors. Probe the opposite tree for a direct or short bridge; if connected, assemble the path and postprocess with visibility compression, randomized shortcuts, and elastic smoothing. Maintain an incumbent best path for informed sampling.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=7.0,\n        goal_bias=0.15,\n        corridor_bias=0.45,\n        informed_bias=0.5,\n        cell_size_factor=1.2,\n        dupe_ratio=0.3,\n        connect_dist_factor=2.5,\n        rewire_mult=2.5,\n        neighbor_cap=32,\n        shortcuts=120,\n        elastic_iters=10\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.cell_size_factor = float(cell_size_factor)\n        self.dupe_ratio = float(dupe_ratio)\n        self.connect_dist_factor = float(connect_dist_factor)\n        self.rewire_mult = float(rewire_mult)\n        self.neighbor_cap = int(neighbor_cap)\n        self.shortcuts = int(max(0, shortcuts))\n        self.elastic_iters = int(max(0, elastic_iters))\n        self._rnd = 2463534242\n\n    # Public entry\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if getattr(map, \"obstacles\", None) else []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        self._seed_from_scene()\n        self._build_obstacle_grid()\n\n        # Endpoint validity\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Parameters\n        self.cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_ratio)\n        self.connect_dist = max(self.step_size, self.connect_dist_factor * self.step_size)\n        corridor_w = max(self.step_size, 0.2 * self._dist(self.start, self.goal))\n\n        # Trees and grids\n        nodes = []\n        edges = []\n\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_insert(Ga, a_root)\n        self._grid_insert(Gb, b_root)\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            T = Ta if side_a else Tb\n            G = Ga if side_a else Gb\n            T_opp = Tb if side_a else Ta\n            G_opp = Gb if side_a else Ga\n            attractor = self.goal if side_a else self.start\n\n            # Target sampling\n            target = self._sample_target(attractor, best_len, corridor_w)\n            if target is None:\n                continue\n\n            # Nearest and steer\n            near = self._nearest_grid(G, target)\n            if near is None:\n                continue\n            new_pos = self._steer(near.position, target)\n            if not self._within_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if self._has_nearby(G, new_pos, self.dupe_radius):\n                continue\n\n            # Best-parent selection with local neighbors\n            parent, new_cost = self._choose_parent(T, G, new_pos)\n            if parent is None:\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            # Insert node\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            T.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(G, new_node)\n\n            # Visibility jump to a cheaper visible ancestor\n            self._visibility_jump(new_node, edges)\n\n            # Local rewiring (length/cost reduction)\n            self._rewire_neighbors(G, new_node, edges)\n\n            # Try connect to opposite tree\n            other_near = self._nearest_grid(G_opp, new_node.position)\n            if other_near is not None:\n                dno = self._dist(new_node.position, other_near.position)\n                if dno <= self.connect_dist and self._edge_free(new_node.position, other_near.position):\n                    path = self._assemble_path(new_node, other_near, side_a)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # One-step probe from opposite tree\n                step_p = self._steer(other_near.position, new_node.position)\n                if self._within_bounds(step_p) and not self._point_in_obstacles(step_p):\n                    if not self._has_nearby(G_opp, step_p, self.dupe_radius):\n                        if self._edge_free(other_near.position, step_p):\n                            q = Node(step_p, other_near, other_near.cost + self._dist(other_near.position, step_p))\n                            other_near.add_child(q)\n                            T_opp.append(q)\n                            nodes.append(q)\n                            edges.append((other_near, q))\n                            self._grid_insert(G_opp, q)\n                            self._visibility_jump(q, edges)\n                            self._rewire_neighbors(G_opp, q, edges)\n                            if self._edge_free(new_node.position, q.position):\n                                path = self._assemble_path(new_node, q, side_a)\n                                path = self._postprocess(path)\n                                return PlannerResult(True, path, nodes, edges)\n\n            # Maintain incumbent best for informed sampling\n            if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                tmp = self._assemble_path(new_node, other_near, side_a)\n                L = self._path_len(tmp)\n                if L < best_len:\n                    best_len = L\n                    best_path = tmp\n\n        if best_path is not None:\n            best_path = self._postprocess(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 1) * 2654435761\n        self._rnd = (s ^ 0x9E3779B9) & 0xffffffff\n        if self._rnd == 0:\n            self._rnd = 2463534242\n\n    def _rand(self):\n        self._rnd = (1664525 * self._rnd + 1013904223) & 0xffffffff\n        return self._rnd / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= self.step_size:\n            return self._clamp(b)\n        r = self.step_size / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Sampling\n    def _sample_target(self, attractor, best_len, corridor_w):\n        for _ in range(16):\n            if best_len < float('inf') and self._rand() < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p is not None and not self._point_in_obstacles(p):\n                    return p\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attractor\n            elif r < self.goal_bias + self.corridor_bias:\n                t = self._rand()\n                base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n                if self.dims == 3:\n                    p = (self._rand_range(base[0] - corridor_w, base[0] + corridor_w),\n                         self._rand_range(base[1] - corridor_w, base[1] + corridor_w),\n                         self._rand_range(base[2] - corridor_w, base[2] + corridor_w))\n                else:\n                    p = (self._rand_range(base[0] - corridor_w, base[0] + corridor_w),\n                         self._rand_range(base[1] - corridor_w, base[1] + corridor_w))\n            else:\n                p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            p = self._clamp(p)\n            if not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if self._within_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Node spatial grid\n    def _cell_of(self, pos, cell=None):\n        cs = self.cell_size if cell is None else cell\n        if self.dims == 3:\n            return (int(pos[0] // cs), int(pos[1] // cs), int(pos[2] // cs))\n        return (int(pos[0] // cs), int(pos[1] // cs))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _nearest_grid(self, grid, pos):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        # Expand rings up to 3\n        for r in range(0, 4):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback: scan all buckets\n        for b in grid.values():\n            for n in b:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.dims == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _neighbors_within_radius(self, grid, pos, radius, cap):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        out = []\n        rr = radius * radius\n        for n in cand:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= rr:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _has_nearby(self, grid, pos, radius):\n        neigh = self._neighbors_within_radius(grid, pos, radius, self.neighbor_cap)\n        return len(neigh) > 0\n\n    # Parent selection and optimization\n    def _choose_parent(self, tree, grid, new_pos):\n        n = len(tree)\n        # Dynamic radius ~ n^{-1/d}\n        dyn_r = max(self.step_size, self.rewire_mult * self.step_size * (1.0 / (1.0 + n)) ** (1.0 / max(1, self.dims)))\n        neigh = self._neighbors_within_radius(grid, new_pos, dyn_r, self.neighbor_cap)\n        if not neigh:\n            near = None\n            bestd = 1e100\n            for m in tree:\n                d = self._dist(m.position, new_pos)\n                if d < bestd:\n                    bestd = d\n                    near = m\n            neigh = [near] if near is not None else []\n        best_parent = None\n        best_cost = 1e100\n        for p in neigh:\n            d = self._dist(p.position, new_pos)\n            if d > dyn_r + 1e-9:\n                continue\n            if not self._edge_free(p.position, new_pos):\n                continue\n            gc = p.cost + d\n            if gc < best_cost:\n                best_cost = gc\n                best_parent = p\n        if best_parent is None:\n            return None, None\n        return best_parent, best_cost\n\n    def _visibility_jump(self, node, edges):\n        cur_parent = node.parent\n        if cur_parent is None:\n            return\n        best_parent = cur_parent\n        best_cost = node.cost\n        anc = cur_parent.parent\n        while anc is not None:\n            if self._edge_free(anc.position, node.position):\n                c = anc.cost + self._dist(anc.position, node.position)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best_parent = anc\n            anc = anc.parent\n        if best_parent is not cur_parent:\n            self._reparent(node, best_parent, edges)\n\n    def _rewire_neighbors(self, grid, node, edges):\n        # Use same dynamic radius as parent selection from this node's tree size (approx via node.cost order not needed)\n        radius = max(self.step_size, self.rewire_mult * self.step_size * 0.9)\n        neigh = self._neighbors_within_radius(grid, node.position, radius, self.neighbor_cap)\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if node.cost + d + 1e-9 < nb.cost and self._edge_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        if child.parent is new_parent:\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old_parent = child.parent\n        if old_parent is not None:\n            old_parent.remove_child(child)\n            self._edges_remove(edges, old_parent, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        self._propagate_costs(child)\n\n    def _edges_remove(self, edges, parent, child):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is parent and e[1] is child:\n                edges.pop(i)\n                break\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if abs(newc - ch.cost) > 1e-12:\n                    ch.cost = newc\n                    stack.append(ch)\n\n    # Obstacles\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.dims == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.dims == 3:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Path assembly and post-process\n    def _assemble_path(self, u, v, side_a):\n        # u in current tree, v in opposite\n        pu = u.path_from_root()\n        pv = v.path_from_root()\n        if side_a:\n            # start -> u then v -> goal\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _postprocess(self, path):\n        if len(path) < 2:\n            return path[:]\n        p = self._visibility_compress(path)\n        p = self._shortcut(p, self.shortcuts)\n        p = self._elastic(p, self.elastic_iters)\n        return p\n\n    def _visibility_compress(self, path):\n        out = [path[0]]\n        anchor = path[0]\n        i = 1\n        while i < len(path):\n            far = i\n            j = i\n            while j < len(path):\n                if self._edge_free(anchor, path[j]):\n                    far = j\n                    j += 1\n                else:\n                    break\n            out.append(path[far])\n            anchor = path[far]\n            i = far + 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = path[:]\n        best = self._path_len(pts)\n        n = len(pts)\n        noimp = 0\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j > n:\n                noimp += 1\n                if noimp > 16:\n                    break\n                continue\n            a, b = pts[i], pts[j - 1]\n            if self._edge_free(a, b):\n                candidate = pts[:i + 1] + pts[j - 1:]\n                L = self._path_len(candidate)\n                if L <= best + 1e-12:\n                    pts = candidate\n                    best = L\n                    n = len(pts)\n                    noimp = 0\n                else:\n                    noimp += 1\n            else:\n                noimp += 1\n            if noimp > 24:\n                break\n        return pts\n\n    def _elastic(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return path[:]\n        pts = list(path)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dims))\n                if self._point_in_obstacles(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if mid != pts[i]:\n                        pts[i] = mid\n                        moved = True\n            if not moved:\n                break\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        return pts",
          "objective": -37.60553,
          "time_improvement": 63.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1737.0,
          "node_improvement": 84.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01027677059173584,
                    "num_nodes_avg": 56.0,
                    "path_length_avg": 152.97087548687767,
                    "smoothness_avg": 0.05880624031240139,
                    "success_improvement": 0.0,
                    "time_improvement": 58.34522786771023,
                    "node_improvement": 85.89775875094435,
                    "length_improvement": 16.154239167002743,
                    "smoothness_improvement": 820.4453606838263,
                    "objective_score": 31.298338663933844
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.048004674911499026,
                    "num_nodes_avg": 233.0,
                    "path_length_avg": 260.1076340388263,
                    "smoothness_avg": 0.1240816945243068,
                    "success_improvement": 0.0,
                    "time_improvement": 71.29792559985403,
                    "node_improvement": 84.34455418934354,
                    "length_improvement": 13.168584974709937,
                    "smoothness_improvement": 3092.7113725425193,
                    "objective_score": 44.754085527494766
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021122431755065917,
                    "num_nodes_avg": 136.0,
                    "path_length_avg": 118.36585536678952,
                    "smoothness_avg": 0.1098386556019516,
                    "success_improvement": 0.0,
                    "time_improvement": 58.154110224750575,
                    "node_improvement": 82.70820089001907,
                    "length_improvement": 21.38703484172179,
                    "smoothness_improvement": 1297.1395918106139,
                    "objective_score": 36.764151931511314
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "ABLE-RRT: Adaptive Best-Parent Light Elastic Bidirectional RRT-Connect. Two grids grow start/goal trees with mixture-biased sampling. Each extension selects a locally optimal parent within one-step radius to reduce path cost, enforces strict node/edge collision checks, and performs greedy connect to the opposite tree. AABB-pruned edge checks accelerate collision tests. Upon connection, a light two-stage smoother (visibility compression + shortcutting + optional rubber-band) improves length and smoothness while keeping runtime low.",
          "planning_mechanism": "Initialize bidirectional trees and coarse grids. Each iteration: sample (goal/corridor/uniform), find a near node via grid, propose a one-step point, choose the best parent among nearby nodes that can reach it collision-free, then insert. Greedily connect the other tree toward the new node; if a short, collision-free bridge closes the gap, assemble the path and apply lightweight smoothing.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=7.0,\n        goal_bias=0.20,\n        corridor_bias=0.40,\n        cell_size_factor=2.0,\n        edge_resolution=1.0,\n        dupe_radius_ratio=0.40,\n        neighbor_radius_ratio=1.25,\n        smooth_shortcuts=80,\n        rubber_iters=6\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.cell_size_factor = float(cell_size_factor)\n        self.edge_resolution = float(edge_resolution)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.neighbor_radius_ratio = float(neighbor_radius_ratio)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self.rubber_iters = int(max(0, rubber_iters))\n\n    def plan(self, map):\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        obstacles = list(map.obstacles)\n\n        # Validate start/goal\n        if not self._within_bounds(start, bounds) or not self._within_bounds(goal, bounds):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight line\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_resolution):\n            n0 = Node(start, None, 0.0)\n            n1 = Node(goal, n0, self._distance(start, goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [start, goal], [n0, n1], [(n0, n1)])\n\n        # Init trees and grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n        cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        grid_start, grid_goal = {}, {}\n        self._grid_insert(grid_start, start_root.position, start_root, cell_size, dim)\n        self._grid_insert(grid_goal, goal_root.position, goal_root, cell_size, dim)\n\n        dsg = self._distance(start, goal)\n        corridor_w = max(self.step_size, 0.18 * dsg)\n        dupe_radius = max(0.5, self.dupe_radius_ratio * self.step_size)\n        neighbor_radius = max(self.step_size, self.neighbor_radius_ratio * self.step_size)\n\n        for it in range(self.max_iter):\n            # Alternate growth\n            if it % 2 == 0:\n                grow_tree, grow_grid, grow_root = start_tree, grid_start, start_root\n                other_tree, other_grid, other_root = goal_tree, grid_goal, goal_root\n                other_root_pos = goal\n                a_is_start_side = True\n            else:\n                grow_tree, grow_grid, grow_root = goal_tree, grid_goal, goal_root\n                other_tree, other_grid, other_root = start_tree, grid_start, start_root\n                other_root_pos = start\n                a_is_start_side = False\n\n            target = self._sample_target(bounds, obstacles, is_3d, start, goal, corridor_w, other_root_pos)\n            a_near = self._nearest_from_grid(grow_tree, grow_grid, target, cell_size, dim)\n\n            # Propose a one-step point\n            proposed = self._steer(a_near.position, target, self.step_size)\n            if not self._within_bounds(proposed, bounds):\n                continue\n            if self._is_in_obstacle(proposed, obstacles, is_3d):\n                continue\n            if self._exists_close(grow_grid, proposed, dupe_radius, cell_size, dim):\n                continue\n\n            # Choose best parent among neighbors that can reach proposed within one step\n            candidates = self._neighbors_within_radius(grow_grid, proposed, neighbor_radius, cell_size, dim)\n            if a_near not in candidates:\n                candidates.append(a_near)\n            best_parent = None\n            best_cost = float('inf')\n            for cand in candidates:\n                dcp = self._distance(cand.position, proposed)\n                if dcp > self.step_size + 1e-9:\n                    continue\n                if self._is_edge_in_obstacle(cand.position, proposed, obstacles, is_3d, self.edge_resolution):\n                    continue\n                cost = cand.cost + dcp\n                if cost < best_cost:\n                    best_cost = cost\n                    best_parent = cand\n            if best_parent is None:\n                continue\n\n            # Commit new node (both node and edge already validated)\n            new_node = Node(proposed, best_parent, best_cost)\n            best_parent.add_child(new_node)\n            grow_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            self._grid_insert(grow_grid, new_node.position, new_node, cell_size, dim)\n\n            # Greedy connect from the other tree toward new_node\n            b_near = self._nearest_from_grid(other_tree, other_grid, new_node.position, cell_size, dim)\n            b_last = self._greedy_extend(other_tree, other_grid, b_near, new_node.position,\n                                         nodes, edges, obstacles, is_3d, bounds, cell_size, dim)\n            if b_last is None:\n                continue\n\n            # Try final short bridge\n            if self._distance(b_last.position, new_node.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(b_last.position, new_node.position, obstacles, is_3d, self.edge_resolution):\n                    edges.append((b_last, new_node))\n                    # Assemble path\n                    if a_is_start_side:\n                        pa = new_node.path_from_root()\n                        pb = b_last.path_from_root()\n                        raw_path = pa + pb[::-1]\n                    else:\n                        pa = new_node.path_from_root()\n                        pb = b_last.path_from_root()\n                        raw_path = pb + pa[::-1]\n                    # Smooth\n                    path = self._compress_visibility(raw_path, obstacles, is_3d)\n                    path = self._shortcut_path(path, obstacles, is_3d, bounds, self.smooth_shortcuts)\n                    path = self._rubber_band(path, obstacles, is_3d, self.rubber_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---- Geometry utilities ----\n    def _distance(self, a, b):\n        s = 0.0\n        for i in range(len(a)):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p, bounds):\n        for i in range(len(bounds)):\n            if p[i] < 0.0 or p[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._distance(from_pos, to_pos)\n        if d <= step:\n            return tuple(to_pos[i] for i in range(len(to_pos)))\n        r = step / (d + 1e-12)\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    # ---- Sampling ----\n    def _sample_target(self, bounds, obstacles, is_3d, start, goal, corridor_w, other_root_pos):\n        import random  # Local import to avoid global requirement; acceptable inline\n        r = random.random()\n        if r < self.goal_bias:\n            return other_root_pos\n        elif r < self.goal_bias + self.corridor_bias:\n            t = random.random()\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(len(bounds)))\n            if len(bounds) == 3:\n                return (\n                    self._clamp(base[0] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[0]),\n                    self._clamp(base[1] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[1]),\n                    self._clamp(base[2] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[2]),\n                )\n            else:\n                return (\n                    self._clamp(base[0] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[0]),\n                    self._clamp(base[1] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[1]),\n                )\n        else:\n            # rejection sample in free space\n            for _ in range(32):\n                if len(bounds) == 3:\n                    p = (random.uniform(0.0, bounds[0]),\n                         random.uniform(0.0, bounds[1]),\n                         random.uniform(0.0, bounds[2]))\n                else:\n                    p = (random.uniform(0.0, bounds[0]),\n                         random.uniform(0.0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback (may be occupied; extension will reject)\n            if len(bounds) == 3:\n                return (random.uniform(0.0, bounds[0]),\n                        random.uniform(0.0, bounds[1]),\n                        random.uniform(0.0, bounds[2]))\n            else:\n                return (random.uniform(0.0, bounds[0]),\n                        random.uniform(0.0, bounds[1]))\n\n    def _clamp(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # ---- Collision utilities ----\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for x, y, z, w, h, d in obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for x, y, w, h in obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _seg_aabb_overlap(self, a, b, obs, is_3d):\n        if is_3d:\n            x, y, z, w, h, d = obs\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            if maxx < x or minx > x + w or maxy < y or miny > y + h or maxz < z or minz > z + d:\n                return False\n            return True\n        else:\n            x, y, w, h = obs\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            if maxx < x or minx > x + w or maxy < y or miny > y + h:\n                return False\n            return True\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._distance(a, b)\n        steps = int(max(1, d / max(1e-9, resolution)))\n        # Pre-filter obstacles by segment AABB overlap\n        relevant = []\n        for obs in obstacles:\n            if self._seg_aabb_overlap(a, b, obs, is_3d):\n                relevant.append(obs)\n        if not relevant:\n            return False\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(len(a)))\n            if self._is_in_obstacle(p, relevant, is_3d):\n                return True\n        return False\n\n    # ---- Grid NN and neighborhood ----\n    def _cell_index(self, pos, cell_size, dim):\n        if dim == 2:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size))\n        else:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size), int(pos[2] // cell_size))\n\n    def _grid_insert(self, grid, pos, node, cell_size, dim):\n        idx = self._cell_index(pos, cell_size, dim)\n        bucket = grid.get(idx)\n        if bucket is None:\n            grid[idx] = [node]\n        else:\n            bucket.append(node)\n\n    def _nearest_from_grid(self, tree, grid, point, cell_size, dim, max_rings=3):\n        if len(tree) < 32:\n            best = None\n            bestd = float('inf')\n            for n in tree:\n                d = self._distance(n.position, point)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            return best\n        center = self._cell_index(point, cell_size, dim)\n        best = None\n        bestd = float('inf')\n        found = False\n        for r in range(0, max_rings + 1):\n            cand = []\n            if dim == 2:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        idx = (center[0] + dx, center[1] + dy)\n                        if idx in grid:\n                            cand.extend(grid[idx])\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            idx = (center[0] + dx, center[1] + dy, center[2] + dz)\n                            if idx in grid:\n                                cand.extend(grid[idx])\n            if cand:\n                for n in cand:\n                    d = self._distance(n.position, point)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                        found = True\n            if found:\n                break\n        if best is None:\n            # fallback linear\n            best = tree[0]\n            bestd = self._distance(best.position, point)\n            for n in tree:\n                d = self._distance(n.position, point)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors_within_radius(self, grid, point, radius, cell_size, dim):\n        cells = int(radius / max(1e-9, cell_size)) + 1\n        center = self._cell_index(point, cell_size, dim)\n        out = []\n        if dim == 2:\n            for dx in range(-cells, cells + 1):\n                for dy in range(-cells, cells + 1):\n                    idx = (center[0] + dx, center[1] + dy)\n                    if idx in grid:\n                        out.extend(grid[idx])\n        else:\n            for dx in range(-cells, cells + 1):\n                for dy in range(-cells, cells + 1):\n                    for dz in range(-cells, cells + 1):\n                        idx = (center[0] + dx, center[1] + dy, center[2] + dz)\n                        if idx in grid:\n                            out.extend(grid[idx])\n        # filter by true distance\n        rr = radius * radius\n        fil = []\n        for n in out:\n            s = 0.0\n            p = n.position\n            for i in range(dim):\n                d = p[i] - point[i]\n                s += d * d\n            if s <= rr:\n                fil.append(n)\n        return fil\n\n    def _exists_close(self, grid, pos, radius, cell_size, dim):\n        neigh = self._neighbors_within_radius(grid, pos, radius, cell_size, dim)\n        return len(neigh) > 0\n\n    # ---- Extend/connect ----\n    def _greedy_extend(self, tree, grid, from_node, target_pos, nodes, edges, obstacles, is_3d, bounds, cell_size, dim):\n        current = from_node\n        last_new = None\n        while True:\n            step_pos = self._steer(current.position, target_pos, self.step_size)\n            if not self._within_bounds(step_pos, bounds):\n                break\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                break\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d, self.edge_resolution):\n                break\n            new_node = Node(step_pos, current, current.cost + self._distance(current.position, step_pos))\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node.position, new_node, cell_size, dim)\n            last_new = new_node\n            current = new_node\n            if self._distance(current.position, target_pos) <= self.step_size:\n                break\n        return last_new\n\n    # ---- Smoothing ----\n    def _compress_visibility(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        last = path[0]\n        i = 1\n        while i < len(path):\n            far = i\n            j = i\n            while j < len(path):\n                if self._is_edge_in_obstacle(last, path[j], obstacles, is_3d, self.edge_resolution):\n                    break\n                far = j\n                j += 1\n            out.append(path[far])\n            last = path[far]\n            i = far + 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds, attempts):\n        if len(path) < 3:\n            return list(path)\n        import random\n        pts = list(path)\n        n = len(pts)\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_resolution):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts\n\n    def _rubber_band(self, path, obstacles, is_3d, iters):\n        if len(path) < 3 or iters <= 0:\n            return list(path)\n        pts = list(path)\n        for _ in range(iters):\n            changed = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(len(a)))\n                if self._is_in_obstacle(mid, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(a, mid, obstacles, is_3d, self.edge_resolution):\n                    continue\n                if self._is_edge_in_obstacle(mid, c, obstacles, is_3d, self.edge_resolution):\n                    continue\n                if mid != pts[i]:\n                    pts[i] = mid\n                    changed = True\n            if not changed:\n                break\n        return pts",
          "objective": -37.59775,
          "time_improvement": 66.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1905.0,
          "node_improvement": 85.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009185576438903808,
                    "num_nodes_avg": 64.4,
                    "path_length_avg": 170.56202690395023,
                    "smoothness_avg": 0.04785735504538155,
                    "success_improvement": 0.0,
                    "time_improvement": 62.768158532802346,
                    "node_improvement": 83.782422563586,
                    "length_improvement": 6.512250325673065,
                    "smoothness_improvement": 649.0715303700621,
                    "objective_score": 25.983155407094852
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027295637130737304,
                    "num_nodes_avg": 154.6,
                    "path_length_avg": 240.5028644826979,
                    "smoothness_avg": 0.12901280114279629,
                    "success_improvement": 0.0,
                    "time_improvement": 83.67989348599582,
                    "node_improvement": 89.61230934623397,
                    "length_improvement": 19.713221344549247,
                    "smoothness_improvement": 3219.5922975687886,
                    "objective_score": 53.02986234037223
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02437562942504883,
                    "num_nodes_avg": 141.5,
                    "path_length_avg": 127.88160399822759,
                    "smoothness_avg": 0.15294445433893913,
                    "success_improvement": 0.0,
                    "time_improvement": 51.70916332215004,
                    "node_improvement": 82.00890019071836,
                    "length_improvement": 15.067127691977475,
                    "smoothness_improvement": 1845.4421700060007,
                    "objective_score": 33.7802364618615
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "AERO-Connect-R*: Adaptive Elliptic Rewired Connect BiRRT with Hash-Grids. It couples bidirectional RRT-Connect growth (greedy multi-step connect) with lightweight RRT* local optimization (best-parent selection and bounded rewiring), uses adaptive informed sampling (goal/corridor \u2192 ellipse after first incumbent), and fast slab-based collision via obstacle bins. A two-stage path refiner (visibility + shortcut + corner-round) improves length and smoothness at negligible cost.",
          "planning_mechanism": "Mechanism: Alternate expanding start/goal trees. Each iteration: draw a guided sample (goal/corridor/uniform; switch to ellipse once a path is known), pick an anchor via multi-ring hash-grid nearest, steer one step, validate node/edge, choose cheapest parent among nearby anchors, insert and locally rewire. Then greedily connect the opposite tree toward the new node with multiple validated steps; on meeting, extract the path and run refinements, then return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.25,\n                 corridor_bias=0.35,\n                 ellipse_bias=0.55,\n                 grid_cell_factor=1.7,\n                 neighbor_radius_factor=2.4,\n                 min_sep_ratio=0.4,\n                 k_parent=6,\n                 k_rewire=6,\n                 connect_mult=1.8,\n                 smoothing_attempts=120):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.ellipse_bias = float(ellipse_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neigh_factor = float(neighbor_radius_factor)\n        self.min_sep_ratio = float(min_sep_ratio)\n        self.k_parent = int(max(1, k_parent))\n        self.k_rewire = int(max(0, k_rewire))\n        self.connect_mult = float(connect_mult)\n        self.smoothing_attempts = int(max(0, smoothing_attempts))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self._is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Spatial parameters\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.neigh_radius = max(self.step * 1.2, self.step * self.neigh_factor)\n        self.min_sep = max(0.5, self.step * self.min_sep_ratio)\n        self.connect_step = max(self.step, self.step * self.connect_mult)\n\n        # Initialize RNG seed\n        self._seed()\n\n        # Build obstacle bins before any collision checks\n        self._build_obs_bins()\n\n        # Validate start/goal\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Trivial straight-line solution\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._smooth_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize two trees and their grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = self.goal if active_start else self.start\n\n            # Guided sampling with informed ellipse once best path exists\n            sp = self._guided_sample(root_other, best_len)\n            if sp is None:\n                continue\n\n            # Nearest anchor in active tree\n            anchor = self._nearest_grid(grid_a, sp)\n            if anchor is None:\n                anchor = tree_a[-1]\n\n            # Steer one step toward sample\n            newp = self._steer(anchor.position, sp, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(grid_a, newp, self.min_sep):\n                continue\n            if not self._edge_free(anchor.position, newp):\n                continue\n\n            # Best-parent selection (local RRT*)\n            neigh = self._neighbors(grid_a, newp, self.neigh_radius)\n            if not neigh:\n                neigh = [anchor]\n            # Sort few closest anchors\n            neigh = sorted(neigh, key=lambda n: self._dist2(n.position, newp))[:self.k_parent]\n            parent = anchor\n            bestc = anchor.cost + self._dist(anchor.position, newp)\n            for nb in neigh:\n                gc = nb.cost + self._dist(nb.position, newp)\n                if gc + 1e-12 < bestc and self._edge_free(nb.position, newp):\n                    parent = nb\n                    bestc = gc\n\n            # Final checks before adding node/edge\n            if self._point_in_obstacles(newp) or (not self._edge_free(parent.position, newp)):\n                continue\n\n            nn = Node(newp, parent, bestc)\n            parent.add_child(nn)\n            tree_a.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(grid_a, nn)\n\n            # Bounded local rewiring\n            if self.k_rewire > 0:\n                self._rewire_lite(nn, grid_a, edges)\n\n            # Greedy multi-step connect from the opposite tree toward nn\n            other_near = self._nearest_grid(grid_b, nn.position)\n            meet_b = other_near\n            connected = False\n            cur = other_near\n            if cur is not None:\n                while True:\n                    # If we are close and direct edge is free, consider connected\n                    if self._dist(cur.position, nn.position) <= self.connect_step and self._edge_free(cur.position, nn.position):\n                        connected = True\n                        meet_b = cur\n                        break\n                    # Otherwise extend the other tree by a connect step\n                    nxtp = self._steer(cur.position, nn.position, self.connect_step)\n                    if (not self._in_bounds(nxtp)) or self._point_in_obstacles(nxtp):\n                        break\n                    if not self._edge_free(cur.position, nxtp):\n                        break\n                    # Add the node to the opposite tree (both checks already passed)\n                    cn = Node(nxtp, cur, cur.cost + self._dist(cur.position, nxtp))\n                    cur.add_child(cn)\n                    tree_b.append(cn)\n                    nodes.append(cn)\n                    edges.append((cur, cn))\n                    self._grid_add(grid_b, cn)\n                    cur = cn\n                    meet_b = cur\n                    # Loop continues until blocked or within direct reach\n\n            if connected:\n                # Extract full path (do not insert a cross-edge to preserve tree structures)\n                path = self._extract_path(nn, meet_b)\n                L = self._path_len(path)\n                if best_len is None or L + 1e-9 < best_len:\n                    best_len = L\n                path = self._smooth_path(path)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- RNG ----------\n    def _seed(self):\n        s = 0x9E3779B97F4A7C15 & 0xffffffff\n        for v in self.start + self.goal:\n            zv = int(v * 1315423911) & 0xffffffff\n            s ^= ((zv ^ (zv << 13) ^ (zv >> 17)) & 0xffffffff)\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # ---------- Spatial hash for nodes ----------\n    def _cell_key(self, p):\n        if self._is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self._is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            cand.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        cand.extend(lst)\n        return cand\n\n    def _nearest_grid(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback scan\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self._is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors(grid, pos, radius)) > 0\n\n    # ---------- Obstacles: binning and collision ----------\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self._is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obin.get(key)\n                            if b is None:\n                                self.obin[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obin.get(key)\n                        if b is None:\n                            self.obin[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self._is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self._is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # ---------- Rewiring ----------\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _erase_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                del edges[i]\n                break\n\n    def _propagate_cost(self, node, delta):\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    def _rewire_lite(self, new_node, grid, edges):\n        neigh = self._neighbors(grid, new_node.position, self.neigh_radius)\n        if not neigh:\n            return\n        neigh = sorted(neigh, key=lambda n: self._dist2(n.position, new_node.position))[:self.k_rewire]\n        for nb in neigh:\n            if nb is new_node or nb is new_node.parent:\n                continue\n            if self._is_ancestor(nb, new_node):\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            cand = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand + 1e-9 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._erase_edge(edges, oldp, nb)\n                new_node.add_child(nb)\n                edges.append((new_node, nb))\n                delta = cand - nb.cost\n                nb.cost = cand\n                self._propagate_cost(nb, delta)\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, target_root, incumbent_len):\n        tries = 20\n        while tries > 0:\n            tries -= 1\n            r = self._rand()\n            if incumbent_len is not None and r < self.ellipse_bias:\n                p = self._sample_in_ellipse(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                r2 = self._rand()\n                if r2 < self.goal_bias:\n                    p = target_root\n                elif r2 < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_point()\n                else:\n                    if self._is3:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]),\n                             self._rand_range(0.0, self.bounds[2]))\n                    else:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _corridor_point(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step, 0.07 * sg)\n        if self._is3:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            oz = self._rand_range(-w, w)\n            return self._clamp((base[0] + ox, base[1] + oy, base[2] + oz))\n        else:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            return self._clamp((base[0] + ox, base[1] + oy))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(16):\n            if self._is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if not self._in_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # ---------- Paths and smoothing ----------\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, meet_a, meet_b):\n        # meet_a is in active tree; meet_b is in the opposite tree\n        path_a = self._trace_to_root(meet_a)\n        # path_b: from meet_b up to its root\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # Concatenate without adding a cross edge to preserve structures\n        return path_a + path_b\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _prune_collinear(self, pts, cos_eps=0.999):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        for i in range(1, len(pts) - 1):\n            a = out[-1]\n            b = pts[i]\n            c = pts[i + 1]\n            v1 = tuple(b[j] - a[j] for j in range(self.dim))\n            v2 = tuple(c[j] - b[j] for j in range(self.dim))\n            n1 = sum(v1[j] * v1[j] for j in range(self.dim)) ** 0.5\n            n2 = sum(v2[j] * v2[j] for j in range(self.dim)) ** 0.5\n            if n1 < 1e-9 or n2 < 1e-9:\n                continue\n            cosang = sum(v1[j] * v2[j] for j in range(self.dim)) / (n1 * n2)\n            if cosang < cos_eps:\n                out.append(b)\n        out.append(pts[-1])\n        return out\n\n    def _vis_collapse(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = pts[:]\n        i = 0\n        while i < len(out) - 2:\n            j = len(out) - 1\n            collapsed = False\n            while j > i + 1:\n                if self._edge_free(out[i], out[j]):\n                    del out[i + 1:j]\n                    collapsed = True\n                    break\n                j -= 1\n            if not collapsed:\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        stall = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 1, len(cur) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-9 <= bestL:\n                    cur = cand\n                    bestL = L\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            tries += 1\n            if stall > 24:\n                break\n        return cur\n\n    def _round_corners(self, pts, passes=2):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            i = 1\n            while i < len(cur) - 1:\n                a = cur[i - 1]\n                c = cur[i + 1]\n                # propose midpoint between a and c\n                mid = tuple(0.5 * (a[j] + c[j]) for j in range(self.dim))\n                if self._in_bounds(mid) and (not self._point_in_obstacles(mid)):\n                    if self._edge_free(a, mid) and self._edge_free(mid, c):\n                        cur[i] = mid\n                i += 1\n        return cur\n\n    def _smooth_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._prune_collinear(path)\n        p1 = self._vis_collapse(p0)\n        p2 = self._shortcut(p1, self.smoothing_attempts)\n        p3 = self._round_corners(p2, passes=2)\n        return p3",
          "objective": -37.18079,
          "time_improvement": 73.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1385.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009148359298706055,
                    "num_nodes_avg": 41.0,
                    "path_length_avg": 160.05130696013703,
                    "smoothness_avg": 0.047923416631070685,
                    "success_improvement": 0.0,
                    "time_improvement": 62.919010542245815,
                    "node_improvement": 89.67514479979855,
                    "length_improvement": 12.273342479892806,
                    "smoothness_improvement": 650.1055376411265,
                    "objective_score": 29.490236338815063
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.039803075790405276,
                    "num_nodes_avg": 172.0,
                    "path_length_avg": 240.87765654308606,
                    "smoothness_avg": 0.0896202009366,
                    "success_improvement": 0.0,
                    "time_improvement": 76.20167525773196,
                    "node_improvement": 88.44319021702614,
                    "length_improvement": 19.588104967000366,
                    "smoothness_improvement": 2205.992320920289,
                    "objective_score": 45.64332716212125
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.00955343246459961,
                    "num_nodes_avg": 74.0,
                    "path_length_avg": 136.5410158564313,
                    "smoothness_avg": 0.11001885368701667,
                    "success_improvement": 0.0,
                    "time_improvement": 81.07358629325219,
                    "node_improvement": 90.59122695486332,
                    "length_improvement": 9.315958652640234,
                    "smoothness_improvement": 1299.4316981518023,
                    "objective_score": 36.40880957031881
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SIBiRRT-Connect-Lite: A streamlined balanced informed BiRRT-Connect with light neighbor parent selection, grid-accelerated proximity/collision, and two-phase shortcut refinement for faster search, shorter paths, and improved smoothness.",
          "planning_mechanism": "Per iteration, expand the smaller tree: sample from a mixed distribution (uniform/corridor/goal; ellipse after a first solution), steer one bounded step, validate node and edge, pick the cheapest feasible parent among the nearest few neighbors, insert, then greedily connect the opposite tree toward it until blocked. On connection, extract and shortcut the path and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=6.0,\n        goal_bias=0.25,\n        corridor_bias=0.35,\n        grid_cell_factor=1.0,\n        min_sep_ratio=0.3,\n        neighbor_radius_factor=2.0,\n        neighbor_cap=6,\n        connect_steps=32,\n        shortcut_attempts=80\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.min_sep_ratio = min_sep_ratio\n        self.neighbor_radius_factor = neighbor_radius_factor\n        self.neighbor_cap = neighbor_cap\n        self.connect_steps = connect_steps\n        self.shortcut_attempts = shortcut_attempts\n        self._rnd_state = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step_size * self.min_sep_ratio)\n        self.neighbor_radius = max(self.step_size * 1.2, self.step_size * self.neighbor_radius_factor)\n\n        self._seed_from_scene()\n\n        nodes = []\n        edges = []\n\n        if (not self._within_bounds(self.start)) or (not self._within_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._build_obstacle_grid()\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        incumbent_len = None\n\n        for _ in range(self.max_iter):\n            if len(tree_a) <= len(tree_b):\n                active_tree, active_grid = tree_a, grid_a\n                passive_tree, passive_grid = tree_b, grid_b\n                attractor = self.goal\n            else:\n                active_tree, active_grid = tree_b, grid_b\n                passive_tree, passive_grid = tree_a, grid_a\n                attractor = self.start\n\n            s = self._sample(attractor, incumbent_len)\n            if s is None:\n                continue\n\n            nearest = self._nearest_in_grid(active_grid, s)\n            if nearest is None:\n                continue\n\n            new_pos = self._steer(nearest.position, s, self.step_size)\n            if not self._within_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if self._has_nearby(active_grid, new_pos, self.min_sep):\n                continue\n\n            parent, new_cost = self._choose_parent_light(active_grid, nearest, new_pos)\n            if parent is None:\n                continue\n\n            if self._point_in_obstacles(new_pos):\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(active_grid, new_node)\n\n            meet = self._connect_toward(passive_tree, passive_grid, new_node.position, nodes, edges)\n            if meet is not None and self._edge_free(meet.position, new_node.position):\n                path = self._extract_path(new_node, meet)\n                incumbent_len = self._path_len(path)\n                path = self._shortcut(path)\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0x7fffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0x7fffffff\n        self._rnd_state = (s ^ 0x9E3779B9) & 0x7fffffff\n        if self._rnd_state == 0:\n            self._rnd_state = 123456789\n\n    def _rand(self):\n        self._rnd_state = (1103515245 * self._rnd_state + 12345) & 0x7fffffff\n        return self._rnd_state / 2147483647.0\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            q = []\n            for i in range(self.dims):\n                q.append(self._clamp_val(b[i], 0.0, self.bounds[i]))\n            return tuple(q)\n        d = d2 ** 0.5\n        r = step / d\n        q = []\n        for i in range(self.dims):\n            v = a[i] + (b[i] - a[i]) * r\n            q.append(self._clamp_val(v, 0.0, self.bounds[i]))\n        return tuple(q)\n\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_in_grid(self, grid, pos, max_ring=4):\n        key = self._cell_of(pos)\n        best = None\n        bestd2 = 1e100\n        for r in range(0, max_ring + 1):\n            cand = self._ring_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            if best is not None:\n                return best\n        buckets = list(grid.values())\n        if not buckets:\n            return None\n        trials = 0\n        while trials < 24:\n            b = buckets[int(self._rand() * len(buckets)) % max(1, len(buckets))]\n            if b:\n                n = b[int(self._rand() * len(b)) % max(1, len(b))]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            trials += 1\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        rc = int(radius // self.cell_size) + 1\n        r2 = radius * radius\n        for n in self._ring_collect(grid, key, rc):\n            if self._dist2(n.position, pos) <= r2:\n                return True\n        return False\n\n    def _nearby_nodes(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        rc = int(radius // self.cell_size) + 1\n        r2 = radius * radius\n        out = []\n        for n in self._ring_collect(grid, key, rc):\n            if self._dist2(n.position, pos) <= r2:\n                out.append(n)\n        return out\n\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            b = self.obs_grid.get((cx, cy, cz))\n            if not b:\n                return False\n            px, py, pz = p\n            for idx in b:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            b = self.obs_grid.get((cx, cy))\n            if not b:\n                return False\n            px, py = p\n            for idx in b:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _choose_parent_light(self, grid, nearest, new_pos):\n        neigh = self._nearby_nodes(grid, new_pos, self.neighbor_radius)\n        if nearest not in neigh:\n            neigh.append(nearest)\n        neigh.sort(key=lambda n: self._dist2(n.position, new_pos))\n        cand = neigh[:max(1, self.neighbor_cap)]\n        best_parent = None\n        best_cost = 1e100\n        for n in cand:\n            if not self._edge_free(n.position, new_pos):\n                continue\n            c = n.cost + self._dist(n.position, new_pos)\n            if c + 1e-9 < best_cost:\n                best_cost = c\n                best_parent = n\n        if best_parent is None:\n            return None, None\n        return best_parent, best_cost\n\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        near = self._nearest_in_grid(grid, target_pos)\n        if near is None:\n            return None\n        cur = near\n        steps = 0\n        while steps < self.connect_steps:\n            nxt = self._steer(cur.position, target_pos, self.step_size)\n            if self._dist2(cur.position, nxt) < (self.min_sep * self.min_sep * 0.25):\n                break\n            if not self._within_bounds(nxt):\n                break\n            if self._point_in_obstacles(nxt):\n                break\n            if self._has_nearby(grid, nxt, self.min_sep):\n                break\n            if not self._edge_free(cur.position, nxt):\n                break\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            q = Node(nxt, cur, new_cost)\n            cur.add_child(q)\n            tree.append(q)\n            nodes.append(q)\n            edges.append((cur, q))\n            self._grid_insert(grid, q)\n            cur = q\n            steps += 1\n            if self._dist2(cur.position, target_pos) <= (self.step_size * self.step_size) and self._edge_free(cur.position, target_pos):\n                return cur\n        return None\n\n    def _sample(self, attractor, incumbent_len):\n        for _ in range(20):\n            r = self._rand()\n            if incumbent_len is not None and r < 0.55:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                elif r < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_sample()\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            if p is not None and self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        if self._within_bounds(attractor) and not self._point_in_obstacles(attractor):\n            return attractor\n        return None\n\n    def _corridor_sample(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n        dsg = self._dist(self.start, self.goal)\n        width = max(self.step_size, 0.08 * dsg)\n        if self.is_3d:\n            return (\n                self._clamp_val(base[0] + self._rand_range(-width, width), 0.0, self.bounds[0]),\n                self._clamp_val(base[1] + self._rand_range(-width, width), 0.0, self.bounds[1]),\n                self._clamp_val(base[2] + self._rand_range(-width, width), 0.0, self.bounds[2]),\n            )\n        else:\n            return (\n                self._clamp_val(base[0] + self._rand_range(-width, width), 0.0, self.bounds[0]),\n                self._clamp_val(base[1] + self._rand_range(-width, width), 0.0, self.bounds[1]),\n            )\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum_dist\n        ext = [max(self.step_size, half)] * self.dims\n        for _ in range(18):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._within_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum_dist and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        pb.reverse()\n        if pa and pb and pa[-1] == pb[0]:\n            pb = pb[1:]\n        return pa + pb\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        i = 0\n        while i < len(pts) - 2:\n            j = len(pts) - 1\n            improved = False\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    del pts[i + 1:j]\n                    improved = True\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n        attempts = 0\n        while attempts < self.shortcut_attempts and len(pts) > 2:\n            i = int(self._rand_range(0, len(pts) - 2))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                attempts += 1\n                continue\n            if self._edge_free(pts[i], pts[j]):\n                pts = pts[:i + 1] + pts[j:]\n            attempts += 1\n        return pts",
          "objective": -37.09124,
          "time_improvement": 61.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1377.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011144709587097169,
                    "num_nodes_avg": 49.0,
                    "path_length_avg": 150.61019244127573,
                    "smoothness_avg": 0.04827733550563596,
                    "success_improvement": 0.0,
                    "time_improvement": 54.82721598316178,
                    "node_improvement": 87.6605389070763,
                    "length_improvement": 17.448166951713837,
                    "smoothness_improvement": 655.6451365752101,
                    "objective_score": 30.195290648852886
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04703662395477295,
                    "num_nodes_avg": 160.0,
                    "path_length_avg": 222.69131300634007,
                    "smoothness_avg": 0.08728289130799861,
                    "success_improvement": 0.0,
                    "time_improvement": 71.87672486543198,
                    "node_improvement": 89.24947927165222,
                    "length_improvement": 25.65922990444059,
                    "smoothness_improvement": 2145.851660680297,
                    "objective_score": 47.68781370569543
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02253601551055908,
                    "num_nodes_avg": 116.0,
                    "path_length_avg": 125.1119046359757,
                    "smoothness_avg": 0.11227318427452833,
                    "success_improvement": 0.0,
                    "time_improvement": 55.35364337006359,
                    "node_improvement": 85.2511125238398,
                    "length_improvement": 16.906630129474358,
                    "smoothness_improvement": 1328.1066168275754,
                    "objective_score": 33.39060417284157
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "INSTAR-BiRRT*: Informed-Indexed Star-Rewire Bidirectional Planner. A bidirectional, obstacle-indexed RRT with local best-parent selection, limited RRT*-style rewiring, cached edge checks, and informed corridor sampling that tightens after the first solution. It enforces strict node and edge collision checks before any insertion, caps connect steps, and maintains coherent trees/edges. On connection, it performs visibility compression, endpoint-inclusive shortcutting, and elastic smoothing for shorter, smoother paths while keeping runtime low.",
          "planning_mechanism": "Mechanism: Build start/goal trees with a spatial node grid and an obstacle cell index. Each iteration alternates trees, samples goal/corridor/informed/uniform targets using LCG RNG, gathers near candidates from grid rings, selects the cheapest collision-free parent, and inserts a single node after both node and edge checks. It then locally rewires cheaper neighbors (edge-checked) and attempts a bounded greedy connect on the opposite tree with commit-per-step checks. A cached, AABB-prefiltered edge tester accelerates validation. Upon bridge closure, it assembles the path and applies visibility compression, endpoint-inclusive random shortcuts, and elastic smoothing.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=7000,\n        step_size=6.0,\n        goal_bias=0.22,\n        corridor_bias=0.40,\n        grid_cell_factor=1.3,\n        neighbor_radius_ratio=1.5,\n        rewire_radius_ratio=1.8,\n        dupe_radius_ratio=0.30,\n        connect_hops=6,\n        edge_resolution=0.9,\n        shortcut_attempts=120,\n        elastic_iters=8\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neighbor_radius_ratio = float(neighbor_radius_ratio)\n        self.rewire_radius_ratio = float(rewire_radius_ratio)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.connect_hops = int(connect_hops)\n        self.edge_resolution = float(edge_resolution)\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.elastic_iters = int(max(0, elastic_iters))\n        # runtime fields\n        self.bounds = None\n        self.dim = 2\n        self.is_3d = False\n        self.start = None\n        self.goal = None\n        self.obstacles = None\n        self.grid_cell = 1.0\n        self.obs_cell = 4.0\n        self.edge_res = 1.0\n        self.cache_bin = 1.0\n        self._free_edge_cache = None\n        self._blocked_edge_cache = None\n        self.obs_index = None\n\n    # ---- Public API ----\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles)\n\n        # Parameterize\n        self.grid_cell = max(1.0, self.grid_cell_factor * self.step_size)\n        self.obs_cell = max(4.0, 1.2 * self.step_size)\n        self.edge_res = max(0.5, min(self.edge_resolution, self.step_size))\n        self.cache_bin = max(1.0, self.edge_res)\n\n        # Validate start/goal\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._build_obstacle_index()\n        if self._is_point_blocked_indexed(self.start) or self._is_point_blocked_indexed(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct LOS\n        self._free_edge_cache, self._blocked_edge_cache = set(), set()\n        if not self._is_edge_blocked_cached(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._distance(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Initialize trees, grids, edges\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree, goal_tree = [start_root], [goal_root]\n        grid_start, grid_goal = {}, {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n        edges = []\n\n        # RNG init\n        self._lcg_state = 2463534242\n\n        # Sampling parameters\n        dsg = self._distance(self.start, self.goal)\n        corridor_w = max(self.step_size, 0.2 * dsg)\n        dupe_radius = max(0.5, self.dupe_radius_ratio * self.step_size)\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            # Alternate sides\n            if it % 2 == 0:\n                grow_tree, grow_grid, grow_root_pos = start_tree, grid_start, self.start\n                other_tree, other_grid, other_root_pos = goal_tree, grid_goal, self.goal\n                start_side_active = True\n            else:\n                grow_tree, grow_grid, grow_root_pos = goal_tree, grid_goal, self.goal\n                other_tree, other_grid, other_root_pos = start_tree, grid_start, self.start\n                start_side_active = False\n\n            # Dynamic radii (light dependence on current tree size)\n            nA = max(1, len(grow_tree))\n            neighbor_radius = max(self.step_size, self.neighbor_radius_ratio * self.step_size * (1.0 + 0.15 * (1.0 / (1.0 + nA / 300.0))))\n            rewire_radius = max(self.step_size, self.rewire_radius_ratio * self.step_size * (1.0 + 0.10 * (1.0 / (1.0 + nA / 300.0))))\n\n            # Target sampling (goal / informed corridor / uniform)\n            r = self._rand()\n            if r < self.goal_bias:\n                target = other_root_pos\n            else:\n                # informed corridor tightens once a path exists\n                use_informed = best_len < float('inf') and self._rand() < self.corridor_bias\n                if use_informed:\n                    width = max(self.step_size, 0.25 * (best_len - dsg) + 0.15 * dsg)\n                    target = self._sample_corridor(self.start, self.goal, width)\n                elif self._rand() < self.corridor_bias:\n                    target = self._sample_corridor(self.start, self.goal, corridor_w)\n                else:\n                    target = self._sample_free()\n\n            # Choose near set and best parent\n            near_candidates = self._nearest_candidates(grow_tree, grow_grid, target, min_k=16, max_rings=4)\n            if not near_candidates:\n                near_candidates = [self._nearest_linear(grow_tree, target)]\n            base_parent = self._best_near(near_candidates, target)\n            proposed = self._steer(base_parent.position, target, self.step_size)\n            if not self._within_bounds(proposed):\n                continue\n            if self._is_point_blocked_indexed(proposed):\n                continue\n            if self._exists_close(grow_grid, proposed, dupe_radius):\n                continue\n\n            # Best-parent selection within neighbor radius (strict node+edge checks)\n            neighbors = self._neighbors_within_radius(grow_grid, proposed, neighbor_radius)\n            if base_parent not in neighbors:\n                neighbors.append(base_parent)\n            best_parent = None\n            best_cost = float('inf')\n            for cand in neighbors:\n                dcp = self._distance(cand.position, proposed)\n                if dcp > self.step_size + 1e-9:\n                    continue\n                if self._is_edge_blocked_cached(cand.position, proposed):\n                    continue\n                cost = cand.cost + dcp\n                if cost < best_cost:\n                    best_cost = cost\n                    best_parent = cand\n            if best_parent is None:\n                continue\n\n            # Commit new node (both checks enforced)\n            new_node = self._commit_node(grow_tree, grow_grid, edges, best_parent, proposed, best_cost)\n            if new_node is None:\n                continue\n\n            # Local rewiring (limited) with strict edge checks\n            self._local_rewire(new_node, grow_grid, edges, rewire_radius, max_rewires=16)\n\n            # Attempt immediate direct bridge to nearest of other tree\n            other_near = self._nearest_from_grid(other_tree, other_grid, new_node.position, max_rings=3)\n            if other_near is not None and not self._is_edge_blocked_cached(new_node.position, other_near.position):\n                # Bridge and finish\n                edges.append((other_near, new_node))\n                raw_path = self._assemble_path(start_root, goal_root, new_node, other_near, start_side_active)\n                best_len = self._path_length(raw_path)\n                path = self._postprocess(raw_path)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Greedy bounded connect on the other tree toward new_node\n            if other_near is None:\n                other_near = self._nearest_linear(other_tree, new_node.position)\n            last_b = self._bounded_connect(other_tree, other_grid, other_near, new_node.position, edges, self.connect_hops)\n            if last_b is not None:\n                # Try final bridge\n                if not self._is_edge_blocked_cached(last_b.position, new_node.position):\n                    edges.append((last_b, new_node))\n                    raw_path = self._assemble_path(start_root, goal_root, new_node, last_b, start_side_active)\n                    best_len = self._path_length(raw_path)\n                    path = self._postprocess(raw_path)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---- RNG ----\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---- Geometry ----\n    def _distance(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_pos(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._distance(from_pos, to_pos)\n        if d <= step:\n            return self._clamp_pos(to_pos)\n        r = step / (d + 1e-12)\n        return self._clamp_pos(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---- Obstacle index and collision ----\n    def _build_obstacle_index(self):\n        self.obs_index = {}\n        if self.is_3d:\n            for oi, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                minx = int(x // self.obs_cell)\n                maxx = int((x + w) // self.obs_cell)\n                miny = int(y // self.obs_cell)\n                maxy = int((y + h) // self.obs_cell)\n                minz = int(z // self.obs_cell)\n                maxz = int((z + d) // self.obs_cell)\n                for cx in range(minx, maxx + 1):\n                    for cy in range(miny, maxy + 1):\n                        for cz in range(minz, maxz + 1):\n                            key = (cx, cy, cz)\n                            bucket = self.obs_index.get(key)\n                            if bucket is None:\n                                self.obs_index[key] = [oi]\n                            else:\n                                bucket.append(oi)\n        else:\n            for oi, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                minx = int(x // self.obs_cell)\n                maxx = int((x + w) // self.obs_cell)\n                miny = int(y // self.obs_cell)\n                maxy = int((y + h) // self.obs_cell)\n                for cx in range(minx, maxx + 1):\n                    for cy in range(miny, maxy + 1):\n                        key = (cx, cy)\n                        bucket = self.obs_index.get(key)\n                        if bucket is None:\n                            self.obs_index[key] = [oi]\n                        else:\n                            bucket.append(oi)\n\n    def _obs_cell_key(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.obs_cell), int(pos[1] // self.obs_cell), int(pos[2] // self.obs_cell))\n        else:\n            return (int(pos[0] // self.obs_cell), int(pos[1] // self.obs_cell))\n\n    def _obs_candidates_for_segment(self, a, b, pad):\n        if self.is_3d:\n            mins = (min(a[0], b[0]) - pad, min(a[1], b[1]) - pad, min(a[2], b[2]) - pad)\n            maxs = (max(a[0], b[0]) + pad, max(a[1], b[1]) + pad, max(a[2], b[2]) + pad)\n            minc = (int(mins[0] // self.obs_cell), int(mins[1] // self.obs_cell), int(mins[2] // self.obs_cell))\n            maxc = (int(maxs[0] // self.obs_cell), int(maxs[1] // self.obs_cell), int(maxs[2] // self.obs_cell))\n            seen = set()\n            cand = []\n            for cx in range(minc[0], maxc[0] + 1):\n                for cy in range(minc[1], maxc[1] + 1):\n                    for cz in range(minc[2], maxc[2] + 1):\n                        bucket = self.obs_index.get((cx, cy, cz))\n                        if bucket:\n                            for oi in bucket:\n                                if oi not in seen:\n                                    seen.add(oi)\n                                    cand.append(oi)\n            return cand\n        else:\n            mins = (min(a[0], b[0]) - pad, min(a[1], b[1]) - pad)\n            maxs = (max(a[0], b[0]) + pad, max(a[1], b[1]) + pad)\n            minc = (int(mins[0] // self.obs_cell), int(mins[1] // self.obs_cell))\n            maxc = (int(maxs[0] // self.obs_cell), int(maxs[1] // self.obs_cell))\n            seen = set()\n            cand = []\n            for cx in range(minc[0], maxc[0] + 1):\n                for cy in range(minc[1], maxc[1] + 1):\n                    bucket = self.obs_index.get((cx, cy))\n                    if bucket:\n                        for oi in bucket:\n                            if oi not in seen:\n                                seen.add(oi)\n                                cand.append(oi)\n            return cand\n\n    def _is_point_blocked_indexed(self, pos):\n        key = self._obs_cell_key(pos)\n        bucket = self.obs_index.get(key)\n        if not bucket:\n            return False\n        if self.is_3d:\n            px, py, pz = pos\n            for oi in bucket:\n                x, y, z, w, h, d = self.obstacles[oi]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for oi in bucket:\n                x, y, w, h = self.obstacles[oi]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_blocked_cached(self, a, b):\n        key = self._edge_key_q(a, b)\n        if key in self._blocked_edge_cache:\n            return True\n        if key in self._free_edge_cache:\n            return False\n        blocked = self._is_edge_blocked_filtered(a, b)\n        if blocked:\n            self._blocked_edge_cache.add(key)\n            return True\n        else:\n            self._free_edge_cache.add(key)\n            return False\n\n    def _is_edge_blocked_filtered(self, a, b):\n        d = self._distance(a, b)\n        steps = int(max(1, d / max(1e-9, self.edge_res)))\n        cand = self._obs_candidates_for_segment(a, b, pad=self.edge_res)\n        if not cand:\n            return False\n        if steps <= 1:\n            mid = tuple((a[i] + b[i]) * 0.5 for i in range(self.dim))\n            return self._is_point_blocked_in_list(mid, cand) or self._is_point_blocked_in_list(a, cand) or self._is_point_blocked_in_list(b, cand)\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_point_blocked_in_list(p, cand):\n                return True\n        return False\n\n    def _is_point_blocked_in_list(self, pos, cand_idx):\n        if not cand_idx:\n            return False\n        if self.is_3d:\n            px, py, pz = pos\n            for oi in cand_idx:\n                x, y, z, w, h, d = self.obstacles[oi]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for oi in cand_idx:\n                x, y, w, h = self.obstacles[oi]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    # ---- Sampling ----\n    def _sample_free(self):\n        for _ in range(64):\n            if self.is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_point_blocked_indexed(p):\n                return p\n        # fallback within bounds (may be blocked; extension will reject)\n        if self.is_3d:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]),\n                    self._uniform(0.0, self.bounds[2]))\n        else:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]))\n\n    def _sample_corridor(self, a, b, width):\n        t = self._rand()\n        base = tuple(a[i] + t * (b[i] - a[i]) for i in range(self.dim))\n        if self.is_3d:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_point_blocked_indexed(p):\n            return p\n        return self._sample_free()\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # ---- Node grid and nearest ----\n    def _grid_key(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell), int(pos[2] // self.grid_cell))\n        else:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _nearest_from_grid(self, tree, grid, point, max_rings=4):\n        # ring search with early exit only if enough candidates seen; else fallback\n        cand = self._collect_ring(grid, point, max_rings)\n        if cand:\n            best = cand[0]\n            bestd = self._distance(best.position, point)\n            for n in cand:\n                d = self._distance(n.position, point)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            return best\n        return self._nearest_linear(tree, point)\n\n    def _nearest_linear(self, tree, point):\n        best = tree[0]\n        bestd = self._distance(best.position, point)\n        for n in tree:\n            d = self._distance(n.position, point)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _collect_ring(self, grid, point, max_rings):\n        center = self._grid_key(point)\n        out = []\n        # grow rings\n        for r in range(0, max_rings + 1):\n            if self.is_3d:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            k = (center[0] + dx, center[1] + dy, center[2] + dz)\n                            if k in grid:\n                                out.extend(grid[k])\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        k = (center[0] + dx, center[1] + dy)\n                        if k in grid:\n                            out.extend(grid[k])\n        return out\n\n    def _nearest_candidates(self, tree, grid, point, min_k=16, max_rings=4):\n        cand = []\n        center = self._grid_key(point)\n        for r in range(0, max_rings + 1):\n            if self.is_3d:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            k = (center[0] + dx, center[1] + dy, center[2] + dz)\n                            if k in grid:\n                                cand.extend(grid[k])\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        k = (center[0] + dx, center[1] + dy)\n                        if k in grid:\n                            cand.extend(grid[k])\n            if len(cand) >= min_k:\n                break\n        if not cand and tree:\n            cand = tree[:min(min_k, len(tree))]\n        return cand\n\n    def _neighbors_within_radius(self, grid, point, radius):\n        cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        center = self._grid_key(point)\n        out = []\n        if self.is_3d:\n            for dx in range(-cells, cells + 1):\n                for dy in range(-cells, cells + 1):\n                    for dz in range(-cells, cells + 1):\n                        k = (center[0] + dx, center[1] + dy, center[2] + dz)\n                        if k in grid:\n                            out.extend(grid[k])\n        else:\n            for dx in range(-cells, cells + 1):\n                for dy in range(-cells, cells + 1):\n                    k = (center[0] + dx, center[1] + dy)\n                    if k in grid:\n                        out.extend(grid[k])\n        # distance filter\n        rr = radius * radius\n        fil = []\n        for n in out:\n            s = 0.0\n            p = n.position\n            for i in range(self.dim):\n                d = p[i] - point[i]\n                s += d * d\n            if s <= rr:\n                fil.append(n)\n        return fil\n\n    def _exists_close(self, grid, pos, radius):\n        return len(self._neighbors_within_radius(grid, pos, radius)) > 0\n\n    def _best_near(self, nodes, target):\n        best = nodes[0]\n        bestd = self._distance(best.position, target)\n        for n in nodes:\n            d = self._distance(n.position, target)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    # ---- Commit/rewire/connect ----\n    def _commit_node(self, tree, grid, edges, parent, pos, cost):\n        if not self._within_bounds(pos):\n            return None\n        if self._is_point_blocked_indexed(pos):\n            return None\n        if self._is_edge_blocked_cached(parent.position, pos):\n            return None\n        new_node = Node(pos, parent, cost)\n        parent.add_child(new_node)\n        tree.append(new_node)\n        self._grid_add(grid, new_node)\n        edges.append((parent, new_node))\n        return new_node\n\n    def _local_rewire(self, new_node, grid, edges, radius, max_rewires=16):\n        # try to improve nearby neighbors' costs via new_node\n        neigh = self._neighbors_within_radius(grid, new_node.position, radius)\n        count = 0\n        for nb in neigh:\n            if nb is new_node or nb is new_node.parent:\n                continue\n            d = self._distance(new_node.position, nb.position)\n            if d <= 1e-9 or d > radius + 1e-9:\n                continue\n            new_cost = new_node.cost + d\n            if new_cost + 1e-9 < nb.cost:\n                # enforce both checks\n                if self._is_edge_blocked_cached(new_node.position, nb.position):\n                    continue\n                if self._is_point_blocked_indexed(nb.position):  # redundant but explicit\n                    continue\n                old_parent = nb.parent\n                if old_parent is None:\n                    continue\n                # apply rewire\n                self._remove_child(old_parent, nb)\n                self._remove_edge(edges, old_parent, nb)\n                new_node.add_child(nb)\n                nb.parent = new_node\n                delta = new_cost - nb.cost\n                nb.cost = new_cost\n                self._propagate_cost(nb, delta)\n                edges.append((new_node, nb))\n                count += 1\n                if count >= max_rewires:\n                    break\n\n    def _remove_child(self, parent, child):\n        if child in parent.children:\n            parent.children.remove(child)\n\n    def _remove_edge(self, edges, parent, child):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is parent and e[1] is child:\n                del edges[i]\n                return\n\n    def _propagate_cost(self, node, delta):\n        # BFS propagate cost changes to subtree\n        q = [node]\n        while q:\n            cur = q.pop()\n            for ch in cur.children:\n                ch.cost += delta\n                q.append(ch)\n\n    def _bounded_connect(self, tree, grid, from_node, target_pos, edges, max_hops):\n        current = from_node\n        last_new = None\n        hops = 0\n        while hops < max_hops:\n            step_pos = self._steer(current.position, target_pos, self.step_size)\n            if not self._within_bounds(step_pos):\n                break\n            if self._is_point_blocked_indexed(step_pos):\n                break\n            if self._is_edge_blocked_cached(current.position, step_pos):\n                break\n            # commit (strict checks already done)\n            new_cost = current.cost + self._distance(current.position, step_pos)\n            nxt = Node(step_pos, current, new_cost)\n            current.add_child(nxt)\n            tree.append(nxt)\n            self._grid_add(grid, nxt)\n            edges.append((current, nxt))\n            last_new = nxt\n            current = nxt\n            hops += 1\n            if self._distance(current.position, target_pos) <= self.step_size:\n                break\n        return last_new\n\n    # ---- Path assembly and post-processing ----\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _assemble_path(self, start_root, goal_root, a_node, b_node, a_is_start_side):\n        if a_is_start_side:\n            pa = self._path_to_root(a_node)  # start -> a_node\n            pb = self._path_to_root(b_node)  # goal -> b_node\n            return pa + pb[::-1]\n        else:\n            pa = self._path_to_root(a_node)  # goal-side growth\n            pb = self._path_to_root(b_node)\n            return pb + pa[::-1]\n\n    def _path_length(self, path):\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._distance(path[i - 1], path[i])\n        return total\n\n    def _visibility_compress(self, path):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            jumped = False\n            while j > i + 1:\n                if not self._is_edge_blocked_cached(path[i], path[j]):\n                    out.append(path[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(path[i + 1])\n                i += 1\n        if out[-1] != path[-1]:\n            out.append(path[-1])\n        # de-dup\n        ded = [out[0]]\n        for k in range(1, len(out)):\n            if self._distance(ded[-1], out[k]) > 1e-9:\n                ded.append(out[k])\n        return ded\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return list(path)\n        pts = list(path)\n        for _ in range(attempts):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_blocked_cached(a, b):\n                pts = pts[:i + 1] + pts[j:]\n        return pts\n\n    def _elastic(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return list(path)\n        pts = list(path)\n        for _ in range(iters):\n            changed = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                if self._is_point_blocked_indexed(mid):\n                    continue\n                if self._is_edge_blocked_cached(a, mid):\n                    continue\n                if self._is_edge_blocked_cached(mid, c):\n                    continue\n                if self._distance(pts[i], mid) > 1e-9:\n                    pts[i] = mid\n                    changed = True\n            if not changed:\n                break\n        return pts\n\n    def _postprocess(self, raw_path):\n        p = self._visibility_compress(raw_path)\n        p = self._shortcut(p, self.shortcut_attempts)\n        p = self._elastic(p, self.elastic_iters)\n        return p",
          "objective": -36.94679,
          "time_improvement": 62.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1876.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01455528736114502,
                    "num_nodes_avg": 56.0,
                    "path_length_avg": 153.05488117915178,
                    "smoothness_avg": 0.04323917072604063,
                    "success_improvement": 0.0,
                    "time_improvement": 41.00314170328443,
                    "node_improvement": 85.89775875094435,
                    "length_improvement": 16.108194315911927,
                    "smoothness_improvement": 576.7869172246149,
                    "objective_score": 24.84979368665556
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04361860752105713,
                    "num_nodes_avg": 170.0,
                    "path_length_avg": 244.2123677023688,
                    "smoothness_avg": 0.12207511882177972,
                    "success_improvement": 0.0,
                    "time_improvement": 73.92036253535261,
                    "node_improvement": 88.57757172613049,
                    "length_improvement": 18.474882397693065,
                    "smoothness_improvement": 3041.0807344384375,
                    "objective_score": 48.466441871413814
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014497733116149903,
                    "num_nodes_avg": 74.0,
                    "path_length_avg": 135.28177456457792,
                    "smoothness_avg": 0.16586943691668363,
                    "success_improvement": 0.0,
                    "time_improvement": 71.27837604096456,
                    "node_improvement": 90.59122695486332,
                    "length_improvement": 10.15228676006259,
                    "smoothness_improvement": 2009.8469943719351,
                    "objective_score": 37.5241198401866
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SAGE-BRRT: Simple Adaptive Grid-Enhanced BiRRT with Local Rewire and On-the-fly Visibility. Two trees grow toward each other using grid-accelerated nearest search and informed/corridor-biased sampling. Each insertion selects the least-cost feasible parent among nearby nodes, performs ancestor visibility compression, and locally rewires neighbors. A probe-then-commit connect adds at most one node on the opposite tree per iteration and bridges if a short direct link is free. Obstacle checks use a spatial hash for fast node and edge validation. On success, a lightweight visibility pass, shortcutting, and elastic smoothing return a short, smooth path quickly.",
          "planning_mechanism": "Initialize bidirectional trees, node-grid, and obstacle-grid. Iterate: sample a target (goal/corridor/informed/uniform), find a near node via grid rings, steer by a fixed step, and validate node (inside-bounds, not in obstacles) and edge (segment-obstacle free). Choose the best feasible parent within a local radius; insert the node, then optionally compress to a visible ancestor and rewire nearby nodes if cheaper. Probe the other tree: try a direct bridge; else simulate one feasible step toward the new node and commit at most one opposite-node; if the short bridge becomes free, assemble the path. Maintain an incumbent path for informed sampling. After connection, run visibility compression, shortcutting, and elastic smoothing, then return the result.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=7.0,\n        goal_bias=0.18,\n        corridor_bias=0.35,\n        informed_bias=0.55,\n        cell_size_factor=1.6,\n        dupe_radius_ratio=0.45,\n        rewire_radius_factor=2.0,\n        neighbor_cap=24,\n        connect_steps=1,\n        smooth_shortcuts=80,\n        rubber_iters=8\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.cell_size_factor = float(cell_size_factor)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.rewire_radius_factor = float(rewire_radius_factor)\n        self.neighbor_cap = int(neighbor_cap)\n        self.connect_steps = int(connect_steps)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self.rubber_iters = int(max(0, rubber_iters))\n\n        self._rnd = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_from_scene()\n\n        # Build obstacle spatial hash\n        self._build_obstacle_grid()\n\n        # Validate endpoints\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Setup structures\n        self.cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.rewire_radius = max(self.step_size * 1.25, self.rewire_radius_factor * self.step_size)\n\n        nodes = []\n        edges = []\n\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        tree_a, tree_b = [a_root], [b_root]\n        grid_a, grid_b = {}, {}\n        anchors_a, anchors_b = [a_root], [b_root]\n        self._grid_insert(grid_a, a_root)\n        self._grid_insert(grid_b, b_root)\n\n        best_path = None\n        best_len = float('inf')\n\n        # Corridor width for biased sampling\n        sg = self._dist(self.start, self.goal)\n        corridor_w = max(self.step_size, 0.2 * sg)\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            tree1 = tree_a if side_a else tree_b\n            grid1 = grid_a if side_a else grid_b\n            anchors1 = anchors_a if side_a else anchors_b\n\n            tree2 = tree_b if side_a else tree_a\n            grid2 = grid_b if side_a else grid_a\n            anchors2 = anchors_b if side_a else anchors_a\n\n            attractor = self.goal if side_a else self.start\n\n            # Sample a target\n            target = self._sample_target(attractor, best_len, corridor_w)\n            if target is None:\n                continue\n\n            # Find near node and steer\n            near = self._nearest_hashed(grid1, anchors1, target, 3)\n            if near is None:\n                continue\n            new_pos = self._steer(near.position, target)\n\n            # Validity checks for node and edge\n            if not self._within_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if self._has_nearby(grid1, new_pos, self.dupe_radius):\n                continue\n\n            # Select best parent among local candidates\n            parent, new_cost = self._choose_parent(grid1, anchors1, tree1, new_pos)\n            if parent is None:\n                continue\n\n            # Node collision already checked; ensure edge is free\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            # Insert node\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(grid1, new_node)\n            if (len(tree1) % 24) == 0:\n                anchors1.append(new_node)\n\n            # Optional: compress to visible ancestor (one hop)\n            gp = parent.parent\n            if gp is not None:\n                if self._edge_free(gp.position, new_node.position):\n                    self._reparent(new_node, gp, edges)\n\n            # Local rewiring\n            self._rewire_neighbors(grid1, new_node, self.rewire_radius, edges)\n\n            # Try to connect the other tree\n            other_near = self._nearest_hashed(grid2, anchors2, new_node.position, 3)\n            if other_near is not None:\n                # Direct bridge\n                if self._edge_free(new_node.position, other_near.position):\n                    path = self._assemble_path(new_node, other_near, side_a)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # Probe-then-commit: at most one step on the other tree\n                committed = None\n                steps = 0\n                probe_from = other_near\n                while steps < self.connect_steps:\n                    step_p = self._steer(probe_from.position, new_node.position)\n                    if not self._within_bounds(step_p):\n                        break\n                    if self._point_in_obstacles(step_p):\n                        break\n                    if self._has_nearby(grid2, step_p, self.dupe_radius):\n                        break\n                    if not self._edge_free(probe_from.position, step_p):\n                        break\n                    # Commit this single step\n                    q = Node(step_p, probe_from, probe_from.cost + self._dist(probe_from.position, step_p))\n                    probe_from.add_child(q)\n                    tree2.append(q)\n                    nodes.append(q)\n                    edges.append((probe_from, q))\n                    self._grid_insert(grid2, q)\n                    if (len(tree2) % 24) == 0:\n                        anchors2.append(q)\n                    # Light local optimize\n                    self._compress_one(q, edges)\n                    self._rewire_neighbors(grid2, q, self.rewire_radius, edges)\n                    committed = q\n                    break\n                # If committed, try short bridge\n                if committed is not None:\n                    if self._edge_free(new_node.position, committed.position):\n                        path = self._assemble_path(new_node, committed, side_a)\n                        path = self._postprocess(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n            # Maintain best incumbent (for informed sampling)\n            if best_path is None:\n                # Try a temporary connection via NN if possible (no commit)\n                if other_near is not None:\n                    if self._edge_free(new_node.position, other_near.position):\n                        tmp = self._assemble_path(new_node, other_near, side_a)\n                        L = self._path_len(tmp)\n                        if L < best_len:\n                            best_len = L\n                            best_path = tmp\n\n        if best_path is not None:\n            best_path = self._postprocess(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG utilities\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 1) * 2654435761\n        self._rnd = (s ^ 0x9E3779B9) & 0xffffffff\n        if self._rnd == 0:\n            self._rnd = 2463534242\n\n    def _rand(self):\n        self._rnd = (1664525 * self._rnd + 1013904223) & 0xffffffff\n        return self._rnd / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= self.step_size:\n            return self._clamp(b)\n        r = self.step_size / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Sampling\n    def _sample_target(self, attractor, best_len, corridor_w):\n        for _ in range(24):\n            if best_len < float('inf') and self._rand() < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p is not None and not self._point_in_obstacles(p):\n                    return p\n            else:\n                r = self._rand()\n                if r < self.goal_bias:\n                    p = attractor\n                elif r < self.goal_bias + self.corridor_bias:\n                    t = self._rand()\n                    base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n                    if self.is_3d:\n                        p = (\n                            self._clamp((base[0] + self._rand_range(-corridor_w, corridor_w),\n                                         base[1] + self._rand_range(-corridor_w, corridor_w),\n                                         base[2] + self._rand_range(-corridor_w, corridor_w)))[0],\n                            self._clamp((base[0] + self._rand_range(-corridor_w, corridor_w),\n                                         base[1] + self._rand_range(-corridor_w, corridor_w),\n                                         base[2] + self._rand_range(-corridor_w, corridor_w)))[1],\n                            self._clamp((base[0] + self._rand_range(-corridor_w, corridor_w),\n                                         base[1] + self._rand_range(-corridor_w, corridor_w),\n                                         base[2] + self._rand_range(-corridor_w, corridor_w)))[2]\n                        )\n                        p = (min(max(base[0] + self._rand_range(-corridor_w, corridor_w), 0.0), self.bounds[0]),\n                             min(max(base[1] + self._rand_range(-corridor_w, corridor_w), 0.0), self.bounds[1]),\n                             min(max(base[2] + self._rand_range(-corridor_w, corridor_w), 0.0), self.bounds[2]))\n                    else:\n                        p = (min(max(base[0] + self._rand_range(-corridor_w, corridor_w), 0.0), self.bounds[0]),\n                             min(max(base[1] + self._rand_range(-corridor_w, corridor_w), 0.0), self.bounds[1]))\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n                if self._within_bounds(p) and not self._point_in_obstacles(p):\n                    return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._within_bounds(p):\n                return p\n        return None\n\n    # Node grid\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, anchors, pos, max_rings=3):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # Fallback: scan grid buckets\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors_within_radius(self, grid, pos, radius, cap):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        # Filter and cap\n        out = []\n        rr = radius * radius\n        for n in cand:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= rr:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _has_nearby(self, grid, pos, radius):\n        neigh = self._neighbors_within_radius(grid, pos, radius, self.neighbor_cap)\n        return len(neigh) > 0\n\n    # Parent selection\n    def _choose_parent(self, grid, anchors, tree, new_pos):\n        neigh = self._neighbors_within_radius(grid, new_pos, self.rewire_radius, self.neighbor_cap)\n        if not neigh:\n            # include a nearest fallback\n            near = None\n            bestd = 1e100\n            for n in tree:\n                d = self._dist(n.position, new_pos)\n                if d < bestd:\n                    bestd = d\n                    near = n\n            if near is None:\n                return None, None\n            neigh = [near]\n        best_parent = None\n        best_cost = 1e100\n        for p in neigh:\n            d = self._dist(p.position, new_pos)\n            if d > self.step_size + 1e-9:\n                continue\n            if not self._edge_free(p.position, new_pos):\n                continue\n            gc = p.cost + d\n            if gc < best_cost:\n                best_cost = gc\n                best_parent = p\n        if best_parent is None:\n            return None, None\n        return best_parent, best_cost\n\n    # Obstacle spatial hash\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Local optimization helpers\n    def _compress_one(self, node, edges):\n        p = node.parent\n        if p is None or p.parent is None:\n            return\n        gp = p.parent\n        if self._edge_free(gp.position, node.position):\n            self._reparent(node, gp, edges)\n\n    def _rewire_neighbors(self, grid, node, radius, edges):\n        neigh = self._neighbors_within_radius(grid, node.position, radius, self.neighbor_cap)\n        count = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            new_cost = node.cost + d\n            if new_cost + 1e-9 < nb.cost and self._edge_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n                count += 1\n                if count >= self.neighbor_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        old_parent = child.parent\n        if old_parent is new_parent:\n            return\n        if old_parent is not None:\n            old_parent.remove_child(child)\n            self._edges_remove(edges, old_parent, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        self._propagate_costs(child)\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                old = ch.cost\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                if abs(ch.cost - old) > 1e-12:\n                    stack.append(ch)\n\n    # Path assembly and post-processing\n    def _assemble_path(self, new_node, other_node, side_a):\n        if side_a:\n            pa = new_node.path_from_root()\n            pb = other_node.path_from_root()\n            if pa and pb and pa[0] == pb[-1]:\n                pb = pb[:-1]\n            return pa + pb[::-1]\n        else:\n            pa = new_node.path_from_root()\n            pb = other_node.path_from_root()\n            if pa and pb and pb[0] == pa[-1]:\n                pa = pa[:-1]\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _postprocess(self, path):\n        if len(path) < 3:\n            return path[:]\n        p = self._visibility_compress(path)\n        p = self._shortcut(p, self.smooth_shortcuts)\n        p = self._rubber_band(p, self.rubber_iters)\n        return p\n\n    def _visibility_compress(self, path):\n        out = [path[0]]\n        last = path[0]\n        i = 1\n        while i < len(path):\n            far = i\n            j = i\n            while j < len(path):\n                if self._edge_free(last, path[j]):\n                    far = j\n                    j += 1\n                else:\n                    break\n            out.append(path[far])\n            last = path[far]\n            i = far + 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = path[:]\n        best_len = self._path_len(pts)\n        n = len(pts)\n        tries = 0\n        noimp = 0\n        stop = 12\n        while tries < attempts and n >= 3:\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j > n:\n                tries += 1\n                continue\n            a, b = pts[i], pts[j - 1]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j - 1:]\n                L = self._path_len(new_pts)\n                if L <= best_len + 1e-12:\n                    pts = new_pts\n                    best_len = L\n                    n = len(pts)\n                    noimp = 0\n                else:\n                    noimp += 1\n            else:\n                noimp += 1\n            tries += 1\n            if noimp >= stop:\n                break\n        return pts\n\n    def _rubber_band(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return path[:]\n        pts = list(path)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dims))\n                if self._point_in_obstacles(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if mid != pts[i]:\n                        pts[i] = mid\n                        moved = True\n            if not moved:\n                break\n        return pts",
          "objective": -36.91755,
          "time_improvement": 60.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 2316.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016495347023010254,
                    "num_nodes_avg": 71.0,
                    "path_length_avg": 170.6218692301367,
                    "smoothness_avg": 0.05965294648609013,
                    "success_improvement": 0.0,
                    "time_improvement": 33.13950960050793,
                    "node_improvement": 82.12037270209015,
                    "length_improvement": 6.479449798427921,
                    "smoothness_improvement": 833.6981509539397,
                    "objective_score": 17.99801351397883
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03120548725128174,
                    "num_nodes_avg": 138.0,
                    "path_length_avg": 245.4887822432574,
                    "smoothness_avg": 0.18956585497977163,
                    "success_improvement": 0.0,
                    "time_improvement": 81.34218764255085,
                    "node_improvement": 90.72767587180005,
                    "length_improvement": 18.048778484388976,
                    "smoothness_improvement": 4777.665987395928,
                    "objective_score": 59.12025332037828
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01702072620391846,
                    "num_nodes_avg": 92.0,
                    "path_length_avg": 132.8506469498789,
                    "smoothness_avg": 0.1130542551758292,
                    "success_improvement": 0.0,
                    "time_improvement": 66.28004574080119,
                    "node_improvement": 88.30260648442466,
                    "length_improvement": 11.766925963888978,
                    "smoothness_improvement": 1338.0417810394658,
                    "objective_score": 33.63437820577107
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "HASTE-BiRRT: Hashed, Anytime, Saturation\u2011Throttled, Efficient BiRRT-Connect. It accelerates bidirectional RRT with cached collision tests, hashed nearest search with leader fallbacks, per-cell growth throttling, and duplicate-suppressed commit-only connections. A light visibility prune plus brief shortcutting refines the path while keeping postprocessing costs low.",
          "planning_mechanism": "Alternate expanding start/goal trees with goal-biased sampling; find nearest via grid rings, else leader-guided buckets; steer one step and validate with cached edge checks; suppress inserts in saturated/duplicate cells; attempt a single, commit-only direct bridge to the opposite tree, skipping known-blocked cell pairs; upon success, extract start-to-goal path, visibility-prune, then run a few shortcuts; terminate on success or iteration cap.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=7.0,\n                 goal_bias=0.25,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=40,\n                 max_per_cell=6,\n                 search_r_max=2,\n                 leader_stride=25):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n        self.max_per_cell = max_per_cell\n        self.search_r_max = search_r_max\n        self.leader_stride = leader_stride\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        # Caches\n        self._edge_blocked_cache = set()   # quantized blocked segments (safe to reuse only for blocked)\n        self._edge_exact_cache = {}        # exact endpoint pairs -> bool\n        self._connect_blocked_cells = set()  # (cellA, cellB) pairs known to fail direct connect\n\n    # ------------- Public API -------------\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Parameters derived\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size * 2.5)\n        self.edge_res = max(0.5, self.collision_step)\n\n        # Reset caches\n        self._edge_blocked_cache = set()\n        self._edge_exact_cache = {}\n        self._connect_blocked_cells = set()\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            path = [start, goal]\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Initialize trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Grids and counts\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n        self._grid_add(grid_start, counts_start, start_root)\n        self._grid_add(grid_goal, counts_goal, goal_root)\n\n        # Leaders\n        leaders_start = [start_root]\n        leaders_goal = [goal_root]\n        inserted_since_leader_start = 0\n        inserted_since_leader_goal = 0\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            grid_a = grid_start if active_start else grid_goal\n            counts_a = counts_start if active_start else counts_goal\n            leaders_a = leaders_start if active_start else leaders_goal\n\n            tree_b = goal_tree if active_start else start_tree\n            grid_b = grid_goal if active_start else grid_start\n            counts_b = counts_goal if active_start else counts_start\n            leaders_b = leaders_goal if active_start else leaders_start\n\n            root_other = goal if active_start else start\n\n            # Sample with goal/opposite-root bias\n            if self._rand() < self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest lookup\n            nearest = self._nearest_hashed(grid_a, leaders_a, tree_a, x_rand)\n            if nearest is None:\n                continue\n\n            # Steer\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Per-cell throttling and duplicate suppression\n            key_new = self._grid_key(new_pos)\n            if self._cell_count(counts_a, key_new) >= self.max_per_cell:\n                continue\n            if self._near_duplicate(grid_a, new_pos, dup_radius=0.7 * self.step_size):\n                continue\n\n            # Insert node and edge\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, counts_a, new_node)\n\n            # Leader sampling\n            if active_start:\n                inserted_since_leader_start += 1\n                if inserted_since_leader_start >= self.leader_stride:\n                    leaders_start.append(new_node)\n                    inserted_since_leader_start = 0\n            else:\n                inserted_since_leader_goal += 1\n                if inserted_since_leader_goal >= self.leader_stride:\n                    leaders_goal.append(new_node)\n                    inserted_since_leader_goal = 0\n\n            # Try commit-only direct connection to the other tree (with cell-pair de-dup)\n            other_near = self._nearest_hashed(grid_b, leaders_b, tree_b, new_node.position)\n            if other_near is not None:\n                pair_key = (self._grid_key(new_node.position), self._grid_key(other_near.position))\n                if pair_key not in self._connect_blocked_cells:\n                    if not self._edge_blocked(new_node.position, other_near.position, obstacles, is_3d):\n                        path = self._extract_path(new_node, other_near, a_is_start_tree=active_start)\n                        path = self._visibility_prune(path, obstacles, is_3d)\n                        path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                        return PlannerResult(True, path, start_tree + goal_tree, edges)\n                    else:\n                        # cache blocked cell pair to avoid repeating futile checks\n                        self._connect_blocked_cells.add(pair_key)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ------------- Random -------------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------- Geometry -------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ------------- Collision & caches -------------\n    def _quant(self, p, q=1.5):\n        # Quantize for blocked-segment cache; coarse to avoid false frees; safe for blocked reuse only\n        if self.dim == 3:\n            return (int(p[0] // q), int(p[1] // q), int(p[2] // q))\n        else:\n            return (int(p[0] // q), int(p[1] // q))\n\n    def _seg_key_exact(self, a, b):\n        # Canonicalize order for undirected segment\n        if a <= b:\n            return (a, b)\n        else:\n            return (b, a)\n\n    def _seg_key_quant_blocked(self, a, b):\n        qa = self._quant(a)\n        qb = self._quant(b)\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        # Exact cache check\n        k_exact = self._seg_key_exact(a, b)\n        cached = self._edge_exact_cache.get(k_exact)\n        if cached is not None:\n            return cached\n        # Blocked quantized cache\n        kq = self._seg_key_quant_blocked(a, b)\n        if kq in self._edge_blocked_cache:\n            self._edge_exact_cache[k_exact] = True\n            return True\n        # Compute\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res)\n        # Update caches\n        self._edge_exact_cache[k_exact] = blocked\n        if blocked:\n            self._edge_blocked_cache.add(kq)\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ------------- Sampling -------------\n    def _sample_free(self, obstacles, is_3d):\n        # Rejection sampling within bounds until a free point is found\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ------------- Grid / NN -------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n\n    def _cell_count(self, counts, key):\n        return counts.get(key, 0)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, leaders, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Local rings\n        for r in range(0, self.search_r_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Leader fallback\n        if leaders:\n            lead_best = None\n            lead_bestd = float('inf')\n            for n in leaders:\n                d = self._dist(n.position, pos)\n                if d < lead_bestd:\n                    lead_bestd = d\n                    lead_best = n\n            if lead_best is not None:\n                # Search around leader cell for neighbors\n                lk = self._grid_key(lead_best.position)\n                for r in range(0, min(2, self.search_r_max) + 1):\n                    cand = self._grid_ring_collect(grid, lk, r)\n                    for n in cand:\n                        d = self._dist(n.position, pos)\n                        if d < bestd:\n                            bestd = d\n                            best = n\n                if best is not None:\n                    return best\n        # Sparse random subset fallback (avoid full scan)\n        if tree:\n            trials = min(64, len(tree))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(tree)))\n                n = tree[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            if best is not None:\n                return best\n        return None\n\n    def _near_duplicate(self, grid, pos, dup_radius):\n        key = self._grid_key(pos)\n        r = 1\n        cand = self._grid_ring_collect(grid, key, r)\n        rr = dup_radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # ------------- Path -------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            # start-tree path to meet, then meet->goal via reversed goal-tree path\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -35.78786,
          "time_improvement": 66.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1772.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016536712646484375,
                    "num_nodes_avg": 67.3,
                    "path_length_avg": 176.25078259592178,
                    "smoothness_avg": 0.05067539409595988,
                    "success_improvement": 0.0,
                    "time_improvement": 35.1470831615236,
                    "node_improvement": 83.05212792747419,
                    "length_improvement": 3.3941531868009323,
                    "smoothness_improvement": 693.1799609813568,
                    "objective_score": 16.046516665444422
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023010659217834472,
                    "num_nodes_avg": 105.2,
                    "path_length_avg": 247.25890321415372,
                    "smoothness_avg": 0.1191098532602342,
                    "success_improvement": 0.0,
                    "time_improvement": 85.63605318102866,
                    "node_improvement": 92.93153262111133,
                    "length_improvement": 17.45786115419664,
                    "smoothness_improvement": 2964.7823157454163,
                    "objective_score": 50.989444225553655
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.011754655838012695,
                    "num_nodes_avg": 94.4,
                    "path_length_avg": 127.41557160345823,
                    "smoothness_avg": 0.13822063405561777,
                    "success_improvement": 0.0,
                    "time_improvement": 76.0361625858193,
                    "node_improvement": 87.99745708836618,
                    "length_improvement": 15.376644218505373,
                    "smoothness_improvement": 1658.156262801516,
                    "objective_score": 40.327616620856595
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Bounded BiRRT-Connect with Grid-Accelerated Nearest and Lightweight Shortcutting: a time-capped, bidirectional RRT-Connect that uses a coarse spatial grid for fast nearest-neighbor queries, commits only validated steps, attempts a single greedy bridge per iteration, and applies a brief shortcut smoother to the first found path for quality without heavy rewiring or anytime overhead.",
          "planning_mechanism": "Mechanism: Alternate growing start/goal trees with one extend loop toward a biased sample; each successful extension triggers a greedy extend from the opposite tree toward the new node. Both node and edge collisions are strictly checked before every insertion and the final bridge. Nearest queries use a bucket grid with limited ring expansion and linear fallback. On success, a bounded-time shortcut pass improves path length/smoothness; the planner enforces a hard time limit and returns the best (first) feasible path promptly.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=6.0,\n        goal_sample_rate=0.15,\n        bridge_bias_rate=0.30,\n        cell_size_factor=2.0,\n        time_limit_sec=12.0,\n        edge_resolution=1.0,\n        smooth_attempts=80,\n        smooth_time_frac=0.2\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.bridge_bias_rate = bridge_bias_rate\n        self.cell_size_factor = cell_size_factor\n        self.time_limit_sec = time_limit_sec\n        self.edge_resolution = edge_resolution\n        self.smooth_attempts = smooth_attempts\n        self.smooth_time_frac = smooth_time_frac\n\n    def plan(self, map):\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Validate start/goal feasibility\n        if self._is_in_obstacle(start_position, obstacles, is_3d) or self._is_in_obstacle(goal_position, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Initialize trees and spatial grids\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root = Node(goal_position, parent=None, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        grid_start = {}\n        grid_goal = {}\n        self._grid_insert(grid_start, start_root.position, start_root, cell_size, dim)\n        self._grid_insert(grid_goal, goal_root.position, goal_root, cell_size, dim)\n\n        start_time = time.time()\n\n        # Early straight-line check\n        if not self._is_edge_in_obstacle(start_position, goal_position, obstacles, is_3d, self.edge_resolution):\n            edges.append((start_root, goal_root))\n            direct_path = [start_position, goal_position]\n            return PlannerResult(True, direct_path, start_tree + goal_tree, edges)\n\n        # Main loop\n        for it in range(self.max_iter):\n            if time.time() - start_time >= self.time_limit_sec:\n                return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n            # Alternate tree growth\n            if it % 2 == 0:\n                grow_tree, grow_grid = start_tree, grid_start\n                other_tree, other_grid = goal_tree, grid_goal\n                a_is_start_side = True\n                other_root_pos = goal_root.position\n            else:\n                grow_tree, grow_grid = goal_tree, grid_goal\n                other_tree, other_grid = start_tree, grid_start\n                a_is_start_side = False\n                other_root_pos = start_root.position\n\n            sample = self._sample(bounds, obstacles, is_3d, other_root_pos)\n\n            # Extend grow_tree toward sample\n            a_near = self._nearest_from_grid(grow_tree, grow_grid, sample, cell_size, dim)\n            a_last = self._extend(grow_tree, grow_grid, a_near, sample, nodes, edges, obstacles, is_3d, bounds, cell_size, dim)\n            if a_last is None:\n                continue\n\n            # Greedy connect: extend other_tree toward the new node\n            b_near = self._nearest_from_grid(other_tree, other_grid, a_last.position, cell_size, dim)\n            b_last = self._extend(other_tree, other_grid, b_near, a_last.position, nodes, edges, obstacles, is_3d, bounds, cell_size, dim)\n            if b_last is None:\n                continue\n\n            # Attempt final short bridge\n            if self._distance(b_last.position, a_last.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(b_last.position, a_last.position, obstacles, is_3d, self.edge_resolution):\n                    edges.append((b_last, a_last))\n                    # Extract and smooth path\n                    final_path = self._assemble_path(a_last, b_last, a_is_start_side)\n                    remaining = max(0.0, self.time_limit_sec - (time.time() - start_time))\n                    budget = min(remaining, self.time_limit_sec * self.smooth_time_frac)\n                    final_path = self._shortcut_path(final_path, obstacles, is_3d, bounds, budget, self.smooth_attempts)\n                    return PlannerResult(True, final_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---- Utilities ----\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _within_bounds(self, p, bounds):\n        for i in range(len(bounds)):\n            if p[i] < 0.0 or p[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step_size):\n        d = self._distance(from_pos, to_pos)\n        if d <= step_size:\n            return to_pos\n        r = step_size / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    def _sample(self, bounds, obstacles, is_3d, other_root_pos):\n        # Bias toward the opposite root\n        if random.random() < self.bridge_bias_rate:\n            return other_root_pos\n        # Mild goal bias to encourage meeting/goal attraction\n        if random.random() < self.goal_sample_rate:\n            return other_root_pos\n        # Uniform rejection sampling in free space\n        dim = len(bounds)\n        for _ in range(30):\n            pt = tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n        # Fallback: last sample even if occupied (extend will reject)\n        return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n\n    def _extend(self, tree, grid, nearest_node, target_pos, nodes, edges, obstacles, is_3d, bounds, cell_size, dim):\n        current = nearest_node\n        last_new = None\n        while True:\n            step_pos = self._steer(current.position, target_pos, self.step_size)\n            if not self._within_bounds(step_pos, bounds):\n                break\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                break\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d, self.edge_resolution):\n                break\n            # Both node and edge are valid \u2192 commit\n            new_node = Node(step_pos)\n            new_node.cost = current.cost + self._distance(current.position, step_pos)\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node.position, new_node, cell_size, dim)\n            last_new = new_node\n            current = new_node\n            # Stop if reached target (within one step)\n            if self._distance(current.position, target_pos) <= self.step_size:\n                break\n        return last_new\n\n    def _assemble_path(self, a_node, b_node, a_is_start_side):\n        if a_is_start_side:\n            pa = a_node.path_from_root()   # start -> ... -> a\n            pb = b_node.path_from_root()   # goal  -> ... -> b\n            return pa + pb[::-1]           # start ... a, b ... goal\n        else:\n            pa = a_node.path_from_root()   # goal  -> ... -> a\n            pb = b_node.path_from_root()   # start -> ... -> b\n            return pb + pa[::-1]           # start ... b, a ... goal\n\n    # ---- Spatial grid for approximate nearest ----\n    def _cell_index(self, pos, cell_size, dim):\n        if dim == 2:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size))\n        else:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size), int(pos[2] // cell_size))\n\n    def _grid_insert(self, grid, pos, node, cell_size, dim):\n        idx = self._cell_index(pos, cell_size, dim)\n        if idx in grid:\n            grid[idx].append(node)\n        else:\n            grid[idx] = [node]\n\n    def _nearest_from_grid(self, tree, grid, point, cell_size, dim, max_rings=3):\n        # For small trees, just do linear scan\n        if len(tree) < 32:\n            return min(tree, key=lambda n: self._distance(n.position, point))\n\n        center = self._cell_index(point, cell_size, dim)\n        best = None\n        # Expand rings until some candidates found, then pick nearest among them\n        for r in range(0, max_rings + 1):\n            candidates = []\n            if dim == 2:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        idx = (center[0] + dx, center[1] + dy)\n                        if idx in grid:\n                            candidates.extend(grid[idx])\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            idx = (center[0] + dx, center[1] + dy, center[2] + dz)\n                            if idx in grid:\n                                candidates.extend(grid[idx])\n            if candidates:\n                best = min(candidates, key=lambda n: self._distance(n.position, point))\n                break\n\n        if best is None:\n            # Fallback to linear scan if grid empty nearby\n            best = min(tree, key=lambda n: self._distance(n.position, point))\n        return best\n\n    # ---- Collision utilities ----\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist / max(1e-6, resolution)))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    # ---- Path shortcutting ----\n    def _shortcut_path(self, path, obstacles, is_3d, bounds, time_budget, attempts):\n        if len(path) < 3:\n            return path\n        start_t = time.time()\n        pts = list(path)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and (time.time() - start_t) <= time_budget:\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            # Keep within bounds and collision-free\n            if not self._segment_within_bounds(a, b, bounds):\n                tries += 1\n                continue\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_resolution):\n                # Apply shortcut\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n            tries += 1\n        return pts\n\n    def _segment_within_bounds(self, a, b, bounds):\n        # The interpolated segment is within bounds if endpoints are; checks along the way via edge collision\n        for d in range(len(bounds)):\n            if a[d] < 0.0 or a[d] > bounds[d]:\n                return False\n            if b[d] < 0.0 or b[d] > bounds[d]:\n                return False\n        return True",
          "objective": -35.38986,
          "time_improvement": 79.0,
          "length_improvement": 6.0,
          "smoothness_improvement": 1571.0,
          "node_improvement": 81.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009288859367370606,
                    "num_nodes_avg": 87.5,
                    "path_length_avg": 179.7819366813108,
                    "smoothness_avg": 0.041891929272141075,
                    "success_improvement": 0.0,
                    "time_improvement": 63.57137981686718,
                    "node_improvement": 77.96524804835055,
                    "length_improvement": 1.4586716778820132,
                    "smoothness_improvement": 555.6996628894441,
                    "objective_score": 22.725115266236582
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009074711799621582,
                    "num_nodes_avg": 124.9,
                    "path_length_avg": 251.58839597257443,
                    "smoothness_avg": 0.10077141463831178,
                    "success_improvement": 0.0,
                    "time_improvement": 94.3352914641303,
                    "node_improvement": 91.6078747564335,
                    "length_improvement": 16.01255185389636,
                    "smoothness_improvement": 2492.9210813599107,
                    "objective_score": 50.372723958376454
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01003124713897705,
                    "num_nodes_avg": 215.4,
                    "path_length_avg": 148.33090891427284,
                    "smoothness_avg": 0.13860849885025553,
                    "success_improvement": 0.0,
                    "time_improvement": 79.54962026854608,
                    "node_improvement": 72.6128417037508,
                    "length_improvement": 1.4856730579993105,
                    "smoothness_improvement": 1663.0898743601072,
                    "objective_score": 33.07173928716395
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "FIBER-Connect*: Fast Informed Bidirectional RRT*-Connect with Cached Collisions and Local Rewiring \u2014 a bidirectional planner that blends informed sampling, grid-accelerated near/nearest, per-cell cost gating, limited RRT* rewiring, and multi-step connect-extend bridging; it maintains an edge-collision cache and applies visibility pruning plus shortcuts for short, smooth paths with low planning time.",
          "planning_mechanism": "Alternate expanding the two trees; sample with goal/line bias and informed-ellipsoid once a path exists; find nearest via grid rings, steer, and validate; select the lowest-cost parent among radius neighbors (LOS) and insert under per-cell cost gates; locally rewire a few neighbors to reduce path cost; then attempt multi-step connect from the opposite tree toward the new node and bridge on first free LOS; upon success, extract start\u2192meetA + meetB\u2192goal, visibility-prune and shortcut, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.22,\n                 line_bias=0.30,\n                 informed_tries=80,\n                 grid_cell_factor=1.5,\n                 max_per_cell=6,\n                 duplicate_radius_factor=0.5,\n                 rewire_k=10,\n                 rewire_depth=5,\n                 neighbor_radius_factor=3.0,\n                 connect_steps=6,\n                 smoothing_iters=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.informed_tries = informed_tries\n        self.grid_cell_factor = grid_cell_factor\n        self.max_per_cell = max_per_cell\n        self.duplicate_radius_factor = duplicate_radius_factor\n        self.rewire_k = rewire_k\n        self.rewire_depth = rewire_depth\n        self.neighbor_radius_factor = neighbor_radius_factor\n        self.connect_steps = connect_steps\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        self.edge_res = max(0.5, min(1.0, 0.5 * self.step_size))\n        self.cell_size = max(1.0, self.grid_cell_factor * self.step_size)\n        self.min_sep = max(0.3, self.duplicate_radius_factor * self.step_size)\n\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.append(g)\n            return PlannerResult(True, [start, goal], [s, g], [(s, g)])\n\n        s_root = Node(start, None, 0.0)\n        g_root = Node(goal, None, 0.0)\n\n        start_tree = [s_root]\n        goal_tree = [g_root]\n        nodes = [s_root, g_root]\n        edges = []\n\n        grid_s = {}\n        grid_g = {}\n        counts_s = {}\n        counts_g = {}\n        bestcost_s = {}\n        bestcost_g = {}\n\n        self._grid_add(grid_s, counts_s, bestcost_s, s_root)\n        self._grid_add(grid_g, counts_g, bestcost_g, g_root)\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_s if active_start else grid_g\n            grid_b = grid_g if active_start else grid_s\n            counts_a = counts_s if active_start else counts_g\n            counts_b = counts_g if active_start else counts_s\n            bestcost_a = bestcost_s if active_start else bestcost_g\n            bestcost_b = bestcost_g if active_start else bestcost_s\n            root_other = goal if active_start else start\n\n            x_rand = self._sample(obstacles, is_3d, start, goal, best_len, root_other)\n\n            n_near = self._nearest(grid_a, tree_a, x_rand)\n            x_new = self._steer(n_near.position, x_rand)\n            if not self._in_bounds(x_new):\n                continue\n            if self._is_in_obstacle(x_new, obstacles, is_3d):\n                continue\n            if self._edge_blocked(n_near.position, x_new, obstacles, is_3d):\n                continue\n            if self._near_duplicate(grid_a, x_new, self.min_sep):\n                continue\n\n            r_near = max(self.neighbor_radius_factor * self.step_size, self.step_size)\n            neigh = self._near(grid_a, x_new, r_near)\n            parent, new_cost = self._choose_parent(neigh, n_near, x_new, obstacles, is_3d)\n\n            key_new = self._grid_key(x_new)\n            ccount = counts_a.get(key_new, 0)\n            bestc = bestcost_a.get(key_new, float('inf'))\n            if ccount >= self.max_per_cell and not (new_cost + 1e-12 < bestc):\n                continue\n\n            new_node = Node(x_new, None, new_cost)\n            new_node.attach(parent)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(grid_a, counts_a, bestcost_a, new_node)\n\n            if neigh:\n                self._rewire(new_node, neigh, obstacles, is_3d, edges)\n\n            meet_b, bridged = self._connect_toward(tree_b, grid_b, counts_b, bestcost_b, new_node.position, obstacles, is_3d)\n            if meet_b is None:\n                meet_candidate = self._nearest(grid_b, tree_b, new_node.position)\n                if meet_candidate is not None and not self._edge_blocked(new_node.position, meet_candidate.position, obstacles, is_3d):\n                    meet_b = meet_candidate\n                    bridged = True\n\n            if bridged and meet_b is not None:\n                if active_start:\n                    a = new_node\n                    b = meet_b\n                else:\n                    a = meet_b\n                    b = new_node\n                if not self._edge_blocked(a.position, b.position, obstacles, is_3d):\n                    edges.append((a, b))\n                    path = self._extract_path(a, b)\n                    path = self._visibility_prune(path, obstacles, is_3d)\n                    path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _uniform_point(self):\n        if self.dim == 3:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]),\n                    self._uniform(0.0, self.bounds[2]))\n        else:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]))\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos):\n        d = self._dist(from_pos, to_pos)\n        if d <= 1e-12:\n            return self._clamp(from_pos)\n        if d <= self.step_size:\n            return self._clamp(to_pos)\n        r = self.step_size / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _segment_hits(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        if k in self._edge_cache:\n            return self._edge_cache[k]\n        blocked = self._segment_hits(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, bestcost, node):\n        k = self._grid_key(node.position)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n        counts[k] = counts.get(k, 0) + 1\n        prev = bestcost.get(k, None)\n        if prev is None or node.cost < prev:\n            bestcost[k] = node.cost\n\n    def _grid_collect_ring(self, grid, key, r):\n        cand = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        return cand\n\n    def _nearest(self, grid, nodes, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        cand_total = []\n        r = 0\n        max_r = 4\n        while r <= max_r and len(cand_total) < 12:\n            cand_total.extend(self._grid_collect_ring(grid, key, r))\n            r += 1\n        if cand_total:\n            for n in cand_total:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            return best\n        if nodes:\n            trials = min(64, len(nodes))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(nodes)))\n                n = nodes[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _near(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        rng = int(max(1, radius // self.cell_size)) + 1\n        cand = []\n        if self.dim == 3:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        cand = self._grid_collect_ring(grid, key, 1)\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                return True\n        return False\n\n    def _choose_parent(self, neighbors, fallback_near, new_pos, obstacles, is_3d):\n        best_parent = fallback_near\n        best_cost = fallback_near.cost + self._dist(fallback_near.position, new_pos)\n        for n in neighbors:\n            if n is fallback_near:\n                continue\n            if not self._edge_blocked(n.position, new_pos, obstacles, is_3d):\n                c = n.cost + self._dist(n.position, new_pos)\n                if c + 1e-12 < best_cost:\n                    best_cost = c\n                    best_parent = n\n        return best_parent, best_cost\n\n    def _can_rewire(self, node, new_parent):\n        cur = new_parent\n        while cur is not None:\n            if cur is node:\n                return False\n            cur = cur.parent\n        return True\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                edges.pop(i)\n                break\n\n    def _propagate_cost(self, node, edges, depth):\n        if depth <= 0:\n            return\n        for ch in node.children:\n            old = ch.cost\n            ch.cost = node.cost + self._dist(node.position, ch.position)\n            if abs(ch.cost - old) > 1e-12:\n                self._propagate_cost(ch, edges, depth - 1)\n\n    def _rewire(self, new_node, neighbors, obstacles, is_3d, edges):\n        if not neighbors:\n            return\n        cand = []\n        for n in neighbors:\n            if n is new_node or n is new_node.parent:\n                continue\n            cand.append((self._dist(n.position, new_node.position), n))\n        cand.sort(key=lambda t: t[0])\n        limit = min(self.rewire_k, len(cand))\n        for i in range(limit):\n            n = cand[i][1]\n            if not self._can_rewire(n, new_node):\n                continue\n            if self._edge_blocked(new_node.position, n.position, obstacles, is_3d):\n                continue\n            new_cost = new_node.cost + self._dist(new_node.position, n.position)\n            if new_cost + 1e-12 < n.cost:\n                old_parent = n.parent\n                n.attach(new_node)\n                n.cost = new_cost\n                if old_parent is not None:\n                    self._remove_edge(edges, old_parent, n)\n                edges.append((new_node, n))\n                self._propagate_cost(n, edges, self.rewire_depth)\n\n    def _extend_toward(self, tree, grid, counts, bestcost, target_pos, obstacles, is_3d):\n        current = self._nearest(grid, tree, target_pos)\n        last = current\n        for _ in range(self.connect_steps):\n            nxt = self._steer(current.position, target_pos)\n            if not self._in_bounds(nxt):\n                break\n            if self._is_in_obstacle(nxt, obstacles, is_3d):\n                break\n            if self._edge_blocked(current.position, nxt, obstacles, is_3d):\n                break\n            if self._near_duplicate(grid, nxt, self.min_sep):\n                break\n            r_near = max(self.neighbor_radius_factor * self.step_size, self.step_size)\n            neigh = self._near(grid, nxt, r_near)\n            parent, new_cost = self._choose_parent(neigh, current, nxt, obstacles, is_3d)\n            key_new = self._grid_key(nxt)\n            ccount = counts.get(key_new, 0)\n            bestc = bestcost.get(key_new, float('inf'))\n            if ccount >= self.max_per_cell and not (new_cost + 1e-12 < bestc):\n                break\n            newn = Node(nxt, None, new_cost)\n            newn.attach(parent)\n            tree.append(newn)\n            self._grid_add(grid, counts, bestcost, newn)\n            last = newn\n            current = newn\n            if self._dist(nxt, target_pos) <= self.step_size:\n                break\n        return last\n\n    def _connect_toward(self, tree_b, grid_b, counts_b, bestcost_b, a_pos, obstacles, is_3d):\n        last = self._extend_toward(tree_b, grid_b, counts_b, bestcost_b, a_pos, obstacles, is_3d)\n        if last is None:\n            return None, False\n        if not self._edge_blocked(last.position, a_pos, obstacles, is_3d):\n            return last, True\n        return last, False\n\n    def _path_to_root(self, node):\n        seq = []\n        cur = node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _extract_path(self, meet_a, meet_b):\n        pa = self._path_to_root(meet_a)\n        pb = []\n        cur = meet_b\n        while cur is not None:\n            pb.append(cur.position)\n            cur = cur.parent\n        return pa + pb\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        n = len(path)\n        i = 0\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts\n\n    def _sample(self, obstacles, is_3d, start, goal, best_len, attractor):\n        r = self._rand()\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        if best_len < float('inf'):\n            for _ in range(self.informed_tries):\n                p = self._uniform_point()\n                if self._dist(p, start) + self._dist(p, goal) <= best_len and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jit = 0.5 * self.step_size\n            if self.dim == 3:\n                p = (self._clamp((base[0] + self._uniform(-jit, jit), base[1] + self._uniform(-jit, jit), base[2] + self._uniform(-jit, jit))))\n            else:\n                p = (min(max(base[0] + self._uniform(-jit, jit), 0.0), self.bounds[0]),\n                     min(max(base[1] + self._uniform(-jit, jit), 0.0), self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        while True:\n            p = self._uniform_point()\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p",
          "objective": -35.01262,
          "time_improvement": 55.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1329.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016425013542175293,
                    "num_nodes_avg": 47.0,
                    "path_length_avg": 154.62508050902176,
                    "smoothness_avg": 0.04071980109549708,
                    "success_improvement": 0.0,
                    "time_improvement": 33.4245918733191,
                    "node_improvement": 88.16419038025687,
                    "length_improvement": 15.247543181809576,
                    "smoothness_improvement": 537.3533116078908,
                    "objective_score": 21.86267002912093
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04094517230987549,
                    "num_nodes_avg": 124.0,
                    "path_length_avg": 229.46535757937585,
                    "smoothness_avg": 0.08684323820145955,
                    "success_improvement": 0.0,
                    "time_improvement": 75.51881386278623,
                    "node_improvement": 91.66834643553047,
                    "length_improvement": 23.397858845899172,
                    "smoothness_improvement": 2134.539069579714,
                    "objective_score": 47.36705481427394
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022255563735961915,
                    "num_nodes_avg": 88.0,
                    "path_length_avg": 119.3089523489693,
                    "smoothness_avg": 0.11130492356865981,
                    "success_improvement": 0.0,
                    "time_improvement": 55.909249570294364,
                    "node_improvement": 88.81118881118881,
                    "length_improvement": 20.760674731610354,
                    "smoothness_improvement": 1315.790412118499,
                    "objective_score": 35.80813177064702
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "FLASH-IBiConnect: Fast, Lightweight, Adaptive\u2011Stride, Hashed Informed Bi\u2011Connect planner. It accelerates bidirectional exploration with early throttling before collisions, adaptive multi\u2011step steering, bounded Connect\u2011style bridging, and cached edge tests. A greedy visibility pass plus a few shortcuts refine the first solution with minimal overhead.",
          "planning_mechanism": "Alternate expanding start/goal trees using hashed-grid nearest neighbors; for each sample, pick the nearest, then adaptively stride 1\u20133 steps toward the target while skipping saturated/duplicate cells before doing any collision tests. Insert only if both node and edge are free. After each insertion, greedily Connect the opposite tree toward the new node for a few steps, stopping on the first valid bridge. Maintain exact/quantized blocked edge caches to avoid repeated tests. On success, extract, visibility-prune, then lightly shortcut the path and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=6.0,\n                 goal_bias=0.35,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=24,\n                 max_per_cell=8,\n                 search_r_max=2,\n                 max_stride_steps=3,\n                 connect_steps=6,\n                 dup_radius_factor=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n        self.max_per_cell = max_per_cell\n        self.search_r_max = search_r_max\n        self.max_stride_steps = max_stride_steps\n        self.connect_steps = connect_steps\n        self.dup_radius_factor = dup_radius_factor\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        # Caches\n        self._edge_blocked_cache = set()  # quantized blocked segments only\n        self._edge_exact_cache = {}       # (a,b) exact -> bool\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Parameters derived\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size * 1.1)\n        self.edge_res = max(0.5, self.collision_step)\n\n        # Reset caches\n        self._edge_blocked_cache = set()\n        self._edge_exact_cache = {}\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            path = [start, goal]\n            path = self._visibility_prune(path, obstacles, is_3d)\n            path = self._shortcut_smooth(path, obstacles, is_3d, max(4, self.smoothing_iters // 3))\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Initialize trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Grids and counts\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n        self._grid_add(grid_start, counts_start, start_root)\n        self._grid_add(grid_goal, counts_goal, goal_root)\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            grid_a = grid_start if active_start else grid_goal\n            counts_a = counts_start if active_start else counts_goal\n\n            tree_b = goal_tree if active_start else start_tree\n            grid_b = grid_goal if active_start else grid_start\n            counts_b = counts_goal if active_start else counts_start\n\n            root_other = goal if active_start else start\n\n            # Sample with goal/opposite-root bias\n            if self._rand() < self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest lookup\n            nearest = self._nearest_hashed(grid_a, tree_a, x_rand)\n            if nearest is None:\n                continue\n\n            # Adaptive stride toward sample with pre-throttling before collision checks\n            cand_pos = None\n            dist_to_rand = self._dist(nearest.position, x_rand)\n            if dist_to_rand < 1e-9:\n                continue\n            for stride in range(1, self.max_stride_steps + 1):\n                step = min(self.step_size * stride, dist_to_rand)\n                new_pos = self._interpolate(nearest.position, x_rand, step / dist_to_rand)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                # Per-cell throttling and near-dup suppression before edge checks\n                k_new = self._grid_key(new_pos)\n                if self._cell_count(counts_a, k_new) >= self.max_per_cell:\n                    continue\n                if self._near_duplicate(grid_a, new_pos, self.dup_radius_factor * self.step_size):\n                    continue\n                # Candidate accepted; check edge\n                if not self._edge_blocked(nearest.position, new_pos, obstacles, is_3d):\n                    cand_pos = new_pos\n                    break\n\n            if cand_pos is None:\n                continue\n\n            # Insert node and edge (both node and edge have been checked)\n            new_node = Node(cand_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, cand_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, counts_a, new_node)\n\n            # Try bounded Connect from the other tree toward new_node\n            meet = self._connect_toward(tree_b, grid_b, counts_b, new_node.position, obstacles, is_3d, edges)\n            if meet is not None:\n                # Build path\n                path = self._extract_path(new_node, meet, a_is_start_tree=active_start)\n                path = self._visibility_prune(path, obstacles, is_3d)\n                path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ------------- Random -------------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------- Geometry -------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _interpolate(self, a, b, t):\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim)))\n\n    # ------------- Collision & caches -------------\n    def _quant(self, p, q=1.5):\n        if self.dim == 3:\n            return (int(p[0] // q), int(p[1] // q), int(p[2] // q))\n        else:\n            return (int(p[0] // q), int(p[1] // q))\n\n    def _seg_key_exact(self, a, b):\n        if a <= b:\n            return (a, b)\n        else:\n            return (b, a)\n\n    def _seg_key_quant_blocked(self, a, b):\n        qa = self._quant(a)\n        qb = self._quant(b)\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k_exact = self._seg_key_exact(a, b)\n        cached = self._edge_exact_cache.get(k_exact)\n        if cached is not None:\n            return cached\n        kq = self._seg_key_quant_blocked(a, b)\n        if kq in self._edge_blocked_cache:\n            self._edge_exact_cache[k_exact] = True\n            return True\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_exact_cache[k_exact] = blocked\n        if blocked:\n            self._edge_blocked_cache.add(kq)\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ------------- Sampling -------------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ------------- Grid / NN -------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n\n    def _cell_count(self, counts, key):\n        return counts.get(key, 0)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.search_r_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback: random subset\n        if tree:\n            trials = min(64, len(tree))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(tree)))\n                n = tree[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _near_duplicate(self, grid, pos, dup_radius):\n        key = self._grid_key(pos)\n        cand = self._grid_ring_collect(grid, key, 1)\n        rr = dup_radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # ------------- Connect -------------\n    def _connect_toward(self, tree, grid, counts, target_pos, obstacles, is_3d, edges):\n        # Find a starting node in this tree nearest to target\n        nearest = self._nearest_hashed(grid, tree, target_pos)\n        if nearest is None:\n            return None\n\n        cur = nearest\n        for _ in range(self.connect_steps):\n            d = self._dist(cur.position, target_pos)\n            if d <= self.step_size:\n                # Attempt direct bridge (edge check only; target node already validated earlier)\n                if not self._edge_blocked(cur.position, target_pos, obstacles, is_3d):\n                    return cur\n                else:\n                    return None\n            # Propose next step toward target with pre-throttling\n            new_pos = self._interpolate(cur.position, target_pos, self.step_size / d)\n            if not self._in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            k_new = self._grid_key(new_pos)\n            if self._cell_count(counts, k_new) >= self.max_per_cell or self._near_duplicate(grid, new_pos, self.dup_radius_factor * self.step_size):\n                # Try skipping ahead one extra step if possible\n                if d > 2 * self.step_size:\n                    new_pos2 = self._interpolate(cur.position, target_pos, (2.0 * self.step_size) / d)\n                    if self._in_bounds(new_pos2) and (not self._is_in_obstacle(new_pos2, obstacles, is_3d)):\n                        k_new2 = self._grid_key(new_pos2)\n                        if self._cell_count(counts, k_new2) < self.max_per_cell and (not self._near_duplicate(grid, new_pos2, self.dup_radius_factor * self.step_size)):\n                            if not self._edge_blocked(cur.position, new_pos2, obstacles, is_3d):\n                                n2 = Node(new_pos2, parent=cur, cost=cur.cost + self._dist(cur.position, new_pos2))\n                                cur.add_child(n2)\n                                tree.append(n2)\n                                edges.append((cur, n2))\n                                self._grid_add(grid, counts, n2)\n                                cur = n2\n                                continue\n                return None\n            if self._edge_blocked(cur.position, new_pos, obstacles, is_3d):\n                return None\n            # Commit\n            nxt = Node(new_pos, parent=cur, cost=cur.cost + self._dist(cur.position, new_pos))\n            cur.add_child(nxt)\n            tree.append(nxt)\n            edges.append((cur, nxt))\n            self._grid_add(grid, counts, nxt)\n            cur = nxt\n        # Final attempt if close enough\n        if self._dist(cur.position, target_pos) <= self.step_size and not self._edge_blocked(cur.position, target_pos, obstacles, is_3d):\n            return cur\n        return None\n\n    # ------------- Path -------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -34.17161,
          "time_improvement": 53.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1656.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017466092109680177,
                    "num_nodes_avg": 62.6,
                    "path_length_avg": 163.87259344320734,
                    "smoothness_avg": 0.04964655781883516,
                    "success_improvement": 0.0,
                    "time_improvement": 29.204794407362268,
                    "node_improvement": 84.2357088894485,
                    "length_improvement": 10.178834806362733,
                    "smoothness_improvement": 677.0764390906203,
                    "objective_score": 18.25412140147942
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05110058784484863,
                    "num_nodes_avg": 150.2,
                    "path_length_avg": 234.1330981250513,
                    "smoothness_avg": 0.10546763418938201,
                    "success_improvement": 0.0,
                    "time_improvement": 69.44687414469483,
                    "node_improvement": 89.90794866626352,
                    "length_improvement": 21.839632698290526,
                    "smoothness_improvement": 2613.7581929591665,
                    "objective_score": 47.0066328271786
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.020591354370117186,
                    "num_nodes_avg": 111.5,
                    "path_length_avg": 122.69634602394744,
                    "smoothness_avg": 0.13971203959587924,
                    "success_improvement": 0.0,
                    "time_improvement": 59.20623367201239,
                    "node_improvement": 85.82326764144946,
                    "length_improvement": 18.510929143043064,
                    "smoothness_improvement": 1677.1268311895358,
                    "objective_score": 37.254061743377235
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "ARC-BiRRT: Adaptive Reuse-Cached, Ring-Hashed, Cost-Gated BiRRT-Connect. It accelerates bidirectional planning with exact edge-collision memoization, ring-hash nearest search, local LOS parent selection, per-cell cost-gated admission, and single-shot tree bridging; upon success it applies cache-reused visibility pruning and bounded shortcut smoothing for shorter, smoother paths.",
          "planning_mechanism": "Alternate expanding start/goal trees with small-beam guided sampling (goal/corridor bias); find a near node via ring-hash, steer one step, enforce node+edge checks and near-duplicate rejection; pick a best-cost parent among nearby ring neighbors that see the new point; admit only if per-cell capacity or cost improves; after insertion, attempt a direct LOS bridge to the opposite tree; on success, extract and cache-prune/shortcut the path and stop early.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=7.5,\n        beam_width=2,\n        goal_bias=0.3,\n        grid_cell_factor=1.6,\n        ring_max=3,\n        max_per_cell=6,\n        min_sep_factor=0.5,\n        los_neighbor_rings=1,\n        smoothing_iters=50,\n        corridor_bias=0.5\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.ring_max = ring_max\n        self.max_per_cell = max_per_cell\n        self.min_sep_factor = min_sep_factor\n        self.los_neighbor_rings = los_neighbor_rings\n        self.smoothing_iters = smoothing_iters\n        self.corridor_bias = corridor_bias\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        # RNG state\n        self._lcg_state = 2463534242\n\n        # Caches\n        self._edge_cache = {}  # exact endpoints (ordered) -> bool blocked\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Derived params\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.3, self.step_size * self.min_sep_factor)\n        self.edge_res = max(0.5, min(1.0, self.step_size * 0.5))\n\n        # Reset caches\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            path = [start, goal]\n            path = self._visibility_prune(path, obstacles, is_3d)\n            path = self._shortcut_smooth(path, obstacles, is_3d, iters=min(10, self.smoothing_iters))\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Initialize trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n        bestcost_start = {}\n        bestcost_goal = {}\n\n        self._grid_add(grid_start, counts_start, bestcost_start, start_root)\n        self._grid_add(grid_goal, counts_goal, bestcost_goal, goal_root)\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n\n            tree_a = start_tree if active_start else goal_tree\n            grid_a = grid_start if active_start else grid_goal\n            counts_a = counts_start if active_start else counts_goal\n            bestcost_a = bestcost_start if active_start else bestcost_goal\n\n            tree_b = goal_tree if active_start else start_tree\n            grid_b = grid_goal if active_start else grid_start\n            counts_b = counts_goal if active_start else counts_start\n            bestcost_b = bestcost_goal if active_start else bestcost_start\n\n            attractor = goal if active_start else start\n\n            for _ in range(self.beam_width):\n                x_rand = self._guided_sample(obstacles, is_3d, attractor)\n\n                nearest = self._nearest_hashed(grid_a, tree_a, x_rand)\n                if nearest is None:\n                    continue\n\n                new_pos = self._steer(nearest.position, x_rand)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._edge_blocked(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                if self._near_duplicate(grid_a, new_pos, self.min_sep):\n                    continue\n\n                # Choose a parent among local neighbors with LOS (limited rings) for better path cost\n                parent = self._choose_parent_local(grid_a, new_pos, nearest, obstacles, is_3d)\n                if self._edge_blocked(parent.position, new_pos, obstacles, is_3d):\n                    continue  # safety\n\n                new_cost = parent.cost + self._dist(parent.position, new_pos)\n\n                # Per-cell cost-gated admission\n                key_new = self._grid_key(new_pos)\n                ccount = counts_a.get(key_new, 0)\n                bestc = bestcost_a.get(key_new, float('inf'))\n                if ccount >= self.max_per_cell and not (new_cost + 1e-9 < bestc):\n                    continue\n\n                # Insert node\n                new_node = Node(new_pos, parent=parent, cost=new_cost)\n                parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((parent, new_node))\n                self._grid_add(grid_a, counts_a, bestcost_a, new_node)\n\n                # Try single-shot direct bridge to the other tree\n                other_near = self._nearest_hashed(grid_b, tree_b, new_node.position)\n                if other_near is not None:\n                    if not self._edge_blocked(new_node.position, other_near.position, obstacles, is_3d):\n                        path = self._extract_path(new_node, other_near, a_is_start_tree=active_start)\n                        path = self._visibility_prune(path, obstacles, is_3d)\n                        path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos):\n        d = self._dist(from_pos, to_pos)\n        if d <= 1e-9:\n            return self._clamp(from_pos)\n        if d <= self.step_size:\n            return self._clamp(to_pos)\n        r = self.step_size / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision and caching\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        if k in self._edge_cache:\n            return self._edge_cache[k]\n        blocked = self._segment_hits(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_hits(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _guided_sample(self, obstacles, is_3d, attractor):\n        # Goal-biased with optional corridor pull (activated only after success; here kept generic)\n        if self._rand() < self.goal_bias:\n            p = attractor\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # Mild blend toward attractor\n        alpha = 0.2\n        if self.dim == 3:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]),\n                   self._uniform(0.0, self.bounds[2]))\n            p = tuple(alpha * attractor[i] + (1.0 - alpha) * rnd[i] for i in range(3))\n        else:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]))\n            p = tuple(alpha * attractor[i] + (1.0 - alpha) * rnd[i] for i in range(2))\n        if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    # Grid / NN\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, bestcost, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n        bc = bestcost.get(k)\n        if bc is None or node.cost < bc:\n            bestcost[k] = node.cost\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.ring_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback to limited random subset to avoid O(N)\n        if not tree:\n            return None\n        trials = min(64, len(tree))\n        for _ in range(trials):\n            idx = int(self._uniform(0, len(tree)))\n            n = tree[idx]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r = 1\n        cand = self._grid_ring_collect(grid, key, r)\n        rr = radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # Parent selection among local neighbors with LOS\n    def _choose_parent_local(self, grid, new_pos, fallback_nearest, obstacles, is_3d):\n        key = self._grid_key(new_pos)\n        best_parent = fallback_nearest\n        best_cost = fallback_nearest.cost + self._dist(fallback_nearest.position, new_pos)\n        max_r = max(1, self.los_neighbor_rings)\n        for r in range(0, max_r + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            for n in cand:\n                if n is fallback_nearest or n is best_parent:\n                    pass\n                # Check LOS\n                if not self._edge_blocked(n.position, new_pos, obstacles, is_3d):\n                    c = n.cost + self._dist(n.position, new_pos)\n                    if c + 1e-9 < best_cost:\n                        best_cost = c\n                        best_parent = n\n        return best_parent\n\n    # Path\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -33.74569,
          "time_improvement": 58.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1051.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010497808456420898,
                    "num_nodes_avg": 34.0,
                    "path_length_avg": 154.57051194099205,
                    "smoothness_avg": 0.03958955729868922,
                    "success_improvement": 0.0,
                    "time_improvement": 58.830179046785545,
                    "node_improvement": 91.4379249559305,
                    "length_improvement": 15.277453078640955,
                    "smoothness_improvement": 519.6625418241595,
                    "objective_score": 29.41383827034103
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.049208974838256835,
                    "num_nodes_avg": 116.0,
                    "path_length_avg": 236.11546529476226,
                    "smoothness_avg": 0.06943512420354042,
                    "success_improvement": 0.0,
                    "time_improvement": 69.28227518814471,
                    "node_improvement": 92.20587247194786,
                    "length_improvement": 21.177861477765767,
                    "smoothness_improvement": 1686.6157578555544,
                    "objective_score": 41.92447823238064
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026494455337524415,
                    "num_nodes_avg": 117.0,
                    "path_length_avg": 122.03531483713664,
                    "smoothness_avg": 0.08227711903121854,
                    "success_improvement": 0.0,
                    "time_improvement": 45.98660915000911,
                    "node_improvement": 85.12396694214877,
                    "length_improvement": 18.94995458240024,
                    "smoothness_improvement": 946.5588810119002,
                    "objective_score": 29.898749899502377
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "QUICKSILVER-IBiRRT#: Quick Informed Bidirectional RRT with Low-Dispersion Sampling, Sparse Best-Parent, and Direct-Connect. It accelerates planning with Halton-guided samples and ring-hash nearest queries, reduces detours via best-parent plus short ancestor compression and light rewiring, and minimizes post-processing by immediate visibility collapse and targeted shortcuts. A strict direct-connect (no opposite-tree growth) avoids node bloat, while adaptive neighbor radii and step sizes cut search time.",
          "planning_mechanism": "Alternate expanding two trees. Each iteration: draw a bounded Halton/uniform/corridor sample (switch to an informed ellipse after any solution). From the nearest node, steer one step; pick a best parent from local neighbors (with edge checks), then attempt short ancestor compression if visible. Insert the node (only if node- and edge-safe) and lightly rewire cheaper neighbors. Try a direct connect to the opposite tree\u2019s nearest; on success, extract the path, apply visibility collapse, shortcutting, and corner rounding, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=7.5,\n                 goal_bias=0.18,\n                 corridor_bias=0.30,\n                 ellipse_bias=0.52,\n                 grid_cell_factor=1.6,\n                 k_parent=8,\n                 k_rewire=6,\n                 min_sep_ratio=0.18,\n                 smoothing_attempts=140,\n                 improve_iters=0):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.ellipse_bias = float(ellipse_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.k_parent = int(max(1, k_parent))\n        self.k_rewire = int(max(0, k_rewire))\n        self.min_sep_ratio = float(min_sep_ratio)\n        self.smoothing_attempts = int(max(0, smoothing_attempts))\n        self.improve_iters = int(max(0, improve_iters))\n        self._rng = 123456789\n        self._halton_idx = 1\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self._is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if hasattr(map, 'obstacles') and map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        # Bounds and feasibility checks\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Trivial straight line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._refine_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize spatial and dynamic parameters\n        diag = (sum((self.bounds[i]) * (self.bounds[i]) for i in range(self.dim))) ** 0.5\n        self.step = max(1.0, min(self.step, 0.08 * diag))\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.min_sep = max(0.2, self.step * self.min_sep_ratio)\n        self.connect_step = max(self.step, 1.8 * self.step)\n        self.dup_thresh = max(0.35, 0.7 * self.step)\n\n        # Trees\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        Ta = [a_root]\n        Tb = [b_root]\n        nodes.extend([a_root, b_root])\n\n        G_a = {}\n        G_b = {}\n        self._grid_add(G_a, a_root)\n        self._grid_add(G_b, b_root)\n\n        best_len = None\n        incumbent_path = None\n\n        for it in range(self.max_iter):\n            # Alternate active tree\n            if (it & 1) == 0:\n                A, B = Ta, Tb\n                GA, GB = G_a, G_b\n                target_root = self.goal\n            else:\n                A, B = Tb, Ta\n                GA, GB = G_b, G_a\n                target_root = self.start\n\n            # Adaptive neighbor radius (shrinks with growth)\n            Ra = self._adaptive_radius(len(A) + len(B))\n            # Guided sample (Halton/uniform/corridor/informed)\n            sp = self._guided_sample(target_root, best_len)\n            if sp is None:\n                continue\n\n            # Nearest in active tree\n            near = self._nearest(GA, sp)\n            if near is None:\n                continue\n\n            newp = self._steer(near.position, sp, self.step)\n            if (not self._in_bounds(newp)) or self._point_blocked(newp):\n                continue\n            if self._too_close(GA, newp, self.min_sep):\n                continue\n\n            # Best parent among neighbors including anchor\n            neigh = self._neighbors(GA, newp, Ra)\n            if not neigh:\n                neigh = [near]\n            cand_parents = self._select_k_by_dist(neigh, newp, self.k_parent)\n            parent = None\n            gbest = 1e100\n            for nb in cand_parents:\n                if not self._edge_free(nb.position, newp):\n                    continue\n                gc = nb.cost + self._dist(nb.position, newp)\n                if gc < gbest:\n                    gbest = gc\n                    parent = nb\n            if parent is None:\n                continue\n\n            # Short ancestor compression (deepen if beneficial)\n            anc = parent\n            hops = 0\n            while anc.parent is not None and hops < 6:\n                up = anc.parent\n                if self._edge_free(up.position, newp):\n                    gc = up.cost + self._dist(up.position, newp)\n                    if gc + 1e-12 < gbest:\n                        gbest = gc\n                        parent = up\n                anc = up\n                hops += 1\n\n            # Final checks before insertion (both checks)\n            if self._point_blocked(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, gbest)\n            parent.add_child(nn)\n            A.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(GA, nn)\n\n            # Light local rewiring to reduce path length\n            if self.k_rewire > 0:\n                self._rewire_local(nn, GA, edges, radius=Ra)\n\n            # Direct connect attempt to the other tree (no bloat)\n            other = self._nearest(GB, nn.position)\n            if other is not None and self._edge_free(nn.position, other.position):\n                path = self._merge_path(nn, other)\n                raw_len = self._path_len(path)\n                if best_len is None or raw_len < best_len:\n                    best_len = raw_len\n                    incumbent_path = path\n                path = self._refine_path(path)\n                return PlannerResult(True, path, Ta + Tb, edges)\n\n        # If loop ends without direct connect, optionally refine any incumbent\n        if incumbent_path is not None:\n            path = self._refine_path(incumbent_path)\n            return PlannerResult(True, path, Ta + Tb, edges)\n\n        return PlannerResult(False, [], Ta + Tb, edges)\n\n    # ---------- RNG and low-disersion sampling ----------\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            iv = int((v + 0.12345) * 2654435761) & 0xffffffff\n            s ^= (iv + 0x9E3779B97F4A7C15) & 0xffffffff\n            s = ((s << 13) ^ (s >> 17) ^ (s << 7)) & 0xffffffff\n        s ^= (len(self.obstacles) * 1103515245) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n        self._halton_idx = 1\n\n    def _randu(self):\n        x = self._rng\n        x ^= (x << 13) & 0xffffffff\n        x ^= (x >> 17) & 0xffffffff\n        x ^= (x << 5) & 0xffffffff\n        self._rng = x & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rad_inv(self, n, base):\n        inv = 0.0\n        f = 1.0 / base\n        while n > 0:\n            inv += f * (n % base)\n            n //= base\n            f /= base\n        return inv\n\n    def _halton(self, idx):\n        if self._is3:\n            return (self._rad_inv(idx, 2), self._rad_inv(idx, 3), self._rad_inv(idx, 5))\n        else:\n            return (self._rad_inv(idx, 2), self._rad_inv(idx, 3))\n\n    # ---------- Geometry ----------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # ---------- Spatial hashing ----------\n    def _cell_key(self, p):\n        if self._is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _neighbors(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        span = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self._is3:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        # Expand rings up to 3; then fallback scan\n        for r in range(0, 4):\n            cand = []\n            if self._is3:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                            if lst:\n                                cand += lst\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy))\n                        if lst:\n                            cand += lst\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback full scan\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _select_k_by_dist(self, nodes, pos, k):\n        if not nodes:\n            return []\n        # Partial selection without heavy sorts\n        buf = []\n        for nd in nodes:\n            buf.append((self._dist2(nd.position, pos), nd))\n        # Simple selection of k smallest\n        k = min(k, len(buf))\n        # Manual partial ordering\n        for i in range(k):\n            mi = i\n            mv = buf[i][0]\n            for j in range(i + 1, len(buf)):\n                if buf[j][0] < mv:\n                    mi = j\n                    mv = buf[j][0]\n            if mi != i:\n                buf[i], buf[mi] = buf[mi], buf[i]\n        return [buf[i][1] for i in range(k)]\n\n    def _too_close(self, grid, pos, radius):\n        neigh = self._neighbors(grid, pos, radius)\n        return len(neigh) > 0\n\n    # ---------- Obstacles & collision ----------\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self._is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            self._obin_add((i, j, k), idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        self._obin_add((i, j), idx)\n\n    def _obin_add(self, key, idx):\n        lst = self.obin.get(key)\n        if lst is None:\n            self.obin[key] = [idx]\n        else:\n            lst.append(idx)\n\n    def _bucket_candidates(self, a, b):\n        if self._is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self.obin.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            return cand\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self.obin.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            return cand\n\n    def _point_blocked(self, p):\n        if self._is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            lst = self.obin.get((ix, iy, iz))\n            if not lst:\n                return False\n            x, y, z = p\n            for idx in lst:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            lst = self.obin.get((ix, iy))\n            if not lst:\n                return False\n            x, y = p\n            for idx in lst:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        cand = self._bucket_candidates(a, b)\n        if not cand:\n            return True\n        if self._is3:\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            q = p1[i]\n            d = q - p\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # ---------- Rewiring ----------\n    def _rewire_local(self, new_node, grid, edges, radius):\n        neigh = self._neighbors(grid, new_node.position, radius)\n        if not neigh:\n            return\n        cands = self._select_k_by_dist(neigh, new_node.position, self.k_rewire)\n        for nb in cands:\n            if nb is new_node or nb is new_node.parent:\n                continue\n            # Prevent cycles\n            cur = new_node\n            cyc = False\n            while cur is not None:\n                if cur is nb:\n                    cyc = True\n                    break\n                cur = cur.parent\n            if cyc:\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            cand_cost = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand_cost + 1e-9 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, oldp, nb)\n                new_node.add_child(nb)\n                edges.append((new_node, nb))\n                delta = cand_cost - nb.cost\n                nb.cost = cand_cost\n                self._propagate_cost_limited(nb, delta, cap=256)\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                del edges[i]\n                break\n\n    def _propagate_cost_limited(self, node, delta, cap=256):\n        stack = [node]\n        visited = 0\n        while stack and visited < cap:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n                visited += 1\n                if visited >= cap:\n                    break\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, target_root, incumbent_len):\n        # Halton base sample mixed with biases\n        tries = 10\n        while tries > 0:\n            tries -= 1\n            r = self._randu()\n            if incumbent_len is not None and r < self.ellipse_bias:\n                p = self._sample_in_ellipse(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                r2 = self._randu()\n                if r2 < self.goal_bias:\n                    p = target_root\n                elif r2 < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_point()\n                else:\n                    h = self._halton(self._halton_idx)\n                    self._halton_idx += 1\n                    if self._is3:\n                        p = (h[0] * self.bounds[0], h[1] * self.bounds[1], h[2] * self.bounds[2])\n                    else:\n                        p = (h[0] * self.bounds[0], h[1] * self.bounds[1])\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            return p\n        return None\n\n    def _corridor_point(self):\n        t = self._randu()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step, 0.06 * sg)\n        if self._is3:\n            ox = (self._randu() * 2.0 - 1.0) * w\n            oy = (self._randu() * 2.0 - 1.0) * w\n            oz = (self._randu() * 2.0 - 1.0) * w\n            p = (base[0] + ox, base[1] + oy, base[2] + oz)\n        else:\n            ox = (self._randu() * 2.0 - 1.0) * w\n            oy = (self._randu() * 2.0 - 1.0) * w\n            p = (base[0] + ox, base[1] + oy)\n        return self._clamp(p)\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        center = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(16):\n            if self._is3:\n                p = (center[0] + self._randu() * 2 * ext[0] - ext[0],\n                     center[1] + self._randu() * 2 * ext[1] - ext[1],\n                     center[2] + self._randu() * 2 * ext[2] - ext[2])\n            else:\n                p = (center[0] + self._randu() * 2 * ext[0] - ext[0],\n                     center[1] + self._randu() * 2 * ext[1] - ext[1])\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            if self._dist(p, f1) + self._dist(p, f2) <= max_sum + 1e-9:\n                return p\n        return None\n\n    def _adaptive_radius(self, n):\n        # Shrink with growth; keep above 1.2*step\n        base = 3.5 * self.step\n        shrink = 0.5 + 0.5 / ((1.0 + n) ** 0.5)\n        return max(1.2 * self.step, base * shrink)\n\n    # ---------- Paths ----------\n    def _trace(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _merge_path(self, meet_a, meet_b):\n        pa = self._trace(meet_a)\n        pb = []\n        cur = meet_b\n        while cur is not None:\n            pb.append(cur.position)\n            cur = cur.parent\n        return pa + pb\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # ---------- Refinement ----------\n    def _prune_collinear(self, pts, cos_eps=0.997):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        for i in range(1, len(pts) - 1):\n            a = out[-1]\n            b = pts[i]\n            c = pts[i + 1]\n            v1 = tuple(b[j] - a[j] for j in range(self.dim))\n            v2 = tuple(c[j] - b[j] for j in range(self.dim))\n            n1 = (sum(v1[j] * v1[j] for j in range(self.dim))) ** 0.5\n            n2 = (sum(v2[j] * v2[j] for j in range(self.dim))) ** 0.5\n            if n1 < 1e-9 or n2 < 1e-9:\n                continue\n            cosang = sum(v1[j] * v2[j] for j in range(self.dim)) / (n1 * n2)\n            if cosang < cos_eps:\n                out.append(b)\n        out.append(pts[-1])\n        return out\n\n    def _vis_collapse(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = pts[:]\n        i = 0\n        while i < len(out) - 2:\n            j = len(out) - 1\n            collapsed = False\n            while j > i + 1:\n                if self._edge_free(out[i], out[j]):\n                    del out[i + 1:j]\n                    collapsed = True\n                    break\n                j -= 1\n            if not collapsed:\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        stall = 0\n        n = len(cur)\n        while tries < attempts and len(cur) > 2:\n            # Bias towards wide-span pairs\n            i = int(self._randu() * max(1, len(cur) - 2))\n            j = i + 2 + int(self._randu() * max(1, len(cur) - i - 2))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-9 <= bestL:\n                    cur = cand\n                    bestL = L\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            tries += 1\n            if stall > 28:\n                break\n        return cur\n\n    def _round_corners(self, pts, passes=2):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            k = 1\n            while k < len(cur) - 1:\n                a = cur[k - 1]\n                c = cur[k + 1]\n                mid = tuple(0.5 * (a[i] + c[i]) for i in range(self.dim))\n                if self._in_bounds(mid) and (not self._point_blocked(mid)):\n                    if self._edge_free(a, mid) and self._edge_free(mid, c):\n                        cur[k] = mid\n                k += 1\n        return cur\n\n    def _refine_path(self, path):\n        if not path or len(path) < 2:\n            return path[:]\n        p0 = self._prune_collinear(path)\n        p1 = self._vis_collapse(p0)\n        p2 = self._shortcut(p1, self.smoothing_attempts)\n        p3 = self._round_corners(p2, passes=2)\n        return p3",
          "objective": -33.56039,
          "time_improvement": 59.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1214.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018087029457092285,
                    "num_nodes_avg": 76.0,
                    "path_length_avg": 164.1642926287751,
                    "smoothness_avg": 0.037059814088076425,
                    "success_improvement": 0.0,
                    "time_improvement": 26.68795280970323,
                    "node_improvement": 80.86124401913875,
                    "length_improvement": 10.018949860483662,
                    "smoothness_improvement": 480.06656715276216,
                    "objective_score": 16.418088594964978
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02971317768096924,
                    "num_nodes_avg": 127.0,
                    "path_length_avg": 235.99878921874523,
                    "smoothness_avg": 0.08998990022915673,
                    "success_improvement": 0.0,
                    "time_improvement": 82.23444199890521,
                    "node_improvement": 91.46677417187395,
                    "length_improvement": 21.216811310274892,
                    "smoothness_improvement": 2215.5049500014106,
                    "objective_score": 48.47794413584356
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016322517395019533,
                    "num_nodes_avg": 90.0,
                    "path_length_avg": 123.58708796709747,
                    "smoothness_avg": 0.0823046580695243,
                    "success_improvement": 0.0,
                    "time_improvement": 67.6632751528354,
                    "node_improvement": 88.55689764780675,
                    "length_improvement": 17.919340756976133,
                    "smoothness_improvement": 946.9091755464293,
                    "objective_score": 35.78513287776844
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "IBEX-Lite: Informed Beam-Expand Bi-Tree with on-the-fly visibility compression and lazy bounded connect. It grows two sparse trees from start and goal using a small beam of candidate samples per iteration, selects the best steer via a simple cost+heuristic score, enforces strict node/edge collision checks, suppresses near-duplicates with a spatial hash, and line-of-sight compresses to ancestors to keep chains short. Upon a short-range or lazily-bridged connection, it visibility-prunes and performs bounded shortcut smoothing, enabling early termination with a short, smooth path.",
          "planning_mechanism": "Alternate expansion between start and goal trees. Each iteration: beam-sample around an attractor (goal/start) with goal/informed bias; pick a nearest-based parent and steer once; validate node and edge, insert, and compress to a visible ancestor. Try a direct or short-step lazy connect to the opposite tree. On success, extract, visibility-prune, shortcut, and return. Spatial hashing accelerates nearest checks and duplicate suppression; no rewiring keeps computations light.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=8.0,\n        goal_bias=0.2,\n        informed_bias=0.5,\n        beam_width=4,\n        dupe_radius_ratio=0.5,\n        connect_radius_factor=4.0,\n        connect_steps=4,\n        smoothing_iters=60,\n        no_improve_stop=15,\n        cell_factor=1.0\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.beam_width = int(beam_width)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.connect_radius_factor = float(connect_radius_factor)\n        self.connect_steps = int(connect_steps)\n        self.smoothing_iters = int(smoothing_iters)\n        self.no_improve_stop = int(no_improve_stop)\n        self.cell_factor = float(cell_factor)\n        self._rng = 1234567\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_from_scene()\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Parameters\n        self.cell_size = max(1.0, self.step_size * self.cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.connect_radius = max(self.step_size, self.connect_radius_factor * self.step_size)\n\n        # Trees and grids\n        nodes = []\n        edges = []\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        nodes.extend([root_a, root_b])\n        tree_a, tree_b = [root_a], [root_b]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, root_a)\n        self._grid_insert(grid_b, root_b)\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            tree = tree_a if side_a else tree_b\n            other_tree = tree_b if side_a else tree_a\n            grid = grid_a if side_a else grid_b\n            other_grid = grid_b if side_a else grid_a\n            attractor = self.goal if side_a else self.start\n\n            # Beam sampling and candidate selection\n            best_cand = None\n            best_score = 1e100\n            samples = self._beam_samples(attractor, best_len)\n            for s in samples:\n                near = self._nearest_hashed(grid, tree, s, 4)\n                if near is None:\n                    continue\n                new_pos = self._steer(near.position, s)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._point_in_obstacles(new_pos):\n                    continue\n                if self._has_nearby(grid, new_pos, self.dupe_radius):\n                    continue\n                if not self._edge_free(near.position, new_pos):\n                    continue\n                g = near.cost + self._dist(near.position, new_pos)\n                h = self._dist(new_pos, attractor)\n                score = g + h\n                if score < best_score:\n                    best_score = score\n                    best_cand = (near, new_pos)\n\n            if best_cand is None:\n                continue\n\n            parent, new_pos = best_cand\n            # Validate node and edge before adding\n            if self._point_in_obstacles(new_pos):\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, parent, parent.cost + self._dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(grid, new_node)\n\n            # On-the-fly visibility compression to up to 3 visible ancestors\n            self._compress_to_ancestors(new_node, edges, 3)\n\n            # Try to connect to the other tree\n            other_near = self._nearest_hashed(other_grid, other_tree, new_node.position, 4)\n            if other_near is not None:\n                if self._dist(other_near.position, new_node.position) <= self.connect_radius and self._edge_free(other_near.position, new_node.position):\n                    path = self._extract_path(new_node, other_near, side_a)\n                    final = self._finalize_path(path)\n                    return PlannerResult(True, final, nodes, edges)\n                ok, joined = self._lazy_connect(new_node, other_tree, other_grid, nodes, edges)\n                if ok:\n                    path = self._extract_path(new_node, joined, side_a)\n                    final = self._finalize_path(path)\n                    return PlannerResult(True, final, nodes, edges)\n\n        if best_path:\n            final = self._finalize_path(best_path)\n            return PlannerResult(True, final, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG utilities\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1103515245 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 1) * 2654435761\n        if s == 0:\n            s = 1234567\n        self._rng = s & 0x7fffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0x7fffffff\n        return self._rng / float(1 << 31)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry and bounds\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= self.step_size:\n            return tuple(b)\n        r = self.step_size / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n\n    # Obstacles and collisions\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            px, py, pz = p\n            for o in self.obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            px, py = p\n            for o in self.obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            for o in self.obstacles:\n                x, y, z, w, h, d = o\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            for o in self.obstacles:\n                x, y, w, h = o\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Spatial hashing\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, tree, pos, max_rings):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        found = False\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n                    found = True\n            if found:\n                return best\n        # fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    # Sampling\n    def _beam_samples(self, attractor, best_len):\n        out = []\n        for _ in range(self.beam_width * 2):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p and self._in_bounds(p) and not self._point_in_obstacles(p):\n                    out.append(p)\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._in_bounds(p) and not self._point_in_obstacles(p):\n                    out.append(p)\n            if len(out) >= self.beam_width:\n                break\n        if not out:\n            # fallback uniform\n            p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n            if self._in_bounds(p) and not self._point_in_obstacles(p):\n                out.append(p)\n        return out\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [half] * self.dim\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dim))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # Compression\n    def _compress_to_ancestors(self, node, edges, depth_limit):\n        depth = 0\n        cur = node\n        while depth < depth_limit and cur.parent is not None and cur.parent.parent is not None:\n            gp = cur.parent.parent\n            if self._edge_free(gp.position, cur.position):\n                self._reparent(cur, gp, edges)\n            else:\n                break\n            depth += 1\n\n    def _reparent(self, child, new_parent, edges):\n        old_parent = child.parent\n        if old_parent is new_parent:\n            return\n        if old_parent is not None:\n            old_parent.remove_child(child)\n            self._edges_remove(edges, old_parent, child)\n        new_parent.add_child(child)\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        edges.append((new_parent, child))\n        self._propagate_costs(child)\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                old = ch.cost\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                if abs(ch.cost - old) > 1e-12:\n                    stack.append(ch)\n\n    # Lazy connect\n    def _lazy_connect(self, new_node, other_tree, other_grid, nodes, edges):\n        near = self._nearest_hashed(other_grid, other_tree, new_node.position, 4)\n        if near is None:\n            return False, None\n        if self._edge_free(near.position, new_node.position):\n            return True, near\n        p = near\n        steps = 0\n        while steps < self.connect_steps:\n            step_pos = self._steer(p.position, new_node.position)\n            if not self._in_bounds(step_pos):\n                break\n            if self._point_in_obstacles(step_pos):\n                break\n            if not self._edge_free(p.position, step_pos):\n                break\n            if self._has_nearby(other_grid, step_pos, self.dupe_radius):\n                break\n            q = Node(step_pos, p, p.cost + self._dist(p.position, step_pos))\n            p.add_child(q)\n            other_tree.append(q)\n            nodes.append(q)\n            edges.append((p, q))\n            self._grid_insert(other_grid, q)\n            if self._edge_free(q.position, new_node.position):\n                return True, q\n            p = q\n            steps += 1\n        return False, None\n\n    # Paths\n    def _path_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        return out[::-1]\n\n    def _extract_path(self, a_node, b_node, a_forward=True):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return (pa + pb[::-1]) if a_forward else (pb + pa[::-1])\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # Finalization: prune + shortcut\n    def _finalize_path(self, path):\n        if not path:\n            return []\n        pruned = self._visibility_prune(path)\n        sm = self._shortcut(pruned)\n        return sm\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        pts = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(pts[-1], path[j]):\n                    pts.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pts.append(path[i + 1])\n                i += 1\n        return pts\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best_len = self._path_len(pts)\n        attempts = 0\n        no_imp = 0\n        while attempts < self.smoothing_iters:\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                attempts += 1\n                continue\n            a, b = pts[i], pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= best_len + 1e-12:\n                    pts = new_pts\n                    best_len = L\n                    no_imp = 0\n                else:\n                    no_imp += 1\n            else:\n                no_imp += 1\n            attempts += 1\n            if no_imp >= self.no_improve_stop:\n                break\n        return pts",
          "objective": -33.37732,
          "time_improvement": 62.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1447.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020781850814819335,
                    "num_nodes_avg": 68.0,
                    "path_length_avg": 170.9976979112377,
                    "smoothness_avg": 0.05181632978932453,
                    "success_improvement": 0.0,
                    "time_improvement": 15.765049686457818,
                    "node_improvement": 82.87584991186098,
                    "length_improvement": 6.2734521429299,
                    "smoothness_improvement": 711.0380821640268,
                    "objective_score": 12.04877660251542
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02635343074798584,
                    "num_nodes_avg": 100.0,
                    "path_length_avg": 249.8743230654094,
                    "smoothness_avg": 0.09393033531173191,
                    "success_improvement": 0.0,
                    "time_improvement": 84.24324023811695,
                    "node_improvement": 93.28092454478264,
                    "length_improvement": 16.58475872716112,
                    "smoothness_improvement": 2316.8951828567397,
                    "objective_score": 46.808303222015454
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.007054257392883301,
                    "num_nodes_avg": 52.0,
                    "path_length_avg": 128.22672229799147,
                    "smoothness_avg": 0.11108113551878454,
                    "success_improvement": 0.0,
                    "time_improvement": 86.02473045093231,
                    "node_improvement": 93.38842975206612,
                    "length_improvement": 14.837916550041735,
                    "smoothness_improvement": 1312.943844642401,
                    "objective_score": 41.274888288516735
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "Bi-Hash RRT*-Gate: a bidirectional, hash-accelerated RRT* with cost-gated cells, angle-aware parentging, bounded rewiring, and best-of-many short bridging. It balances exploration and smoothness using per-cell admission with dynamic best-cost updates, ring-limited neighbor scans computed from true radii, cached edge checks, and informed sampling after first solution. Post-bridge, it performs visibility pruning and non-length-increasing shortcuts for compact, smooth paths.",
          "planning_mechanism": "Alternate expanding start/goal trees. Each step: sample (goal-biased; then informed ellipse after first path), find hashed-nearest, steer, validate node and edge, then select the lowest (cost + lambda\u00b7turn) parent among line-of-sight neighbors within a bounded radius, admit via a per-cell cost gate, insert, and perform bounded rewiring with ancestor guard and incremental cost propagation. Attempt a best-of-many short bridge to the other tree; on success, extract the bi-tree path, prune by visibility, shortcut without increasing length, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=6.0,\n        goal_bias=0.22,\n        cell_factor=1.2,\n        max_per_cell=6,\n        parent_radius_factor=2.6,\n        rewire_radius_factor=1.8,\n        connect_radius_factor=3.2,\n        ring_cap=4,\n        smoothing_iters=100\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.cell_factor = float(cell_factor)\n        self.max_per_cell = int(max_per_cell)\n        self.parent_radius_factor = float(parent_radius_factor)\n        self.rewire_radius_factor = float(rewire_radius_factor)\n        self.connect_radius_factor = float(connect_radius_factor)\n        self.ring_cap = int(ring_cap)\n        self.smoothing_iters = int(smoothing_iters)\n\n        self._rng = 123456789\n        self.edge_res = 0.8\n        self._edge_cache = {}\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        # Validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._in_obs(self.start) or self._in_obs(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        self._edge_cache = {}\n        self._seed_from_scene()\n\n        # Early straight line\n        if not self._edge_blocked(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Parameters derived\n        self.cell_size = max(1.0, self.step_size * self.cell_factor)\n        parent_radius = max(self.step_size * self.parent_radius_factor, self.step_size + 1e-9)\n        rewire_radius = max(self.step_size * self.rewire_radius_factor, self.step_size + 1e-9)\n        connect_radius = max(self.step_size, self.connect_radius_factor * self.step_size)\n        self.edge_res = max(0.4, min(1.0, self.step_size * 0.5))\n        dupe_radius = max(0.4, 0.55 * self.step_size)\n\n        # Trees, grids, and per-cell gates\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes = [start_root, goal_root]\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n\n        grid_start, grid_goal = {}, {}\n        counts_start, counts_goal = {}, {}\n        bestcost_start, bestcost_goal = {}, {}\n\n        self._grid_add(grid_start, counts_start, bestcost_start, start_root)\n        self._grid_add(grid_goal, counts_goal, bestcost_goal, goal_root)\n\n        # Informed sampling bookkeeping\n        have_solution = False\n        best_path = []\n        best_len = float('inf')\n        c_min = self._dist(self.start, self.goal)\n\n        for it in range(self.max_iter):\n            a_is_start = (it % 2 == 0)\n            tree_a = start_tree if a_is_start else goal_tree\n            tree_b = goal_tree if a_is_start else start_tree\n            grid_a = grid_start if a_is_start else grid_goal\n            grid_b = grid_goal if a_is_start else grid_start\n            counts_a = counts_start if a_is_start else counts_goal\n            bestcost_a = bestcost_start if a_is_start else bestcost_goal\n            bestcost_b = bestcost_goal if a_is_start else bestcost_start\n            attractor = self.goal if a_is_start else self.start\n\n            # Sample\n            x_rand = self._sample(attractor, have_solution, best_len, c_min)\n            if x_rand is None:\n                continue\n\n            # Nearest and steer\n            nearest = self._nearest_hashed(grid_a, tree_a, x_rand)\n            if nearest is None:\n                continue\n            new_pos = self._steer(nearest.position, x_rand)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._in_obs(new_pos):\n                continue\n            if self._edge_blocked(nearest.position, new_pos):\n                continue\n            if self._has_nearby(grid_a, new_pos, dupe_radius):\n                continue\n\n            # Choose parent among local LOS neighbors with turn smoothing bias\n            parent = self._choose_parent(new_pos, nearest, grid_a, tree_a, parent_radius)\n            # Ensure edge is valid\n            if self._edge_blocked(parent.position, new_pos):\n                continue\n\n            # Per-cell admission: allow if space remains or if it improves local best cost\n            key_new = self._cell_of(new_pos)\n            new_cost = parent.cost + self._dist(parent.position, new_pos)\n            ccount = counts_a.get(key_new, 0)\n            bestc = bestcost_a.get(key_new, float('inf'))\n            if ccount >= self.max_per_cell and not (new_cost + 1e-9 < bestc * 0.98):\n                continue\n\n            # Insert node (node collision and parent edge collision already checked)\n            a_new = Node(new_pos, parent, new_cost)\n            parent.add_child(a_new)\n            tree_a.append(a_new)\n            nodes.append(a_new)\n            self._grid_add(grid_a, counts_a, bestcost_a, a_new)\n\n            # Local rewiring (bounded, ancestor guard)\n            self._rewire_local(a_new, grid_a, rewire_radius, bestcost_a)\n\n            # Try a best-of-many short bridge to the opposite tree\n            cand_b = self._neighbors_within(grid_b, a_new.position, connect_radius)\n            best_bridge = None\n            best_total = float('inf')\n            for bnode in cand_b:\n                if bnode is None:\n                    continue\n                if self._edge_blocked(bnode.position, a_new.position):\n                    continue\n                total = a_new.cost + self._dist(a_new.position, bnode.position) + bnode.cost\n                if total < best_total:\n                    best_total = total\n                    best_bridge = bnode\n            if best_bridge is not None:\n                path = self._extract_path_with_bridge(a_new, best_bridge, a_is_start)\n                path = self._visibility_prune(path)\n                path = self._shortcut_smooth(path, self.smoothing_iters)\n                plen = self._path_length(path)\n                if plen + 1e-9 < best_len:\n                    best_len = plen\n                    have_solution = True\n                    best_path = path\n                    # Early return on first valid bridge to reduce time\n                    edges = self._collect_edges(nodes)\n                    return PlannerResult(True, best_path, nodes, edges)\n\n        # Finalize\n        if have_solution:\n            edges = self._collect_edges(nodes)\n            return PlannerResult(True, best_path, nodes, edges)\n        edges = self._collect_edges(nodes)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1103515245 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 33) * 2654435761\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _sub(self, a, b):\n        return tuple(a[i] - b[i] for i in range(self.dim))\n\n    def _dot(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            s += a[i] * b[i]\n        return s\n\n    def _norm(self, v):\n        return self._dist((0.0,) * self.dim, v)\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= self.step_size:\n            return tuple(b)\n        r = self.step_size / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n\n    # Obstacles and edges\n    def _in_obs(self, p):\n        if self.is_3d:\n            px, py, pz = p\n            for o in self.obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            px, py = p\n            for o in self.obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked(self, a, b):\n        k = self._edge_key(a, b)\n        val = self._edge_cache.get(k)\n        if val is not None:\n            return val\n        blocked = self._segment_hits(a, b)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _segment_hits(self, a, b):\n        d = self._dist(a, b)\n        steps = max(1, int(d / max(1e-9, self.edge_res)))\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._in_obs(p):\n                return True\n        return False\n\n    # Spatial hashing\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_add(self, grid, counts, bestcost, node):\n        k = self._cell_of(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n        counts[k] = counts.get(k, 0) + 1\n        bc = bestcost.get(k)\n        if bc is None or node.cost < bc:\n            bestcost[k] = node.cost\n\n    def _neighbors_within(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        out = []\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            for n in b:\n                                if self._dist(n.position, pos) <= radius:\n                                    out.append(n)\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        for n in b:\n                            if self._dist(n.position, pos) <= radius:\n                                out.append(n)\n        return out\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._cell_of(pos)\n        best = None\n        bestd2 = float('inf')\n        found_any = False\n        for r in range(0, self.ring_cap + 1):\n            # Collect ring up to r\n            cand = []\n            if self.is_3d:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                            if b:\n                                cand.extend(b)\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy))\n                        if b:\n                            cand.extend(b)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n                    found_any = True\n            if found_any:\n                return best\n        # Fallback random subset if very sparse\n        if not tree:\n            return None\n        tries = min(64, len(tree))\n        for i in range(tries):\n            n = tree[int(self._rand_range(0, len(tree)))]\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd2:\n                bestd2 = d2\n                best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    # Parent selection with turn penalty\n    def _choose_parent(self, new_pos, fallback_nearest, grid, tree, radius_bound):\n        best_parent = fallback_nearest\n        best_score = fallback_nearest.cost + self._dist(fallback_nearest.position, new_pos)\n        # Simple angle penalty encourages smoothness\n        lam = 0.15\n        prev_dir = None\n        if fallback_nearest.parent is not None:\n            prev_dir = self._sub(fallback_nearest.position, fallback_nearest.parent.position)\n        if prev_dir is not None:\n            cur_dir = self._sub(new_pos, fallback_nearest.position)\n            dp = self._dot(prev_dir, cur_dir)\n            np = max(1e-12, self._norm(prev_dir) * self._norm(cur_dir))\n            turn_pen = 1.0 - max(-1.0, min(1.0, dp / np))\n            best_score += lam * turn_pen\n\n        cand = self._neighbors_within(grid, new_pos, radius_bound)\n        for n in cand:\n            if n is fallback_nearest:\n                continue\n            if self._edge_blocked(n.position, new_pos):\n                continue\n            c = n.cost + self._dist(n.position, new_pos)\n            # angle penalty\n            pd = None\n            if n.parent is not None:\n                pd = self._sub(n.position, n.parent.position)\n            if pd is not None:\n                cd = self._sub(new_pos, n.position)\n                dp = self._dot(pd, cd)\n                np = max(1e-12, self._norm(pd) * self._norm(cd))\n                turn_pen = 1.0 - max(-1.0, min(1.0, dp / np))\n                c += lam * turn_pen\n            if c + 1e-12 < best_score:\n                best_score = c\n                best_parent = n\n        return best_parent\n\n    # Rewiring\n    def _rewire_local(self, pivot, grid, radius, bestcost_map):\n        cand = self._neighbors_within(grid, pivot.position, radius)\n        for nb in cand:\n            if nb is pivot or nb.parent is pivot:\n                continue\n            # Ancestor guard\n            if self._is_ancestor(nb, pivot):\n                continue\n            # Check edge\n            if self._edge_blocked(pivot.position, nb.position):\n                continue\n            new_cost = pivot.cost + self._dist(pivot.position, nb.position)\n            if new_cost + 1e-12 < nb.cost:\n                # Reconnect nb under pivot\n                old_parent = nb.parent\n                if old_parent is not None:\n                    try:\n                        old_parent.children.remove(nb)\n                    except:\n                        pass\n                pivot.add_child(nb)\n                nb.cost = new_cost\n                # Propagate decreased costs locally\n                self._propagate_cost_decrease(nb, bestcost_map)\n\n    def _is_ancestor(self, node, potential_child):\n        cur = potential_child\n        while cur is not None:\n            if cur is node:\n                return True\n            cur = cur.parent\n        return False\n\n    def _propagate_cost_decrease(self, node, bestcost_map):\n        queue = [node]\n        qi = 0\n        while qi < len(queue):\n            cur = queue[qi]\n            qi += 1\n            # Update per-cell best cost\n            cell = self._cell_of(cur.position)\n            bc = bestcost_map.get(cell)\n            if bc is None or cur.cost < bc:\n                bestcost_map[cell] = cur.cost\n            # Update children costs\n            for ch in cur.children:\n                new_c = cur.cost + self._dist(cur.position, ch.position)\n                if new_c + 1e-12 < ch.cost:\n                    ch.cost = new_c\n                    queue.append(ch)\n\n    # Sampling\n    def _sample(self, attractor, informed, best_len, c_min):\n        r = self._rand()\n        if informed and best_len < float('inf') and r < 0.6:\n            p = self._informed_sample(self.start, self.goal, best_len * 1.01, c_min)\n            if p is not None and self._in_bounds(p) and not self._in_obs(p):\n                return p\n        if r < self.goal_bias:\n            p = attractor\n        else:\n            p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n        if self._in_bounds(p) and not self._in_obs(p):\n            return p\n        return None\n\n    def _informed_sample(self, f1, f2, c_best, c_min):\n        if not (c_best > c_min + 1e-9):\n            return None\n        center = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        a_vec = self._sub(f2, f1)\n        a_norm = self._norm(a_vec)\n        if a_norm <= 1e-12:\n            return None\n        a_hat = tuple(a_vec[i] / a_norm for i in range(self.dim))\n        r1 = 0.5 * c_best\n        r2 = 0.5 * ((c_best * c_best - c_min * c_min) ** 0.5) if c_best > c_min else 0.0\n        for _ in range(32):\n            if self.is_3d:\n                # build orthonormal basis [a_hat, v, w]\n                u = (1.0, 0.0, 0.0) if abs(a_hat[0]) < 0.9 else (0.0, 1.0, 0.0)\n                v = self._orth(self._cross(a_hat, u))\n                w = self._cross(a_hat, v)\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                z = self._rand_range(-1.0, 1.0)\n                if x * x + y * y + z * z > 1.0:\n                    continue\n                px = r1 * x\n                py = r2 * y\n                pz = r2 * z\n                ex = center[0] + px * a_hat[0] + py * v[0] + pz * w[0]\n                ey = center[1] + px * a_hat[1] + py * v[1] + pz * w[1]\n                ez = center[2] + px * a_hat[2] + py * v[2] + pz * w[2]\n                p = (ex, ey, ez)\n            else:\n                perp = (-a_hat[1], a_hat[0])\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                if x * x + y * y > 1.0:\n                    continue\n                px = r1 * x\n                py = r2 * y\n                ex = center[0] + px * a_hat[0] + py * perp[0]\n                ey = center[1] + px * a_hat[1] + py * perp[1]\n                p = (ex, ey)\n            if self._in_bounds(p) and not self._in_obs(p):\n                return p\n        return None\n\n    def _cross(self, a, b):\n        return (a[1] * b[2] - a[2] * b[1],\n                a[2] * b[0] - a[0] * b[2],\n                a[0] * b[1] - a[1] * b[0])\n\n    def _orth(self, v):\n        n = self._norm(v)\n        if n <= 1e-12:\n            return (1.0, 0.0, 0.0) if self.dim == 3 else (1.0, 0.0)\n        return tuple(v[i] / n for i in range(len(v)))\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path_with_bridge(self, a_node, b_node, a_is_start_tree):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if a_is_start_tree:\n            return pa + list(reversed(pb))\n        else:\n            return pb + list(reversed(pa))\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(pruned[-1], path[j]):\n                    # Only accept if not longer than original subpath\n                    seg = self._dist(pruned[-1], path[j])\n                    mid = 0.0\n                    for t in range(i + 1, j + 1):\n                        mid += self._dist(path[t - 1], path[t])\n                    if seg + 1e-9 <= mid:\n                        pruned.append(path[j])\n                        i = j\n                        advanced = True\n                        break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _shortcut_smooth(self, path, iters):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        best_L = self._path_length(pts)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_length(new_pts)\n                if L <= best_L + 1e-12:\n                    pts = new_pts\n                    best_L = L\n        return pts\n\n    def _collect_edges(self, nodes):\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        return edges",
          "objective": -33.07941,
          "time_improvement": 56.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1266.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01999363899230957,
                    "num_nodes_avg": 65.0,
                    "path_length_avg": 168.19610907842977,
                    "smoothness_avg": 0.05993023295813018,
                    "success_improvement": 0.0,
                    "time_improvement": 18.95990390311455,
                    "node_improvement": 83.63132712163183,
                    "length_improvement": 7.809047376207891,
                    "smoothness_improvement": 838.0382863785782,
                    "objective_score": 14.56359102855199
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03245158195495605,
                    "num_nodes_avg": 126.0,
                    "path_length_avg": 231.15171948335015,
                    "smoothness_avg": 0.06895159120076712,
                    "success_improvement": 0.0,
                    "time_improvement": 80.59714556153635,
                    "node_improvement": 91.53396492642612,
                    "length_improvement": 22.834902703116473,
                    "smoothness_improvement": 1674.174105419453,
                    "objective_score": 46.25095581742806
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01587519645690918,
                    "num_nodes_avg": 87.0,
                    "path_length_avg": 121.87513711670701,
                    "smoothness_avg": 0.10888485954924418,
                    "success_improvement": 0.0,
                    "time_improvement": 68.54946775070414,
                    "node_improvement": 88.93833439287985,
                    "length_improvement": 19.0563369974662,
                    "smoothness_improvement": 1285.0073764220767,
                    "objective_score": 38.423679405801344
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "IBI-Connect-Lite: Informed Batched BiRRT with LOS compression and elastic shortcutting. The planner alternates growth of two trees, evaluates a small batch of guided samples per side using a hashed nearest-neighbor, inserts only the best feasible candidate that passes node and edge checks, and compresses to a visible ancestor to reduce turns and cost. It tries a minimal bridge to the opposite tree without forcing target insertions. Upon success, it performs bounded shortcutting and a light elastic smoothing with continuous collision checks. Spatial hashing accelerates lookup and duplicate suppression, while an ellipse-informed sampler focuses search after the first solution.",
          "planning_mechanism": "At each iteration, pick an active tree and generate a batch of candidates biased toward the opposite root (and within an informed ellipse when an incumbent exists). For each candidate, find a hashed-nearest node, steer by a fixed step, and score by g+dist+h; keep several best that are in-bounds and not duplicates. Try to insert candidates in score order, enforcing both node and edge collision checks; on insertion, attempt line-of-sight compression to an ancestor. Then attempt a limited, stepwise bridge from the other tree; if a direct edge becomes free, merge trees and extract a path. Post-process with greedy shortcuts and a few elastic adjustments that preserve feasibility and do not increase length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3500,\n        step_size=8.0,\n        batch_size=4,\n        goal_bias=0.2,\n        cell_factor=1.2,\n        dupe_radius_ratio=0.5,\n        los_lookback=6,\n        connect_steps_limit=16,\n        collision_res=0.75,\n        shortcut_attempts=60,\n        elastic_iters=20\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.batch_size = batch_size\n        self.goal_bias = goal_bias\n        self.cell_factor = cell_factor\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.los_lookback = los_lookback\n        self.connect_steps_limit = connect_steps_limit\n        self.collision_res = collision_res\n        self.shortcut_attempts = shortcut_attempts\n        self.elastic_iters = elastic_iters\n        self._rng = 2463534242\n\n    # ----------------- Public API -----------------\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obstacle(self.start) or self._point_in_obstacle(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        self._seed_rng()\n        self.cell_size = max(1.0, self.step_size * self.cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n\n        # Straight-line early exit\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        nodes = []\n        edges = []\n\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        A, B = [a_root], [b_root]\n        GA, GB = {}, {}\n        self._grid_add(GA, a_root)\n        self._grid_add(GB, b_root)\n\n        best_len = float('inf')\n        best_path = None\n\n        for it in range(self.max_iter):\n            # Alternate sides\n            sideA = (it % 2 == 0)\n            T = A if sideA else B\n            TO = B if sideA else A\n            G = GA if sideA else GB\n            GO = GB if sideA else GA\n            attractor = self.goal if sideA else self.start\n\n            candidates = []\n            for _ in range(self.batch_size):\n                qrand = self._sample(attractor, best_len)\n                if qrand is None:\n                    continue\n                qnear = self._nearest(G, qrand)\n                if qnear is None:\n                    continue\n                qnew = self._steer(qnear.position, qrand, self.step_size)\n                if not self._in_bounds(qnew):\n                    continue\n                if self._point_in_obstacle(qnew):\n                    continue\n                if self._has_near(G, qnew, self.dupe_radius):\n                    continue\n                # score without edge check to limit expensive calls\n                f = qnear.cost + self._dist(qnear.position, qnew) + 0.9 * self._dist(qnew, attractor)\n                candidates.append((f, qnear, qnew))\n\n            if not candidates:\n                continue\n\n            # Try best-first\n            candidates.sort(key=lambda t: t[0])\n            inserted = None\n            for _, qnear, qnew in candidates:\n                # Both checks before insertion\n                if self._point_in_obstacle(qnew):\n                    continue\n                if not self._edge_free(qnear.position, qnew):\n                    continue\n                qnode = Node(qnew, qnear, qnear.cost + self._dist(qnear.position, qnew))\n                qnode.attach(qnear)\n                T.append(qnode)\n                nodes.append(qnode)\n                edges.append((qnear, qnode))\n                self._grid_add(G, qnode)\n\n                # LOS compression to ancestor\n                self._compress_los(qnode, edges)\n\n                inserted = qnode\n                break\n\n            if inserted is None:\n                continue\n\n            # Attempt to bridge\n            meet = self._attempt_bridge(TO, GO, inserted.position, nodes, edges)\n            if meet is not None:\n                # Path extraction\n                path_a = self._path_to_root(inserted)\n                path_b = self._path_to_root(meet)\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                raw = path_a + path_b[::-1]\n                # Post-process\n                sm = self._shortcut(raw, self.shortcut_attempts)\n                sm = self._elastic_smooth(sm, self.elastic_iters)\n                bl = self._path_len(sm)\n                best_len = bl\n                best_path = sm\n                return PlannerResult(True, best_path, nodes, edges)\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # ----------------- Geometry and Utils -----------------\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            s ^= int(v * 997 + 0.5) + 0x9E3779B97F4A7C15 + (s << 6) + (s >> 2)\n            s &= 0xffffffff\n        s ^= len(self.obstacles) * 2654435761\n        self._rng = s if s != 0 else 2463534242\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(max(0.0, min(a[i], self.bounds[i])) for i in range(self.dims))\n        if d <= step:\n            tgt = b\n        else:\n            r = step / d\n            tgt = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n        # clamp\n        return tuple(max(0.0, min(tgt[i], self.bounds[i])) for i in range(self.dims))\n\n    # ----------------- Spatial Hash -----------------\n    def _cell_key(self, p):\n        if self.is3d:\n            return (int(p[0] // self.cell_size), int(p[1] // self.cell_size), int(p[2] // self.cell_size))\n        return (int(p[0] // self.cell_size), int(p[1] // self.cell_size))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos):\n        k = self._cell_key(pos)\n        best = None\n        bd = float('inf')\n        for r in range(0, 4):\n            cand = self._grid_ring(grid, k, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bd:\n                        bd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback linear (rare)\n        nearest = None\n        nd = float('inf')\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._dist(n.position, pos)\n                if d < nd:\n                    nd = d\n                    nearest = n\n        return nearest\n\n    def _has_near(self, grid, pos, radius):\n        k = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell_size) + 1)\n        if self.is3d:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        b = grid.get((k[0] + dx, k[1] + dy, k[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    b = grid.get((k[0] + dx, k[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    # ----------------- Collision -----------------\n    def _point_in_obstacle(self, p):\n        if self.is3d:\n            px, py, pz = p\n            for x, y, z, w, h, d in self.obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            px, py = p\n            for x, y, w, h in self.obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        # Sample along the segment with adaptive resolution\n        dist = self._dist(a, b)\n        if dist <= 1e-12:\n            return not self._point_in_obstacle(a)\n        res = max(0.25, min(self.collision_res, self.step_size * 0.5))\n        steps = max(1, int(dist / res))\n        for i in range(steps + 1):\n            t = i / steps\n            p = tuple(a[d] + (b[d] - a[d]) * t for d in range(self.dims))\n            if self._point_in_obstacle(p):\n                return False\n        return True\n\n    # ----------------- LOS compression -----------------\n    def _compress_los(self, node, edges):\n        p = node.parent\n        if p is None:\n            return\n        best_parent = p\n        best_cost = node.cost\n        steps = 0\n        cur = p\n        while cur is not None and steps < self.los_lookback:\n            if self._edge_free(cur.position, node.position):\n                cand_cost = cur.cost + self._dist(cur.position, node.position)\n                if cand_cost + 1e-12 < best_cost:\n                    best_cost = cand_cost\n                    best_parent = cur\n            cur = cur.parent\n            steps += 1\n        if best_parent is not node.parent:\n            oldp = node.parent\n            node.attach(best_parent)\n            node.cost = best_cost\n            self._remove_edge(edges, oldp, node)\n            edges.append((best_parent, node))\n\n    def _remove_edge(self, edges, p, c):\n        if p is None:\n            return\n        rm = -1\n        for i in range(len(edges)):\n            if edges[i][0] is p and edges[i][1] is c:\n                rm = i\n                break\n        if rm >= 0:\n            edges.pop(rm)\n\n    # ----------------- Bridge attempt -----------------\n    def _attempt_bridge(self, tree_other, grid_other, target_pos, nodes, edges):\n        if not tree_other:\n            return None\n        qnear = self._nearest(grid_other, target_pos)\n        if qnear is None:\n            return None\n        # Direct edge first\n        if self._edge_free(qnear.position, target_pos):\n            return qnear\n\n        # Minimal progressive connection: grow the other tree slightly toward target\n        current = qnear\n        for _ in range(self.connect_steps_limit):\n            step = self._steer(current.position, target_pos, self.step_size)\n            if not self._in_bounds(step):\n                return None\n            if self._point_in_obstacle(step):\n                return None\n            if not self._edge_free(current.position, step):\n                return None\n            # avoid duplicates near existing nodes in other grid\n            if self._has_near(grid_other, step, self.dupe_radius):\n                return None\n            new_node = Node(step, current, current.cost + self._dist(current.position, step))\n            new_node.attach(current)\n            tree_other.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_add(grid_other, new_node)\n            current = new_node\n            # Check if we can now directly connect\n            if self._edge_free(current.position, target_pos):\n                return current\n        return None\n\n    # ----------------- Sampling -----------------\n    def _sample(self, attractor, best_len):\n        # Informed ellipse if we have an incumbent\n        for _ in range(24):\n            if best_len < float('inf') and self._rand() < 0.65:\n                p = self._ellipse_pick(self.start, self.goal, best_len * 1.02)\n                if p is not None:\n                    return p\n            else:\n                r = self._rand()\n                if r < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n                if self._in_bounds(p) and not self._point_in_obstacle(p):\n                    return p\n        return None\n\n    def _ellipse_pick(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(18):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._in_bounds(p) and not self._point_in_obstacle(p):\n                return p\n        return None\n\n    # ----------------- Path ops -----------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best_L = self._path_len(pts)\n        tries = 0\n        no_imp = 0\n        while tries < attempts and len(pts) > 2:\n            i = int(self._rand_range(0, len(pts) - 2))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                cand = pts[:i + 1] + pts[j:]\n                L = self._path_len(cand)\n                if L <= best_L + 1e-12:\n                    pts = cand\n                    best_L = L\n                    no_imp = 0\n                else:\n                    no_imp += 1\n            else:\n                no_imp += 1\n            tries += 1\n            if no_imp >= 12:\n                break\n        return pts\n\n    def _elastic_smooth(self, path, iters):\n        if len(path) < 3:\n            return path[:]\n        pts = [tuple(p) for p in path]\n        base_len = self._path_len(pts)\n        for _ in range(iters):\n            changed = False\n            for k in range(1, len(pts) - 1):\n                a = pts[k - 1]\n                b = pts[k]\n                c = pts[k + 1]\n                # proposed move toward midpoint of neighbors\n                mid = tuple(0.5 * (a[d] + c[d]) for d in range(self.dims))\n                prop = tuple(0.6 * mid[d] + 0.4 * b[d] for d in range(self.dims))\n                # bounds and collision\n                prop = tuple(max(0.0, min(prop[d], self.bounds[d])) for d in range(self.dims))\n                if self._point_in_obstacle(prop):\n                    continue\n                if self._edge_free(a, prop) and self._edge_free(prop, c):\n                    old_len = self._dist(a, b) + self._dist(b, c)\n                    new_len = self._dist(a, prop) + self._dist(prop, c)\n                    if new_len <= old_len + 1e-9:\n                        pts[k] = prop\n                        changed = True\n            if not changed:\n                break\n        # final feasibility check\n        ok = True\n        for i in range(1, len(pts)):\n            if not self._edge_free(pts[i - 1], pts[i]):\n                ok = False\n                break\n        if not ok:\n            return path[:]\n        return pts",
          "objective": -33.03942,
          "time_improvement": 57.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1596.0,
          "node_improvement": 92.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02291398048400879,
                    "num_nodes_avg": 48.0,
                    "path_length_avg": 162.3715024736225,
                    "smoothness_avg": 0.045283030818523244,
                    "success_improvement": 0.0,
                    "time_improvement": 7.122901383760357,
                    "node_improvement": 87.91236464366659,
                    "length_improvement": 11.001606553100745,
                    "smoothness_improvement": 608.7777659851962,
                    "objective_score": 11.781723176914534
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028193902969360352,
                    "num_nodes_avg": 106.0,
                    "path_length_avg": 226.46753860051695,
                    "smoothness_avg": 0.08639360422955294,
                    "success_improvement": 0.0,
                    "time_improvement": 83.14281885776845,
                    "node_improvement": 92.87778001746959,
                    "length_improvement": 24.398617108477243,
                    "smoothness_improvement": 2122.969663624298,
                    "objective_score": 50.19686424053837
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.008996152877807617,
                    "num_nodes_avg": 48.0,
                    "path_length_avg": 145.04275395386156,
                    "smoothness_avg": 0.16957145057025852,
                    "success_improvement": 0.0,
                    "time_improvement": 82.17761922058317,
                    "node_improvement": 93.89701207883026,
                    "length_improvement": 3.6695090175910625,
                    "smoothness_improvement": 2056.936334791184,
                    "objective_score": 37.13967285068551
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Adaptive Goal-Biased Grid BiRRT (AG-GBiRRT): a simplified, robust bidirectional RRT with commit-only connection, grid-accelerated nearest search, and light post-connection shortcut smoothing. It alternates growing two trees, uses uniform-with-goal-bias sampling, single-step steering with strict node/edge collision checks, and an early straight-line test. Upon any successful bridge between trees, it extracts the path and performs a few inexpensive shortcuts for smoothness, returning quickly without extra rewiring or bloat.",
          "planning_mechanism": "Mechanism: alternate start/goal tree expansion; sample (goal-biased), find nearest via grid, steer one step, validate node and edge, add node and edge, attempt a direct, collision-free bridge to the opposite tree (commit-only); on success, extract [start\u2192\u2026\u2192meetA, meetB\u2192\u2026\u2192goal] and run brief shortcut smoothing; terminate on success or iteration budget.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size * 2.0)\n        self.edge_res = max(0.5, self.collision_step)\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_res):\n            path = [start, goal]\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Trees and grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = goal if active_start else start\n\n            # Sample with goal/opposite-root bias\n            if self._rand() < self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest and steer\n            nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                continue\n\n            # Insert node (both node and edge validated)\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, new_node)\n\n            # Try commit-only direct connection to the other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None:\n                if not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                    path = self._extract_path(new_node, other_near)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- Random ----------\n    def _rand(self):\n        try:\n            return self._lcg_next()\n        except:\n            return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Sampling ----------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ---------- Grid nearest ----------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    # ---------- Path ----------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # path_a ends at meet_a; we then go straight to meet_b and up to other root\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            # pick two indices i < j with at least one point between\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -32.96764,
          "time_improvement": 69.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1142.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01299290657043457,
                    "num_nodes_avg": 78.8,
                    "path_length_avg": 167.86786188508313,
                    "smoothness_avg": 0.03825680999831742,
                    "success_improvement": 0.0,
                    "time_improvement": 49.04501835909778,
                    "node_improvement": 80.15613195668597,
                    "length_improvement": 7.988964864290817,
                    "smoothness_improvement": 498.8021524662562,
                    "objective_score": 22.000895188635106
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02625594139099121,
                    "num_nodes_avg": 208.9,
                    "path_length_avg": 244.3021244779086,
                    "smoothness_avg": 0.07331771296729457,
                    "success_improvement": 0.0,
                    "time_improvement": 83.61025026480232,
                    "node_improvement": 85.96385137405093,
                    "length_improvement": 18.444919002512343,
                    "smoothness_improvement": 1786.5175632625994,
                    "objective_score": 45.082614297261095
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01305999755859375,
                    "num_nodes_avg": 163.0,
                    "path_length_avg": 140.27860161008172,
                    "smoothness_avg": 0.09759083301298958,
                    "success_improvement": 0.0,
                    "time_improvement": 73.37500455677744,
                    "node_improvement": 79.27527018436109,
                    "length_improvement": 6.833632159773637,
                    "smoothness_improvement": 1141.348192519241,
                    "objective_score": 31.819421625493614
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "FALCON-IBiRRT*: Fast Adaptive Lazy-Connect Optimal BiRRT with Cone-Guided Sampling and Lite Rewiring. It blends bidirectional growth, informed/corridor/goal-biased sampling with directional cone gating, spatial hash for near/nearest, obstacle binning for fast segment tests, best-parent with short ancestor compression, and bounded local rewiring. A lazy, capped-node connect avoids opposite-tree bloat. On first meet, a two-pass visibility+shortcut+rounding refiner outputs a short, smooth path quickly.",
          "planning_mechanism": "Alternate expand start/goal trees. For each iteration: draw a guided sample (goal/corridor/uniform; switch to informed ellipse once an incumbent exists) filtered by a cone toward the opposite root. Steer one step, pick a best parent from k-near via grid, optionally compress to a visible ancestor, validate node and edge, insert, then lightly rewire k neighbors. Try a lazy connect from the other tree: direct line-of-sight or at most two validated steps with duplicate suppression. On connection, extract, refine (visibility collapse, randomized shortcutting, corner rounding), and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=7.0,\n                 goal_bias=0.20,\n                 corridor_bias=0.30,\n                 ellipse_bias=0.55,\n                 grid_cell_factor=1.8,\n                 neighbor_radius_factor=2.5,\n                 k_parent=6,\n                 k_rewire=6,\n                 connect_mult=1.8,\n                 min_sep_ratio=0.25,\n                 smoothing_attempts=100):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.ellipse_bias = float(ellipse_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neigh_factor = float(neighbor_radius_factor)\n        self.k_parent = int(max(1, k_parent))\n        self.k_rewire = int(max(0, k_rewire))\n        self.connect_mult = float(connect_mult)\n        self.min_sep_ratio = float(min_sep_ratio)\n        self.smoothing_attempts = int(max(0, smoothing_attempts))\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self._is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if hasattr(map, 'obstacles') and map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        # Bounds/start-goal validation\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.neigh_radius = max(self.step * 1.2, self.step * self.neigh_factor)\n        self.min_sep = max(0.25, self.step * self.min_sep_ratio)\n        self.cstep = max(self.step, self.step * self.connect_mult)\n        self.dup_thresh = max(0.4, 0.8 * self.step)\n\n        # Build obstacle bins\n        self._build_obs_bins()\n\n        # Node validity\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Trivial solution\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._refine_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize trees and grids\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        Ta = [a_root]\n        Tb = [b_root]\n        nodes.extend([a_root, b_root])\n\n        G_a = {}\n        G_b = {}\n        self._grid_add(G_a, a_root)\n        self._grid_add(G_b, b_root)\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            # Alternate active tree\n            if (it & 1) == 0:\n                A, B = Ta, Tb\n                GA, GB = G_a, G_b\n                root_other = self.goal\n            else:\n                A, B = Tb, Ta\n                GA, GB = G_b, G_a\n                root_other = self.start\n\n            # Guided sample with cone gating\n            sample = self._guided_sample(root_other, best_len)\n            if sample is None:\n                continue\n\n            # Nearest and steer\n            anchor = self._nearest(GA, sample)\n            newp = self._steer(anchor.position, sample, self.step)\n\n            # Pre-insertion checks: bounds, node collision, proximity, edge collision\n            if (not self._in_bounds(newp)) or self._point_blocked(newp):\n                continue\n            if self._too_close(GA, newp, self.min_sep):\n                continue\n\n            # Best-parent selection among k nearest neighbors\n            neigh = self._neighbors(GA, newp, self.neigh_radius)\n            cands = self._k_nearest(neigh if neigh else [anchor], newp, self.k_parent)\n            parent, gbest = None, 1e100\n            for nb in cands:\n                if not self._edge_free(nb.position, newp):\n                    continue\n                gc = nb.cost + self._dist(nb.position, newp)\n                if gc < gbest:\n                    parent = nb\n                    gbest = gc\n\n            if parent is None:\n                continue\n\n            # Short ancestor compression (up to 3 hops) for flatter chains\n            anc = parent\n            hops = 0\n            while anc is not None and anc.parent is not None and hops < 3:\n                up = anc.parent\n                if self._edge_free(up.position, newp):\n                    gc = up.cost + self._dist(up.position, newp)\n                    if gc + 1e-12 < gbest:\n                        parent = up\n                        gbest = gc\n                anc = up\n                hops += 1\n\n            # Final insertion checks (both checks before adding)\n            if self._point_blocked(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, gbest)\n            parent.add_child(nn)\n            A.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(GA, nn)\n\n            # Local bounded rewiring\n            if self.k_rewire > 0:\n                self._rewire_lite(nn, GA, edges)\n\n            # Lazy connect attempt from the other tree\n            meet_b = None\n            other_near = self._nearest(GB, nn.position)\n            # Direct connect\n            if self._edge_free(other_near.position, nn.position):\n                meet_b = other_near\n            else:\n                # At most two validated steps to avoid bloat\n                cur = other_near\n                steps = 0\n                added_nodes = 0\n                while steps < 2:\n                    nxtp = self._steer(cur.position, nn.position, self.cstep)\n                    if (not self._in_bounds(nxtp)) or self._point_blocked(nxtp):\n                        break\n                    if not self._edge_free(cur.position, nxtp):\n                        break\n                    # Duplicate suppression\n                    if self._too_close(GB, nxtp, self.dup_thresh):\n                        break\n                    # Add step node (both checks already OK)\n                    cn = Node(nxtp, cur, cur.cost + self._dist(cur.position, nxtp))\n                    cur.add_child(cn)\n                    B.append(cn)\n                    nodes.append(cn)\n                    edges.append((cur, cn))\n                    self._grid_add(GB, cn)\n                    added_nodes += 1\n                    cur = cn\n                    # Try final snap\n                    if self._edge_free(cur.position, nn.position):\n                        meet_b = cur\n                        break\n                    steps += 1\n\n            if meet_b is not None:\n                # Extract path without adding cross-edge\n                path = self._merge_path(nn, meet_b)\n                rawL = self._path_len(path)\n                if best_len is None or rawL < best_len:\n                    best_len = rawL\n                path = self._refine_path(path)\n                return PlannerResult(True, path, Ta + Tb, edges)\n\n        return PlannerResult(False, [], Ta + Tb, edges)\n\n    # ---------- RNG ----------\n    def _seed_rng(self):\n        s = 0\n        for v in self.start + self.goal:\n            iv = int((v + 1.2345) * 2654435761) & 0xffffffff\n            s ^= iv\n            s = (s << 13) ^ (s >> 17) ^ (s << 7)\n            s &= 0xffffffff\n        s ^= len(self.obstacles) * 1103515245 & 0xffffffff\n        if s == 0:\n            s = 2463534242\n        self._rng = s & 0xffffffff\n\n    def _randu(self):\n        # xorshift32\n        x = self._rng\n        x ^= (x << 13) & 0xffffffff\n        x ^= (x >> 17) & 0xffffffff\n        x ^= (x << 5) & 0xffffffff\n        self._rng = x & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._randu()\n\n    # ---------- Geometry ----------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # ---------- Spatial hashing for nodes ----------\n    def _cell_key(self, p):\n        if self._is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _neighbors(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        span = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self._is3:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        # Expanding rings up to 3\n        for r in range(0, 4):\n            cand = []\n            if self._is3:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                            if lst:\n                                cand += lst\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy))\n                        if lst:\n                            cand += lst\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback full scan\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _k_nearest(self, nodes, pos, k):\n        # Keep k best by squared distance without full sort\n        buf_d = [1e200] * k\n        buf_n = [None] * k\n        for nd in nodes:\n            d2 = self._dist2(nd.position, pos)\n            # find slot\n            mx = -1\n            mxd = -1.0\n            for i in range(k):\n                if buf_n[i] is None:\n                    mx = i\n                    mxd = -1.0\n                    break\n                if buf_d[i] > mxd:\n                    mxd = buf_d[i]\n                    mx = i\n            if mx >= 0 and (buf_n[mx] is None or d2 < buf_d[mx]):\n                # Replace worst if buffer full\n                worst_i = 0\n                worst_d = -1.0\n                for j in range(k):\n                    if buf_n[j] is None:\n                        worst_i = j\n                        worst_d = -1.0\n                        break\n                    if buf_d[j] > worst_d:\n                        worst_d = buf_d[j]\n                        worst_i = j\n                if buf_n[worst_i] is None or d2 < buf_d[worst_i]:\n                    buf_d[worst_i] = d2\n                    buf_n[worst_i] = nd\n        # Compact\n        out = []\n        for i in range(k):\n            if buf_n[i] is not None:\n                out.append(buf_n[i])\n        # Order roughly by distance\n        out.sort(key=lambda n: self._dist2(n.position, pos))\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        neigh = self._neighbors(grid, pos, radius)\n        return len(neigh) > 0\n\n    # ---------- Obstacles & collision ----------\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.6)\n        self.obin = {}\n        if self._is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            self._obin_add((i, j, k), idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        self._obin_add((i, j), idx)\n\n    def _obin_add(self, key, idx):\n        lst = self.obin.get(key)\n        if lst is None:\n            self.obin[key] = [idx]\n        else:\n            lst.append(idx)\n\n    def _bucket_candidates(self, a, b):\n        if self._is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self.obin.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            return cand\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self.obin.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            return cand\n\n    def _point_blocked(self, p):\n        if self._is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            lst = self.obin.get((ix, iy, iz))\n            if not lst:\n                return False\n            x, y, z = p\n            for idx in lst:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            lst = self.obin.get((ix, iy))\n            if not lst:\n                return False\n            x, y = p\n            for idx in lst:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        # Segment vs candidate obstacles\n        cand = self._bucket_candidates(a, b)\n        if not cand:\n            return True\n        if self._is3:\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        # Slab intersection (Liang-Barsky style)\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            q = p1[i]\n            d = q - p\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # ---------- Rewiring ----------\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                del edges[i]\n                break\n\n    def _propagate_cost_limited(self, node, delta, cap=128):\n        stack = [node]\n        visited = 0\n        while stack and visited < cap:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n                visited += 1\n                if visited >= cap:\n                    break\n\n    def _rewire_lite(self, new_node, grid, edges):\n        neigh = self._neighbors(grid, new_node.position, self.neigh_radius)\n        if not neigh:\n            return\n        cands = self._k_nearest(neigh, new_node.position, self.k_rewire)\n        for nb in cands:\n            if nb is new_node or nb is new_node.parent:\n                continue\n            # Avoid cycles\n            cur = new_node\n            cyc = False\n            while cur is not None:\n                if cur is nb:\n                    cyc = True\n                    break\n                cur = cur.parent\n            if cyc:\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            cand_cost = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand_cost + 1e-9 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, oldp, nb)\n                new_node.add_child(nb)\n                edges.append((new_node, nb))\n                delta = cand_cost - nb.cost\n                nb.cost = cand_cost\n                self._propagate_cost_limited(nb, delta, cap=256)\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, target_root, incumbent_len):\n        tries = 18\n        while tries > 0:\n            tries -= 1\n            r = self._randu()\n            if incumbent_len is not None and r < self.ellipse_bias:\n                p = self._sample_in_ellipse(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                r2 = self._randu()\n                if r2 < self.goal_bias:\n                    p = target_root\n                elif r2 < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_point()\n                else:\n                    if self._is3:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]),\n                             self._rand_range(0.0, self.bounds[2]))\n                    else:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]))\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            # Cone gating: encourage samples pointing toward the opposite root\n            v1 = tuple(p[i] - self.start[i] for i in range(self.dim))\n            v2 = tuple(target_root[i] - self.start[i] for i in range(self.dim))\n            if self._cos_align(v1, v2) < -0.2 and self._randu() < 0.5:\n                continue\n            return p\n        return None\n\n    def _cos_align(self, a, b):\n        na = 0.0\n        nb = 0.0\n        dp = 0.0\n        for i in range(self.dim):\n            na += a[i] * a[i]\n            nb += b[i] * b[i]\n            dp += a[i] * b[i]\n        if na <= 1e-18 or nb <= 1e-18:\n            return 1.0\n        return dp / ((na ** 0.5) * (nb ** 0.5))\n\n    def _corridor_point(self):\n        t = self._randu()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step, 0.06 * sg)\n        if self._is3:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            oz = self._rand_range(-w, w)\n            return self._clamp((base[0] + ox, base[1] + oy, base[2] + oz))\n        else:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            return self._clamp((base[0] + ox, base[1] + oy))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        center = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(20):\n            if self._is3:\n                p = (center[0] + self._rand_range(-ext[0], ext[0]),\n                     center[1] + self._rand_range(-ext[1], ext[1]),\n                     center[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (center[0] + self._rand_range(-ext[0], ext[0]),\n                     center[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            if self._dist(p, f1) + self._dist(p, f2) <= max_sum + 1e-9:\n                return p\n        return None\n\n    # ---------- Paths and smoothing ----------\n    def _trace(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _merge_path(self, meet_a, meet_b):\n        pa = self._trace(meet_a)\n        # meet_b is in the other tree towards its root\n        pb = []\n        cur = meet_b\n        while cur is not None:\n            pb.append(cur.position)\n            cur = cur.parent\n        return pa + pb\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _prune_collinear(self, pts, cos_eps=0.9975):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        for i in range(1, len(pts) - 1):\n            a = out[-1]\n            b = pts[i]\n            c = pts[i + 1]\n            v1 = tuple(b[j] - a[j] for j in range(self.dim))\n            v2 = tuple(c[j] - b[j] for j in range(self.dim))\n            n1 = (sum(v1[j] * v1[j] for j in range(self.dim))) ** 0.5\n            n2 = (sum(v2[j] * v2[j] for j in range(self.dim))) ** 0.5\n            if n1 < 1e-9 or n2 < 1e-9:\n                continue\n            cosang = sum(v1[j] * v2[j] for j in range(self.dim)) / (n1 * n2)\n            if cosang < cos_eps:\n                out.append(b)\n        out.append(pts[-1])\n        return out\n\n    def _vis_collapse(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = pts[:]\n        i = 0\n        while i < len(out) - 2:\n            j = len(out) - 1\n            collapsed = False\n            while j > i + 1:\n                if self._edge_free(out[i], out[j]):\n                    del out[i + 1:j]\n                    collapsed = True\n                    break\n                j -= 1\n            if not collapsed:\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        stall = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-9 <= bestL:\n                    cur = cand\n                    bestL = L\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            tries += 1\n            if stall > 28:\n                break\n        return cur\n\n    def _round_corners(self, pts, passes=2):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            k = 1\n            while k < len(cur) - 1:\n                a = cur[k - 1]\n                c = cur[k + 1]\n                mid = tuple(0.5 * (a[i] + c[i]) for i in range(self.dim))\n                if self._in_bounds(mid) and (not self._point_blocked(mid)):\n                    if self._edge_free(a, mid) and self._edge_free(mid, c):\n                        cur[k] = mid\n                k += 1\n        return cur\n\n    def _refine_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._prune_collinear(path)\n        p1 = self._vis_collapse(p0)\n        p2 = self._shortcut(p1, self.smoothing_attempts)\n        p3 = self._round_corners(p2, passes=2)\n        return p3",
          "objective": -32.87452,
          "time_improvement": 65.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1389.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012348318099975586,
                    "num_nodes_avg": 55.0,
                    "path_length_avg": 174.85272669498227,
                    "smoothness_avg": 0.04900620000433415,
                    "success_improvement": 0.0,
                    "time_improvement": 49.9486368718647,
                    "node_improvement": 86.14958448753463,
                    "length_improvement": 4.160449779719303,
                    "smoothness_improvement": 667.0534487344287,
                    "objective_score": 20.816128173063134
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04547526836395264,
                    "num_nodes_avg": 139.0,
                    "path_length_avg": 237.675280217124,
                    "smoothness_avg": 0.0895281065411136,
                    "success_improvement": 0.0,
                    "time_improvement": 72.81026195146428,
                    "node_improvement": 90.66048511724787,
                    "length_improvement": 20.65715035989825,
                    "smoothness_improvement": 2203.6226657915117,
                    "objective_score": 45.25548213033579
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014064836502075195,
                    "num_nodes_avg": 75.0,
                    "path_length_avg": 139.45225702777378,
                    "smoothness_avg": 0.10977562995077768,
                    "success_improvement": 0.0,
                    "time_improvement": 72.13599244643852,
                    "node_improvement": 90.46408137317228,
                    "length_improvement": 7.382450885042043,
                    "smoothness_improvement": 1296.337910179751,
                    "objective_score": 32.55195781585554
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "AIL-Connect: Adaptive Informed Lazy BiRRT-Connect with grid-kNN, direct bridging, and on-the-fly corner-cut smoothing. It accelerates planning via analytic segment\u2013AABB collision tests (broad-phase + slab), informed corridor-biased sampling after a candidate path, k-nearest grid lookup with cost-aware parent choice, greedy connect with immediate direct-bridge checks, and local grandparent rewiring to cut corners during growth. A short bounded-time shortcut pass finalizes the path.",
          "planning_mechanism": "Alternate growing two trees. Each iteration: sample (uniform early, corridor-biased later), pick a parent via grid-based kNN minimizing cost+heuristic, extend-connect until blocked while validating node and edge. After each insertion, attempt grandparent bypass and then a direct bridge to the opposite tree; if blocked, greedily connect the opposite tree toward the new node. On success, assemble and briefly shortcut the path; stop at first feasible solution or time cap.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=5.0,\n        time_limit_sec=10.0,\n        grid_cell_factor=1.6,\n        k_candidates=12,\n        goal_bias=0.08,\n        corridor_bias=0.35,\n        smooth_attempts=50,\n        smooth_time_frac=0.08\n    ):\n        self.max_iter = max_iter\n        self.step_size = float(step_size)\n        self.time_limit_sec = float(time_limit_sec)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.k_candidates = int(k_candidates)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.smooth_attempts = int(smooth_attempts)\n        self.smooth_time_frac = float(smooth_time_frac)\n\n    # -------- Public API --------\n    def plan(self, map):\n        bounds = map.size\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        obstacles = list(map.obstacles)\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Validate start/goal\n        if not self._within_bounds(start, bounds) or not self._within_bounds(goal, bounds):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line check\n        if not self._edge_hits_any_obstacle(start, goal, obstacles, is_3d):\n            start_node = Node(start, parent=None, cost=0.0)\n            goal_node = Node(goal, parent=start_node, cost=self._dist(start, goal))\n            start_node.add_child(goal_node)\n            nodes = [start_node, goal_node]\n            edges = [(start_node, goal_node)]\n            return PlannerResult(True, [start, goal], nodes, edges)\n\n        # Initialize trees and grids\n        start_root = Node(start, parent=None, cost=0.0)\n        goal_root = Node(goal, parent=None, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n        nodes = [start_root, goal_root]\n\n        cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        grid_start = {}\n        grid_goal = {}\n        self._grid_insert(grid_start, start_root.position, start_root, cell_size, dim)\n        self._grid_insert(grid_goal, goal_root.position, goal_root, cell_size, dim)\n\n        # Corridor sampler parameters\n        have_candidate = False  # becomes True once any connection is attempted successfully\n        best_path_cost = float(\"inf\")\n\n        import time  # environment commonly provides, guarded import to avoid top-level\n        t0 = time.time()\n\n        for it in range(self.max_iter):\n            if (time.time() - t0) >= self.time_limit_sec:\n                return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n            # Alternate sides\n            grow_from_start = (it % 2 == 0)\n            if grow_from_start:\n                grow_tree, grow_grid = start_tree, grid_start\n                other_tree, other_grid = goal_tree, grid_goal\n                other_root = goal_root\n            else:\n                grow_tree, grow_grid = goal_tree, grid_goal\n                other_tree, other_grid = start_tree, grid_start\n                other_root = start_root\n\n            # Sample\n            sample = self._sample(bounds, is_3d, start, goal, have_candidate)\n\n            # Choose parent via grid-kNN (cost-aware)\n            parent_node = self._best_parent(grow_tree, grow_grid, sample, cell_size, dim)\n\n            # Extend toward sample\n            last_new = self._extend_connect(grow_tree, grow_grid, parent_node, sample, nodes, edges, obstacles, is_3d, bounds, cell_size, dim)\n            if last_new is None:\n                continue\n\n            # Try direct bridge to opposite tree's nearest\n            near_other = self._nearest_from_grid(other_tree, other_grid, last_new.position, cell_size, dim, want_k=1, max_rings=4)\n            bridge_ok = False\n            if not self._edge_hits_any_obstacle(last_new.position, near_other.position, obstacles, is_3d):\n                edges.append((last_new, near_other))\n                have_candidate = True\n                bridge_ok = True\n                a_node = last_new\n                b_node = near_other\n            else:\n                # Greedy connect other tree toward last_new\n                b_last = self._extend_connect(other_tree, other_grid, near_other, last_new.position, nodes, edges, obstacles, is_3d, bounds, cell_size, dim)\n                if b_last is not None and not self._edge_hits_any_obstacle(b_last.position, last_new.position, obstacles, is_3d):\n                    edges.append((b_last, last_new))\n                    have_candidate = True\n                    bridge_ok = True\n                    a_node = last_new\n                    b_node = b_last\n\n            if bridge_ok:\n                # Assemble path\n                if grow_from_start:\n                    pa = a_node.path_from_root()\n                    pb = b_node.path_from_root()\n                    path = pa + pb[::-1]\n                else:\n                    pa = a_node.path_from_root()\n                    pb = b_node.path_from_root()\n                    path = pb + pa[::-1]\n\n                # Quick bounded-time shortcutting\n                remaining = self.time_limit_sec - (time.time() - t0)\n                budget = max(0.0, min(remaining, self.time_limit_sec * self.smooth_time_frac))\n                path = self._shortcut_path(path, obstacles, is_3d, bounds, budget, self.smooth_attempts)\n\n                # Update best and return immediately (time-optimized)\n                best_path_cost = self._path_length(path)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # -------- Core utilities --------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(len(a)):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        if len(path) < 2:\n            return 0.0\n        c = 0.0\n        for i in range(1, len(path)):\n            c += self._dist(path[i - 1], path[i])\n        return c\n\n    def _within_bounds(self, p, bounds):\n        for i in range(len(bounds)):\n            if p[i] < 0.0 or p[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return tuple(to_pos)\n        r = step / d if d > 0.0 else 0.0\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    def _sample(self, bounds, is_3d, start, goal, focused):\n        # Bias toward corridor after first candidate\n        try:\n            import random\n        except:\n            random = None\n        dim = len(bounds)\n        if focused:\n            if random is not None and self._rand01(random) < self.corridor_bias:\n                t = self._rand01(random)\n                base = tuple(start[i] + (goal[i] - start[i]) * t for i in range(dim))\n                # Jitter per-dimension within a small corridor (proportional to step_size)\n                jitter = []\n                for i in range(dim):\n                    width = max(1.0, self.step_size * 2.5)\n                    u = (self._rand01(random) * 2.0 - 1.0) * width\n                    jitter.append(u)\n                pt = tuple(base[i] + jitter[i] for i in range(dim))\n                if self._within_bounds(pt, bounds):\n                    return pt\n        # Occasional direct goal bias\n        if random is not None and self._rand01(random) < self.goal_bias:\n            return tuple(goal)\n        # Uniform sampling with limited rejection\n        for _ in range(8):\n            if random is not None:\n                pt = tuple(self._rand01(random) * bounds[i] for i in range(dim))\n            else:\n                # Fallback deterministic mid-bounds (rare path)\n                pt = tuple(bounds[i] * 0.5 for i in range(dim))\n            if self._within_bounds(pt, bounds):\n                return pt\n        return tuple(min(max(0.0, pt[i]), bounds[i]) for i in range(dim))\n\n    def _rand01(self, random_mod):\n        return random_mod.random()\n\n    # -------- Tree growth --------\n    def _best_parent(self, tree, grid, sample, cell_size, dim):\n        # For small trees, linear scan\n        if len(tree) < 32:\n            best = tree[0]\n            best_val = best.cost + self._dist(best.position, sample)\n            for n in tree[1:]:\n                v = n.cost + self._dist(n.position, sample)\n                if v < best_val:\n                    best = n\n                    best_val = v\n            return best\n        # Gather k candidates from expanding rings\n        candidates = self._nearest_from_grid(tree, grid, sample, cell_size, dim, want_k=self.k_candidates, max_rings=5, break_on_k=True, return_all=True)\n        if not candidates:\n            # Fallback to nearest by distance\n            return self._nearest_from_grid(tree, grid, sample, cell_size, dim, want_k=1, max_rings=5)\n        best = candidates[0]\n        best_val = best.cost + self._dist(best.position, sample)\n        for n in candidates[1:]:\n            v = n.cost + self._dist(n.position, sample)\n            if v < best_val:\n                best = n\n                best_val = v\n        return best\n\n    def _extend_connect(self, tree, grid, from_node, target_pos, nodes, edges, obstacles, is_3d, bounds, cell_size, dim):\n        current = from_node\n        last_new = None\n        while True:\n            step_pos = self._steer(current.position, target_pos, self.step_size)\n            if not self._within_bounds(step_pos, bounds):\n                break\n            # Node and edge collision checks\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                break\n            if self._edge_hits_any_obstacle(current.position, step_pos, obstacles, is_3d):\n                break\n            # Commit node\n            new_node = Node(step_pos, parent=current, cost=current.cost + self._dist(current.position, step_pos))\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node.position, new_node, cell_size, dim)\n\n            # Local on-the-fly corner cut (grandparent bypass)\n            gp = current.parent\n            if gp is not None:\n                if not self._edge_hits_any_obstacle(gp.position, new_node.position, obstacles, is_3d):\n                    # Rewire new_node to grandparent\n                    current.remove_child(new_node)\n                    new_node.parent = gp\n                    gp.add_child(new_node)\n                    # Update edge list: replace (current, new_node) with (gp, new_node)\n                    self._replace_edge(edges, current, new_node, gp, new_node)\n                    # Update cost from gp\n                    new_node.cost = gp.cost + self._dist(gp.position, new_node.position)\n\n            last_new = new_node\n            current = new_node\n            if self._dist(current.position, target_pos) <= self.step_size:\n                break\n        return last_new\n\n    # -------- Grid NN --------\n    def _cell_index(self, pos, cell_size, dim):\n        if dim == 2:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size))\n        else:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size), int(pos[2] // cell_size))\n\n    def _grid_insert(self, grid, pos, node, cell_size, dim):\n        key = self._cell_index(pos, cell_size, dim)\n        if key in grid:\n            grid[key].append(node)\n        else:\n            grid[key] = [node]\n\n    def _nearest_from_grid(self, tree, grid, point, cell_size, dim, want_k=1, max_rings=4, break_on_k=False, return_all=False):\n        # Linear scan for small trees\n        if len(tree) < 32:\n            if want_k <= 1 and not return_all:\n                best = tree[0]\n                best_d = self._dist(best.position, point)\n                for n in tree[1:]:\n                    d = self._dist(n.position, point)\n                    if d < best_d:\n                        best = n\n                        best_d = d\n                return best\n            else:\n                arr = list(tree)\n                arr.sort(key=lambda n: self._dist(n.position, point))\n                return arr[:want_k]\n\n        center = self._cell_index(point, cell_size, dim)\n        candidates = []\n        for r in range(0, max_rings + 1):\n            if dim == 2:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        idx = (center[0] + dx, center[1] + dy)\n                        if idx in grid:\n                            candidates.extend(grid[idx])\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            idx = (center[0] + dx, center[1] + dy, center[2] + dz)\n                            if idx in grid:\n                                candidates.extend(grid[idx])\n            if break_on_k and len(candidates) >= want_k:\n                break\n        if not candidates:\n            candidates = tree\n\n        # Return nearest or top-k\n        if want_k <= 1 and not return_all:\n            best = candidates[0]\n            best_d = self._dist(best.position, point)\n            for n in candidates[1:]:\n                d = self._dist(n.position, point)\n                if d < best_d:\n                    best = n\n                    best_d = d\n            return best\n        else:\n            # Partial selection by distance\n            cand = list(candidates)\n            cand.sort(key=lambda n: self._dist(n.position, point))\n            return cand[:want_k]\n\n    # -------- Collision checks --------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for x, y, z, w, h, d in obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for x, y, w, h in obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_hits_any_obstacle(self, p0, p1, obstacles, is_3d):\n        # Broad-phase: segment AABB vs box AABB\n        if is_3d:\n            minx = p0[0] if p0[0] < p1[0] else p1[0]\n            maxx = p0[0] if p0[0] > p1[0] else p1[0]\n            miny = p0[1] if p0[1] < p1[1] else p1[1]\n            maxy = p0[1] if p0[1] > p1[1] else p1[1]\n            minz = p0[2] if p0[2] < p1[2] else p1[2]\n            maxz = p0[2] if p0[2] > p1[2] else p1[2]\n            for x, y, z, w, h, d in obstacles:\n                if (maxx < x) or (minx > x + w) or (maxy < y) or (miny > y + h) or (maxz < z) or (minz > z + d):\n                    continue\n                if self._segment_intersects_box(p0, p1, (x, y, z, w, h, d), True):\n                    return True\n            return False\n        else:\n            minx = p0[0] if p0[0] < p1[0] else p1[0]\n            maxx = p0[0] if p0[0] > p1[0] else p1[0]\n            miny = p0[1] if p0[1] < p1[1] else p1[1]\n            maxy = p0[1] if p0[1] > p1[1] else p1[1]\n            for x, y, w, h in obstacles:\n                if (maxx < x) or (minx > x + w) or (maxy < y) or (miny > y + h):\n                    continue\n                if self._segment_intersects_box(p0, p1, (x, y, w, h), False):\n                    return True\n            return False\n\n    def _segment_intersects_box(self, p0, p1, box, is_3d):\n        # Slab method for segment-box intersection; includes endpoints.\n        if is_3d:\n            x, y, z, w, h, d = box\n            bmin = (x, y, z)\n            bmax = (x + w, y + h, z + d)\n            tmin = 0.0\n            tmax = 1.0\n            for i in range(3):\n                a = p0[i]\n                b = p1[i]\n                dlt = b - a\n                if dlt == 0.0:\n                    if a < bmin[i] or a > bmax[i]:\n                        return False\n                    else:\n                        continue\n                inv = 1.0 / dlt\n                t1 = (bmin[i] - a) * inv\n                t2 = (bmax[i] - a) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n            return True\n        else:\n            x, y, w, h = box\n            bmin = (x, y)\n            bmax = (x + w, y + h)\n            tmin = 0.0\n            tmax = 1.0\n            for i in range(2):\n                a = p0[i]\n                b = p1[i]\n                dlt = b - a\n                if dlt == 0.0:\n                    if a < bmin[i] or a > bmax[i]:\n                        return False\n                    else:\n                        continue\n                inv = 1.0 / dlt\n                t1 = (bmin[i] - a) * inv\n                t2 = (bmax[i] - a) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n            return True\n\n    # -------- Edges / smoothing --------\n    def _replace_edge(self, edges, old_u, old_v, new_u, new_v):\n        # Remove first occurrence of (old_u, old_v), then append (new_u, new_v)\n        idx = -1\n        for i in range(len(edges)):\n            u, v = edges[i]\n            if u is old_u and v is old_v:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n        edges.append((new_u, new_v))\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds, time_budget, attempts):\n        if len(path) < 3:\n            return path\n        import time\n        start_t = time.time()\n        pts = list(path)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and (time.time() - start_t) <= time_budget:\n            # Prefer larger gaps\n            i = self._bounded_rand_int(0, n - 3)\n            j = self._bounded_rand_int(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            # Endpoints are in bounds -> segment stays in bounds (box is convex)\n            if not self._edge_hits_any_obstacle(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n            tries += 1\n        return pts\n\n    def _bounded_rand_int(self, lo, hi):\n        try:\n            import random\n            return random.randint(lo, hi)\n        except:\n            # Fallback deterministic midpoint\n            return (lo + hi) // 2",
          "objective": -32.81411,
          "time_improvement": 53.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 2252.0,
          "node_improvement": 60.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0225860595703125,
                    "num_nodes_avg": 251.7,
                    "path_length_avg": 171.85198364917562,
                    "smoothness_avg": 0.06040808331984212,
                    "success_improvement": 0.0,
                    "time_improvement": 8.452061241470474,
                    "node_improvement": 36.61546210022665,
                    "length_improvement": 5.805204592942339,
                    "smoothness_improvement": 845.5176822080389,
                    "objective_score": 10.24632953924674
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02895486354827881,
                    "num_nodes_avg": 340.9,
                    "path_length_avg": 245.2869996289932,
                    "smoothness_avg": 0.1574856214355659,
                    "success_improvement": 0.0,
                    "time_improvement": 82.68783927105191,
                    "node_improvement": 77.09467177316402,
                    "length_improvement": 18.116139329020882,
                    "smoothness_improvement": 3952.2184718452627,
                    "objective_score": 55.43712773795441
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.015923190116882324,
                    "num_nodes_avg": 261.0,
                    "path_length_avg": 144.47625851074147,
                    "smoothness_avg": 0.16187356345760986,
                    "success_improvement": 0.0,
                    "time_improvement": 68.45438696509973,
                    "node_improvement": 66.81500317863954,
                    "length_improvement": 4.045748317297235,
                    "smoothness_improvement": 1959.0197789172153,
                    "objective_score": 32.75886397449433
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "FIBCO: Fast Indexed BiRRT-Connect with Obstacle Binning. A time-focused bidirectional planner that combines single-step tree growth, spatial hashing for fast nearest queries, and an obstacle binning index for cheap, exact line-of-sight tests. It uses corridor- and goal-biased sampling, throttles near-duplicate nodes, performs on-the-fly grandparent compression, attempts an immediate bridge to the opposite tree, and only applies a lightweight visibility-first smoothing once a connection is found. By filtering collision checks to only nearby obstacles and minimizing per-iteration work, it yields faster plans with coherent edges and improved path quality.",
          "planning_mechanism": "Mechanism: Build an obstacle bin grid and two node grids, seed start/goal roots. Each iteration select a target (goal/corridor/uniform), pick the nearest node in the active tree, steer one step, and validate node and edge against only obstacles retrieved from the bins. If valid and not a near-duplicate, insert the node, try grandparent line-of-sight compression, then attempt a direct bridge to the nearest node in the other tree; if that fails, run a very short greedy connect with per-step validation. On success, extract the path, run a fast visibility compression followed by a few shortcuts, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=8.0,\n                 goal_bias=0.20,\n                 corridor_bias=0.55,\n                 connect_steps=6,\n                 min_sep_ratio=0.3,\n                 dupe_radius_ratio=0.5,\n                 smoothing_shortcuts=14):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.connect_steps = connect_steps\n        self.min_sep_ratio = min_sep_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.smoothing_shortcuts = smoothing_shortcuts\n\n        self.dim = 2\n        self.bounds = None\n        self.start = None\n        self.goal = None\n\n        # Node grid (for nearest and duplicate suppression)\n        self.grid_cell = None\n\n        # RNG state\n        self._lcg_state = 2463534242\n\n        # Obstacle bins\n        self._bins_cell = None\n        self._bins_n = None\n        self._bins = None\n        self._obstacles = None\n\n    # ---------------- Planning ----------------\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self._obstacles = list(map.obstacles)\n        is_3d = (self.dim == 3)\n\n        # Grid cell for nodes tuned to step size\n        self.grid_cell = max(1.0, 0.85 * self.step_size)\n\n        # Build obstacle bins for fast filtering\n        self._build_obstacle_bins(is_3d)\n\n        # Validate start/goal inside bounds and free\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obstacle(self.start, is_3d) or self._point_in_obstacle(self.goal, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._edge_blocked(self.start, self.goal, is_3d):\n            nodes = [Node(self.start), Node(self.goal)]\n            return PlannerResult(True, [self.start, self.goal], nodes, [])\n\n        # Initialize trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Corridor parameters\n        dsg = self._dist(self.start, self.goal)\n        base_corridor = max(self.step_size, 0.15 * dsg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = self.goal if active_start else self.start\n\n            # Target selection\n            r = self._rand()\n            if r < self.goal_bias:\n                x_rand = root_other\n            elif r < self.goal_bias + self.corridor_bias:\n                x_rand = self._sample_corridor(base_corridor, is_3d)\n            else:\n                x_rand = self._sample_free(is_3d)\n\n            # Nearest and one-step steer\n            nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n            if nearest is None:\n                continue\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n\n            # Bounds, node collision, separation, duplicate throttle\n            if not self._in_bounds(new_pos):\n                continue\n            if self._point_in_obstacle(new_pos, is_3d):\n                continue\n            if self._dist(nearest.position, new_pos) < self.step_size * self.min_sep_ratio:\n                continue\n            if self._exists_close(grid_a, new_pos, self.step_size * self.dupe_radius_ratio):\n                continue\n\n            # Edge collision check (must be clear)\n            if self._edge_blocked(nearest.position, new_pos, is_3d):\n                continue\n\n            # Insert node and edge\n            new_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, new_node)\n\n            # On-the-fly grandparent compression\n            gp = nearest.parent\n            if gp is not None and not self._edge_blocked(gp.position, new_node.position, is_3d):\n                nearest.remove_child(new_node)\n                try:\n                    edges.remove((nearest, new_node))\n                except:\n                    pass\n                gp.add_child(new_node)\n                edges.append((gp, new_node))\n                new_node.cost = gp.cost + self._dist(gp.position, new_node.position)\n\n            # Try direct bridge to the nearest in the other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None and not self._edge_blocked(new_node.position, other_near.position, is_3d):\n                path = self._extract_path(new_node, other_near)\n                path = self._smooth_path(path, is_3d)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Short greedy connect from other tree\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, new_node.position, self.step_size)\n                if not self._in_bounds(to_pos):\n                    break\n                if self._point_in_obstacle(to_pos, is_3d):\n                    break\n                if self._dist(p.position, to_pos) < self.step_size * self.min_sep_ratio:\n                    break\n                if self._edge_blocked(p.position, to_pos, is_3d):\n                    break\n\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                edges.append((p, q))\n                self._grid_add(grid_b, q)\n                p = q\n                steps += 1\n\n                # Bridge now?\n                if not self._edge_blocked(new_node.position, p.position, is_3d):\n                    path = self._extract_path(new_node, p)\n                    path = self._smooth_path(path, is_3d)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------------- RNG ----------------\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------------- Geometry ----------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------------- Obstacle bins ----------------\n    def _build_obstacle_bins(self, is_3d):\n        nobs = len(self._obstacles)\n        if nobs <= 0:\n            # Single bin fallback\n            self._bins_cell = (max(self.bounds[0], 1.0), max(self.bounds[1], 1.0)) if not is_3d else (max(self.bounds[0], 1.0), max(self.bounds[1], 1.0), max(self.bounds[2], 1.0))\n            self._bins_n = (1, 1) if not is_3d else (1, 1, 1)\n            self._bins = { (0, 0) if not is_3d else (0, 0, 0): [] }\n            return\n\n        # Choose grid resolution based on obstacle count\n        base = int((nobs ** 0.5) * 2.0) + 4\n        g = max(8, min(48, base))\n        if not is_3d:\n            cx = max(self.bounds[0] / g, 1.0)\n            cy = max(self.bounds[1] / g, 1.0)\n            nx = max(int(self.bounds[0] / cx), 1)\n            ny = max(int(self.bounds[1] / cy), 1)\n            self._bins_cell = (cx, cy)\n            self._bins_n = (nx, ny)\n            self._bins = {}\n            for obs in self._obstacles:\n                x, y, w, h = obs\n                i0 = int(x / cx)\n                j0 = int(y / cy)\n                i1 = int((x + w) / cx)\n                j1 = int((y + h) / cy)\n                if i0 < 0: i0 = 0\n                if j0 < 0: j0 = 0\n                if i1 >= nx: i1 = nx - 1\n                if j1 >= ny: j1 = ny - 1\n                for i in range(i0, i1 + 1):\n                    for j in range(j0, j1 + 1):\n                        k = (i, j)\n                        bucket = self._bins.get(k)\n                        if bucket is None:\n                            self._bins[k] = [obs]\n                        else:\n                            bucket.append(obs)\n        else:\n            cx = max(self.bounds[0] / g, 1.0)\n            cy = max(self.bounds[1] / g, 1.0)\n            cz = max(self.bounds[2] / max(int(g * 0.75), 1), 1.0)\n            nx = max(int(self.bounds[0] / cx), 1)\n            ny = max(int(self.bounds[1] / cy), 1)\n            nz = max(int(self.bounds[2] / cz), 1)\n            self._bins_cell = (cx, cy, cz)\n            self._bins_n = (nx, ny, nz)\n            self._bins = {}\n            for obs in self._obstacles:\n                x, y, z, w, h, d = obs\n                i0 = int(x / cx)\n                j0 = int(y / cy)\n                k0 = int(z / cz)\n                i1 = int((x + w) / cx)\n                j1 = int((y + h) / cy)\n                k1 = int((z + d) / cz)\n                if i0 < 0: i0 = 0\n                if j0 < 0: j0 = 0\n                if k0 < 0: k0 = 0\n                if i1 >= nx: i1 = nx - 1\n                if j1 >= ny: j1 = ny - 1\n                if k1 >= nz: k1 = nz - 1\n                for i in range(i0, i1 + 1):\n                    for j in range(j0, j1 + 1):\n                        for k in range(k0, k1 + 1):\n                            key = (i, j, k)\n                            bucket = self._bins.get(key)\n                            if bucket is None:\n                                self._bins[key] = [obs]\n                            else:\n                                bucket.append(obs)\n\n    def _bin_key(self, pos):\n        if self.dim == 2:\n            cx, cy = self._bins_cell\n            i = int(pos[0] / cx)\n            j = int(pos[1] / cy)\n            nx, ny = self._bins_n\n            if i < 0: i = 0\n            if j < 0: j = 0\n            if i >= nx: i = nx - 1\n            if j >= ny: j = ny - 1\n            return (i, j)\n        else:\n            cx, cy, cz = self._bins_cell\n            i = int(pos[0] / cx)\n            j = int(pos[1] / cy)\n            k = int(pos[2] / cz)\n            nx, ny, nz = self._bins_n\n            if i < 0: i = 0\n            if j < 0: j = 0\n            if k < 0: k = 0\n            if i >= nx: i = nx - 1\n            if j >= ny: j = ny - 1\n            if k >= nz: k = nz - 1\n            return (i, j, k)\n\n    def _bin_range_for_bbox(self, bmin, bmax):\n        # Returns iterator over bin keys intersecting an AABB\n        if self.dim == 2:\n            cx, cy = self._bins_cell\n            nx, ny = self._bins_n\n            i0 = int(bmin[0] / cx)\n            j0 = int(bmin[1] / cy)\n            i1 = int(bmax[0] / cx)\n            j1 = int(bmax[1] / cy)\n            if i0 < 0: i0 = 0\n            if j0 < 0: j0 = 0\n            if i1 >= nx: i1 = nx - 1\n            if j1 >= ny: j1 = ny - 1\n            return ((i, j) for i in range(i0, i1 + 1) for j in range(j0, j1 + 1))\n        else:\n            cx, cy, cz = self._bins_cell\n            nx, ny, nz = self._bins_n\n            i0 = int(bmin[0] / cx)\n            j0 = int(bmin[1] / cy)\n            k0 = int(bmin[2] / cz)\n            i1 = int(bmax[0] / cx)\n            j1 = int(bmax[1] / cy)\n            k1 = int(bmax[2] / cz)\n            if i0 < 0: i0 = 0\n            if j0 < 0: j0 = 0\n            if k0 < 0: k0 = 0\n            if i1 >= nx: i1 = nx - 1\n            if j1 >= ny: j1 = ny - 1\n            if k1 >= nz: k1 = nz - 1\n            return ((i, j, k) for i in range(i0, i1 + 1) for j in range(j0, j1 + 1) for k in range(k0, k1 + 1))\n\n    def _point_in_obstacle(self, pos, is_3d):\n        key = self._bin_key(pos)\n        bucket = self._bins.get(key)\n        if not bucket:\n            return False\n        if not is_3d:\n            px, py = pos\n            for obs in bucket:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        else:\n            px, py, pz = pos\n            for obs in bucket:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        return False\n\n    def _edge_blocked(self, a, b, is_3d):\n        # Fetch candidate obstacles using segment bbox and test with slab method\n        if self.dim == 2:\n            bmin = (min(a[0], b[0]), min(a[1], b[1]))\n            bmax = (max(a[0], b[0]), max(a[1], b[1]))\n        else:\n            bmin = (min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2]))\n            bmax = (max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2]))\n        seen = {}\n        for key in self._bin_range_for_bbox(bmin, bmax):\n            bucket = self._bins.get(key)\n            if not bucket:\n                continue\n            for obs in bucket:\n                oid = id(obs)\n                if seen.get(oid) is not None:\n                    continue\n                seen[oid] = True\n                if self._segment_intersects_box(a, b, obs, is_3d):\n                    return True\n        return False\n\n    def _segment_intersects_box(self, a, b, obs, is_3d):\n        # Liang-Barsky style slab intersection for a segment [a,b] against axis-aligned box\n        tmin = 0.0\n        tmax = 1.0\n        eps = 1e-12\n        if not is_3d:\n            x, y, w, h = obs\n            bmin = (x, y)\n            bmax = (x + w, y + h)\n            for i in range(2):\n                p0 = a[i]\n                p1 = b[i]\n                d = p1 - p0\n                lo = bmin[i]\n                hi = bmax[i]\n                if abs(d) < eps:\n                    if p0 < lo or p0 > hi:\n                        return False\n                else:\n                    inv = 1.0 / d\n                    t1 = (lo - p0) * inv\n                    t2 = (hi - p0) * inv\n                    if t1 > t2:\n                        t1, t2 = t2, t1\n                    if t1 > tmin:\n                        tmin = t1\n                    if t2 < tmax:\n                        tmax = t2\n                    if tmin > tmax:\n                        return False\n            return True\n        else:\n            x, y, z, w, h, dlen = obs\n            bmin = (x, y, z)\n            bmax = (x + w, y + h, z + dlen)\n            for i in range(3):\n                p0 = a[i]\n                p1 = b[i]\n                d = p1 - p0\n                lo = bmin[i]\n                hi = bmax[i]\n                if abs(d) < eps:\n                    if p0 < lo or p0 > hi:\n                        return False\n                else:\n                    inv = 1.0 / d\n                    t1 = (lo - p0) * inv\n                    t2 = (hi - p0) * inv\n                    if t1 > t2:\n                        t1, t2 = t2, t1\n                    if t1 > tmin:\n                        tmin = t1\n                    if t2 < tmax:\n                        tmax = t2\n                    if tmin > tmax:\n                        return False\n            return True\n\n    # ---------------- Sampling ----------------\n    def _sample_free(self, is_3d):\n        # Rejection sampling with bin-based point test\n        for _ in range(64):\n            if not is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            if not self._point_in_obstacle(p, is_3d):\n                return p\n        # Fallback deterministic center\n        return tuple(min(max((self.start[i] + self.goal[i]) * 0.5, 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _sample_corridor(self, width, is_3d):\n        # Sample near the start-goal line with bounded jitter\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 2:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        if not self._point_in_obstacle(p, is_3d):\n            return p\n        return self._sample_free(is_3d)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # ---------------- Node grid ----------------\n    def _grid_key(self, pos):\n        if self.dim == 2:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell))\n        else:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell), int(pos[2] // self.grid_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, 3):\n            cand = self._grid_collect_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_collect_ring(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # ---------------- Path utilities ----------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)  # root_A -> meet_a\n        # meet_b -> root_B\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _smooth_path(self, path, is_3d):\n        if not path or len(path) < 3:\n            return path\n        # Visibility compression\n        pts = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            found = False\n            while j > i + 1:\n                if not self._edge_blocked(path[i], path[j], is_3d):\n                    pts.append(path[j])\n                    i = j\n                    found = True\n                    break\n                j -= 1\n            if not found:\n                pts.append(path[i + 1])\n                i += 1\n        # Shortcutting (bounded)\n        for _ in range(self.smoothing_shortcuts):\n            m = len(pts)\n            if m < 3:\n                break\n            i = int(self._uniform(0, m - 2))\n            j = int(self._uniform(i + 1, m - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j], is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -32.67315,
          "time_improvement": 61.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 1710.0,
          "node_improvement": 86.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01368570327758789,
                    "num_nodes_avg": 72.6,
                    "path_length_avg": 180.7567919414105,
                    "smoothness_avg": 0.05117958870062285,
                    "success_improvement": 0.0,
                    "time_improvement": 44.5278216138749,
                    "node_improvement": 81.7174515235457,
                    "length_improvement": 0.9243380622512352,
                    "smoothness_improvement": 701.0717014204404,
                    "objective_score": 17.41830782861541
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025516176223754884,
                    "num_nodes_avg": 128.9,
                    "path_length_avg": 245.53658465189,
                    "smoothness_avg": 0.1119686843118635,
                    "success_improvement": 0.0,
                    "time_improvement": 84.74383610072074,
                    "node_improvement": 91.33911173822482,
                    "length_improvement": 18.032820664471366,
                    "smoothness_improvement": 2781.03489512775,
                    "objective_score": 50.14801770453779
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022872543334960936,
                    "num_nodes_avg": 112.6,
                    "path_length_avg": 135.98428209550633,
                    "smoothness_avg": 0.13735319148358044,
                    "success_improvement": 0.0,
                    "time_improvement": 54.686944269812166,
                    "node_improvement": 85.68340750158931,
                    "length_improvement": 9.685714707833764,
                    "smoothness_improvement": 1647.1224573131515,
                    "objective_score": 30.453124392209663
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "FALCON-IBiRRT*: Fast LRU-cached, AABB-indexed, Corridor-Optimized BiRRT* with micro-rewiring and informed bridging. It accelerates collision checks via an obstacle spatial grid and slab-based segment-vs-AABB tests, boosts cache reuse with coarse edge quantization and gentle LRU pruning, focuses growth using goal/ellipse-guided sampling once a provisional bound exists, and keeps NN queries light with a coarse node grid and per-cell caps. Shortcuts and collinearity pruning finalize smooth, short paths quickly.",
          "planning_mechanism": "Mechanism: Build an obstacle grid for fast point/segment queries, then grow two trees from start/goal. Each step samples (goal-biased; ellipse-focused after a bound), steers once, validates node+edge, picks the cheapest parent from nearby nodes, inserts, and micro-rewires. After each insertion, try a cost-aware direct bridge to nearby nodes of the opposite tree. Edge checks use slab-AABB tests with an LRU edge cache. On bridge, extract, shortcut with cached checks, and prune collinear points; otherwise iterate until the budget.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=2800,\n        step_size=5.5,\n        beam_width=2,\n        goal_bias=0.35,\n        grid_cell_factor=1.8,\n        neighbor_radius_factor=2.2,\n        rewire_ratio=0.6,\n        per_cell_cap=8,\n        min_separation_factor=0.5,\n        edge_cache_capacity=48000,\n        cache_quant_factor=0.9,\n        shortcut_attempts=70,\n        no_improve_stop=16,\n        connect_radius_factor=2.2\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.neighbor_radius_factor = neighbor_radius_factor\n        self.rewire_ratio = rewire_ratio\n        self.per_cell_cap = per_cell_cap\n        self.min_separation_factor = min_separation_factor\n        self.edge_cache_capacity = edge_cache_capacity\n        self.cache_quant_factor = cache_quant_factor\n        self.shortcut_attempts = shortcut_attempts\n        self.no_improve_stop = no_improve_stop\n        self.connect_radius_factor = connect_radius_factor\n\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = map.start\n        self.goal = map.goal\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        # Parameterized helpers\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n        self.neighbor_radius = max(self.step_size * self.neighbor_radius_factor, self.cell_size * 1.4)\n        self.connect_radius = max(self.neighbor_radius, self.step_size * self.connect_radius_factor)\n\n        # Edge cache (LRU-ish)\n        self._ecache = {}\n        self._tick = 0\n        self._q = max(1.0, self.step_size * self.cache_quant_factor)\n\n        # Seed RNG from scene\n        seedmix = 1469598103934665603\n        seedmix ^= int(sum(self.start) * 1315423911) & 0xFFFFFFFF\n        seedmix ^= int(sum(self.goal) * 2654435761) & 0xFFFFFFFF\n        seedmix ^= int(self.bounds[0]) & 0xFFFFFFFF\n        self._rng = (seedmix | 1) & 0xFFFFFFFF\n\n        # Validate start/goal\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._build_obstacle_grid()\n        if self._in_obstacle(self.start) or self._in_obstacle(self.goal):\n            return PlannerResult(False, [], [], [])\n        # Early LOS\n        if self._edge_free(self.start, self.goal):\n            nodes = [Node(self.start), Node(self.goal)]\n            return PlannerResult(True, [self.start, self.goal], nodes, [])\n\n        # Trees and spatial hashing\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        best_path = None\n        incumbent_len = None\n        dsg = self._distance(self.start, self.goal)\n\n        for _ in range(self.max_iter):\n            for active_tree, active_grid, other_tree, other_grid, attractor in [\n                (tree_a, grid_a, tree_b, grid_b, self.goal),\n                (tree_b, grid_b, tree_a, grid_a, self.start),\n            ]:\n                progressed = False\n                for _b in range(self.beam_width):\n                    sp = self._guided_sample(attractor, incumbent_len, dsg)\n                    if sp is None:\n                        continue\n                    nearest = self._nearest_in_grid(active_grid, sp)\n                    if nearest is None:\n                        continue\n                    new_pos = self._steer(nearest.position, sp)\n                    if not self._within_bounds(new_pos):\n                        continue\n                    if self._in_obstacle(new_pos):\n                        continue\n                    if not self._edge_free(nearest.position, new_pos):\n                        continue\n                    if self._has_nearby(active_grid, new_pos, self.min_separation):\n                        continue\n\n                    parent, new_cost = self._choose_parent(active_grid, nearest, new_pos)\n                    cell_key = self._cell_of(new_pos)\n                    bucket = active_grid.get(cell_key)\n                    if bucket and len(bucket) >= self.per_cell_cap:\n                        best_bucket_cost = min(n.cost for n in bucket)\n                        if new_cost >= best_bucket_cost - 1e-9:\n                            continue\n\n                    # Insert node (both checks already done)\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node)\n                    progressed = True\n\n                    # Micro-rewiring with both checks\n                    self._rewire_neighbors(active_grid, new_node, nodes, edges)\n\n                    # Attempt cost-aware bridge\n                    partner = self._best_bridge(new_node, other_grid)\n                    if partner is not None:\n                        raw = self._path_from_root(new_node) + self._path_from_root(partner)[::-1]\n                        raw = self._dedup_consecutive(raw)\n                        sm = self._shortcut_and_prune(raw)\n                        final_path = sm if sm else raw\n                        best_path = final_path\n                        incumbent_len = self._path_length(final_path)\n                        return PlannerResult(True, final_path, nodes, edges)\n                if not progressed:\n                    continue\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xFFFFFFFF\n        return self._rng / 4294967296.0\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _distance(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._distance(path[i - 1], path[i])\n        return total\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    def _steer(self, a, b):\n        d = self._distance(a, b)\n        if d <= 1e-12:\n            return a\n        if d <= self.step_size:\n            p = b\n        else:\n            r = self.step_size / d\n            p = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n        if self.is_3d:\n            return (self._clamp(p[0], 0.0, self.bounds[0]),\n                    self._clamp(p[1], 0.0, self.bounds[1]),\n                    self._clamp(p[2], 0.0, self.bounds[2]))\n        else:\n            return (self._clamp(p[0], 0.0, self.bounds[0]),\n                    self._clamp(p[1], 0.0, self.bounds[1]))\n\n    # Sampling\n    def _guided_sample(self, attractor, incumbent_len, dsg):\n        for _ in range(14):\n            if incumbent_len is not None and dsg > 1e-9:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.02)\n                if p is not None:\n                    return p\n            if self._rand() < self.goal_bias:\n                jit = self.step_size * 0.6\n                if self.is_3d:\n                    p = (self._clamp(attractor[0] + self._rand_range(-jit, jit), 0.0, self.bounds[0]),\n                         self._clamp(attractor[1] + self._rand_range(-jit, jit), 0.0, self.bounds[1]),\n                         self._clamp(attractor[2] + self._rand_range(-jit, jit), 0.0, self.bounds[2]))\n                else:\n                    p = (self._clamp(attractor[0] + self._rand_range(-jit, jit), 0.0, self.bounds[0]),\n                         self._clamp(attractor[1] + self._rand_range(-jit, jit), 0.0, self.bounds[1]))\n            else:\n                if self.is_3d:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n            if self._within_bounds(p) and not self._in_obstacle(p):\n                return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        c = tuple((f1[i] + f2[i]) * 0.5 for i in range(self.dims))\n        half = max_sum_dist * 0.5\n        for _ in range(12):\n            if self.is_3d:\n                p = (self._clamp(c[0] + self._rand_range(-half, half), 0.0, self.bounds[0]),\n                     self._clamp(c[1] + self._rand_range(-half, half), 0.0, self.bounds[1]),\n                     self._clamp(c[2] + self._rand_range(-half, half), 0.0, self.bounds[2]))\n            else:\n                p = (self._clamp(c[0] + self._rand_range(-half, half), 0.0, self.bounds[0]),\n                     self._clamp(c[1] + self._rand_range(-half, half), 0.0, self.bounds[1]))\n            if self._distance(p, f1) + self._distance(p, f2) <= max_sum_dist and not self._in_obstacle(p):\n                return p\n        return None\n\n    # Node grid\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        k = self._cell_of(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _nearest_in_grid(self, grid, pos, max_ring=4):\n        cell = self._cell_of(pos)\n        best = None\n        best_d = 1e100\n        if self.is_3d:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            b = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if b:\n                                found = True\n                                for n in b:\n                                    d = self._distance(n.position, pos)\n                                    if d < best_d:\n                                        best_d = d\n                                        best = n\n                if found and best is not None:\n                    return best\n        else:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        b = grid.get((cell[0] + dx, cell[1] + dy))\n                        if b:\n                            found = True\n                            for n in b:\n                                d = self._distance(n.position, pos)\n                                if d < best_d:\n                                    best_d = d\n                                    best = n\n                if found and best is not None:\n                    return best\n        # fallback scan if grid sparse\n        for b in grid.values():\n            for n in b:\n                d = self._distance(n.position, pos)\n                if d < best_d:\n                    best_d = d\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        res = []\n        cell = self._cell_of(pos)\n        rc = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        b = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if b:\n                            for n in b:\n                                if self._distance(n.position, pos) <= radius:\n                                    res.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    b = grid.get((cell[0] + dx, cell[1] + dy))\n                    if b:\n                        for n in b:\n                            if self._distance(n.position, pos) <= radius:\n                                res.append(n)\n        return res\n\n    def _has_nearby(self, grid, pos, radius):\n        cell = self._cell_of(pos)\n        rc = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        b = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if b:\n                            for n in b:\n                                if self._distance(n.position, pos) <= radius:\n                                    return True\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    b = grid.get((cell[0] + dx, cell[1] + dy))\n                    if b:\n                        for n in b:\n                            if self._distance(n.position, pos) <= radius:\n                                return True\n        return False\n\n    # Parent selection and rewiring\n    def _choose_parent(self, grid, nearest, new_pos):\n        best_parent = nearest\n        best_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        neigh = self._neighbors_in_radius(grid, new_pos, self.neighbor_radius)\n        for n in neigh:\n            if self._in_obstacle(n.position):\n                continue\n            if not self._edge_free(n.position, new_pos):\n                continue\n            cand = n.cost + self._distance(n.position, new_pos)\n            if cand + 1e-9 < best_cost:\n                best_cost = cand\n                best_parent = n\n        return best_parent, best_cost\n\n    def _rewire_neighbors(self, grid, new_node, nodes, edges):\n        radius = self.neighbor_radius * self.rewire_ratio\n        neigh = self._neighbors_in_radius(grid, new_node.position, radius)\n        rewired = 0\n        for nb in neigh:\n            if nb is new_node or nb.parent is None:\n                continue\n            if self._in_obstacle(nb.position):\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            new_cost = new_node.cost + self._distance(new_node.position, nb.position)\n            if new_cost + 1e-9 < nb.cost:\n                old_parent = nb.parent\n                if old_parent is not None and nb in old_parent.children:\n                    old_parent.children.remove(nb)\n                new_node.add_child(nb)\n                self._replace_edge(edges, old_parent, nb, new_node, nb)\n                delta = new_cost - nb.cost\n                self._update_subtree_cost(nb, delta)\n                rewired += 1\n                if rewired >= 8:\n                    break\n\n    def _replace_edge(self, edges, old_u, old_v, new_u, new_v):\n        idx = -1\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is old_u and e[1] is old_v:\n                idx = i\n                break\n        if idx >= 0:\n            del edges[idx]\n        present = False\n        for e in edges:\n            if e[0] is new_u and e[1] is new_v:\n                present = True\n                break\n        if not present:\n            edges.append((new_u, new_v))\n\n    def _update_subtree_cost(self, node, delta):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            cur.cost += delta\n            for ch in cur.children:\n                stack.append(ch)\n\n    # Bridging and path extraction\n    def _best_bridge(self, new_node, other_grid):\n        candidates = self._neighbors_in_radius(other_grid, new_node.position, self.connect_radius)\n        if not candidates:\n            near = self._nearest_in_grid(other_grid, new_node.position)\n            if near is not None:\n                candidates = [near]\n        best = None\n        best_total = 1e100\n        for n in candidates:\n            if not self._edge_free(new_node.position, n.position):\n                continue\n            total = new_node.cost + self._distance(new_node.position, n.position) + n.cost\n            if total < best_total:\n                best_total = total\n                best = n\n        return best\n\n    def _path_from_root(self, node):\n        seq = []\n        cur = node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        return seq[::-1]\n\n    def _dedup_consecutive(self, path):\n        if not path:\n            return path\n        out = [path[0]]\n        last = path[0]\n        for p in path[1:]:\n            same = True\n            for i in range(self.dims):\n                if abs(p[i] - last[i]) > 1e-12:\n                    same = False\n                    break\n            if not same:\n                out.append(p)\n                last = p\n        return out\n\n    def _shortcut_and_prune(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        attempts = 0\n        no_imp = 0\n        i = 0\n        while attempts < self.shortcut_attempts and i < len(pts) - 2:\n            improved = False\n            j = len(pts) - 1\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    del pts[i + 1:j]\n                    improved = True\n                    no_imp = 0\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n                no_imp += 1\n            attempts += 1\n            if no_imp >= self.no_improve_stop:\n                break\n        return self._prune_collinear(pts)\n\n    def _prune_collinear(self, pts, tol=1e-3):\n        if len(pts) < 3:\n            return pts[:]\n        res = [pts[0]]\n        for k in range(1, len(pts) - 1):\n            a = res[-1]\n            b = pts[k]\n            c = pts[k + 1]\n            if self._point_line_distance(b, a, c) <= tol:\n                continue\n            res.append(b)\n        res.append(pts[-1])\n        return res\n\n    def _point_line_distance(self, p, a, b):\n        ap = tuple(p[i] - a[i] for i in range(self.dims))\n        ab = tuple(b[i] - a[i] for i in range(self.dims))\n        ab2 = 0.0\n        for i in range(self.dims):\n            ab2 += ab[i] * ab[i]\n        if ab2 <= 1e-12:\n            return self._distance(p, a)\n        t = 0.0\n        num = 0.0\n        for i in range(self.dims):\n            num += ap[i] * ab[i]\n        t = num / ab2\n        if t < 0.0:\n            t = 0.0\n        elif t > 1.0:\n            t = 1.0\n        proj = tuple(a[i] + ab[i] * t for i in range(self.dims))\n        return self._distance(p, proj)\n\n    # Obstacles and collision (spatial grid + slab tests)\n    def _build_obstacle_grid(self):\n        # Choose obstacle grid cell size from scene stats\n        if not self.obstacles:\n            self.og_cell = max(4.0, self.step_size * 2.5)\n            self.og = {}\n            return\n        avg_span = 0.0\n        for obs in self.obstacles:\n            if self.is_3d:\n                avg_span += (obs[3] + obs[4] + obs[5]) / 3.0\n            else:\n                avg_span += (obs[2] + obs[3]) / 2.0\n        avg_span /= max(1, len(self.obstacles))\n        self.og_cell = max(self.step_size * 2.0, avg_span)\n        self.og = {}\n        for obs in self.obstacles:\n            if self.is_3d:\n                x, y, z, w, h, d = obs\n                i0 = int(x // self.og_cell); i1 = int((x + w) // self.og_cell)\n                j0 = int(y // self.og_cell); j1 = int((y + h) // self.og_cell)\n                k0 = int(z // self.og_cell); k1 = int((z + d) // self.og_cell)\n                for i in range(i0, i1 + 1):\n                    for j in range(j0, j1 + 1):\n                        for k in range(k0, k1 + 1):\n                            key = (i, j, k)\n                            b = self.og.get(key)\n                            if b is None:\n                                self.og[key] = [obs]\n                            else:\n                                b.append(obs)\n            else:\n                x, y, w, h = obs\n                i0 = int(x // self.og_cell); i1 = int((x + w) // self.og_cell)\n                j0 = int(y // self.og_cell); j1 = int((y + h) // self.og_cell)\n                for i in range(i0, i1 + 1):\n                    for j in range(j0, j1 + 1):\n                        key = (i, j)\n                        b = self.og.get(key)\n                        if b is None:\n                            self.og[key] = [obs]\n                        else:\n                            b.append(obs)\n\n    def _og_key(self, p):\n        if self.is_3d:\n            return (int(p[0] // self.og_cell), int(p[1] // self.og_cell), int(p[2] // self.og_cell))\n        return (int(p[0] // self.og_cell), int(p[1] // self.og_cell))\n\n    def _candidates_in_box(self, mn, mx):\n        if self.is_3d:\n            i0 = int(mn[0] // self.og_cell); i1 = int(mx[0] // self.og_cell)\n            j0 = int(mn[1] // self.og_cell); j1 = int(mx[1] // self.og_cell)\n            k0 = int(mn[2] // self.og_cell); k1 = int(mx[2] // self.og_cell)\n            seen = set()\n            res = []\n            for i in range(i0, i1 + 1):\n                for j in range(j0, j1 + 1):\n                    for k in range(k0, k1 + 1):\n                        b = self.og.get((i, j, k))\n                        if b:\n                            for o in b:\n                                if o not in seen:\n                                    seen.add(o)\n                                    res.append(o)\n            return res\n        else:\n            i0 = int(mn[0] // self.og_cell); i1 = int(mx[0] // self.og_cell)\n            j0 = int(mn[1] // self.og_cell); j1 = int(mx[1] // self.og_cell)\n            seen = set()\n            res = []\n            for i in range(i0, i1 + 1):\n                for j in range(j0, j1 + 1):\n                    b = self.og.get((i, j))\n                    if b:\n                        for o in b:\n                            if o not in seen:\n                                seen.add(o)\n                                res.append(o)\n            return res\n\n    def _in_obstacle(self, pos):\n        if not self.obstacles:\n            return False\n        key = self._og_key(pos)\n        bucket = self.og.get(key)\n        if not bucket:\n            return False\n        if self.is_3d:\n            px, py, pz = pos\n            for o in bucket:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in bucket:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] // self._q) for i in range(self.dims))\n        qb = tuple(int(b[i] // self._q) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        k = self._edge_key(a, b)\n        hit = self._ecache.get(k)\n        if hit is not None:\n            self._tick += 1\n            self._ecache[k] = (hit[0], self._tick)\n            return hit[0]\n        # Query candidate obstacles via bounding box\n        mn = tuple(min(a[i], b[i]) for i in range(self.dims))\n        mx = tuple(max(a[i], b[i]) for i in range(self.dims))\n        cands = self._candidates_in_box(mn, mx)\n        free = True\n        if cands:\n            if self.is_3d:\n                for o in cands:\n                    if self._seg_box_intersect_3d(a, b, o):\n                        free = False\n                        break\n            else:\n                for o in cands:\n                    if self._seg_box_intersect_2d(a, b, o):\n                        free = False\n                        break\n        self._tick += 1\n        self._ecache[k] = (free, self._tick)\n        if len(self._ecache) > self.edge_cache_capacity:\n            self._prune_cache()\n        return free\n\n    def _prune_cache(self):\n        # Remove oldest ~35%\n        if not self._ecache:\n            return\n        # Collect items with timestamps\n        items = list(self._ecache.items())\n        # Simple selection by threshold\n        thresh = self._tick - 3000\n        removed = 0\n        for key, (val, ts) in items:\n            if ts < thresh:\n                if key in self._ecache:\n                    del self._ecache[key]\n                    removed += 1\n        if removed == 0:\n            # Fallback: drop every 4th\n            i = 0\n            for key in list(self._ecache.keys()):\n                if i % 4 == 0:\n                    del self._ecache[key]\n                i += 1\n\n    # Segment vs AABB slab tests\n    def _seg_box_intersect_2d(self, a, b, box):\n        x, y, w, h = box\n        bminx, bminy = x, y\n        bmaxx, bmaxy = x + w, y + h\n        ox, oy = a[0], a[1]\n        dx, dy = b[0] - a[0], b[1] - a[1]\n        t0, t1 = 0.0, 1.0\n        # X slab\n        if abs(dx) < 1e-12:\n            if ox < bminx or ox > bmaxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            tmin = (bminx - ox) * inv\n            tmax = (bmaxx - ox) * inv\n            if tmin > tmax:\n                tmin, tmax = tmax, tmin\n            t0 = max(t0, tmin); t1 = min(t1, tmax)\n            if t0 > t1:\n                return False\n        # Y slab\n        if abs(dy) < 1e-12:\n            if oy < bminy or oy > bmaxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            tmin = (bminy - oy) * inv\n            tmax = (bmaxy - oy) * inv\n            if tmin > tmax:\n                tmin, tmax = tmax, tmin\n            t0 = max(t0, tmin); t1 = min(t1, tmax)\n            if t0 > t1:\n                return False\n        return True\n\n    def _seg_box_intersect_3d(self, a, b, box):\n        x, y, z, w, h, d = box\n        bminx, bminy, bminz = x, y, z\n        bmaxx, bmaxy, bmaxz = x + w, y + h, z + d\n        ox, oy, oz = a[0], a[1], a[2]\n        dx, dy, dz = b[0] - a[0], b[1] - a[1], b[2] - a[2]\n        t0, t1 = 0.0, 1.0\n        # X\n        if abs(dx) < 1e-12:\n            if ox < bminx or ox > bmaxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            tmin = (bminx - ox) * inv\n            tmax = (bmaxx - ox) * inv\n            if tmin > tmax:\n                tmin, tmax = tmax, tmin\n            t0 = max(t0, tmin); t1 = min(t1, tmax)\n            if t0 > t1:\n                return False\n        # Y\n        if abs(dy) < 1e-12:\n            if oy < bminy or oy > bmaxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            tmin = (bminy - oy) * inv\n            tmax = (bmaxy - oy) * inv\n            if tmin > tmax:\n                tmin, tmax = tmax, tmin\n            t0 = max(t0, tmin); t1 = min(t1, tmax)\n            if t0 > t1:\n                return False\n        # Z\n        if abs(dz) < 1e-12:\n            if oz < bminz or oz > bmaxz:\n                return False\n        else:\n            inv = 1.0 / dz\n            tmin = (bminz - oz) * inv\n            tmax = (bmaxz - oz) * inv\n            if tmin > tmax:\n                tmin, tmax = tmax, tmin\n            t0 = max(t0, tmin); t1 = min(t1, tmax)\n            if t0 > t1:\n                return False\n        return True",
          "objective": -32.58157,
          "time_improvement": 42.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 2603.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027050352096557616,
                    "num_nodes_avg": 98.0,
                    "path_length_avg": 171.85513554228032,
                    "smoothness_avg": 0.04724224515093277,
                    "success_improvement": 0.0,
                    "time_improvement": -9.643028675411124,
                    "node_improvement": 75.3210778141526,
                    "length_improvement": 5.803476990386709,
                    "smoothness_improvement": 639.4437247894238,
                    "objective_score": 3.7863962155558073
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.040798068046569824,
                    "num_nodes_avg": 162.0,
                    "path_length_avg": 248.73422617933517,
                    "smoothness_avg": 0.19760167426978067,
                    "success_improvement": 0.0,
                    "time_improvement": 75.60676774473131,
                    "node_improvement": 89.11509776254786,
                    "length_improvement": 16.965355883602044,
                    "smoothness_improvement": 4984.433405694544,
                    "objective_score": 57.78341088205333
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02036159038543701,
                    "num_nodes_avg": 137.0,
                    "path_length_avg": 132.12841630096472,
                    "smoothness_avg": 0.17969480341941338,
                    "success_improvement": 0.0,
                    "time_improvement": 59.66142171516668,
                    "node_improvement": 82.58105530832803,
                    "length_improvement": 12.246597171969995,
                    "smoothness_improvement": 2185.7046358042544,
                    "objective_score": 36.17490799675328
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "Flash-IBiRRT-DC: A fast Bidirectional RRT with Informed Biasing, Direct-Connect, and sparse grids. It minimizes planning time by (1) aggressive informed sampling once an incumbent appears, (2) single-step expansion with min-separation to cap node count, (3) direct cross-tree connection without growing the opposite tree, (4) lightweight neighbor search via sparse spatial hash, and (5) minimal, collision-aware smoothing.",
          "planning_mechanism": "Mechanism: Alternate expanding start/goal trees. Each iteration: draw an informed/corridor/goal-biased sample, find k-nearest anchors from a few grid rings, steer one step, validate node+edge, choose the cheapest feasible parent, and insert. Then try a direct edge to the nearest node of the opposite tree within a connect radius; on success, extract and lightly smooth the path and return. No multi-step connect and no heavy rewiring to reduce time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=7.5,\n                 goal_bias=0.35,\n                 corridor_bias=0.30,\n                 ellipse_bias=0.70,\n                 grid_cell_factor=2.2,\n                 min_sep_ratio=0.6,\n                 k_parent=4,\n                 k_anchor=6,\n                 connect_radius_mult=2.6,\n                 smoothing_attempts=60):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.ellipse_bias = float(ellipse_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.min_sep_ratio = float(min_sep_ratio)\n        self.k_parent = int(max(1, k_parent))\n        self.k_anchor = int(max(1, k_anchor))\n        self.connect_radius_mult = float(connect_radius_mult)\n        self.smoothing_attempts = int(max(0, smoothing_attempts))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self._is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Spatial params\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step * self.min_sep_ratio)\n        self.connect_radius = max(self.step * 1.2, self.step * self.connect_radius_mult)\n\n        # RNG seed\n        self._seed()\n\n        # Build obstacle bins\n        self._build_obs_bins()\n\n        # Validate start/goal occupancy\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Trivial straight-line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._smooth_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        incumbent_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            target_root = self.goal if active_start else self.start\n\n            # Guided sample\n            sp = self._guided_sample(target_root, incumbent_len)\n            if sp is None:\n                continue\n\n            # k-nearest anchors in active tree\n            anchors = self._grid_k_nearest(grid_a, sp, self.k_anchor)\n            if not anchors:\n                anchors = [tree_a[-1]]\n\n            # Try steering from the best anchor\n            parent = None\n            newp = None\n            bestc = None\n            # Evaluate a few anchors, pick cheapest feasible\n            for anc in anchors:\n                cand = self._steer(anc.position, sp, self.step)\n                if not self._in_bounds(cand):\n                    continue\n                # Both checks required before adding node/edge\n                if self._point_in_obstacles(cand):\n                    continue\n                if self._too_close(grid_a, cand, self.min_sep):\n                    continue\n                if not self._edge_free(anc.position, cand):\n                    continue\n                gc = anc.cost + self._dist(anc.position, cand)\n                if (parent is None) or (gc + 1e-12 < bestc):\n                    parent = anc\n                    newp = cand\n                    bestc = gc\n\n            if parent is None or newp is None:\n                continue\n\n            nn = Node(newp, parent, bestc)\n            parent.add_child(nn)\n            tree_a.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(grid_a, nn)\n\n            # Direct-Connect: try connecting to nearest in the opposite tree\n            nb = self._grid_k_nearest(grid_b, nn.position, 1)\n            meet_b = nb[0] if nb else None\n            if meet_b is not None:\n                if self._dist(nn.position, meet_b.position) <= self.connect_radius:\n                    if self._edge_free(nn.position, meet_b.position):\n                        path = self._extract_path(nn, meet_b)\n                        L = self._path_len(path)\n                        if incumbent_len is None or L + 1e-9 < incumbent_len:\n                            incumbent_len = L\n                        path = self._smooth_path(path)\n                        return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- RNG ----------\n    def _seed(self):\n        s = 0xA5A5A5A5\n        for v in self.start + self.goal:\n            s ^= (int(v * 2654435761) & 0xffffffff)\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 374761393) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # ---------- Spatial hash ----------\n    def _cell_key(self, p):\n        if self._is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self._is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            cand.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        cand.extend(lst)\n        return cand\n\n    def _grid_k_nearest(self, grid, pos, k, max_rings=4):\n        key = self._cell_key(pos)\n        best = []\n        bestd = []\n        found_any = False\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                found_any = True\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if len(best) < k:\n                        best.append(n)\n                        bestd.append(d2)\n                    else:\n                        # replace worst if better\n                        wi = 0\n                        wd = -1.0\n                        for i in range(len(best)):\n                            if bestd[i] > wd:\n                                wd = bestd[i]\n                                wi = i\n                        if d2 < bestd[wi]:\n                            best[wi] = n\n                            bestd[wi] = d2\n                # Early exit if we have k candidates from small rings\n                if len(best) >= k and r >= 1:\n                    break\n        if not found_any:\n            # Fallback: return last node if grid empty (shouldn't happen)\n            return []\n        # Sort by distance\n        idx = list(range(len(best)))\n        for i in range(len(idx)):\n            for j in range(i + 1, len(idx)):\n                if bestd[idx[j]] < bestd[idx[i]]:\n                    idx[i], idx[j] = idx[j], idx[i]\n        return [best[i] for i in idx]\n\n    def _neighbors_within(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self._is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors_within(grid, pos, radius)) > 0\n\n    # ---------- Obstacles & collision ----------\n    def _build_obs_bins(self):\n        # cell slightly larger than step keeps buckets small and focused\n        self.obs_cell = max(3.0, self.step * 1.1)\n        self.obin = {}\n        if self._is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obin.get(key)\n                            if b is None:\n                                self.obin[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obin.get(key)\n                        if b is None:\n                            self.obin[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self._is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self._is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, target_root, incumbent_len):\n        tries = 12\n        while tries > 0:\n            tries -= 1\n            r = self._rand()\n            if incumbent_len is not None and r < self.ellipse_bias:\n                p = self._sample_in_ellipse(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                r2 = self._rand()\n                if r2 < self.goal_bias:\n                    p = target_root\n                elif r2 < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_point()\n                else:\n                    if self._is3:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]),\n                             self._rand_range(0.0, self.bounds[2]))\n                    else:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _corridor_point(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step * 0.8, 0.05 * sg)\n        if self._is3:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            oz = self._rand_range(-w, w)\n            return self._clamp((base[0] + ox, base[1] + oy, base[2] + oz))\n        else:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            return self._clamp((base[0] + ox, base[1] + oy))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(10):\n            if self._is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if not self._in_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # ---------- Paths and smoothing ----------\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._trace_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _prune_collinear(self, pts, cos_eps=0.995):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        for i in range(1, len(pts) - 1):\n            a = out[-1]\n            b = pts[i]\n            c = pts[i + 1]\n            v1 = tuple(b[j] - a[j] for j in range(self.dim))\n            v2 = tuple(c[j] - b[j] for j in range(self.dim))\n            n1 = sum(v1[j] * v1[j] for j in range(self.dim)) ** 0.5\n            n2 = sum(v2[j] * v2[j] for j in range(self.dim)) ** 0.5\n            if n1 < 1e-9 or n2 < 1e-9:\n                continue\n            cosang = sum(v1[j] * v2[j] for j in range(self.dim)) / (n1 * n2)\n            if cosang < cos_eps:\n                out.append(b)\n        out.append(pts[-1])\n        return out\n\n    def _vis_collapse(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = pts[:]\n        i = 0\n        while i < len(out) - 2:\n            j = len(out) - 1\n            collapsed = False\n            while j > i + 1:\n                if self._edge_free(out[i], out[j]):\n                    del out[i + 1:j]\n                    collapsed = True\n                    break\n                j -= 1\n            if not collapsed:\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        stall = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 1, len(cur) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-9 <= bestL:\n                    cur = cand\n                    bestL = L\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            tries += 1\n            if stall > 20:\n                break\n        return cur\n\n    def _smooth_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._prune_collinear(path)\n        p1 = self._vis_collapse(p0)\n        p2 = self._shortcut(p1, self.smoothing_attempts)\n        return p2",
          "objective": -32.29794,
          "time_improvement": 42.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1657.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011611437797546387,
                    "num_nodes_avg": 45.0,
                    "path_length_avg": 147.65257627327262,
                    "smoothness_avg": 0.04617885414768348,
                    "success_improvement": 0.0,
                    "time_improvement": 52.93542934839856,
                    "node_improvement": 88.66784185343742,
                    "length_improvement": 19.069283239823644,
                    "smoothness_improvement": 622.7993463980489,
                    "objective_score": 30.436195480404
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05334858894348145,
                    "num_nodes_avg": 129.0,
                    "path_length_avg": 238.3184995191058,
                    "smoothness_avg": 0.08995418290254918,
                    "success_improvement": 0.0,
                    "time_improvement": 68.1027905756774,
                    "node_improvement": 91.3323926627696,
                    "length_improvement": 20.44242524285565,
                    "smoothness_improvement": 2214.585917461648,
                    "objective_score": 43.76922190572485
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.047772574424743655,
                    "num_nodes_avg": 100.0,
                    "path_length_avg": 124.42974925219728,
                    "smoothness_avg": 0.1755580483910071,
                    "success_improvement": 0.0,
                    "time_improvement": 5.357209489940944,
                    "node_improvement": 87.28544183089637,
                    "length_improvement": 17.359685254631263,
                    "smoothness_improvement": 2133.0854171864203,
                    "objective_score": 22.68840108569314
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Algorithm description: SWIFT-BiRRT-LOS \u2014 Simple, Weighted-bias, Informed, Fast Triaged Bi-directional RRT with hashed-near lookup, near-duplicate suppression, on-the-fly line-of-sight grandparent compression, light bounded connect-extend, and capped shortcut smoothing for faster, shorter, and smoother paths.",
          "planning_mechanism": "Planning mechanism: Alternate growing two trees with balanced goal/corridor/informed-biased samples. For each sample, find a hashed-nearest node, steer once, check node and edge collisions, insert if not near-duplicate and the cell is not saturated, then immediately try LOS compression to the grandparent to shorten chains. Attempt to connect to the opposite tree using a costless direct check first, then a few bounded, collision-checked extend steps. On success, merge trees and return a visibility-pruned, lightly-shortcutted path; otherwise stop on budget or stall.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=10.0,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 rings_near=2,\n                 goal_bias=0.2,\n                 corridor_bias=0.4,\n                 informed_bias=0.5,\n                 dupe_radius_ratio=0.6,\n                 cell_cap=10,\n                 connect_radius_factor=4.0,\n                 connect_steps=3,\n                 smoothing_attempts=24,\n                 stall_limit=700,\n                 edge_cache_limit=30000):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.collision_step = float(collision_step)\n        self.grid_cell = grid_cell\n        self.rings_near = int(max(1, rings_near))\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.cell_cap = int(max(2, cell_cap))\n        self.connect_radius_factor = float(max(1.0, connect_radius_factor))\n        self.connect_steps = int(max(0, connect_steps))\n        self.smoothing_attempts = int(max(0, smoothing_attempts))\n        self.stall_limit = int(max(100, stall_limit))\n        self.edge_cache_limit = int(max(2000, edge_cache_limit))\n\n        self.bounds = None\n        self.dim = 2\n        self.start = None\n        self.goal = None\n        self.edge_cache = None\n        self.edge_stamp = 0\n        self.edge_res = 1.0\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.8 * self.step_size)\n        self.edge_res = max(0.5, min(self.collision_step, 0.5 * self.step_size))\n\n        self.edge_cache = {}\n        self.edge_stamp = 0\n\n        # Early direct connection\n        if not self._edge_blocked_memo(self.start, self.goal, obstacles, is_3d):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            edges = [(n0, n1)]\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], edges)\n\n        # Initialize trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n\n        dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        connect_radius = max(self.step_size, self.connect_radius_factor * self.step_size)\n        dsg = self._dist(self.start, self.goal)\n        corridor_base = max(self.step_size, 0.2 * dsg)\n\n        best_path = None\n        best_len = float('inf')\n        last_improve = 0\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            other_root = self.goal if active_start else self.start\n\n            # Sampling strategy\n            if best_path is not None and self._rand() < self.informed_bias:\n                x_rand = self._sample_informed(best_len, obstacles, is_3d)\n            else:\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = other_root\n                elif r < self.goal_bias + self.corridor_bias:\n                    width = max(self.step_size, corridor_base + (0.1 * (best_len - dsg) if best_path is not None else 0.0))\n                    x_rand = self._sample_corridor(width, obstacles, is_3d)\n                else:\n                    x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest and steer\n            nearest = self._nearest(grid1, tree1, x_rand)\n            if nearest is None:\n                continue\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._exists_close(grid1, new_pos, dupe_radius):\n                continue\n            if not self._cell_accept(grid1, new_pos):\n                continue\n            if self._edge_blocked_memo(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Insert node\n            new_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            self._grid_add(grid1, new_node)\n            edges.append((nearest, new_node))\n\n            # LOS grandparent compression\n            gp = nearest.parent\n            if gp is not None and not self._edge_blocked_memo(gp.position, new_pos, obstacles, is_3d):\n                # reparent new_node to grandparent\n                try:\n                    nearest.children.remove(new_node)\n                except:\n                    pass\n                self._remove_edge(edges, nearest, new_node)\n                gp.add_child(new_node)\n                new_node.cost = gp.cost + self._dist(gp.position, new_pos)\n                edges.append((gp, new_node))\n\n            # Try connect to opposite tree (direct first, then bounded extend)\n            qnear = self._nearest(grid2, tree2, new_node.position)\n            if qnear is not None and self._dist(qnear.position, new_node.position) <= connect_radius:\n                if not self._edge_blocked_memo(new_node.position, qnear.position, obstacles, is_3d):\n                    a_end = new_node\n                    b_end = qnear\n                else:\n                    a_end, b_end = self._bounded_connect_extend(new_node, tree2, grid2, dupe_radius, obstacles, is_3d, edges, nodes)\n                if a_end is not None and b_end is not None:\n                    path = self._merge_paths(a_end, b_end) if active_start else self._merge_paths(b_end, a_end)\n                    plen = self._path_length(path)\n                    if plen < best_len:\n                        best_path = path\n                        best_len = plen\n                        last_improve = it\n                    final = self._finalize_path(best_path, obstacles, is_3d)\n                    return PlannerResult(True, final, nodes, edges)\n\n            if best_path is not None and (it - last_improve) >= self.stall_limit:\n                final = self._finalize_path(best_path, obstacles, is_3d)\n                return PlannerResult(True, final, nodes, edges)\n\n        if best_path is not None:\n            final = self._finalize_path(best_path, obstacles, is_3d)\n            return PlannerResult(True, final, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG (deterministic)\n    def _rand(self):\n        if not hasattr(self, \"_rng\"):\n            self._rng = 987654321\n        self._rng = (1103515245 * self._rng + 12345) % (1 << 31)\n        return (self._rng & 0x7fffffff) / float(1 << 31)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp_tuple(b)\n        if d <= 1e-12:\n            return self._clamp_tuple(a)\n        r = step / d\n        return self._clamp_tuple(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_exact(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked_memo(self, a, b, obstacles, is_3d):\n        key = self._edge_key_exact(a, b)\n        st = self.edge_cache.get(key)\n        if st is not None:\n            return st[0] == 1\n        blocked = self._edge_blocked(a, b, obstacles, is_3d)\n        self.edge_stamp += 1\n        self.edge_cache[key] = (1 if blocked else 2, self.edge_stamp)\n        if len(self.edge_cache) > self.edge_cache_limit:\n            cutoff = self.edge_stamp - (self.edge_cache_limit // 2)\n            self.edge_cache = {k: v for k, v in self.edge_cache.items() if v[1] >= cutoff}\n        return blocked\n\n    # Spatial hashing\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.rings_near + 1):\n            cand = self._ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback random subset\n        if tree:\n            k = min(16, len(tree))\n            for _ in range(k):\n                idx = int(self._uniform(0, len(tree)))\n                n = tree[idx % len(tree)]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius // self.grid_cell) + 1\n        cand = self._ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    def _cell_accept(self, grid, pos):\n        key = self._grid_key(pos)\n        lst = grid.get(key)\n        if lst is None:\n            return True\n        return len(lst) < self.cell_cap\n\n    # Connect helpers\n    def _bounded_connect_extend(self, new_node, other_tree, other_grid, dupe_radius, obstacles, is_3d, edges, nodes):\n        q = self._nearest(other_grid, other_tree, new_node.position)\n        if q is None:\n            return (None, None)\n        cur = q\n        for _ in range(self.connect_steps):\n            nxt_pos = self._steer(cur.position, new_node.position, self.step_size)\n            if not self._in_bounds(nxt_pos):\n                break\n            if self._is_in_obstacle(nxt_pos, obstacles, is_3d):\n                break\n            if self._exists_close(other_grid, nxt_pos, dupe_radius):\n                break\n            if self._edge_blocked_memo(cur.position, nxt_pos, obstacles, is_3d):\n                break\n            nxt = Node(nxt_pos, cur, cur.cost + self._dist(cur.position, nxt_pos))\n            cur.add_child(nxt)\n            other_tree.append(nxt)\n            nodes.append(nxt)\n            self._grid_add(other_grid, nxt)\n            edges.append((cur, nxt))\n            # LOS compression toward grandparent\n            gp = cur.parent\n            if gp is not None and not self._edge_blocked_memo(gp.position, nxt_pos, obstacles, is_3d):\n                try:\n                    cur.children.remove(nxt)\n                except:\n                    pass\n                self._remove_edge(edges, cur, nxt)\n                gp.add_child(nxt)\n                nxt.cost = gp.cost + self._dist(gp.position, nxt_pos)\n                edges.append((gp, nxt))\n            cur = nxt\n            if not self._edge_blocked_memo(cur.position, new_node.position, obstacles, is_3d):\n                return (new_node, cur)\n        return (None, None)\n\n    # Path utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_paths(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        pb.reverse()\n        return pa + pb\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _remove_edge(self, edges, a, b):\n        for i in range(len(edges)):\n            if edges[i][0] is a and edges[i][1] is b:\n                edges.pop(i)\n                return\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked_memo(pruned[-1], path[j], obstacles, is_3d):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _smooth_path(self, path, obstacles, is_3d, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return list(path)\n        pts = list(path)\n        best_len = self._path_length(pts)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and n >= 3:\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked_memo(a, b, obstacles, is_3d):\n                new_pts = pts[:i + 1] + pts[j:]\n                new_len = self._path_length(new_pts)\n                if new_len + 1e-9 < best_len:\n                    pts = new_pts\n                    best_len = new_len\n                    n = len(pts)\n            tries += 1\n        return pts\n\n    def _finalize_path(self, path, obstacles, is_3d):\n        if not path:\n            return []\n        pruned = self._visibility_prune(path, obstacles, is_3d)\n        return self._smooth_path(pruned, obstacles, is_3d, self.smoothing_attempts)\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        for _ in range(64):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        if self.dim == 3:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5, self.bounds[2] * 0.5)\n        else:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5)\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        tries = 0\n        while tries < 24:\n            if self.dim == 3:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                else:\n                    tries += 1\n                    continue\n            else:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                else:\n                    tries += 1\n                    continue\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n            tries += 1\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d):\n        for _ in range(48):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if (self._dist(self.start, p) + self._dist(p, self.goal) <= best_len + 1e-9 and\n                not self._is_in_obstacle(p, obstacles, is_3d)):\n                return p\n        return self._sample_corridor(max(self.step_size, 0.2 * self._dist(self.start, self.goal)), obstacles, is_3d)",
          "objective": -32.12619,
          "time_improvement": 59.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 1812.0,
          "node_improvement": 91.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01643836498260498,
                    "num_nodes_avg": 47.5,
                    "path_length_avg": 172.57597716951437,
                    "smoothness_avg": 0.055340882959087935,
                    "success_improvement": 0.0,
                    "time_improvement": 35.532778493067305,
                    "node_improvement": 88.03827751196172,
                    "length_improvement": 5.408372272033185,
                    "smoothness_improvement": 766.2049929605337,
                    "objective_score": 17.73588187594277
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.024622559547424316,
                    "num_nodes_avg": 81.2,
                    "path_length_avg": 250.16418359040821,
                    "smoothness_avg": 0.12448872572717391,
                    "success_improvement": 0.0,
                    "time_improvement": 84.62985642705796,
                    "node_improvement": 94.5441107303635,
                    "length_improvement": 16.487994940743906,
                    "smoothness_improvement": 3103.1845785650153,
                    "objective_score": 50.7976767853888
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.020916748046875,
                    "num_nodes_avg": 75.5,
                    "path_length_avg": 143.54340806097915,
                    "smoothness_avg": 0.13110948178151688,
                    "success_improvement": 0.0,
                    "time_improvement": 57.35770095388541,
                    "node_improvement": 90.40050858232676,
                    "length_improvement": 4.665303168464438,
                    "smoothness_improvement": 1567.7029307656137,
                    "objective_score": 27.845006841072355
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SWIFT-Connect-S: A simplified, fast, and robust bidirectional RRT-Connect with bounded collision memoization, hash-grid nearest search, informed sampling after a provisional path, limited greedy bridging, and shallow multi-ancestor line-of-sight compression. It minimizes redundant checks and data churn for stable, low-latency planning while maintaining high path quality and smoothness.",
          "planning_mechanism": "Alternate expansion of two trees toward sampled targets (goal-biased/uniform; ellipse-informed once a path exists). For each step, pick the nearest by grid, steer once, and add only if both node and edge are free (cached). After insertion, compress up to a few ancestors via LOS to shorten trees, then attempt a short capped greedy connect from the opposite tree; if connected, extract and quickly shortcut-smooth with early stop and return. Bounded caches and light structures keep iterations fast and consistent.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=8.0,\n                 goal_bias=0.15,\n                 informed_bias=0.60,\n                 grid_cell_factor=1.5,\n                 ring_limit=2,\n                 dup_radius_ratio=0.45,\n                 connect_cap=3,\n                 connect_step_factor=1.5,\n                 compress_depth=3,\n                 edge_res=1.0,\n                 edge_cache_max=50000,\n                 point_cache_max=60000,\n                 smoothing_iters=60,\n                 smooth_patience=12):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.informed_bias = informed_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.ring_limit = ring_limit\n        self.dup_radius_ratio = dup_radius_ratio\n        self.connect_cap = connect_cap\n        self.connect_step_factor = connect_step_factor\n        self.compress_depth = compress_depth\n        self.edge_res = edge_res\n        self.edge_cache_max = max(1000, int(edge_cache_max))\n        self.point_cache_max = max(1000, int(point_cache_max))\n        self.smoothing_iters = smoothing_iters\n        self.smooth_patience = smooth_patience\n\n        self.dim = 2\n        self.bounds = None\n        self.is_3d = False\n\n        self.cell = 1.0\n        self.q_point = 0.5\n        self.q_edge = 1.0\n\n        self._edge_cache = {}\n        self._point_cache = {}\n        self._rng_state = 2463534242\n\n        self.start = None\n        self.goal = None\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Quantization and grid\n        self.cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self.q_point = max(0.5, self.edge_res * 0.5)\n        self.q_edge = max(1.0, self.edge_res)\n\n        # reset caches\n        self._edge_cache = {}\n        self._point_cache = {}\n\n        # start/goal validity\n        if not self._point_free(self.start, obstacles) or not self._point_free(self.goal, obstacles):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight connection\n        if self._edge_free(self.start, self.goal, obstacles):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        best_len = float('inf')\n        d_sg = self._dist(self.start, self.goal)\n        dup_radius = max(0.5, self.step_size * self.dup_radius_ratio)\n\n        for it in range(self.max_iter):\n            grow_from_start = (it % 2 == 0)\n            tree1 = tree_a if grow_from_start else tree_b\n            tree2 = tree_b if grow_from_start else tree_a\n            grid1 = grid_a if grow_from_start else grid_b\n            grid2 = grid_b if grow_from_start else grid_a\n            other_root_pos = self.goal if grow_from_start else self.start\n\n            # Sample a target\n            if best_len < float('inf') and self._rand() < self.informed_bias:\n                x_rand = self._sample_informed(best_len, obstacles)\n            else:\n                if self._rand() < self.goal_bias:\n                    x_rand = other_root_pos\n                else:\n                    x_rand = self._sample_free(obstacles)\n\n            # Nearest and steer\n            near = self._nearest_by_grid(tree1, grid1, x_rand)\n            if near is None:\n                continue\n            x_new = self._steer(near.position, x_rand, self.step_size)\n            if not self._in_bounds(x_new):\n                continue\n            if self._has_near_duplicate(grid1, x_new, dup_radius):\n                continue\n\n            # Mandatory checks before insertion\n            if not self._point_free(x_new, obstacles):\n                continue\n            if not self._edge_free(near.position, x_new, obstacles):\n                continue\n\n            # Insert node\n            new_cost = near.cost + self._dist(near.position, x_new)\n            new_node = Node(x_new, near, new_cost)\n            near.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((near, new_node))\n            self._grid_insert(grid1, new_node)\n\n            # Shallow multi-ancestor LOS compression\n            self._compress_chain(new_node, obstacles, edges, self.compress_depth)\n\n            # Attempt to connect the other tree\n            other_near = self._nearest_by_grid(tree2, grid2, new_node.position)\n            connected = False\n            last_other = other_near\n\n            # Direct bridge first\n            if other_near is not None and self._edge_free(new_node.position, other_near.position, obstacles):\n                connected = True\n                last_other = other_near\n            else:\n                # Limited greedy connect from the other tree toward new_node\n                current = other_near\n                for _ in range(self.connect_cap):\n                    if current is None:\n                        break\n                    step = self.step_size * self.connect_step_factor\n                    nxt_pos = self._steer(current.position, new_node.position, step)\n                    if not self._in_bounds(nxt_pos):\n                        break\n                    if self._has_near_duplicate(grid2, nxt_pos, dup_radius):\n                        break\n                    if not self._point_free(nxt_pos, obstacles):\n                        break\n                    if not self._edge_free(current.position, nxt_pos, obstacles):\n                        break\n                    nxt_cost = current.cost + self._dist(current.position, nxt_pos)\n                    nxt_node = Node(nxt_pos, current, nxt_cost)\n                    current.add_child(nxt_node)\n                    tree2.append(nxt_node)\n                    nodes.append(nxt_node)\n                    edges.append((current, nxt_node))\n                    self._grid_insert(grid2, nxt_node)\n                    self._compress_chain(nxt_node, obstacles, edges, self.compress_depth)\n                    last_other = nxt_node\n                    # Try to close the bridge\n                    if self._edge_free(new_node.position, last_other.position, obstacles):\n                        connected = True\n                        break\n                    current = nxt_node\n\n            if connected:\n                path = self._extract_path(new_node, last_other, grow_from_start)\n                best_len = self._path_length(path)\n                path = self._smooth_path(path, obstacles, self.smoothing_iters, self.smooth_patience)\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._rng_state = (1664525 * self._rng_state + 1013904223) % (1 << 32)\n        return self._rng_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp_tuple(b)\n        if d <= 1e-12:\n            return self._clamp_tuple(a)\n        r = step / d\n        return self._clamp_tuple(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    # Collision and caching\n    def _qpos(self, p, q):\n        return tuple(int(p[i] // q) for i in range(self.dim))\n\n    def _edge_key(self, a, b, q):\n        qa = self._qpos(a, q)\n        qb = self._qpos(b, q)\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _point_key(self, p, q):\n        return self._qpos(p, q)\n\n    def _point_free(self, p, obstacles):\n        key = self._point_key(p, self.q_point)\n        cached = self._point_cache.get(key)\n        if cached is not None:\n            return cached\n        free = True\n        if self.is_3d:\n            px, py, pz = p\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    free = False\n                    break\n        else:\n            px, py = p\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    free = False\n                    break\n        self._point_cache[key] = free\n        if len(self._point_cache) > self.point_cache_max:\n            self._prune_half(self._point_cache)\n        return free\n\n    def _edge_free(self, a, b, obstacles):\n        key = self._edge_key(a, b, self.q_edge)\n        cached = self._edge_cache.get(key)\n        if cached is not None:\n            return cached\n        d = self._dist(a, b)\n        steps = int(d / self.edge_res)\n        if steps < 1:\n            steps = 1\n        free = True\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if not self._point_free(p, obstacles):\n                free = False\n                break\n        self._edge_cache[key] = free\n        if len(self._edge_cache) > self.edge_cache_max:\n            self._prune_half(self._edge_cache)\n        return free\n\n    def _prune_half(self, dct):\n        cnt = 0\n        to_del = []\n        for k in dct:\n            if (cnt % 2) == 0:\n                to_del.append(k)\n            cnt += 1\n            if len(to_del) >= len(dct) // 2:\n                break\n        for k in to_del:\n            try:\n                del dct[k]\n            except:\n                pass\n\n    # Spatial hash\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell) for i in range(self.dim))\n\n    def _grid_insert(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _nearest_by_grid(self, tree, grid, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        if self.dim == 3:\n            for r in range(self.ring_limit + 1):\n                found = False\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                            if b:\n                                for n in b:\n                                    d = self._dist(n.position, pos)\n                                    if d < bestd:\n                                        bestd = d\n                                        best = n\n                                        found = True\n                if found and best is not None:\n                    return best\n        else:\n            for r in range(self.ring_limit + 1):\n                found = False\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy))\n                        if b:\n                            for n in b:\n                                d = self._dist(n.position, pos)\n                                if d < bestd:\n                                    bestd = d\n                                    best = n\n                                    found = True\n                if found and best is not None:\n                    return best\n        # fallback\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _has_near_duplicate(self, grid, pos, radius):\n        rng = int(max(1, radius // self.cell)) + 1\n        key = self._grid_key(pos)\n        r2 = radius * radius\n        if self.dim == 3:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            s = 0.0\n                            for i in range(self.dim):\n                                d = n.position[i] - pos[i]\n                                s += d * d\n                            if s <= r2:\n                                return True\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        s = 0.0\n                        for i in range(self.dim):\n                            d = n.position[i] - pos[i]\n                            s += d * d\n                        if s <= r2:\n                            return True\n        return False\n\n    # Sampling\n    def _sample_free(self, obstacles):\n        for _ in range(64):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and self._point_free(p, obstacles):\n                return p\n        return self._clamp_tuple(self.start)\n\n    def _sample_informed(self, best_len, obstacles):\n        # Rejection sample within the prolate ellipse defined by start/goal foci and perimeter best_len\n        for _ in range(48):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= best_len + 1e-9 and self._point_free(p, obstacles):\n                return p\n        # Fallback to uniform free if ellipse sampling failed\n        return self._sample_free(obstacles)\n\n    # Compression utilities\n    def _compress_chain(self, node, obstacles, edges, depth_limit):\n        depth = 0\n        cur = node\n        while depth < depth_limit:\n            p = cur.parent\n            if p is None:\n                break\n            gp = p.parent\n            if gp is None:\n                break\n            if not self._edge_free(gp.position, cur.position, obstacles):\n                break\n            # reparent\n            p.remove_child(cur)\n            self._edges_remove(edges, p, cur)\n            gp.add_child(cur)\n            edges.append((gp, cur))\n            old_cost = cur.cost\n            cur.cost = gp.cost + self._dist(gp.position, cur.position)\n            delta = cur.cost - old_cost\n            if abs(delta) > 1e-12:\n                self._propagate_cost(cur, delta)\n            depth += 1\n\n    def _propagate_cost(self, node, delta):\n        # Update subtree costs after reparenting\n        stack = list(node.children)\n        while stack:\n            n = stack.pop()\n            n.cost += delta\n            for c in n.children:\n                stack.append(c)\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # Paths and smoothing\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a, b, a_from_start):\n        # a is in the active tree (tree1), b in the opposite tree (tree2)\n        pa = self._path_to_root(a)\n        pb = []\n        cur = b\n        while cur is not None:\n            pb.append(cur.position)\n            cur = cur.parent\n        # If growing from start, pb goes b..goal; else b..start; concatenation stays correct\n        return pa + pb\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _smooth_path(self, path, obstacles, iters, patience):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        best_len = self._path_length(pts)\n        no_improve = 0\n        for _ in range(iters):\n            if len(pts) < 3:\n                break\n            i = int(self._uniform(0, len(pts) - 2))\n            j = int(self._uniform(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                continue\n            if self._edge_free(pts[i], pts[j], obstacles):\n                new_pts = pts[:i + 1] + pts[j:]\n                new_len = self._path_length(new_pts)\n                if new_len + 1e-9 < best_len:\n                    pts = new_pts\n                    best_len = new_len\n                    no_improve = 0\n                else:\n                    no_improve += 1\n            else:\n                no_improve += 1\n            if no_improve >= patience:\n                break\n        # forward LOS collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            k = 1\n            while k < len(pts) - 1:\n                nxt = pts[k + 1]\n                if self._edge_free(last, nxt, obstacles):\n                    k += 1\n                else:\n                    collapsed.append(pts[k])\n                    last = pts[k]\n                    k += 1\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
          "objective": -32.04681,
          "time_improvement": 57.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1606.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0160780668258667,
                    "num_nodes_avg": 54.5,
                    "path_length_avg": 178.9081741619695,
                    "smoothness_avg": 0.051583685968640866,
                    "success_improvement": 0.0,
                    "time_improvement": 36.94577918404633,
                    "node_improvement": 86.27549735582977,
                    "length_improvement": 1.9375947603861294,
                    "smoothness_improvement": 707.3967011761849,
                    "objective_score": 15.783274117326503
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027580070495605468,
                    "num_nodes_avg": 100.1,
                    "path_length_avg": 240.86804814126344,
                    "smoothness_avg": 0.10972615466856887,
                    "success_improvement": 0.0,
                    "time_improvement": 82.78368898030901,
                    "node_improvement": 93.27420546932743,
                    "length_improvement": 19.59131252809127,
                    "smoothness_improvement": 2723.332992176965,
                    "objective_score": 50.20655917183229
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024082136154174805,
                    "num_nodes_avg": 106.1,
                    "path_length_avg": 130.6210437346923,
                    "smoothness_avg": 0.11683429429214313,
                    "success_improvement": 0.0,
                    "time_improvement": 50.90452639893067,
                    "node_improvement": 86.50985378258105,
                    "length_improvement": 13.24772225711989,
                    "smoothness_improvement": 1386.1235995855145,
                    "objective_score": 30.150609271878707
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SIBR-VI: Simple Informed BiRRT with Visibility Insertion. A compact, general-purpose bidirectional planner that grows two balanced trees with goal-biased sampling, grid-based near queries, and visibility-based parent choice. It commits only short, validated edges and uses a minimal single-step opposite-tree probe to connect, then performs lightweight LOS collapse, shortcutting, and corner rounding for smooth paths. The design avoids rewiring and wide scans to improve robustness, speed, and generalization.",
          "planning_mechanism": "Alternate extending start/goal trees with goal-biased uniform sampling. For each sample: find a nearby node via a coarse grid, steer one step, and choose the least-cost visible parent among local neighbors (including the steer source). Insert only after node and edge collision checks. Probe the opposite tree: try a direct bridge; else attempt one short, validated step toward the new node and recheck. On success, assemble and smooth the path; otherwise continue until early success or max iterations.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            i = 0\n            while i < len(self.parent.children):\n                if self.parent.children[i] is self:\n                    self.parent.children.pop(i)\n                    break\n                i += 1\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=6.0,\n                 goal_bias=0.3,\n                 cell_factor=1.8,\n                 neighbor_radius_factor=2.0,\n                 dupe_radius_ratio=0.35,\n                 edge_res=0.8,\n                 smooth_shortcuts=50,\n                 smooth_rounds=6):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.cell_factor = float(cell_factor)\n        self.nei_factor = float(neighbor_radius_factor)\n        self.dupe_ratio = float(dupe_radius_ratio)\n        self.edge_res = float(edge_res)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self.smooth_rounds = int(max(0, smooth_rounds))\n        self._rng = 246813579\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if not self._edge_blocked(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Derived params\n        self.cell = max(1.0, self.step * self.cell_factor)\n        self.nei_radius = max(1.5 * self.step, self.nei_factor * self.step)\n        self.dupe_radius = max(0.4, self.dupe_ratio * self.step)\n\n        nodes = []\n        edges = []\n\n        # Initialize two trees\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        A, B = [a_root], [b_root]\n        GA, GB = {}, {}\n        self._grid_add(GA, a_root)\n        self._grid_add(GB, b_root)\n        frontierA, frontierB = [a_root], [b_root]\n\n        for it in range(self.max_iter):\n            growA = (it % 2 == 0)\n            T = A if growA else B\n            O = B if growA else A\n            G = GA if growA else GB\n            GO = GB if growA else GA\n            frontier = frontierA if growA else frontierB\n            frontierO = frontierB if growA else frontierA\n            attractor = self.goal if growA else self.start\n\n            target = self._sample_target(attractor)\n            if target is None:\n                continue\n\n            qnear = self._nearest(G, frontier, target, max_rings=2)\n            if qnear is None:\n                qnear = T[-1]\n\n            qnew_pos = self._steer(qnear.position, target, self.step)\n            if not self._in_bounds(qnew_pos):\n                continue\n            if self._point_blocked(qnew_pos):\n                continue\n            if self._has_close(G, qnew_pos, self.dupe_radius):\n                continue\n\n            parent = self._choose_parent(G, qnew_pos, qnear)\n            if parent is None:\n                continue\n            if self._edge_blocked(parent.position, qnew_pos):\n                continue\n\n            qnode = Node(qnew_pos, parent, parent.cost + self._dist(parent.position, qnew_pos))\n            qnode.attach(parent)\n            T.append(qnode)\n            nodes.append(qnode)\n            edges.append((parent, qnode))\n            self._grid_add(G, qnode)\n            frontier.append(qnode)\n            if len(frontier) > 160:\n                del frontier[:16]\n\n            # Try to connect to the opposite tree\n            other_near = self._nearest(GO, frontierO, qnode.position, max_rings=2)\n            if other_near is not None:\n                # Direct bridge\n                if not self._edge_blocked(qnode.position, other_near.position):\n                    path = self._assemble_path(qnode, other_near, growA)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # Single opposite-step probe (only commit if it completes a bridge)\n                step_p = self._steer(other_near.position, qnode.position, self.step)\n                if self._in_bounds(step_p) and (not self._point_blocked(step_p)):\n                    if not self._edge_blocked(other_near.position, step_p) and not self._edge_blocked(step_p, qnode.position):\n                        # commit the opposite node and connect\n                        qopp = Node(step_p, other_near, other_near.cost + self._dist(other_near.position, step_p))\n                        qopp.attach(other_near)\n                        O.append(qopp)\n                        nodes.append(qopp)\n                        edges.append((other_near, qopp))\n                        self._grid_add(GO, qopp)\n                        frontierO.append(qopp)\n                        if len(frontierO) > 160:\n                            del frontierO[:16]\n                        path = self._assemble_path(qnode, qopp, growA)\n                        path = self._postprocess(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) % (1 << 31)\n        return self._rng / float(1 << 31)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    # Collision\n    def _point_blocked(self, p):\n        if self.is3d:\n            x0, y0, z0 = p\n            for o in self.obstacles:\n                x, y, z, w, h, d = o\n                if x <= x0 <= x + w and y <= y0 <= y + h and z <= z0 <= z + d:\n                    return True\n            return False\n        else:\n            x0, y0 = p\n            for o in self.obstacles:\n                x, y, w, h = o\n                if x <= x0 <= x + w and y <= y0 <= y + h:\n                    return True\n            return False\n\n    def _edge_blocked(self, a, b):\n        d = self._dist(a, b)\n        steps = max(1, int(d / max(1e-9, self.edge_res)))\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dims))\n            if self._point_blocked(p):\n                return True\n        return False\n\n    # Grid utilities\n    def _cell_key(self, pos):\n        if self.is3d:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, frontier, pos, max_rings=2):\n        k = self._cell_key(pos)\n        best = None\n        bd = 1e100\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring(grid, k, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bd:\n                        bd = d\n                        best = n\n                if best is not None:\n                    return best\n        if frontier:\n            lim = min(24, len(frontier))\n            for i in range(lim):\n                n = frontier[-1 - i]\n                d = self._dist(n.position, pos)\n                if d < bd:\n                    bd = d\n                    best = n\n        return best\n\n    def _nearby(self, grid, pos, radius, cap=20):\n        k = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell) + 1)\n        lst = self._grid_ring(grid, k, rc)\n        out = []\n        r2 = radius * radius\n        for n in lst:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _has_close(self, grid, pos, radius):\n        ns = self._nearby(grid, pos, radius, cap=8)\n        return len(ns) > 0\n\n    # Parent selection: least-cost visible parent among local neighbors (+default)\n    def _choose_parent(self, grid, new_pos, default_parent):\n        cand = self._nearby(grid, new_pos, self.nei_radius, cap=20)\n        if default_parent not in cand:\n            cand.append(default_parent)\n        best = None\n        bestc = 1e100\n        for p in cand:\n            d = self._dist(p.position, new_pos)\n            if d > 1.5 * self.step:\n                continue\n            if self._edge_blocked(p.position, new_pos):\n                continue\n            c = p.cost + d\n            if c < bestc:\n                bestc = c\n                best = p\n        return best\n\n    # Sampling\n    def _sample_target(self, attractor):\n        for _ in range(24):\n            if self._rand() < self.goal_bias:\n                p = attractor\n            else:\n                p = self._random_free()\n            if p is not None:\n                return p\n        return self._random_free()\n\n    def _random_free(self):\n        for _ in range(64):\n            if self.is3d:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n            else:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n            if not self._point_blocked(p):\n                return p\n        return None\n\n    # Path assembly and utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _assemble_path(self, a_end, b_end, a_side_grew):\n        if a_side_grew:\n            pa = self._path_to_root(a_end)\n            pb = self._path_to_root(b_end)\n            if pa and pb and pa[0] == pb[-1]:\n                pb = pb[:-1]\n            return pa + pb[::-1]\n        else:\n            pa = self._path_to_root(a_end)\n            pb = self._path_to_root(b_end)\n            if pa and pb and pb[0] == pa[-1]:\n                pa = pa[:-1]\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # Smoothing\n    def _los_collapse_once(self, path):\n        if len(path) < 3:\n            return path[:]\n        out = [path[0]]\n        anchor = path[0]\n        i = 1\n        while i < len(path) - 1:\n            nxt = path[i + 1]\n            if not self._edge_blocked(anchor, nxt):\n                i += 1\n                continue\n            out.append(path[i])\n            anchor = path[i]\n            i += 1\n        out.append(path[-1])\n        return out\n\n    def _los_collapse_repeat(self, path, rounds=3):\n        cur = path[:]\n        for _ in range(rounds):\n            nxt = self._los_collapse_once(cur)\n            if len(nxt) == len(cur):\n                break\n            cur = nxt\n        return cur\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = path[:]\n        best_len = self._path_len(pts)\n        tries = 0\n        n = len(pts)\n        while tries < attempts and len(pts) >= 3:\n            if len(pts) != n:\n                n = len(pts)\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j >= n:\n                tries += 1\n                continue\n            a, b = pts[i], pts[j]\n            if not self._edge_blocked(a, b):\n                cand = pts[:i + 1] + pts[j:]\n                L = self._path_len(cand)\n                if L <= best_len + 1e-12:\n                    pts = cand\n                    best_len = L\n                    n = len(pts)\n            tries += 1\n        return pts\n\n    def _round_corners(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return path[:]\n        pts = list(path)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dims))\n                if not self._in_bounds(mid):\n                    continue\n                if self._point_blocked(mid):\n                    continue\n                if not self._edge_blocked(a, mid) and not self._edge_blocked(mid, c):\n                    if pts[i] != mid:\n                        pts[i] = mid\n                        moved = True\n            if not moved:\n                break\n        return pts\n\n    def _postprocess(self, path):\n        if len(path) < 3:\n            return path[:]\n        p = self._los_collapse_repeat(path, rounds=3)\n        p = self._shortcut(p, self.smooth_shortcuts)\n        p = self._round_corners(p, self.smooth_rounds)\n        return p",
          "objective": -31.86222,
          "time_improvement": 45.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1790.0,
          "node_improvement": 83.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02052297592163086,
                    "num_nodes_avg": 70.5,
                    "path_length_avg": 165.63949397483105,
                    "smoothness_avg": 0.049746840403639886,
                    "success_improvement": 0.0,
                    "time_improvement": 16.814345726520084,
                    "node_improvement": 82.2462855703853,
                    "length_improvement": 9.210368626649155,
                    "smoothness_improvement": 678.6460793099327,
                    "objective_score": 13.96375529049518
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03236165046691895,
                    "num_nodes_avg": 152.8,
                    "path_length_avg": 238.58207310980575,
                    "smoothness_avg": 0.11234809730455246,
                    "success_improvement": 0.0,
                    "time_improvement": 80.65091574673843,
                    "node_improvement": 89.73325270442787,
                    "length_improvement": 20.35443679173485,
                    "smoothness_improvement": 2790.7974647097694,
                    "objective_score": 50.361924122611285
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03200056552886963,
                    "num_nodes_avg": 169.6,
                    "path_length_avg": 123.51393483095144,
                    "smoothness_avg": 0.15722144556069123,
                    "success_improvement": 0.0,
                    "time_improvement": 36.603315688518556,
                    "node_improvement": 78.43610934520025,
                    "length_improvement": 17.96792558682632,
                    "smoothness_improvement": 1899.845182652034,
                    "objective_score": 31.260975971911527
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "Turbo-Indexed BiConnect (TIBC): an anytime, cache-accelerated bidirectional planner that uses an obstacle-grid index, dual edge caches (free/blocked), single-commit extensions, and lazy short-bridge closure. It prunes collision work via segment\u2013AABB prefiltering, limits per-iteration work to one validated insertion, and exits immediately on a valid bridge, then applies fast visibility compression with bounded shortcutting.",
          "planning_mechanism": "Mechanism: Build start/goal trees and an obstacle spatial index. Each iteration alternates trees, samples (goal/corridor/uniform), finds a hashed-nearest, and proposes one steered node. Before insertion it runs node and edge checks using prefiltered obstacles with edge caching. After insertion it attempts a direct bridge; if blocked, it lazily extends the other tree toward the new node but commits only the furthest valid single node. On connection, it compresses by line-of-sight and a few shortcuts; otherwise it continues or stops early on direct start\u2013goal LOS.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=10.0,\n                 goal_bias=0.25,\n                 corridor_bias=0.5,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 connect_hops=4,\n                 smoothing_iters=14,\n                 min_sep_ratio=0.25,\n                 dupe_radius_ratio=0.5,\n                 cell_expand_limit=2,\n                 leader_stride=24):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.connect_hops = max(1, int(connect_hops))\n        self.smoothing_iters = smoothing_iters\n        self.min_sep_ratio = min_sep_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.cell_expand_limit = max(1, int(cell_expand_limit))\n        self.leader_stride = max(1, int(leader_stride))\n        # runtime fields\n        self.dim = 2\n        self.bounds = None\n        self.start = None\n        self.goal = None\n        self.obstacles = None\n        self.is_3d = False\n        self.edge_res = 1.0\n        self.cache_bin = 1.0\n        self._free_edge_cache = None\n        self._blocked_edge_cache = None\n        # obstacle index\n        self.obs_index = None\n        self.obs_cell = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles)\n\n        # Parameters\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.9 * self.step_size)\n        self.edge_res = max(0.75, min(self.collision_step, max(0.5, 0.5 * self.step_size)))\n        self.cache_bin = max(1.0, self.edge_res)\n        self.obs_cell = max(4.0, 1.5 * self.step_size)\n\n        # Validate start/goal bounds and obstacle-free\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        # Build obstacle index early\n        self._build_obstacle_index()\n        if self._is_point_blocked_indexed(self.start) or self._is_point_blocked_indexed(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct LOS\n        self._free_edge_cache = set()\n        self._blocked_edge_cache = set()\n        if not self._is_edge_blocked_cached(self.start, self.goal):\n            nodes = [Node(self.start), Node(self.goal)]\n            return PlannerResult(True, [self.start, self.goal], nodes, [])\n\n        # Init trees, hashed grids, leaders, edges, throttles\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start, grid_goal = {}, {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        leaders_start, leaders_goal = [start_root], [goal_root]\n        throttle_start, throttle_goal = {}, {}\n\n        # Corridor params\n        dsg = self._dist(self.start, self.goal)\n        best_path_len = float('inf')\n        base_corridor = max(self.step_size, 0.2 * dsg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            leaders_a = leaders_start if active_start else leaders_goal\n            leaders_b = leaders_goal if active_start else leaders_start\n            throttle_a = throttle_start if active_start else throttle_goal\n            throttle_b = throttle_goal if active_start else throttle_start\n            other_root = self.goal if active_start else self.start\n\n            # Sample\n            x_rand = None\n            r = self._rand()\n            if r < self.goal_bias:\n                x_rand = other_root\n            else:\n                r2 = self._rand()\n                if r2 < self.corridor_bias:\n                    width = base_corridor\n                    if best_path_len < float('inf'):\n                        width = max(self.step_size, 0.25 * (best_path_len - dsg) + base_corridor)\n                    x_rand = self._sample_corridor(width)\n                else:\n                    x_rand = self._sample_free()\n\n            # Nearest and steer\n            nearest = self._nearest_hashed(grid_a, tree_a, leaders_a, x_rand)\n            if nearest is None:\n                continue\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n\n            # Bounds and node collision check\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_point_blocked_indexed(new_pos):\n                continue\n\n            # De-duplicate and throttle\n            if self._dist(nearest.position, new_pos) < self.step_size * self.min_sep_ratio:\n                continue\n            if self._exists_close(grid_a, new_pos, self.step_size * self.dupe_radius_ratio):\n                continue\n            kcell = self._grid_key(new_pos)\n            if throttle_a.get(kcell, 0) >= self.cell_expand_limit:\n                continue\n\n            # Edge collision check (both checks enforced)\n            if self._is_edge_blocked_cached(nearest.position, new_pos):\n                continue\n\n            # Insert node\n            new_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            self._edges_add(edges, nearest, new_node)\n            self._grid_add(grid_a, new_node)\n            throttle_a[kcell] = throttle_a.get(kcell, 0) + 1\n            if len(tree_a) % self.leader_stride == 0:\n                leaders_a.append(new_node)\n\n            # Try direct bridge to other tree\n            other_near = self._nearest_hashed(grid_b, tree_b, leaders_b, new_node.position)\n            if other_near is not None and not self._is_edge_blocked_cached(new_node.position, other_near.position):\n                path = self._extract_path(new_node, other_near)\n                best_path_len = self._path_length(path)\n                path = self._postprocess_path(path)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Lazy short connect: extend the other tree toward new_node but commit only furthest valid single node\n            if other_near is not None:\n                added = self._lazy_single_extend(tree_b, grid_b, leaders_b, throttle_b, other_near, new_node.position, active_other=(not active_start), edges=edges)\n                if added is not None:\n                    # Attempt bridge again\n                    if not self._is_edge_blocked_cached(new_node.position, added.position):\n                        path = self._extract_path(new_node, added)\n                        best_path_len = self._path_length(path)\n                        path = self._postprocess_path(path)\n                        return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # RNG\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Obstacle index\n    def _build_obstacle_index(self):\n        self.obs_index = {}\n        # Map obstacle index to cells\n        if self.is_3d:\n            for oi, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                minx = int(x // self.obs_cell)\n                maxx = int((x + w) // self.obs_cell)\n                miny = int(y // self.obs_cell)\n                maxy = int((y + h) // self.obs_cell)\n                minz = int(z // self.obs_cell)\n                maxz = int((z + d) // self.obs_cell)\n                for cx in range(minx, maxx + 1):\n                    for cy in range(miny, maxy + 1):\n                        for cz in range(minz, maxz + 1):\n                            key = (cx, cy, cz)\n                            bucket = self.obs_index.get(key)\n                            if bucket is None:\n                                self.obs_index[key] = [oi]\n                            else:\n                                bucket.append(oi)\n        else:\n            for oi, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                minx = int(x // self.obs_cell)\n                maxx = int((x + w) // self.obs_cell)\n                miny = int(y // self.obs_cell)\n                maxy = int((y + h) // self.obs_cell)\n                for cx in range(minx, maxx + 1):\n                    for cy in range(miny, maxy + 1):\n                        key = (cx, cy)\n                        bucket = self.obs_index.get(key)\n                        if bucket is None:\n                            self.obs_index[key] = [oi]\n                        else:\n                            bucket.append(oi)\n\n    def _obs_cell_key(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.obs_cell), int(pos[1] // self.obs_cell), int(pos[2] // self.obs_cell))\n        else:\n            return (int(pos[0] // self.obs_cell), int(pos[1] // self.obs_cell))\n\n    def _obs_candidates_for_segment(self, a, b, pad):\n        if self.is_3d:\n            mins = (min(a[0], b[0]) - pad, min(a[1], b[1]) - pad, min(a[2], b[2]) - pad)\n            maxs = (max(a[0], b[0]) + pad, max(a[1], b[1]) + pad, max(a[2], b[2]) + pad)\n            minc = (int(mins[0] // self.obs_cell), int(mins[1] // self.obs_cell), int(mins[2] // self.obs_cell))\n            maxc = (int(maxs[0] // self.obs_cell), int(maxs[1] // self.obs_cell), int(maxs[2] // self.obs_cell))\n            seen = set()\n            cand = []\n            for cx in range(minc[0], maxc[0] + 1):\n                for cy in range(minc[1], maxc[1] + 1):\n                    for cz in range(minc[2], maxc[2] + 1):\n                        bucket = self.obs_index.get((cx, cy, cz))\n                        if bucket:\n                            for oi in bucket:\n                                if oi not in seen:\n                                    seen.add(oi)\n                                    cand.append(oi)\n            return cand\n        else:\n            mins = (min(a[0], b[0]) - pad, min(a[1], b[1]) - pad)\n            maxs = (max(a[0], b[0]) + pad, max(a[1], b[1]) + pad)\n            minc = (int(mins[0] // self.obs_cell), int(mins[1] // self.obs_cell))\n            maxc = (int(maxs[0] // self.obs_cell), int(maxs[1] // self.obs_cell))\n            seen = set()\n            cand = []\n            for cx in range(minc[0], maxc[0] + 1):\n                for cy in range(minc[1], maxc[1] + 1):\n                    bucket = self.obs_index.get((cx, cy))\n                    if bucket:\n                        for oi in bucket:\n                            if oi not in seen:\n                                seen.add(oi)\n                                cand.append(oi)\n            return cand\n\n    # Collision helpers using index\n    def _is_point_blocked_indexed(self, pos):\n        key = self._obs_cell_key(pos)\n        bucket = self.obs_index.get(key)\n        if not bucket:\n            return False\n        if self.is_3d:\n            px, py, pz = pos\n            for oi in bucket:\n                x, y, z, w, h, d = self.obstacles[oi]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for oi in bucket:\n                x, y, w, h = self.obstacles[oi]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_point_blocked_in_list(self, pos, cand):\n        if not cand:\n            return False\n        if self.is_3d:\n            px, py, pz = pos\n            for oi in cand:\n                x, y, z, w, h, d = self.obstacles[oi]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for oi in cand:\n                x, y, w, h = self.obstacles[oi]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_blocked_cached(self, a, b):\n        key = self._edge_key_q(a, b)\n        if key in self._blocked_edge_cache:\n            return True\n        if key in self._free_edge_cache:\n            return False\n        blocked = self._is_edge_blocked_filtered(a, b)\n        if blocked:\n            self._blocked_edge_cache.add(key)\n            return True\n        else:\n            self._free_edge_cache.add(key)\n            return False\n\n    def _is_edge_blocked_filtered(self, a, b):\n        d = self._dist(a, b)\n        steps = int(max(1, d / max(1e-9, self.edge_res)))\n        cand = self._obs_candidates_for_segment(a, b, pad=self.edge_res)\n        if steps <= 1:\n            mid = tuple((a[i] + b[i]) * 0.5 for i in range(self.dim))\n            return self._is_point_blocked_in_list(mid, cand) or self._is_point_blocked_in_list(a, cand) or self._is_point_blocked_in_list(b, cand)\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_point_blocked_in_list(p, cand):\n                return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    # Sampling\n    def _sample_free(self):\n        # rejection until free\n        while True:\n            if self.is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_point_blocked_indexed(p):\n                return p\n\n    def _sample_corridor(self, width):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.is_3d:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_point_blocked_indexed(p):\n            return p\n        return self._sample_free()\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # Node grid\n    def _grid_key(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell), int(pos[2] // self.grid_cell))\n        else:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, leaders, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, 5):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # sparse leaders fallback\n        for n in leaders:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        # rare full scan\n        if best is None:\n            for n in tree:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                return True\n        return False\n\n    # Extend other tree lazily toward target, committing one furthest valid node\n    def _lazy_single_extend(self, tree, grid, leaders, throttle, nearest, target, active_other, edges):\n        last_ok = nearest.position\n        cur = nearest.position\n        steps = 0\n        moved = False\n        while steps < self.connect_hops:\n            nxt = self._steer(cur, target, self.step_size)\n            if self._dist(cur, nxt) < self.step_size * self.min_sep_ratio:\n                break\n            if not self._in_bounds(nxt):\n                break\n            if self._is_point_blocked_indexed(nxt):\n                break\n            if self._exists_close(grid, nxt, self.step_size * self.dupe_radius_ratio):\n                break\n            # Check edge from cur to nxt\n            if self._is_edge_blocked_cached(cur, nxt):\n                break\n            moved = True\n            last_ok = nxt\n            if self._dist(nxt, target) <= self.step_size:\n                # small hop remaining; try to end early\n                pass\n            cur = nxt\n            steps += 1\n\n        if moved:\n            # enforce both checks before adding\n            if self._is_point_blocked_indexed(last_ok):\n                return None\n            if self._is_edge_blocked_cached(nearest.position, last_ok):\n                return None\n            kcell = self._grid_key(last_ok)\n            if throttle.get(kcell, 0) >= self.cell_expand_limit:\n                return None\n            new_cost = nearest.cost + self._dist(nearest.position, last_ok)\n            q = Node(last_ok, parent=nearest, cost=new_cost)\n            nearest.add_child(q)\n            tree.append(q)\n            self._edges_add(edges, nearest, q)\n            self._grid_add(grid, q)\n            throttle[kcell] = throttle.get(kcell, 0) + 1\n            if len(tree) % self.leader_stride == 0:\n                leaders.append(q)\n            return q\n        return None\n\n    # Edges store\n    def _edges_add(self, edges, parent, child):\n        edges.append((parent, child))\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _visibility_compress(self, path):\n        if len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            jumped = False\n            while j > i + 1:\n                if not self._is_edge_blocked_cached(path[i], path[j]):\n                    out.append(path[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(path[i + 1])\n                i += 1\n        if out[-1] != path[-1]:\n            out.append(path[-1])\n        # remove possible duplicates\n        dedup = [out[0]]\n        for k in range(1, len(out)):\n            if self._dist(dedup[-1], out[k]) > 1e-6:\n                dedup.append(out[k])\n        return dedup\n\n    def _shortcut_smooth(self, path, iters):\n        if len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_blocked_cached(a, b):\n                pts = pts[:i + 1] + pts[j:]\n        return pts\n\n    def _postprocess_path(self, path):\n        p = self._visibility_compress(path)\n        p = self._shortcut_smooth(p, self.smoothing_iters)\n        return p",
          "objective": -31.19151,
          "time_improvement": 58.0,
          "length_improvement": 7.0,
          "smoothness_improvement": 1875.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020087075233459473,
                    "num_nodes_avg": 59.9,
                    "path_length_avg": 188.98228322088113,
                    "smoothness_avg": 0.07246972163047971,
                    "success_improvement": 0.0,
                    "time_improvement": 18.581179351539294,
                    "node_improvement": 84.91563837824226,
                    "length_improvement": -3.584184049276853,
                    "smoothness_improvement": 1034.3085140363305,
                    "objective_score": 8.595385946077329
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.021776032447814942,
                    "num_nodes_avg": 82.7,
                    "path_length_avg": 249.45981294566687,
                    "smoothness_avg": 0.11028137741702611,
                    "success_improvement": 0.0,
                    "time_improvement": 86.980074240489,
                    "node_improvement": 94.44332459853524,
                    "length_improvement": 16.723134136143443,
                    "smoothness_improvement": 2737.6192734055508,
                    "objective_score": 49.81599912086052
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01589312553405762,
                    "num_nodes_avg": 78.7,
                    "path_length_avg": 137.15585065447857,
                    "smoothness_avg": 0.1535292563753955,
                    "success_improvement": 0.0,
                    "time_improvement": 68.51394825205807,
                    "node_improvement": 89.99364272091545,
                    "length_improvement": 8.907614655064155,
                    "smoothness_improvement": 1852.8808087441291,
                    "objective_score": 35.16315731237656
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "SILK-BiRRT*: Smoothness-Integrated, Curvature-Aware, LRU-cached Bidirectional RRT*. It alternates growth of two trees with adaptive informed sampling and a small beam. Parent selection minimizes g+d plus a curvature penalty and heuristic h; collisions are accelerated by an obstacle grid and memoized in an LRU edge cache. Local bounded rewiring refines costs. Early multi-near bridging merges trees; a fast LOS collapse followed by curvature-aware shortcutting yields short, smooth paths.",
          "planning_mechanism": "Alternate start/goal expansions. For each beam sample: steer from a hashed-nearest node, reject duplicates and cells failing an f-gate, then choose a parent among nearby candidates minimizing g(parent)+d(parent,q)+\u03bc\u00b7turn(q)^2+\u03bb\u00b7h(q,other-root). Enforce both node and edge collision checks before insertion. After insertion, compress to an ancestor if line-of-sight holds and rewire neighbors with cost propagation. Attempt bridges to several nearest nodes in the other tree. On success, merge, LOS-collapse, and curvature-aware shortcuts; otherwise keep exploring with informed (ellipse/corridor) sampling guided by the best incumbent length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4500,\n        step_size=8.0,\n        collision_res=1.0,\n        beam_k=3,\n        goal_bias=0.18,\n        informed_bias=0.65,\n        corridor_bias=0.45,\n        grid_cell_factor=1.15,\n        dupe_radius_ratio=0.5,\n        parent_radius_factor=2.4,\n        rewire_radius_factor=1.9,\n        neighbor_cap=18,\n        connect_k=6,\n        connect_radius_factor=3.5,\n        edge_cache_capacity=50000,\n        edge_cache_quant=0.8,\n        cell_f_relax=1.08,\n        smooth_iters=60,\n        smooth_noimprove=14,\n        curvature_weight=0.18\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_res = collision_res\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.informed_bias = informed_bias\n        self.corridor_bias = corridor_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.parent_radius_factor = parent_radius_factor\n        self.rewire_radius_factor = rewire_radius_factor\n        self.neighbor_cap = neighbor_cap\n        self.connect_k = connect_k\n        self.connect_radius_factor = connect_radius_factor\n        self.edge_cache_capacity = edge_cache_capacity\n        self.edge_cache_quant = edge_cache_quant\n        self.cell_f_relax = cell_f_relax\n        self.smooth_iters = smooth_iters\n        self.smooth_noimprove = smooth_noimprove\n        self.curvature_weight = curvature_weight\n\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        # sanity\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_rng()\n\n        # build spatial structures\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.obs_cell = max(4.0, self.step_size * 1.2)\n        self._build_obs_grid()\n        self.eq = max(0.25, self.edge_cache_quant)\n        self._tick = 0\n        self.ecache = {}\n        self._last_prune = 0\n\n        # endpoints validity\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # trivial straight line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # init trees\n        nodes = []\n        edges = []\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        A, B = [a_root], [b_root]\n        GA, GB = {}, {}\n        self._grid_add(GA, a_root)\n        self._grid_add(GB, b_root)\n\n        # per-cell f-gates\n        gateA, gateB = {}, {}\n        # anchors for fallback NN\n        anchorsA, anchorsB = [a_root], [b_root]\n\n        best_len = float('inf')\n        best_path = None\n        sg = self._dist(self.start, self.goal)\n        corridor_w = max(self.step_size, 0.2 * sg)\n\n        for it in range(self.max_iter):\n            sideA = (it % 2 == 0)\n            T1 = A if sideA else B\n            T2 = B if sideA else A\n            G1 = GA if sideA else GB\n            G2 = GB if sideA else GA\n            gate1 = gateA if sideA else gateB\n            anchors1 = anchorsA if sideA else anchorsB\n            anchors2 = anchorsB if sideA else anchorsA\n            attractor = self.goal if sideA else self.start\n\n            progressed = False\n            for _ in range(self.beam_k):\n                qrand = self._sample_informed(best_len, corridor_w, attractor)\n                if qrand is None:\n                    continue\n                qnear = self._nearest(G1, anchors1, qrand)\n                if qnear is None:\n                    continue\n                qnew = self._steer(qnear.position, qrand, self.step_size)\n                if not self._in_bounds(qnew):\n                    continue\n                if self._point_blocked(qnew):\n                    continue\n                if self._has_close(G1, qnew, self.dupe_radius):\n                    continue\n\n                # per-cell f-gate\n                g_est = qnear.cost + self._dist(qnear.position, qnew)\n                h_est = self._dist(qnew, attractor)\n                f_est = g_est + h_est\n                ck = self._cell_key(qnew)\n                prev = gate1.get(ck, float('inf'))\n                if f_est > prev * self.cell_f_relax:\n                    continue\n\n                # select parent with curvature-aware cost\n                parent, new_cost = self._select_parent(G1, anchors1, qnew, attractor)\n                if parent is None:\n                    continue\n\n                # both checks before insertion\n                if self._point_blocked(qnew):\n                    continue\n                if not self._edge_free(parent.position, qnew):\n                    continue\n\n                qnode = Node(qnew, parent, new_cost)\n                qnode.attach(parent)\n                T1.append(qnode)\n                nodes.append(qnode)\n                edges.append((parent, qnode))\n                self._grid_add(G1, qnode)\n                gate1[ck] = min(prev, new_cost + self._dist(qnew, attractor))\n                progressed = True\n\n                # occasional anchor injection\n                if (len(T1) % 20) == 0:\n                    anchors1.append(qnode)\n\n                # compress to shallow ancestor if LOS\n                self._compress_one(qnode, edges)\n\n                # local bounded rewiring\n                self._rewire_around(G1, qnode, edges)\n\n                # attempt multi-near bridge\n                q_other = self._k_nearest_nodes(G2, anchors2, qnode.position, self.connect_radius_factor * self.step_size, self.connect_k)\n                for nb in q_other:\n                    if self._edge_free(qnode.position, nb.position):\n                        path = self._merge_path(qnode, nb, sideA)\n                        path = self._los_collapse(path)\n                        path = self._curvature_shortcut(path)\n                        bl = self._path_len(path)\n                        best_len = bl\n                        best_path = path\n                        return PlannerResult(True, path, nodes, edges)\n\n            if not progressed:\n                continue\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            s ^= int(v * 997 + 0.5) + 0x9E3779B97F4A7C15 + (s << 6) + (s >> 2)\n            s &= 0xffffffff\n        s ^= len(self.obstacles) * 2654435761\n        self._rng = s if s != 0 else 2463534242\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry utilities\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Obstacle grid\n    def _build_obs_grid(self):\n        self.ogrid = {}\n        if self.is3d:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.ogrid.get(k)\n                            if b is None:\n                                self.ogrid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.ogrid.get(k)\n                        if b is None:\n                            self.ogrid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            lst = self.ogrid.get((cx, cy, cz))\n            if not lst:\n                return False\n            px, py, pz = p\n            for i in lst:\n                x, y, z, w, h, d = self.obstacles[i]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            lst = self.ogrid.get((cx, cy))\n            if not lst:\n                return False\n            px, py = p\n            for i in lst:\n                x, y, w, h = self.obstacles[i]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    # Edge cache and collision\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.eq) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.eq) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._seg_hits_any(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        if len(self.ecache) - self._last_prune > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self.ecache:\n            return\n        thr = self._tick - 3000\n        todel = []\n        for k, v in self.ecache.items():\n            if v[1] < thr:\n                todel.append(k)\n        if not todel:\n            i = 0\n            for k in list(self.ecache.keys()):\n                if (i % 3) == 0:\n                    todel.append(k)\n                i += 1\n        for k in todel:\n            if k in self.ecache:\n                del self.ecache[k]\n        self._last_prune = len(self.ecache)\n\n    def _seg_hits_any(self, a, b):\n        # collect candidate obstacle cells overlapping AABB of segment\n        if self.is3d:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, mnx) // self.obs_cell)\n            cy0 = int(max(0.0, mny) // self.obs_cell)\n            cz0 = int(max(0.0, mnz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        lst = self.ogrid.get((cx, cy, cz))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, mnx) // self.obs_cell)\n            cy0 = int(max(0.0, mny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    lst = self.ogrid.get((cx, cy))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect(self, p0, p1, bmin, bmax):\n        # Liang-Barsky style slab intersection\n        tmin = 0.0\n        tmax = 1.0\n        n = self.dims\n        for i in range(n):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Node grid utilities\n    def _cell_key(self, pos):\n        if self.is3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, anchors, pos):\n        k = self._cell_key(pos)\n        best = None\n        bd = 1e100\n        for r in range(0, 5):\n            cand = self._grid_ring(grid, k, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bd:\n                        bd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback anchors\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bd:\n                bd = d\n                best = n\n        return best\n\n    def _has_close(self, grid, pos, radius):\n        k = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell_size) + 1)\n        if self.is3d:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        b = grid.get((k[0] + dx, k[1] + dy, k[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    b = grid.get((k[0] + dx, k[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    def _nearby(self, grid, pos, radius, cap=None):\n        k = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell_size) + 1)\n        lst = self._grid_ring(grid, k, rc)\n        out = []\n        r2 = radius * radius\n        for n in lst:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                out.append(n)\n        if cap is not None and len(out) > cap:\n            # reservoir-like trim\n            sel = []\n            take = 0\n            for n in out:\n                take += 1\n                if len(sel) < cap:\n                    sel.append(n)\n                else:\n                    j = int(self._rand_range(0, take))\n                    if j < len(sel):\n                        sel[j] = n\n            out = sel\n        return out\n\n    # Sampling\n    def _sample_informed(self, best_len, corridor_w, attractor):\n        for _ in range(32):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._ellipse_pick(self.start, self.goal, best_len * 1.02)\n                if p and not self._point_blocked(p):\n                    return p\n            else:\n                r2 = self._rand()\n                if r2 < self.goal_bias:\n                    p = attractor\n                elif r2 < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_pick(corridor_w)\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n                if self._in_bounds(p) and not self._point_blocked(p):\n                    return p\n        return None\n\n    def _ellipse_pick(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._in_bounds(p) and not self._point_blocked(p):\n                return p\n        return None\n\n    def _corridor_pick(self, width):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n        tries = 0\n        while tries < 20:\n            if self.is3d:\n                ox = self._rand_range(-width, width)\n                oy = self._rand_range(-width, width)\n                oz = self._rand_range(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = (base[0] + ox, base[1] + oy, base[2] + oz)\n                else:\n                    tries += 1\n                    continue\n            else:\n                ox = self._rand_range(-width, width)\n                oy = self._rand_range(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = (base[0] + ox, base[1] + oy)\n                else:\n                    tries += 1\n                    continue\n            p = self._clamp(p)\n            if not self._point_blocked(p):\n                return p\n            tries += 1\n        return tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n\n    # Curvature-aware parent selection\n    def _select_parent(self, grid, anchors, pos, other_root):\n        rad = self.parent_radius_factor * self.step_size\n        cand = self._nearby(grid, pos, rad, cap=max(12, self.neighbor_cap))\n        if not cand:\n            near = self._nearest(grid, anchors, pos)\n            cand = [near] if near is not None else []\n        best_p = None\n        best_cost = float('inf')\n        lam = 0.12\n        h = self._dist(pos, other_root)\n        for p in cand:\n            if not self._edge_free(p.position, pos):\n                continue\n            gc = p.cost + self._dist(p.position, pos)\n            penalty = self._turn_penalty(p, pos)\n            score = gc + self.curvature_weight * penalty + lam * h\n            if score + 1e-12 < best_cost:\n                best_cost = score\n                best_p = p\n        if best_p is None:\n            return None, float('inf')\n        return best_p, best_p.cost + self._dist(best_p.position, pos)\n\n    def _turn_penalty(self, parent, new_pos):\n        gp = parent.parent\n        if gp is None:\n            return 0.0\n        a = gp.position\n        b = parent.position\n        c = new_pos\n        v1 = tuple(b[i] - a[i] for i in range(self.dims))\n        v2 = tuple(c[i] - b[i] for i in range(self.dims))\n        n1 = 0.0\n        n2 = 0.0\n        dot = 0.0\n        for i in range(self.dims):\n            n1 += v1[i] * v1[i]\n            n2 += v2[i] * v2[i]\n            dot += v1[i] * v2[i]\n        if n1 <= 1e-12 or n2 <= 1e-12:\n            return 0.0\n        cosv = dot / ((n1 ** 0.5) * (n2 ** 0.5))\n        if cosv > 1.0:\n            cosv = 1.0\n        if cosv < -1.0:\n            cosv = -1.0\n        # use (1 - cos) as curvature surrogate in [0,2]\n        return 1.0 - cosv\n\n    # Compression and rewiring\n    def _compress_one(self, node, edges):\n        p = node.parent\n        if p is None or p.parent is None:\n            return\n        gp = p.parent\n        if self._edge_free(gp.position, node.position):\n            # both checks satisfied: node is already free; edge gp->node verified\n            old = node.parent\n            node.attach(gp)\n            # update edges list\n            self._remove_edge(edges, old, node)\n            edges.append((gp, node))\n            # cost update along subtree\n            node.cost = gp.cost + self._dist(gp.position, node.position)\n            self._propagate_costs(node)\n\n    def _rewire_around(self, grid, node, edges):\n        rad = max(self.step_size * 1.3, self.rewire_radius_factor * self.step_size)\n        neigh = self._nearby(grid, node.position, rad, cap=self.neighbor_cap * 2)\n        changed = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            # avoid cycles\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            new_c = node.cost + d\n            if new_c + 1e-9 < nb.cost and self._edge_free(node.position, nb.position):\n                oldp = nb.parent\n                nb.attach(node)\n                self._remove_edge(edges, oldp, nb)\n                edges.append((node, nb))\n                nb.cost = new_c\n                self._propagate_costs(nb)\n                changed += 1\n                if changed >= self.neighbor_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _remove_edge(self, edges, p, c):\n        if p is None:\n            return\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is p and edges[i][1] is c:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                old = ch.cost\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                if abs(ch.cost - old) > 1e-12:\n                    stack.append(ch)\n\n    # Connecting\n    def _k_nearest_nodes(self, grid, anchors, pos, radius, k):\n        cand = self._nearby(grid, pos, radius)\n        if not cand:\n            # fallback: combine anchors and sparse grid scan\n            cand = anchors[:]\n            for bucket in grid.values():\n                if len(cand) >= k * 3:\n                    break\n                for n in bucket:\n                    cand.append(n)\n        # select k nearest\n        if len(cand) <= k:\n            return cand\n        best = []\n        bestd = []\n        for n in cand:\n            d = self._dist(n.position, pos)\n            if len(best) < k:\n                best.append(n)\n                bestd.append(d)\n            else:\n                # replace worst\n                wi = 0\n                wv = bestd[0]\n                for i in range(1, k):\n                    if bestd[i] > wv:\n                        wi = i\n                        wv = bestd[i]\n                if d < wv:\n                    best[wi] = n\n                    bestd[wi] = d\n        # order by distance\n        for i in range(len(best)):\n            mi = i\n            for j in range(i + 1, len(best)):\n                if bestd[j] < bestd[mi]:\n                    mi = j\n            if mi != i:\n                bestd[i], bestd[mi] = bestd[mi], bestd[i]\n                best[i], best[mi] = best[mi], best[i]\n        return best\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _merge_path(self, a_side_node, b_side_node, a_is_start_side):\n        if a_is_start_side:\n            pa = self._path_to_root(a_side_node)\n            pb = self._path_to_root(b_side_node)\n            if pa and pb and pa[-1] == pb[-1]:\n                pb = pb[:-1]\n            return pa + pb[::-1]\n        else:\n            pa = self._path_to_root(b_side_node)\n            pb = self._path_to_root(a_side_node)\n            if pa and pb and pa[-1] == pb[-1]:\n                pb = pb[:-1]\n            return pa + pb[::-1]\n\n    # Post-processing\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _los_collapse(self, path):\n        if len(path) < 3:\n            return path[:]\n        out = [path[0]]\n        anchor = path[0]\n        i = 1\n        while i < len(path) - 1:\n            nxt = path[i + 1]\n            if self._edge_free(anchor, nxt):\n                i += 1\n                continue\n            out.append(path[i])\n            anchor = path[i]\n            i += 1\n        out.append(path[-1])\n        return out\n\n    def _curvature_shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best_len = self._path_len(pts)\n        no_imp = 0\n        tries = 0\n        while tries < self.smooth_iters and len(pts) >= 3:\n            # random pair shortcut\n            i = int(self._rand_range(0, max(1, len(pts) - 2)))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(pts[i], pts[j]):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= best_len + 1e-12:\n                    pts = new_pts\n                    best_len = L\n                    no_imp = 0\n                else:\n                    no_imp += 1\n            else:\n                no_imp += 1\n\n            # curvature-local smoothing at a random corner\n            if len(pts) >= 3:\n                k = int(self._rand_range(1, len(pts) - 1))\n                a = pts[k - 1]\n                b = pts[k]\n                c = pts[k + 1] if k + 1 < len(pts) else pts[k]\n                mid = tuple(0.5 * (a[t] + c[t]) for t in range(self.dims))\n                if self._in_bounds(mid) and not self._point_blocked(mid):\n                    if self._edge_free(a, mid) and self._edge_free(mid, c):\n                        cand = pts[:k] + [mid] + pts[k + 1:]\n                        L2 = self._path_len(cand)\n                        if L2 <= best_len + 1e-12:\n                            pts = cand\n                            best_len = L2\n                            no_imp = 0\n                        else:\n                            no_imp += 1\n                    else:\n                        no_imp += 1\n                else:\n                    no_imp += 1\n\n            tries += 1\n            if no_imp >= self.smooth_noimprove:\n                break\n        return pts",
          "objective": -31.05716,
          "time_improvement": 56.0,
          "length_improvement": 8.0,
          "smoothness_improvement": 1907.0,
          "node_improvement": 91.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020774245262145996,
                    "num_nodes_avg": 70.0,
                    "path_length_avg": 196.37557942327294,
                    "smoothness_avg": 0.048317205077675666,
                    "success_improvement": 0.0,
                    "time_improvement": 15.795877227144853,
                    "node_improvement": 82.37219843868043,
                    "length_improvement": -7.636566852083177,
                    "smoothness_improvement": 656.269181955793,
                    "objective_score": 3.4381689666725155
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02782275676727295,
                    "num_nodes_avg": 84.0,
                    "path_length_avg": 238.92221467222308,
                    "smoothness_avg": 0.12122329283088093,
                    "success_improvement": 0.0,
                    "time_improvement": 83.36472778487365,
                    "node_improvement": 94.35597661761742,
                    "length_improvement": 20.240887747767918,
                    "smoothness_improvement": 3019.1626381471497,
                    "objective_score": 52.24976417485859
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.015407848358154296,
                    "num_nodes_avg": 41.0,
                    "path_length_avg": 134.46016775691288,
                    "smoothness_avg": 0.16858850147450788,
                    "success_improvement": 0.0,
                    "time_improvement": 69.47533638429452,
                    "node_improvement": 94.78703115066752,
                    "length_improvement": 10.697958881001766,
                    "smoothness_improvement": 2044.433294846991,
                    "objective_score": 37.48354271812437
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "HARP-BiRRT-Lite: Hierarchically-Compressed, Adaptive, Grid-Indexed Bidirectional RRT. It grows two trees with uniform/goal/informed sampling, grid-accelerated nearest queries, short multi-step extensions, and immediate line-of-sight compression to higher ancestors with a local parent snap. It attempts a multi-near cheapest bridge and, on success, applies fast LOS collapse and shortcut smoothing. The design keeps parameters minimal while improving speed, path length, and smoothness.",
          "planning_mechanism": "Alternate start/goal tree growth. For each iteration: sample a target (goal-biased; informed ellipse if an incumbent exists; else uniform), pick grid-nearest, extend by a few steps toward the target validating both node and edge collisions per step; before inserting, choose the best visible parent in a small radius, then insert and immediately compress to the highest visible ancestor and update costs. After each insertion, try connecting to several nearby nodes of the opposite tree and return the shortest valid bridge. Finalize with LOS collapse and random shortcuts.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            i = 0\n            n = len(self.parent.children)\n            while i < n:\n                if self.parent.children[i] is self:\n                    self.parent.children.pop(i)\n                    break\n                i += 1\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=7.0,\n                 goal_bias=0.25,\n                 informed_bias=0.6,\n                 extend_steps=3,\n                 grid_cell_factor=1.5,\n                 parent_radius_factor=2.5,\n                 connect_radius_factor=3.2,\n                 dupe_radius_ratio=0.5,\n                 collision_step=1.0,\n                 smooth_iters=80):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.extend_steps = int(extend_steps)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.parent_radius_factor = float(parent_radius_factor)\n        self.connect_radius_factor = float(connect_radius_factor)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.collision_step = float(collision_step)\n        self.smooth_iters = int(smooth_iters)\n        self._rng = 2463534242\n\n    # ---------------- Planning ----------------\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n\n        # Parameters derived\n        self.cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self.parent_radius = max(1.5 * self.step_size, self.parent_radius_factor * self.step_size)\n        self.connect_radius = max(2.0 * self.step_size, self.connect_radius_factor * self.step_size)\n        self.dupe_radius = max(0.5, self.dupe_radius_ratio * self.step_size)\n        self.edge_res = max(0.4, self.collision_step)\n\n        # Validate endpoints\n        if self._point_blocked(start) or self._point_blocked(goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line success\n        if not self._edge_blocked(start, goal):\n            n0 = Node(start, None, 0.0)\n            n1 = Node(goal, n0, self._dist(start, goal))\n            n1.attach(n0)\n            return PlannerResult(True, [start, goal], [n0, n1], [(n0, n1)])\n\n        # Initialize trees\n        a_root = Node(start, None, 0.0)\n        b_root = Node(goal, None, 0.0)\n        nodes = [a_root, b_root]\n        edges = []\n        A, B = [a_root], [b_root]\n        GA, GB = {}, {}\n        self._grid_add(GA, a_root)\n        self._grid_add(GB, b_root)\n        frontierA, frontierB = [a_root], [b_root]\n\n        best_len = float('inf')\n        best_path = None\n\n        for it in range(self.max_iter):\n            growA = (it % 2 == 0)\n            T = A if growA else B\n            O = B if growA else A\n            G = GA if growA else GB\n            GO = GB if growA else GA\n            frontier = frontierA if growA else frontierB\n            frontierO = frontierB if growA else frontierA\n            attractor = goal if growA else start\n\n            # Sample target\n            target = self._sample_target(start, goal, best_len, attractor)\n            if target is None:\n                continue\n\n            qnear = self._nearest(G, frontier, target)\n            if qnear is None:\n                qnear = T[-1] if T else (A[0] if growA else B[0])\n\n            last = qnear\n            made_progress = False\n\n            for _ in range(self.extend_steps):\n                qnew = self._steer(last.position, target, self.step_size)\n                if not self._in_bounds(qnew):\n                    break\n                if self._point_blocked(qnew):\n                    break\n                if self._edge_blocked(last.position, qnew):\n                    break\n                if self._has_close(G, qnew, self.dupe_radius):\n                    break\n\n                parent, new_cost = self._select_parent(G, frontier, qnew, default_parent=last)\n                if parent is None:\n                    break\n\n                # enforce both checks before insertion\n                if self._point_blocked(qnew):\n                    break\n                if self._edge_blocked(parent.position, qnew):\n                    break\n\n                qnode = Node(qnew, parent, parent.cost + self._dist(parent.position, qnew))\n                qnode.attach(parent)\n                T.append(qnode)\n                nodes.append(qnode)\n                edges.append((parent, qnode))\n                self._grid_add(G, qnode)\n                frontier.append(qnode)\n                if len(frontier) > 160:\n                    del frontier[:16]\n                made_progress = True\n\n                # LOS compression to higher ancestors\n                self._compress_to_ancestor(qnode, edges)\n\n                # Try bridging to opposite tree\n                candidates = self._nearby(GO, qnode.position, self.connect_radius, cap=16)\n                if not candidates:\n                    onear = self._nearest(GO, frontierO, qnode.position)\n                    if onear is not None:\n                        candidates = [onear]\n                best_bridge = None  # (other_node, total_cost)\n                for nb in candidates:\n                    if not self._edge_blocked(qnode.position, nb.position):\n                        tc = qnode.cost + self._dist(qnode.position, nb.position) + nb.cost\n                        if best_bridge is None or tc < best_bridge[1]:\n                            best_bridge = (nb, tc)\n\n                if best_bridge is not None:\n                    nb = best_bridge[0]\n                    path = self._merge_path(qnode, nb, growA)\n                    path = self._los_collapse_repeat(path, 5)\n                    path = self._shortcut(path, self.smooth_iters)\n                    L = self._path_len(path)\n                    best_len = L\n                    best_path = path\n                    return PlannerResult(True, path, nodes, edges)\n\n                last = qnode  # continue extending toward target\n\n            if not made_progress:\n                continue\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # ---------------- RNG ----------------\n    def _rand(self):\n        # LCG\n        self._rng = (1664525 * self._rng + 1013904223) % (1 << 32)\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------------- Geometry ----------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # ---------------- Collision ----------------\n    def _point_blocked(self, p):\n        if self.is3d:\n            px, py, pz = p\n            for o in self.obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            px, py = p\n            for o in self.obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_blocked(self, a, b):\n        d = self._dist(a, b)\n        steps = int(max(1, d / max(1e-9, self.edge_res)))\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dims))\n            if self._point_blocked(p):\n                return True\n        return False\n\n    # ---------------- Grid NN ----------------\n    def _cell_key(self, pos):\n        if self.is3d:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, frontier, pos):\n        k = self._cell_key(pos)\n        best = None\n        bd = 1e100\n        for r in range(0, 4):\n            cand = self._grid_ring(grid, k, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bd:\n                        bd = d\n                        best = n\n                if best is not None:\n                    return best\n        # frontier-assisted fallback\n        if frontier:\n            lim = min(24, len(frontier))\n            for i in range(lim):\n                n = frontier[-1 - i]\n                d = self._dist(n.position, pos)\n                if d < bd:\n                    bd = d\n                    best = n\n        return best\n\n    def _nearby(self, grid, pos, radius, cap=None):\n        k = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell) + 1)\n        lst = self._grid_ring(grid, k, rc)\n        out = []\n        r2 = radius * radius\n        for n in lst:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                out.append(n)\n        if cap is not None and len(out) > cap:\n            # simple trimming\n            step = max(1, len(out) // cap)\n            out = out[::step][:cap]\n        return out\n\n    def _has_close(self, grid, pos, radius):\n        ns = self._nearby(grid, pos, radius, cap=12)\n        return len(ns) > 0\n\n    # ---------------- Parent selection and compression ----------------\n    def _select_parent(self, grid, frontier, new_pos, default_parent):\n        cand = self._nearby(grid, new_pos, self.parent_radius, cap=24)\n        if default_parent not in cand:\n            cand.append(default_parent)\n        best_p = None\n        best_c = float('inf')\n        for p in cand:\n            if self._edge_blocked(p.position, new_pos):\n                continue\n            gc = p.cost + self._dist(p.position, new_pos)\n            if gc < best_c - 1e-12:\n                best_c = gc\n                best_p = p\n        if best_p is None:\n            return None, float('inf')\n        return best_p, best_c\n\n    def _compress_to_ancestor(self, node, edges):\n        # Iteratively attach to highest visible ancestor\n        changed = True\n        while changed:\n            changed = False\n            p = node.parent\n            if p is None or p.parent is None:\n                break\n            gp = p.parent\n            if not self._edge_blocked(gp.position, node.position):\n                oldp = node.parent\n                node.attach(gp)\n                self._remove_edge(edges, oldp, node)\n                edges.append((gp, node))\n                node.cost = gp.cost + self._dist(gp.position, node.position)\n                self._propagate_costs(node)\n                changed = True\n\n    def _remove_edge(self, edges, p, c):\n        if p is None:\n            return\n        i = 0\n        n = len(edges)\n        while i < n:\n            e = edges[i]\n            if e[0] is p and e[1] is c:\n                edges.pop(i)\n                return\n            i += 1\n\n    def _propagate_costs(self, node):\n        q = [node]\n        head = 0\n        while head < len(q):\n            cur = q[head]\n            head += 1\n            for ch in cur.children:\n                old = ch.cost\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                if abs(ch.cost - old) > 1e-12:\n                    q.append(ch)\n\n    # ---------------- Sampling ----------------\n    def _sample_target(self, start, goal, best_len, attractor):\n        for _ in range(36):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._ellipse_pick(start, goal, best_len * 1.03)\n                if p is not None:\n                    return p\n            else:\n                r2 = self._rand()\n                if r2 < self.goal_bias:\n                    p = attractor\n                else:\n                    p = self._random_free()\n                if p is not None:\n                    return p\n        return None\n\n    def _random_free(self):\n        for _ in range(32):\n            if self.is3d:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n            else:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n            if not self._point_blocked(p):\n                return p\n        # fallback center\n        if self.is3d:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5, self.bounds[2] * 0.5)\n        return (self.bounds[0] * 0.5, self.bounds[1] * 0.5)\n\n    def _ellipse_pick(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(28):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if self._in_bounds(p) and not self._point_blocked(p):\n                if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                    return p\n        return None\n\n    # ---------------- Path utilities ----------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _merge_path(self, a_side_node, b_side_node, a_is_start_side):\n        if a_is_start_side:\n            pa = self._path_to_root(a_side_node)  # start -> a_node\n            pb = self._path_to_root(b_side_node)  # goal -> b_node\n            return pa + [b_side_node.position] + pb[-2::-1]\n        else:\n            pa = self._path_to_root(b_side_node)  # start -> b_node\n            pb = self._path_to_root(a_side_node)  # goal -> a_node\n            return pa + [a_side_node.position] + pb[-2::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _los_collapse_once(self, path):\n        if len(path) < 3:\n            return path[:]\n        out = [path[0]]\n        anchor = path[0]\n        i = 1\n        while i < len(path) - 1:\n            nxt = path[i + 1]\n            if not self._edge_blocked(anchor, nxt):\n                i += 1\n                continue\n            out.append(path[i])\n            anchor = path[i]\n            i += 1\n        out.append(path[-1])\n        return out\n\n    def _los_collapse_repeat(self, path, rounds=5):\n        cur = path[:]\n        for _ in range(rounds):\n            nxt = self._los_collapse_once(cur)\n            if len(nxt) == len(cur):\n                break\n            cur = nxt\n        return cur\n\n    def _shortcut(self, path, iters):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best_len = self._path_len(pts)\n        tries = 0\n        while tries < iters and len(pts) >= 3:\n            i = int(self._rand_range(0, max(1, len(pts) - 2)))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            a, b = pts[i], pts[j]\n            if not self._edge_blocked(a, b):\n                cand = pts[:i + 1] + pts[j:]\n                L = self._path_len(cand)\n                if L <= best_len + 1e-12:\n                    pts = cand\n                    best_len = L\n            tries += 1\n        return pts",
          "objective": -30.96826,
          "time_improvement": 49.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1806.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.026035237312316894,
                    "num_nodes_avg": 60.9,
                    "path_length_avg": 174.7504400904631,
                    "smoothness_avg": 0.05754593544966802,
                    "success_improvement": 0.0,
                    "time_improvement": -5.528470055247981,
                    "node_improvement": 84.66381264165199,
                    "length_improvement": 4.216514688491236,
                    "smoothness_improvement": 800.7188527862356,
                    "objective_score": 4.874962060451525
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.032358980178833006,
                    "num_nodes_avg": 120.5,
                    "path_length_avg": 239.3534678823024,
                    "smoothness_avg": 0.13000974684803965,
                    "success_improvement": 0.0,
                    "time_improvement": 80.65251231639449,
                    "node_improvement": 91.90351407646308,
                    "length_improvement": 20.096923013308043,
                    "smoothness_improvement": 3245.244428635667,
                    "objective_score": 52.48012964608151
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014370584487915039,
                    "num_nodes_avg": 68.8,
                    "path_length_avg": 132.42802274092077,
                    "smoothness_avg": 0.11575588968402828,
                    "success_improvement": 0.0,
                    "time_improvement": 71.53027163442123,
                    "node_improvement": 91.25238397965671,
                    "length_improvement": 12.047612840276742,
                    "smoothness_improvement": 1372.406372569842,
                    "objective_score": 35.549681057341616
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "IRRT*-Balance: Simplified Informed BiRRT* with neighbor choose-parent, bounded local rewiring, obstacle-grid accelerated collision checks, and balanced connect. It minimizes per-iteration work while improving path length and smoothness by selecting optimal parents over nearby nodes and applying light two-stage shortcutting.",
          "planning_mechanism": "At each iteration, expand the smaller tree: draw a guided sample (uniform/corridor; ellipse after a first solution), steer one step, verify node and edge, choose the cheapest collision-free parent among nearby nodes, insert, and rewire cheaper neighbors. Greedily connect the opposite tree toward the new node; if a final collision-free chord exists, extract and shortcut the path, then return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3500,\n        step_size=6.0,\n        beam_k=2,\n        goal_bias=0.2,\n        corridor_bias=0.35,\n        rewire_radius_factor=2.0,\n        min_sep_ratio=0.3,\n        grid_cell_factor=1.0,\n        connect_steps=28,\n        shortcut_attempts=70\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.rewire_radius_factor = rewire_radius_factor\n        self.min_sep_ratio = min_sep_ratio\n        self.grid_cell_factor = grid_cell_factor\n        self.connect_steps = connect_steps\n        self.shortcut_attempts = shortcut_attempts\n        self._rnd_state = 123456789\n\n    def plan(self, map):\n        # Scene\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        # Derived\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step_size * self.min_sep_ratio)\n        self.rewire_radius = max(self.step_size * 1.2, self.step_size * self.rewire_radius_factor)\n\n        # Seed PRNG\n        self._seed_from_scene()\n\n        nodes = []\n        edges = []\n\n        # Validate start/goal\n        if (not self._within_bounds(self.start)) or (not self._within_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Build obstacle grid and validate start/goal clearance\n        self._build_obstacle_grid()\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Init trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        best_len = None\n\n        # Main loop\n        for _ in range(self.max_iter):\n            # Balance: expand smaller tree\n            if len(tree_a) <= len(tree_b):\n                active_tree, active_grid = tree_a, grid_a\n                passive_tree, passive_grid = tree_b, grid_b\n                attractor = self.goal\n            else:\n                active_tree, active_grid = tree_b, grid_b\n                passive_tree, passive_grid = tree_a, grid_a\n                attractor = self.start\n\n            last_new = None\n\n            for _b in range(self.beam_k):\n                s = self._guided_sample(attractor, best_len)\n                if s is None:\n                    continue\n\n                nearest = self._nearest_in_grid(active_grid, s)\n                if nearest is None:\n                    continue\n\n                new_pos = self._steer(nearest.position, s, self.step_size)\n                if not self._within_bounds(new_pos):\n                    continue\n                if self._point_in_obstacles(new_pos):\n                    continue\n                # Suppress near-duplicate only within active grid (avoid over-pruning)\n                if self._has_nearby(active_grid, new_pos, self.min_sep):\n                    continue\n\n                # Choose parent over nearby neighbors (RRT* choose-parent)\n                neigh = self._nearby_nodes(active_grid, new_pos, self.rewire_radius)\n                parent, parent_cost = self._choose_parent(nearest, neigh, new_pos)\n                if parent is None:\n                    continue\n\n                # Final checks before insertion (both checks)\n                if self._point_in_obstacles(new_pos):\n                    continue\n                if not self._edge_free(parent.position, new_pos):\n                    continue\n\n                # Insert node\n                new_cost = parent_cost\n                new_node = Node(new_pos, parent, new_cost)\n                parent.add_child(new_node)\n                active_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((parent, new_node))\n                self._grid_insert(active_grid, new_node)\n                last_new = new_node\n\n                # Local rewiring\n                self._rewire_neighbors(new_node, neigh, edges)\n\n                # Attempt connect from passive tree toward new node\n                meet = self._connect_toward(passive_tree, passive_grid, new_node.position, nodes, edges)\n                if meet is not None and self._edge_free(meet.position, new_node.position):\n                    # Extract path\n                    path = self._extract_path(new_node, meet)\n                    best_len = self._path_len(path)\n                    path = self._shortcut(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n            if last_new is None:\n                continue\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # ---------- PRNG ----------\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 1000 + 0.5)) & 0x7fffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0x7fffffff\n        self._rnd_state = (s ^ 0x9E3779B9) & 0x7fffffff\n        if self._rnd_state == 0:\n            self._rnd_state = 123456789\n\n    def _rand(self):\n        self._rnd_state = (1103515245 * self._rnd_state + 12345) & 0x7fffffff\n        return self._rnd_state / 2147483647.0\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        q = []\n        for i in range(self.dims):\n            v = p[i]\n            if v < 0.0:\n                v = 0.0\n            elif v > self.bounds[i]:\n                v = self.bounds[i]\n            q.append(v)\n        return tuple(q)\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # ---------- Node spatial grid ----------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        cand = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        return cand\n\n    def _nearest_in_grid(self, grid, pos, max_ring=4):\n        key = self._cell_of(pos)\n        best = None\n        bestd2 = 1e100\n        for r in range(0, max_ring + 1):\n            cand = self._ring_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            if best is not None:\n                return best\n        # Fallback: approximate by random in buckets\n        buckets = list(grid.values())\n        if not buckets:\n            return None\n        trials = 0\n        while trials < 24:\n            bucket = buckets[int(self._rand() * len(buckets)) % max(1, len(buckets))]\n            if bucket:\n                n = bucket[int(self._rand() * len(bucket)) % max(1, len(bucket))]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            trials += 1\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        rc = int(radius // self.cell_size) + 1\n        r2 = radius * radius\n        cand = self._ring_collect(grid, key, rc)\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                return True\n        return False\n\n    def _nearby_nodes(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        rc = int(radius // self.cell_size) + 1\n        r2 = radius * radius\n        cand = self._ring_collect(grid, key, rc)\n        out = []\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                out.append(n)\n        return out\n\n    # ---------- Obstacle spatial grid ----------\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            key = (cx, cy, cz)\n                            bucket = self.obs_grid.get(key)\n                            if bucket is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                bucket.append(idx)\n        else:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        key = (cx, cy)\n                        bucket = self.obs_grid.get(key)\n                        if bucket is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    # ---------- Collision ----------\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bucket = self.obs_grid.get((cx, cy, cz))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bucket = self.obs_grid.get((cx, cy))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # ---------- Parent selection and rewiring ----------\n    def _choose_parent(self, nearest, neigh, new_pos):\n        best_parent = None\n        best_cost = 1e100\n        # Always consider nearest\n        cand = [nearest] + [n for n in neigh if n is not nearest]\n        for n in cand:\n            # Edge collision check to candidate parent\n            if not self._edge_free(n.position, new_pos):\n                continue\n            c = n.cost + self._dist(n.position, new_pos)\n            if c + 1e-9 < best_cost:\n                best_cost = c\n                best_parent = n\n        if best_parent is None:\n            return None, None\n        return best_parent, best_cost\n\n    def _rewire_neighbors(self, new_node, neigh, edges):\n        for nb in neigh:\n            if nb is new_node or nb is new_node.parent:\n                continue\n            # Avoid cycles: don't rewire ancestors of new_node\n            if self._is_ancestor(new_node, nb):\n                continue\n            cand_cost = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand_cost + 1e-9 < nb.cost and self._edge_free(new_node.position, nb.position):\n                # Perform rewiring (edge already collision-validated)\n                old_parent = nb.parent\n                if old_parent is not None:\n                    try:\n                        old_parent.children.remove(nb)\n                    except:\n                        pass\n                    self._remove_edge(edges, (old_parent, nb))\n                new_node.add_child(nb)\n                delta = cand_cost - nb.cost\n                nb.cost = cand_cost\n                edges.append((new_node, nb))\n                self._propagate_cost(nb, delta)\n\n    def _is_ancestor(self, node, candidate_ancestor):\n        cur = node.parent\n        while cur is not None:\n            if cur is candidate_ancestor:\n                return True\n            cur = cur.parent\n        return False\n\n    def _propagate_cost(self, node, delta):\n        stack = [node]\n        while stack:\n            n = stack.pop()\n            n.cost += delta\n            for c in n.children:\n                stack.append(c)\n\n    def _remove_edge(self, edges, pair):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is pair[0] and edges[i][1] is pair[1]:\n                del edges[i]\n                break\n\n    # ---------- Connect attempt ----------\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        near = self._nearest_in_grid(grid, target_pos)\n        if near is None:\n            return None\n        cur = near\n        steps = 0\n        last_added = None\n        while steps < self.connect_steps:\n            nxt_pos = self._steer(cur.position, target_pos, self.step_size)\n            # Stop if movement is negligible\n            if self._dist2(cur.position, nxt_pos) < (self.min_sep * self.min_sep * 0.25):\n                break\n            if not self._within_bounds(nxt_pos):\n                break\n            if self._point_in_obstacles(nxt_pos):\n                break\n            if self._has_nearby(grid, nxt_pos, self.min_sep):\n                break\n            if not self._edge_free(cur.position, nxt_pos):\n                break\n            # Insert step node (both checks satisfied)\n            new_cost = cur.cost + self._dist(cur.position, nxt_pos)\n            q = Node(nxt_pos, cur, new_cost)\n            cur.add_child(q)\n            tree.append(q)\n            nodes.append(q)\n            edges.append((cur, q))\n            self._grid_insert(grid, q)\n            last_added = q\n            cur = q\n            steps += 1\n            # If close enough and final chord to target is free, return meeting node\n            if self._dist2(cur.position, target_pos) <= (self.step_size * self.step_size) and self._edge_free(cur.position, target_pos):\n                return cur\n        return last_added\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, attractor, incumbent_len):\n        # Mixture: direct attractor, corridor along start-goal, or uniform; ellipse after first path\n        for _ in range(20):\n            r = self._rand()\n            if incumbent_len is not None and self._dist(self.start, self.goal) > 1e-9 and r < 0.6:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                elif r < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_sample()\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            if p is not None and self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        # Fallback\n        if self._within_bounds(attractor) and not self._point_in_obstacles(attractor):\n            return attractor\n        return None\n\n    def _corridor_sample(self):\n        # Sample around the line segment between start and goal\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n        dsg = self._dist(self.start, self.goal)\n        width = max(self.step_size, 0.08 * dsg)\n        if self.is_3d:\n            p = (self._clamp_val(base[0] + self._rand_range(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._rand_range(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._rand_range(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._rand_range(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._rand_range(-width, width), 0.0, self.bounds[1]))\n        return p\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum_dist\n        ext = [max(self.step_size, half)] * self.dims\n        for _ in range(18):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._within_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum_dist and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # ---------- Path handling ----------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        pb_rev = pb[::-1]\n        if pa and pb_rev and pa[-1] == pb_rev[0]:\n            pb_rev = pb_rev[1:]\n        return pa + pb_rev\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        # Greedy long-span removal\n        i = 0\n        while i < len(pts) - 2:\n            j = len(pts) - 1\n            improved = False\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    del pts[i + 1:j]\n                    improved = True\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n        # Randomized refinement\n        attempts = 0\n        while attempts < self.shortcut_attempts and len(pts) > 2:\n            i = int(self._rand_range(0, len(pts) - 2))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                attempts += 1\n                continue\n            # Prefer longer spans\n            if (j - i) < 3 and self._rand() < 0.6:\n                attempts += 1\n                continue\n            if self._edge_free(pts[i], pts[j]):\n                pts = pts[:i + 1] + pts[j:]\n            attempts += 1\n        return pts",
          "objective": -30.89253,
          "time_improvement": 40.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1691.0,
          "node_improvement": 84.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024645376205444335,
                    "num_nodes_avg": 76.0,
                    "path_length_avg": 151.74061274417835,
                    "smoothness_avg": 0.04953752500528684,
                    "success_improvement": 0.0,
                    "time_improvement": 0.10504556967652061,
                    "node_improvement": 80.86124401913875,
                    "length_improvement": 16.828565671036927,
                    "smoothness_improvement": 675.3698387900448,
                    "objective_score": 13.505502267475338
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04964156150817871,
                    "num_nodes_avg": 186.0,
                    "path_length_avg": 250.78572879945872,
                    "smoothness_avg": 0.12425595091598525,
                    "success_improvement": 0.0,
                    "time_improvement": 70.31922840069336,
                    "node_improvement": 87.5025196532957,
                    "length_improvement": 16.28050525977595,
                    "smoothness_improvement": 3097.1951150122113,
                    "objective_score": 46.35004725113463
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024727296829223634,
                    "num_nodes_avg": 132.0,
                    "path_length_avg": 122.93086491206807,
                    "smoothness_avg": 0.11014540994501384,
                    "success_improvement": 0.0,
                    "time_improvement": 51.01247102822808,
                    "node_improvement": 83.21678321678321,
                    "length_improvement": 18.355172864142737,
                    "smoothness_improvement": 1301.041484412115,
                    "objective_score": 32.822052449014635
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "AURORA-IRRT*-Connect: Adaptive Unrolled Rewire-Optimized, Ring-Organized, Accelerated BiRRT* with informed sampling, obstacle-binned collision queries, safe segment caching, adaptive step/rewire radii, multi-ancestor compression, and greedy connect. It targets fast convergence, shorter paths, and smoother trajectories via bounded RRT* rewiring and LOS compression while keeping per-iteration costs low with spatial hashing and obstacle bins.",
          "planning_mechanism": "Alternate tree growth with best-of-k target sampling (goal/corridor/informed/uniform) scored by local bin density. Use a node grid for nearest/neighbor queries and obstacle bins for constant-time collision filtering. For each sample, compute an adaptive step, select the cheapest feasible parent among near neighbors (bounded RRT*), insert after point+edge checks, then attempt multi-ancestor LOS compression and local rewiring. Immediately try a direct bridge to the opposite tree; if blocked, run a short greedy connect with per-step validations. Upon connection, perform greedy visibility collapse, random shortcuts, and corner-round rounding, then return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=8.0,\n                 goal_bias=0.25,\n                 corridor_bias=0.35,\n                 informed_bias=0.45,\n                 sample_k=3,\n                 grid_cell_factor=1.0,\n                 dup_radius_ratio=0.35,\n                 min_sep_ratio=0.20,\n                 rewire_radius_factor=2.5,\n                 connect_max_steps=18,\n                 smoothing_shortcuts=14):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.informed_bias = informed_bias\n        self.sample_k = sample_k\n        self.grid_cell_factor = grid_cell_factor\n        self.dup_radius_ratio = dup_radius_ratio\n        self.min_sep_ratio = min_sep_ratio\n        self.rewire_radius_factor = rewire_radius_factor\n        self.connect_max_steps = connect_max_steps\n        self.smoothing_shortcuts = smoothing_shortcuts\n\n        self.dim = 2\n        self.bounds = None\n        self.start = None\n        self.goal = None\n\n        # RNG state\n        self._rng = 123456789\n\n        # Grids for nodes\n        self.grid_cell = 1.0\n\n        # Obstacles and bins\n        self._obstacles = None\n        self._bins = None\n        self._bins_cell = None\n        self._bins_n = None\n\n        # Safe segment cache (cleared per run)\n        self._seg_cache = {}\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self._obstacles = list(map.obstacles)\n\n        # Setup\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._build_bins()\n        self._seg_cache = {}\n\n        if self._point_in_obstacle(self.start) or self._point_in_obstacle(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight path\n        if not self._edge_blocked(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Initialize trees\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n        grid_start = {}\n        grid_goal = {}\n        self.grid_cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        dup_radius = max(0.25, self.step_size * self.dup_radius_ratio)\n        min_sep = max(0.25, self.step_size * self.min_sep_ratio)\n        corridor_w = max(self.step_size, 0.2 * self._dist(self.start, self.goal))\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            a_is_start = (it % 2 == 0)\n            tree_a = start_tree if a_is_start else goal_tree\n            tree_b = goal_tree if a_is_start else start_tree\n            grid_a = grid_start if a_is_start else grid_goal\n            grid_b = grid_goal if a_is_start else grid_start\n            other_root = self.goal if a_is_start else self.start\n\n            # Target selection with best-of-k by bin sparsity\n            target = self._pick_target(best_len, corridor_w, other_root)\n\n            # Nearest and adaptive step\n            near = self._nearest_grid(grid_a, tree_a, target)\n            if near is None:\n                continue\n            step = self._adaptive_step(near.position, target)\n            new_pos = self._steer(near.position, target, step)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._dist(near.position, new_pos) < min_sep:\n                continue\n            if self._point_in_obstacle(new_pos):\n                continue\n            if self._exists_close(grid_a, new_pos, dup_radius):\n                continue\n\n            # Choose best parent among neighbors (bounded RRT*)\n            rewire_r = max(step * self.rewire_radius_factor, step)\n            neigh = self._nearby_nodes(grid_a, new_pos, rewire_r)\n            best_parent = None\n            best_cost = float('inf')\n            for cand in neigh if neigh else [near]:\n                # Node already exists and is free by construction; check edge\n                if not self._edge_free_checked(cand.position, new_pos):\n                    continue\n                c = cand.cost + self._dist(cand.position, new_pos)\n                if c < best_cost:\n                    best_cost = c\n                    best_parent = cand\n            if best_parent is None:\n                # Fallback to nearest if feasible\n                if not self._edge_free_checked(near.position, new_pos):\n                    continue\n                best_parent = near\n                best_cost = near.cost + self._dist(near.position, new_pos)\n\n            # Insert node (after both checks)\n            new_node = Node(new_pos, best_parent, best_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            self._grid_add(grid_a, new_node)\n            edges.append((best_parent, new_node))\n\n            # Multi-ancestor LOS compression (iterative)\n            self._compress_to_ancestor(new_node, edges)\n\n            # Local rewiring: improve neighbors through new_node\n            self._local_rewire(new_node, grid_a, edges, rewire_r)\n\n            # Try direct bridge to the opposite tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None and self._edge_free_checked(new_node.position, other_near.position):\n                path = self._merge_paths(new_node, other_near, a_is_start)\n                best_len = self._path_length(path)\n                path = self._post_smooth(path)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Greedy connect from the other tree toward new_node\n            p = other_near\n            steps = 0\n            bridged = False\n            while p is not None and steps < self.connect_max_steps:\n                s = self._adaptive_step(p.position, new_node.position)\n                nxt = self._steer(p.position, new_node.position, s)\n                if not self._in_bounds(nxt):\n                    break\n                if self._dist(p.position, nxt) < min_sep:\n                    break\n                if self._point_in_obstacle(nxt):\n                    break\n                if self._exists_close(grid_b, nxt, dup_radius):\n                    break\n                if not self._edge_free_checked(p.position, nxt):\n                    break\n                q = Node(nxt, p, p.cost + self._dist(p.position, nxt))\n                p.add_child(q)\n                tree_b.append(q)\n                self._grid_add(grid_b, q)\n                edges.append((p, q))\n                # try LOS to new_node\n                if self._edge_free_checked(q.position, new_node.position):\n                    p = q\n                    bridged = True\n                    break\n                p = q\n                steps += 1\n\n            if bridged:\n                path = self._merge_paths(new_node, p, a_is_start)\n                best_len = self._path_length(path)\n                path = self._post_smooth(path)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # RNG\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) % (1 << 32)\n        return self._rng / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        # fast sqrt\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Adaptive step using local bin density\n    def _adaptive_step(self, a, b):\n        base = self.step_size\n        dens_a = self._local_density(a)\n        dens_b = self._local_density(b)\n        dens = 0.5 * (dens_a + dens_b)\n        # map density to factor in [0.6, 1.4]\n        f = 1.4 / (1.0 + 0.25 * dens)\n        step = base * f\n        if step < 0.5 * base:\n            step = 0.5 * base\n        if step > 1.6 * base:\n            step = 1.6 * base\n        return step\n\n    def _local_density(self, p):\n        bucket = self._bins.get(self._bin_key(p))\n        return 0 if bucket is None else len(bucket)\n\n    # Obstacle bins\n    def _build_bins(self):\n        # choose bins count in [8, 64]\n        max_axis = 1.0\n        for i in range(self.dim):\n            if self.bounds[i] > max_axis:\n                max_axis = self.bounds[i]\n        target_bins = max(8, min(64, int(max_axis / max(1.0, self.step_size * 2.0)) + 1))\n        if self.dim == 2:\n            cx = max(self.bounds[0] / target_bins, 1.0)\n            cy = max(self.bounds[1] / target_bins, 1.0)\n            nx = max(int(self.bounds[0] / cx), 1)\n            ny = max(int(self.bounds[1] / cy), 1)\n            self._bins_cell = (cx, cy)\n            self._bins_n = (nx, ny)\n            self._bins = {}\n            for obs in self._obstacles:\n                x, y, w, h = obs\n                i0 = int(x / cx)\n                j0 = int(y / cy)\n                i1 = int((x + w) / cx)\n                j1 = int((y + h) / cy)\n                if i0 < 0: i0 = 0\n                if j0 < 0: j0 = 0\n                if i1 >= nx: i1 = nx - 1\n                if j1 >= ny: j1 = ny - 1\n                for i in range(i0, i1 + 1):\n                    for j in range(j0, j1 + 1):\n                        key = (i, j)\n                        lst = self._bins.get(key)\n                        if lst is None:\n                            self._bins[key] = [obs]\n                        else:\n                            lst.append(obs)\n        else:\n            cx = max(self.bounds[0] / target_bins, 1.0)\n            cy = max(self.bounds[1] / target_bins, 1.0)\n            cz = max(self.bounds[2] / target_bins, 1.0)\n            nx = max(int(self.bounds[0] / cx), 1)\n            ny = max(int(self.bounds[1] / cy), 1)\n            nz = max(int(self.bounds[2] / cz), 1)\n            self._bins_cell = (cx, cy, cz)\n            self._bins_n = (nx, ny, nz)\n            self._bins = {}\n            for obs in self._obstacles:\n                x, y, z, w, h, d = obs\n                i0 = int(x / cx)\n                j0 = int(y / cy)\n                k0 = int(z / cz)\n                i1 = int((x + w) / cx)\n                j1 = int((y + h) / cy)\n                k1 = int((z + d) / cz)\n                if i0 < 0: i0 = 0\n                if j0 < 0: j0 = 0\n                if k0 < 0: k0 = 0\n                if i1 >= nx: i1 = nx - 1\n                if j1 >= ny: j1 = ny - 1\n                if k1 >= nz: k1 = nz - 1\n                for i in range(i0, i1 + 1):\n                    for j in range(j0, j1 + 1):\n                        for k in range(k0, k1 + 1):\n                            key = (i, j, k)\n                            lst = self._bins.get(key)\n                            if lst is None:\n                                self._bins[key] = [obs]\n                            else:\n                                lst.append(obs)\n\n    def _bin_key(self, pos):\n        if self.dim == 2:\n            cx, cy = self._bins_cell\n            nx, ny = self._bins_n\n            i = int(pos[0] / cx)\n            j = int(pos[1] / cy)\n            if i < 0: i = 0\n            if j < 0: j = 0\n            if i >= nx: i = nx - 1\n            if j >= ny: j = ny - 1\n            return (i, j)\n        else:\n            cx, cy, cz = self._bins_cell\n            nx, ny, nz = self._bins_n\n            i = int(pos[0] / cx)\n            j = int(pos[1] / cy)\n            k = int(pos[2] / cz)\n            if i < 0: i = 0\n            if j < 0: j = 0\n            if k < 0: k = 0\n            if i >= nx: i = nx - 1\n            if j >= ny: j = ny - 1\n            if k >= nz: k = nz - 1\n            return (i, j, k)\n\n    def _bin_keys_for_bbox(self, bmin, bmax):\n        if self.dim == 2:\n            cx, cy = self._bins_cell\n            nx, ny = self._bins_n\n            i0 = int(bmin[0] / cx)\n            j0 = int(bmin[1] / cy)\n            i1 = int(bmax[0] / cx)\n            j1 = int(bmax[1] / cy)\n            if i0 < 0: i0 = 0\n            if j0 < 0: j0 = 0\n            if i1 >= nx: i1 = nx - 1\n            if j1 >= ny: j1 = ny - 1\n            for i in range(i0, i1 + 1):\n                for j in range(j0, j1 + 1):\n                    yield (i, j)\n        else:\n            cx, cy, cz = self._bins_cell\n            nx, ny, nz = self._bins_n\n            i0 = int(bmin[0] / cx)\n            j0 = int(bmin[1] / cy)\n            k0 = int(bmin[2] / cz)\n            i1 = int(bmax[0] / cx)\n            j1 = int(bmax[1] / cy)\n            k1 = int(bmax[2] / cz)\n            if i0 < 0: i0 = 0\n            if j0 < 0: j0 = 0\n            if k0 < 0: k0 = 0\n            if i1 >= nx: i1 = nx - 1\n            if j1 >= ny: j1 = ny - 1\n            if k1 >= nz: k1 = nz - 1\n            for i in range(i0, i1 + 1):\n                for j in range(j0, j1 + 1):\n                    for k in range(k0, k1 + 1):\n                        yield (i, j, k)\n\n    def _point_in_obstacle(self, pos):\n        bucket = self._bins.get(self._bin_key(pos))\n        if not bucket:\n            return False\n        if self.dim == 2:\n            px, py = pos\n            for obs in bucket:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        else:\n            px, py, pz = pos\n            for obs in bucket:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        return False\n\n    # Segment queries\n    def _edge_free_checked(self, a, b):\n        if self._point_in_obstacle(a) or self._point_in_obstacle(b):\n            return False\n        return not self._edge_blocked(a, b)\n\n    def _edge_blocked(self, a, b):\n        key = (a, b) if a <= b else (b, a)\n        val = self._seg_cache.get(key)\n        if val is not None:\n            return val\n        # compute bbox\n        if self.dim == 2:\n            bmin = (min(a[0], b[0]), min(a[1], b[1]))\n            bmax = (max(a[0], b[0]), max(a[1], b[1]))\n        else:\n            bmin = (min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2]))\n            bmax = (max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2]))\n        seen = {}\n        for k in self._bin_keys_for_bbox(bmin, bmax):\n            bucket = self._bins.get(k)\n            if not bucket:\n                continue\n            for obs in bucket:\n                oid = id(obs)\n                if seen.get(oid) is not None:\n                    continue\n                seen[oid] = True\n                if self._segment_intersects_box(a, b, obs):\n                    self._seg_cache[key] = True\n                    return True\n        self._seg_cache[key] = False\n        return False\n\n    def _segment_intersects_box(self, a, b, obs):\n        # Liang-Barsky slabs\n        t0 = 0.0\n        t1 = 1.0\n        if self.dim == 2:\n            x, y, w, h = obs\n            bmin = (x, y)\n            bmax = (x + w, y + h)\n            for i in range(2):\n                p0 = a[i]\n                p1 = b[i]\n                d = p1 - p0\n                lo = bmin[i]\n                hi = bmax[i]\n                if abs(d) < 1e-12:\n                    if p0 < lo or p0 > hi:\n                        return False\n                else:\n                    inv = 1.0 / d\n                    tA = (lo - p0) * inv\n                    tB = (hi - p0) * inv\n                    if tA > tB:\n                        tA, tB = tB, tA\n                    if tA > t0:\n                        t0 = tA\n                    if tB < t1:\n                        t1 = tB\n                    if t0 > t1:\n                        return False\n            return True\n        else:\n            x, y, z, w, h, d = obs\n            bmin = (x, y, z)\n            bmax = (x + w, y + h, z + d)\n            for i in range(3):\n                p0 = a[i]\n                p1 = b[i]\n                dn = p1 - p0\n                lo = bmin[i]\n                hi = bmax[i]\n                if abs(dn) < 1e-12:\n                    if p0 < lo or p0 > hi:\n                        return False\n                else:\n                    inv = 1.0 / dn\n                    tA = (lo - p0) * inv\n                    tB = (hi - p0) * inv\n                    if tA > tB:\n                        tA, tB = tB, tA\n                    if tA > t0:\n                        t0 = tA\n                    if tB < t1:\n                        t1 = tB\n                    if t0 > t1:\n                        return False\n            return True\n\n    # Node grid\n    def _grid_key(self, pos):\n        if self.dim == 2:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell))\n        else:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell), int(pos[2] // self.grid_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # ring limit grows mildly with tree size\n        r_limit = 2\n        # Small fallback threshold\n        for r in range(0, r_limit + 1):\n            cand = self._grid_collect_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _nearby_nodes(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._grid_collect_ring(grid, key, r_cells)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                out.append(n)\n        return out\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._grid_collect_ring(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # Sampling\n    def _pick_target(self, best_len, corridor_w, other_root):\n        best = None\n        best_score = 1e18\n        for _ in range(self.sample_k):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._sample_informed(best_len)\n            else:\n                if r < self.goal_bias:\n                    p = other_root\n                elif r < self.goal_bias + self.corridor_bias:\n                    p = self._sample_corridor(corridor_w)\n                else:\n                    p = self._sample_free()\n            score = self._local_density(p)\n            if score < best_score:\n                best_score = score\n                best = p\n        return best\n\n    def _sample_free(self):\n        for _ in range(48):\n            if self.dim == 2:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            if self._in_bounds(p) and not self._point_in_obstacle(p):\n                return p\n        # fallback towards center\n        mid = tuple((self.start[i] + self.goal[i]) * 0.5 for i in range(self.dim))\n        if not self._point_in_obstacle(mid):\n            return self._clamp(mid)\n        # random corner fallback\n        return self._clamp((0.0,) * self.dim)\n\n    def _sample_corridor(self, width):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        tries = 16\n        if self.dim == 2:\n            for _ in range(tries):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp((base[0] + ox, base[1] + oy))\n                    if not self._point_in_obstacle(p):\n                        return p\n        else:\n            for _ in range(tries):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp((base[0] + ox, base[1] + oy, base[2] + oz))\n                    if not self._point_in_obstacle(p):\n                        return p\n        return self._sample_free()\n\n    def _sample_informed(self, best_len):\n        for _ in range(64):\n            if self.dim == 2:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= best_len + 1e-9 and not self._point_in_obstacle(p):\n                return p\n        return self._sample_corridor(max(self.step_size, 0.2 * self._dist(self.start, self.goal)))\n\n    # Compression and rewiring\n    def _compress_to_ancestor(self, node, edges):\n        # try to climb to farthest ancestor with LOS\n        cur = node\n        p = cur.parent\n        if p is None:\n            return\n        # gather ancestors up to limited depth\n        chain = []\n        q = p\n        depth = 0\n        while q is not None and depth < 6:\n            chain.append(q)\n            q = q.parent\n            depth += 1\n        # try farthest first\n        for anc in reversed(chain):\n            if self._edge_free_checked(anc.position, cur.position):\n                # reparent\n                oldp = cur.parent\n                if oldp is anc:\n                    break\n                # remove old edge\n                if oldp is not None:\n                    oldp.remove_child(cur)\n                    self._remove_edge(edges, oldp, cur)\n                # add new edge\n                anc.add_child(cur)\n                edges.append((anc, cur))\n                # update costs and propagate\n                delta = (anc.cost + self._dist(anc.position, cur.position)) - cur.cost\n                self._propagate_cost(cur, delta)\n                break\n\n    def _local_rewire(self, node, grid, edges, radius):\n        neigh = self._nearby_nodes(grid, node.position, radius)\n        for nb in neigh:\n            if nb is node:\n                continue\n            # ensure node exists and point is valid (should be)\n            if self._point_in_obstacle(nb.position):\n                continue\n            # check edge feasibility\n            if not self._edge_free_checked(node.position, nb.position):\n                continue\n            new_cost = node.cost + self._dist(node.position, nb.position)\n            if new_cost + 1e-9 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, oldp, nb)\n                node.add_child(nb)\n                edges.append((node, nb))\n                delta = new_cost - nb.cost\n                self._propagate_cost(nb, delta)\n\n    def _propagate_cost(self, node, delta):\n        node.cost += delta\n        for ch in node.children:\n            self._propagate_cost(ch, delta)\n\n    def _remove_edge(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # Path utils\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_paths(self, a_node, b_node, a_is_start_tree):\n        if a_is_start_tree:\n            left = self._path_to_root(a_node)      # start -> a_node\n            right = self._path_to_root(b_node)     # goal -> b_node\n            right.reverse()                        # b_node -> goal\n        else:\n            left = self._path_to_root(b_node)      # start -> b_node\n            right = self._path_to_root(a_node)     # goal -> a_node\n            right.reverse()                        # a_node -> goal\n        if left and right and left[-1] == right[0]:\n            right = right[1:]\n        return left + right\n\n    def _path_length(self, path):\n        if len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    # Post smoothing: greedy visibility + shortcuts + corner rounding\n    def _post_smooth(self, path):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        # Greedy visibility collapse\n        collapsed = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free_checked(pts[i], pts[j]):\n                    collapsed.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                collapsed.append(pts[i + 1])\n                i += 1\n        pts = collapsed\n        # Random shortcuts\n        for _ in range(self.smoothing_shortcuts):\n            m = len(pts)\n            if m < 3:\n                break\n            i = int(self._uniform(0, m - 2))\n            j = int(self._uniform(i + 1, m - 1))\n            if j <= i + 1:\n                continue\n            if self._edge_free_checked(pts[i], pts[j]):\n                pts = pts[:i + 1] + pts[j:]\n        # Corner rounding via midpoint if improves and collision-free\n        k = 1\n        while k < len(pts) - 1:\n            a = pts[k - 1]\n            b = pts[k]\n            c = pts[k + 1]\n            mid = tuple((a[d] + c[d]) * 0.5 for d in range(self.dim))\n            if self._in_bounds(mid) and not self._point_in_obstacle(mid):\n                if self._edge_free_checked(a, mid) and self._edge_free_checked(mid, c):\n                    if self._dist(a, mid) + self._dist(mid, c) <= 1.02 * self._dist(a, c):\n                        pts[k] = mid\n            k += 1\n        return pts",
          "objective": -30.8744,
          "time_improvement": 54.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1635.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020114612579345704,
                    "num_nodes_avg": 67.8,
                    "path_length_avg": 176.320099967031,
                    "smoothness_avg": 0.04753594664019434,
                    "success_improvement": 0.0,
                    "time_improvement": 18.469562393879325,
                    "node_improvement": 82.92621505917904,
                    "length_improvement": 3.356159237291925,
                    "smoothness_improvement": 644.0407908793593,
                    "objective_score": 10.774768214935749
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.032419776916503905,
                    "num_nodes_avg": 92.6,
                    "path_length_avg": 244.42961205974493,
                    "smoothness_avg": 0.10894580114299243,
                    "success_improvement": 0.0,
                    "time_improvement": 80.61616184654685,
                    "node_improvement": 93.77813612846873,
                    "length_improvement": 18.402359978168796,
                    "smoothness_improvement": 2703.2539338979577,
                    "objective_score": 48.74253421035512
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.019338107109069823,
                    "num_nodes_avg": 62.9,
                    "path_length_avg": 133.48562460693,
                    "smoothness_avg": 0.13037925881861506,
                    "success_improvement": 0.0,
                    "time_improvement": 61.689056074046825,
                    "node_improvement": 92.00254291163382,
                    "length_improvement": 11.345204038462418,
                    "smoothness_improvement": 1558.414548576955,
                    "objective_score": 33.105911988176274
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "DTH-RRT*: Dual-Tree Heuristic RRT*-Lite with adaptive informed sampling, grid-accelerated collision/nearest queries, local rewiring, progressive bidirectional connection, and curvature-aware smoothing. It balances growth between start- and goal-rooted trees, maintains the best path online, and refines it via shortcutting and angle relaxation for short, smooth trajectories.",
          "planning_mechanism": "Alternate expansion of the smaller tree toward guided samples (goal/corridor/informed ellipse after a solution). For each sample, steer a bounded step, choose the best parent among nearby nodes (local RRT*), validate node and edge, then insert. Attempt to connect to the opposite tree via a direct chord or a few progressive steps. Update the incumbent path when improved, stop after limited stagnation, and finalize with greedy shortcutting and angle-based smoothing.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=6.0,\n        goal_bias=0.15,\n        corridor_bias=0.45,\n        dup_ratio=0.6,\n        rewire_ratio=1.8,\n        connect_steps=3,\n        post_improve=250,\n        stagnation_limit=70,\n        shortcut_trials=60,\n        relax_rounds=2\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.dup_ratio = float(dup_ratio)\n        self.rewire_ratio = float(rewire_ratio)\n        self.connect_steps = int(connect_steps)\n        self.post_improve = int(post_improve)\n        self.stagnation_limit = int(stagnation_limit)\n        self.shortcut_trials = int(shortcut_trials)\n        self.relax_rounds = int(relax_rounds)\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        self.s = tuple(map.start)\n        self.g = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if (not self._in_bounds(self.s)) or (not self._in_bounds(self.g)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self.node_cell = max(1.0, self.step_size)\n        self.dup_radius = max(0.25, self.step_size * self.dup_ratio)\n        self.rewire_radius = max(self.step_size, self.step_size * self.rewire_ratio)\n\n        self._build_obs_grid()\n\n        if self._point_blocked(self.s) or self._point_blocked(self.g):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_clear(self.s, self.g):\n            a = Node(self.s, None, 0.0)\n            b = Node(self.g, a, self._dist(self.s, self.g))\n            a.add_child(b)\n            nodes.extend([a, b])\n            edges.append((a, b))\n            return PlannerResult(True, [self.s, self.g], nodes, edges)\n\n        root_a = Node(self.s, None, 0.0)\n        root_b = Node(self.g, None, 0.0)\n        nodes.extend([root_a, root_b])\n\n        tree_a, tree_b = [root_a], [root_b]\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, root_a)\n        self._grid_add(grid_b, root_b)\n\n        best_path = None\n        best_len = None\n        found_iter = None\n        stagnation = 0\n        dsg = self._dist(self.s, self.g)\n\n        for it in range(self.max_iter):\n            if len(tree_a) <= len(tree_b):\n                active, agrid, passive, pgrid, attract = tree_a, grid_a, tree_b, grid_b, self.g\n            else:\n                active, agrid, passive, pgrid, attract = tree_b, grid_b, tree_a, grid_a, self.s\n\n            q_rand = self._sample_guided(attract, best_len, dsg)\n            if q_rand is None:\n                stagnation += 1\n                if best_path is not None and (it - found_iter) > self.post_improve and stagnation > self.stagnation_limit:\n                    break\n                continue\n\n            q_near = self._nearest(agrid, q_rand)\n            if q_near is None:\n                stagnation += 1\n                continue\n\n            q_new_pos = self._steer(q_near.position, q_rand, self.step_size)\n            if (not self._in_bounds(q_new_pos)) or self._point_blocked(q_new_pos):\n                stagnation += 1\n                continue\n            if self._has_near_node(agrid, q_new_pos, self.dup_radius):\n                stagnation += 1\n                continue\n\n            parent = self._best_parent(agrid, q_near, q_new_pos, self.rewire_radius)\n            if parent is None:\n                stagnation += 1\n                continue\n\n            if self._point_blocked(q_new_pos):\n                stagnation += 1\n                continue\n            if not self._edge_clear(parent.position, q_new_pos):\n                stagnation += 1\n                continue\n\n            new_cost = parent.cost + self._dist(parent.position, q_new_pos)\n            q_new = Node(q_new_pos, parent, new_cost)\n            parent.add_child(q_new)\n            active.append(q_new)\n            nodes.append(q_new)\n            edges.append((parent, q_new))\n            self._grid_add(agrid, q_new)\n\n            self._rewire_neighbors(agrid, q_new, self.rewire_radius, edges)\n\n            meet = self._try_connect(passive, pgrid, q_new, nodes, edges)\n            improved = False\n            if meet is not None:\n                path = self._stitch(q_new, meet)\n                L = self._path_len(path)\n                if best_len is None or L + 1e-9 < best_len:\n                    best_len = L\n                    best_path = path\n                    improved = True\n                    if found_iter is None:\n                        found_iter = it\n\n            if improved:\n                stagnation = 0\n            else:\n                stagnation += 1\n\n            if best_path is not None and (it - found_iter) > self.post_improve and stagnation > self.stagnation_limit:\n                break\n\n        if best_path is None:\n            return PlannerResult(False, [], nodes, edges)\n\n        refined = self._refine(best_path)\n        return PlannerResult(True, refined, nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0\n        for v in self.s + self.g:\n            iv = int(v * 1000003) ^ 0x9E3779B9\n            s ^= (iv & 0xffffffff)\n            s = ((s << 13) ^ (s >> 7) ^ (s << 17)) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        if s == 0:\n            s = 0xA5A5A5A5\n        self._rng = s & 0xffffffff\n\n    def _rand01(self):\n        x = self._rng\n        x ^= (x << 13) & 0xffffffff\n        x ^= (x >> 17) & 0xffffffff\n        x ^= (x << 5) & 0xffffffff\n        self._rng = x & 0xffffffff\n        m = 4294967295.0\n        return (self._rng % 4294967295) / m\n\n    def _rr(self, a, b):\n        return a + (b - a) * self._rand01()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_pt(self, p):\n        q = []\n        for i in range(self.dims):\n            v = p[i]\n            if v < 0.0:\n                v = 0.0\n            elif v > self.bounds[i]:\n                v = self.bounds[i]\n            q.append(v)\n        return tuple(q)\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            return self._clamp_pt(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp_pt(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Node spatial grid\n    def _cell_key(self, p, cell):\n        if self.is3d:\n            return (int(p[0] // cell), int(p[1] // cell), int(p[2] // cell))\n        else:\n            return (int(p[0] // cell), int(p[1] // cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position, self.node_cell)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_fetch_ring(self, grid, pos, r_cells):\n        key = self._cell_key(pos, self.node_cell)\n        out = []\n        if self.is3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos):\n        best = None\n        bestd2 = 1e100\n        for r in range(0, 5):\n            cand = self._grid_fetch_ring(grid, pos, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            if best is not None and r >= 1:\n                break\n        if best is None:\n            # scan existing buckets\n            for b in grid.values():\n                for n in b:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd2:\n                        bestd2 = d2\n                        best = n\n        return best\n\n    def _neighbors_within(self, grid, pos, radius):\n        rc = int(radius // self.node_cell) + 1\n        r2 = radius * radius\n        cand = self._grid_fetch_ring(grid, pos, rc)\n        out = []\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                out.append(n)\n        return out\n\n    def _has_near_node(self, grid, pos, radius):\n        rc = int(radius // self.node_cell) + 1\n        r2 = radius * radius\n        cand = self._grid_fetch_ring(grid, pos, rc)\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                return True\n        return False\n\n    # Obstacles grid and collision\n    def _build_obs_grid(self):\n        self.og_cell = max(4.0, self.step_size * 1.5)\n        self.og = {}\n        if self.is3d:\n            for i, ob in enumerate(self.obstacles):\n                x, y, z, w, h, d = ob\n                cx0 = int((x if x > 0.0 else 0.0) // self.og_cell)\n                cy0 = int((y if y > 0.0 else 0.0) // self.og_cell)\n                cz0 = int((z if z > 0.0 else 0.0) // self.og_cell)\n                cx1 = int(((x + w) if (x + w) < self.bounds[0] else self.bounds[0]) // self.og_cell)\n                cy1 = int(((y + h) if (y + h) < self.bounds[1] else self.bounds[1]) // self.og_cell)\n                cz1 = int(((z + d) if (z + d) < self.bounds[2] else self.bounds[2]) // self.og_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            lst = self.og.get(k)\n                            if lst is None:\n                                self.og[k] = [i]\n                            else:\n                                lst.append(i)\n        else:\n            for i, ob in enumerate(self.obstacles):\n                x, y, w, h = ob\n                cx0 = int((x if x > 0.0 else 0.0) // self.og_cell)\n                cy0 = int((y if y > 0.0 else 0.0) // self.og_cell)\n                cx1 = int(((x + w) if (x + w) < self.bounds[0] else self.bounds[0]) // self.og_cell)\n                cy1 = int(((y + h) if (y + h) < self.bounds[1] else self.bounds[1]) // self.og_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        lst = self.og.get(k)\n                        if lst is None:\n                            self.og[k] = [i]\n                        else:\n                            lst.append(i)\n\n    def _point_blocked(self, p):\n        if self.is3d:\n            cx = int(p[0] // self.og_cell)\n            cy = int(p[1] // self.og_cell)\n            cz = int(p[2] // self.og_cell)\n            ids = self.og.get((cx, cy, cz))\n            if not ids:\n                return False\n            x, y, z = p\n            for i in ids:\n                ox, oy, oz, w, h, d = self.obstacles[i]\n                if (ox <= x <= ox + w) and (oy <= y <= oy + h) and (oz <= z <= oz + d):\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.og_cell)\n            cy = int(p[1] // self.og_cell)\n            ids = self.og.get((cx, cy))\n            if not ids:\n                return False\n            x, y = p\n            for i in ids:\n                ox, oy, w, h = self.obstacles[i]\n                if (ox <= x <= ox + w) and (oy <= y <= oy + h):\n                    return True\n            return False\n\n    def _edge_clear(self, a, b):\n        if self.is3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int((minx if minx > 0.0 else 0.0) // self.og_cell)\n            cy0 = int((miny if miny > 0.0 else 0.0) // self.og_cell)\n            cz0 = int((minz if minz > 0.0 else 0.0) // self.og_cell)\n            cx1 = int(((maxx if maxx < self.bounds[0] else self.bounds[0]) // self.og_cell))\n            cy1 = int(((maxy if maxy < self.bounds[1] else self.bounds[1]) // self.og_cell))\n            cz1 = int(((maxz if maxz < self.bounds[2] else self.bounds[2]) // self.og_cell))\n            cand = {}\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        ids = self.og.get((cx, cy, cz))\n                        if ids:\n                            for i in ids:\n                                cand[i] = 1\n            if not cand:\n                return True\n            for i in cand.keys():\n                ox, oy, oz, w, h, d = self.obstacles[i]\n                if self._seg_aabb(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int((minx if minx > 0.0 else 0.0) // self.og_cell)\n            cy0 = int((miny if miny > 0.0 else 0.0) // self.og_cell)\n            cx1 = int(((maxx if maxx < self.bounds[0] else self.bounds[0]) // self.og_cell))\n            cy1 = int(((maxy if maxy < self.bounds[1] else self.bounds[1]) // self.og_cell))\n            cand = {}\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    ids = self.og.get((cx, cy))\n                    if ids:\n                        for i in ids:\n                            cand[i] = 1\n            if not cand:\n                return True\n            for i in cand.keys():\n                ox, oy, w, h = self.obstacles[i]\n                if self._seg_aabb(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    def _seg_aabb(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(len(bmin)):\n            a = p0[i]\n            b = p1[i]\n            d = b - a\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if a < mn or a > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - a) * inv\n                t2 = (mx - a) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Parent selection (local RRT*)\n    def _best_parent(self, grid, near, new_pos, radius):\n        best = None\n        best_cost = 1e100\n        neigh = self._neighbors_within(grid, new_pos, radius)\n        if not neigh:\n            if self._edge_clear(near.position, new_pos):\n                return near\n            return None\n        for n in neigh:\n            if self._edge_clear(n.position, new_pos):\n                c = n.cost + self._dist(n.position, new_pos)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best = n\n        if best is None and self._edge_clear(near.position, new_pos):\n            return near\n        return best\n\n    def _rewire_neighbors(self, grid, q_new, radius, edges):\n        neigh = self._neighbors_within(grid, q_new.position, radius)\n        for n in neigh:\n            if n is q_new or n.parent is None:\n                continue\n            new_c = q_new.cost + self._dist(q_new.position, n.position)\n            if new_c + 1e-9 < n.cost and self._edge_clear(q_new.position, n.position):\n                self._replace_parent(n, q_new, edges)\n                dc = new_c - n.cost\n                n.cost = new_c\n                self._propagate_cost(n, dc)\n\n    def _replace_parent(self, child, new_parent, edges):\n        old = child.parent\n        if old is new_parent:\n            return\n        if old is not None:\n            # remove child from old\n            ch = []\n            for c in old.children:\n                if c is not child:\n                    ch.append(c)\n            old.children = ch\n        new_parent.add_child(child)\n        # update edges list: remove (old, child), add (new_parent, child)\n        idx = -1\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is old and e[1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n        edges.append((new_parent, child))\n\n    def _propagate_cost(self, node, delta):\n        for c in node.children:\n            c.cost += delta\n            self._propagate_cost(c, delta)\n\n    # Connection\n    def _try_connect(self, passive, pgrid, q_new, nodes, edges):\n        if not passive:\n            return None\n        near = self._nearest(pgrid, q_new.position)\n        if near is None:\n            return None\n        if self._edge_clear(near.position, q_new.position):\n            return near\n        cur = near\n        for _ in range(self.connect_steps):\n            nxt_pos = self._steer(cur.position, q_new.position, self.step_size)\n            if (not self._in_bounds(nxt_pos)) or self._point_blocked(nxt_pos):\n                return None\n            if self._has_near_node(pgrid, nxt_pos, self.dup_radius):\n                return None\n            if not self._edge_clear(cur.position, nxt_pos):\n                return None\n            new_cost = cur.cost + self._dist(cur.position, nxt_pos)\n            nxt = Node(nxt_pos, cur, new_cost)\n            cur.add_child(nxt)\n            passive.append(nxt)\n            nodes.append(nxt)\n            edges.append((cur, nxt))\n            self._grid_add(pgrid, nxt)\n            if self._edge_clear(nxt.position, q_new.position):\n                return nxt\n            cur = nxt\n        return None\n\n    # Sampling\n    def _sample_guided(self, attract, incumbent_len, dsg):\n        r = self._rand01()\n        if incumbent_len is not None and r < 0.4:\n            p = self._ellipse_sample(self.s, self.g, incumbent_len * 1.02)\n            if p is not None:\n                return p\n        r2 = self._rand01()\n        if r2 < self.goal_bias:\n            p = attract\n            return p\n        elif r2 < self.goal_bias + self.corridor_bias:\n            return self._corridor_band_sample(dsg)\n        else:\n            p = tuple(self._rr(0.0, self.bounds[i]) for i in range(self.dims))\n            if self._in_bounds(p) and not self._point_blocked(p):\n                return p\n        return None\n\n    def _corridor_band_sample(self, dsg):\n        t = self._rand01()\n        base = tuple(self.s[i] + t * (self.g[i] - self.s[i]) for i in range(self.dims))\n        width = max(self.step_size, 0.08 * dsg)\n        if self.is3d:\n            dx = self._rr(-width, width)\n            dy = self._rr(-width, width)\n            dz = self._rr(-width, width)\n            p = (self._clip(base[0] + dx, 0.0, self.bounds[0]),\n                 self._clip(base[1] + dy, 0.0, self.bounds[1]),\n                 self._clip(base[2] + dz, 0.0, self.bounds[2]))\n        else:\n            dx = self._rr(-width, width)\n            dy = self._rr(-width, width)\n            p = (self._clip(base[0] + dx, 0.0, self.bounds[0]),\n                 self._clip(base[1] + dy, 0.0, self.bounds[1]))\n        if not self._point_blocked(p):\n            return p\n        return None\n\n    def _clip(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [max(self.step_size, half) for _ in range(self.dims)]\n        for _ in range(10):\n            if self.is3d:\n                p = (self._clip(c[0] + self._rr(-ext[0], ext[0]), 0.0, self.bounds[0]),\n                     self._clip(c[1] + self._rr(-ext[1], ext[1]), 0.0, self.bounds[1]),\n                     self._clip(c[2] + self._rr(-ext[2], ext[2]), 0.0, self.bounds[2]))\n            else:\n                p = (self._clip(c[0] + self._rr(-ext[0], ext[0]), 0.0, self.bounds[0]),\n                     self._clip(c[1] + self._rr(-ext[1], ext[1]), 0.0, self.bounds[1]))\n            if self._in_bounds(p) and (self._dist(p, f1) + self._dist(p, f2) <= max_sum) and not self._point_blocked(p):\n                return p\n        return None\n\n    # Path utilities\n    def _path_to_root(self, n):\n        pts = []\n        cur = n\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _stitch(self, a, b):\n        pa = self._path_to_root(a)\n        pb = self._path_to_root(b)\n        rb = list(reversed(pb))\n        if pa and rb and pa[-1] == rb[0]:\n            rb = rb[1:]\n        return pa + rb\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # Refinement\n    def _refine(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = self._prune_collinear(path)\n        pts = self._shortcut_greedy(pts)\n        pts = self._shortcut_random(pts, self.shortcut_trials)\n        pts = self._angle_relax(pts, self.relax_rounds)\n        pts = self._shortcut_greedy(pts)\n        return pts\n\n    def _prune_collinear(self, path):\n        if len(path) < 3:\n            return path[:]\n        out = [path[0]]\n        for i in range(1, len(path) - 1):\n            A = out[-1]\n            B = path[i]\n            C = path[i + 1]\n            if self._edge_clear(A, C):\n                continue\n            out.append(B)\n        out.append(path[-1])\n        return out\n\n    def _shortcut_greedy(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        i = 0\n        while i < len(pts) - 2:\n            j = len(pts) - 1\n            shortened = False\n            while j > i + 1:\n                if self._edge_clear(pts[i], pts[j]):\n                    del pts[i + 1:j]\n                    shortened = True\n                    break\n                j -= 1\n            if not shortened:\n                i += 1\n        return pts\n\n    def _shortcut_random(self, path, trials):\n        pts = path[:]\n        t = 0\n        while t < trials and len(pts) > 2:\n            i = int(self._rr(0, max(1, len(pts) - 2)))\n            j = int(self._rr(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                t += 1\n                continue\n            if self._edge_clear(pts[i], pts[j]):\n                pts = pts[:i + 1] + pts[j:]\n            t += 1\n        return pts\n\n    def _angle_relax(self, path, rounds):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        for _ in range(max(0, rounds)):\n            for i in range(1, len(pts) - 1):\n                A = pts[i - 1]\n                B = pts[i]\n                C = pts[i + 1]\n                q = tuple(0.5 * (A[k] + C[k]) for k in range(self.dims))\n                if self._in_bounds(q) and (not self._point_blocked(q)):\n                    if self._edge_clear(A, q) and self._edge_clear(q, C):\n                        pts[i] = q\n        return pts",
          "objective": -30.78193,
          "time_improvement": 43.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1359.0,
          "node_improvement": 78.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020270347595214844,
                    "num_nodes_avg": 140.0,
                    "path_length_avg": 156.71960834915916,
                    "smoothness_avg": 0.047043782257835294,
                    "success_improvement": 0.0,
                    "time_improvement": 17.838322595234384,
                    "node_improvement": 64.74439687736087,
                    "length_improvement": 14.099499282712719,
                    "smoothness_improvement": 636.337349543378,
                    "objective_score": 16.992883095914834
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.059923958778381345,
                    "num_nodes_avg": 188.0,
                    "path_length_avg": 227.42756281802275,
                    "smoothness_avg": 0.08667560593433135,
                    "success_improvement": 0.0,
                    "time_improvement": 64.17136609342214,
                    "node_improvement": 87.36813814419135,
                    "length_improvement": 24.078133391908842,
                    "smoothness_improvement": 2130.225770605864,
                    "objective_score": 44.34941871620127
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0261333703994751,
                    "num_nodes_avg": 132.0,
                    "path_length_avg": 125.52222401628119,
                    "smoothness_avg": 0.11092749625816936,
                    "success_improvement": 0.0,
                    "time_improvement": 48.22688268693671,
                    "node_improvement": 83.21678321678321,
                    "length_improvement": 16.6341155343847,
                    "smoothness_improvement": 1310.9895645878464,
                    "objective_score": 31.003481949651068
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "LYNX-IQ-BiTree: A fast, informed, bi-directional planner that blends adaptive beam expansion, soft per-cell throttling, cached collision checks, obstacle-gridded edge testing, micro-rewiring with decaying radius, and on-the-fly visibility compression. It favors smooth attachments via a small turn-penalty in parent selection, performs bounded lazy connect, and finalizes with visibility pruning plus shortcutting for short, smooth paths.",
          "planning_mechanism": "Alternate growing two trees from start and goal. Each iteration samples a small beam with informed-biased points, steers from hashed-nearest anchors, selects a parent minimizing g(parent)+d+\u03bb\u00b7h plus a turn penalty, validates node and edge, inserts, compresses to visible ancestors, and micro-rewires neighbors within a decaying radius. It attempts a direct or short-step connect to the opposite tree (also strictly validated). On a bridge, it extracts, visibility-prunes, shortcuts, and returns. Spatial hashing, an obstacle grid, and an LRU-like edge cache accelerate checks; soft per-cell caps reduce redundancy without blocking good costs.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3500,\n        step_size=8.0,\n        goal_bias=0.18,\n        informed_bias=0.55,\n        beam_width=3,\n        grid_cell_factor=1.1,\n        dupe_radius_ratio=0.35,\n        per_cell_cap=7,\n        rewire_radius_factor=2.2,\n        neighbor_cap=20,\n        compress_depth=3,\n        connect_steps=4,\n        edge_cache_capacity=30000,\n        edge_cache_quant=0.9,\n        smoothing_iters=60,\n        no_improve_stop=14\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.beam_width = int(beam_width)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.per_cell_cap = int(per_cell_cap)\n        self.rewire_radius_factor = float(rewire_radius_factor)\n        self.neighbor_cap = int(neighbor_cap)\n        self.compress_depth = int(compress_depth)\n        self.connect_steps = int(connect_steps)\n        self.edge_cache_capacity = int(edge_cache_capacity)\n        self.edge_cache_quant = float(edge_cache_quant)\n        self.smoothing_iters = int(smoothing_iters)\n        self.no_improve_stop = int(no_improve_stop)\n\n        self._rng = 1234567\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        # Bounds and endpoint validation\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_from_scene()\n        self._build_obstacle_grid()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Edge cache\n        self._tick = 0\n        self.ecache = {}\n        self._last_prune_size = 0\n        self.eq = max(0.3, self.edge_cache_quant)\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Parameters and structures\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n\n        nodes = []\n        edges = []\n\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        nodes.extend([root_a, root_b])\n\n        tree_a, tree_b = [root_a], [root_b]\n        grid_a, grid_b = {}, {}\n        anchors_a, anchors_b = [root_a], [root_b]\n        self._grid_insert(grid_a, root_a)\n        self._grid_insert(grid_b, root_b)\n\n        best_len = float('inf')\n        anchor_stride = 18\n        max_rings = 4\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            tree1 = tree_a if side_a else tree_b\n            tree2 = tree_b if side_a else tree_a\n            grid1 = grid_a if side_a else grid_b\n            grid2 = grid_b if side_a else grid_a\n            anchors1 = anchors_a if side_a else anchors_b\n            anchors2 = anchors_b if side_a else anchors_a\n            attractor = self.goal if side_a else self.start\n\n            progressed = False\n            local_beam = self.beam_width + (1 if (it % 50 == 0 and it > 0) else 0)\n\n            for _ in range(local_beam):\n                s = self._sample(attractor, best_len)\n                if s is None:\n                    continue\n\n                near = self._nearest_hashed(grid1, anchors1, s, max_rings)\n                if near is None:\n                    continue\n\n                new_pos = self._steer(near.position, s)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._point_in_obstacles(new_pos):\n                    continue\n                if self._has_nearby(grid1, new_pos, self.dupe_radius):\n                    continue\n\n                # Candidate parents within decaying radius\n                rewire_r = self._rewire_radius(len(nodes))\n                parents = self._candidate_parents(grid1, anchors1, new_pos, rewire_r, max(8, self.neighbor_cap))\n\n                # Heuristic term (computed once)\n                other_near = self._nearest_hashed(grid2, anchors2, new_pos, max_rings)\n                h_term = self._dist(new_pos, other_near.position if other_near else attractor)\n\n                best_parent, best_cost, best_score = None, float('inf'), float('inf')\n                lam = 0.12\n                kappa = 0.05\n                for p in parents:\n                    if not self._edge_free(p.position, new_pos):\n                        continue\n                    gc = p.cost + self._dist(p.position, new_pos)\n                    turn = self._turn_penalty(p, new_pos) * kappa\n                    f = gc + lam * h_term + turn\n                    if f < best_score - 1e-12:\n                        best_score = f\n                        best_parent = p\n                        best_cost = gc\n\n                if best_parent is None:\n                    continue\n\n                # Soft per-cell cap with cost admission\n                ckey = self._cell_of(new_pos)\n                bucket = grid1.get(ckey)\n                if bucket and len(bucket) >= self.per_cell_cap:\n                    best_bucket_cost = min(n.cost for n in bucket)\n                    if best_cost >= best_bucket_cost - 1e-9:\n                        continue\n\n                # Final pre-insert validity (both checks)\n                if self._point_in_obstacles(new_pos):\n                    continue\n                if not self._edge_free(best_parent.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos, best_parent, best_cost)\n                best_parent.add_child(new_node)\n                tree1.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                self._grid_insert(grid1, new_node)\n                if (len(tree1) % anchor_stride) == 0:\n                    anchors1.append(new_node)\n                progressed = True\n\n                # Visibility compression to ancestors (bounded)\n                self._compress_to_ancestors(new_node, edges, self.compress_depth)\n\n                # Micro-rewiring around new_node\n                self._rewire_neighbors(grid1, new_node, rewire_r, edges)\n\n                # Try to connect to opposite tree: direct to near or to its ancestors\n                joined = None\n                if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                    joined = other_near\n                else:\n                    # try a few ancestors of other_near for a straight bridge\n                    anc = other_near\n                    hops = 0\n                    while anc is not None and hops < 2 and joined is None:\n                        if self._edge_free(new_node.position, anc.position):\n                            joined = anc\n                            break\n                        anc = anc.parent\n                        hops += 1\n\n                if joined is not None:\n                    path = self._extract_path(new_node, joined, side_a)\n                    path = self._finalize_path(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n                # Bounded lazy connect growth on the other tree (no rewiring inside)\n                ok, q = self._lazy_connect(new_node, tree2, grid2, anchors2, nodes, edges)\n                if ok:\n                    path = self._extract_path(new_node, q, side_a)\n                    path = self._finalize_path(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n            if not progressed:\n                continue\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1103515245 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 13) * 2654435761\n        if s == 0:\n            s = 1234567\n        self._rng = s & 0x7fffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0x7fffffff\n        return self._rng / float(1 << 31)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry and bounds\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= self.step_size:\n            return self._clamp(b)\n        r = self.step_size / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Turn penalty (small)\n    def _turn_penalty(self, parent, new_pos):\n        if parent is None or parent.parent is None:\n            return 0.0\n        a = tuple(parent.position[i] - parent.parent.position[i] for i in range(self.dim))\n        b = tuple(new_pos[i] - parent.position[i] for i in range(self.dim))\n        na = 0.0\n        nb = 0.0\n        dot = 0.0\n        for i in range(self.dim):\n            dot += a[i] * b[i]\n            na += a[i] * a[i]\n            nb += b[i] * b[i]\n        if na <= 1e-12 or nb <= 1e-12:\n            return 0.0\n        na = na ** 0.5\n        nb = nb ** 0.5\n        c = dot / (na * nb)\n        if c > 1.0:\n            c = 1.0\n        if c < -1.0:\n            c = -1.0\n        return 1.0 - c  # 0 when straight, up to 2 for U-turn\n\n    # Obstacles and collisions\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.eq) for i in range(self.dim))\n        qb = tuple(int(b[i] / self.eq) for i in range(self.dim))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        if len(self.ecache) - self._last_prune_size > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self.ecache:\n            return\n        cutoff = self._tick - 3000\n        todel = []\n        for k, v in self.ecache.items():\n            if v[1] < cutoff:\n                todel.append(k)\n        if not todel:\n            i = 0\n            for k in list(self.ecache.keys()):\n                if (i % 3) == 0:\n                    todel.append(k)\n                i += 1\n        for k in todel:\n            if k in self.ecache:\n                del self.ecache[k]\n        self._last_prune_size = len(self.ecache)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Spatial hashing for nodes\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, anchors, pos, max_rings=4):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback to anchors then buckets\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        tries = 0\n        while tries < 24:\n            tries += 1\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p and self._in_bounds(p) and not self._point_in_obstacles(p):\n                    return p\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._in_bounds(p) and not self._point_in_obstacles(p):\n                    return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [half] * self.dim\n        for _ in range(16):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dim))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _candidate_parents(self, grid, anchors, pos, radius, cap):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        if not cand:\n            cand = anchors[:]\n        if len(cand) > cap:\n            # lightweight reservoir sampling\n            out = []\n            count = 0\n            for n in cand:\n                if len(out) < cap:\n                    out.append(n)\n                else:\n                    j = int(self._rand_range(0, count + 1))\n                    if j < cap:\n                        out[j] = n\n                count += 1\n            cand = out\n        return cand\n\n    # Compression and rewiring\n    def _compress_to_ancestors(self, node, edges, depth_limit):\n        depth = 0\n        while depth < depth_limit and node.parent is not None and node.parent.parent is not None:\n            gp = node.parent.parent\n            # Both checks before adding edge via reparent\n            if not self._point_in_obstacles(node.position) and not self._point_in_obstacles(gp.position) and self._edge_free(gp.position, node.position):\n                self._reparent(node, gp, edges)\n                depth += 1\n            else:\n                break\n\n    def _rewire_radius(self, n_nodes):\n        # Decays with tree size; maintains a minimum\n        return max(self.step_size * 1.4, self.rewire_radius_factor * self.step_size / (1.0 + 0.002 * max(0, n_nodes - 10)))\n\n    def _rewire_neighbors(self, grid, node, radius, edges):\n        key = self._cell_of(node.position)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        neigh = self._grid_ring_nodes(grid, key, r_cells)\n        changed = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if d > radius:\n                continue\n            new_cost = node.cost + d\n            if new_cost + 1e-9 < nb.cost:\n                # Both checks before adding the new edge\n                if not self._point_in_obstacles(nb.position) and not self._point_in_obstacles(node.position) and self._edge_free(node.position, nb.position):\n                    self._reparent(nb, node, edges)\n                    changed += 1\n                    if changed >= self.neighbor_cap:\n                        break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        # Guard both checks before committing new edge\n        if self._point_in_obstacles(child.position) or self._point_in_obstacles(new_parent.position):\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old_parent = child.parent\n        if old_parent is new_parent:\n            return\n        if old_parent is not None:\n            old_parent.remove_child(child)\n            self._edges_remove(edges, old_parent, child)\n        new_parent.add_child(child)\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        edges.append((new_parent, child))\n        self._propagate_costs(child)\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                old = ch.cost\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                if abs(ch.cost - old) > 1e-12:\n                    stack.append(ch)\n\n    # Lazy connect growth (strict checks, no rewiring inside)\n    def _lazy_connect(self, new_node, other_tree, other_grid, other_anchors, nodes, edges):\n        near = self._nearest_hashed(other_grid, other_anchors, new_node.position, 4)\n        if near is None:\n            return False, None\n        if self._edge_free(near.position, new_node.position):\n            return True, near\n        p = near\n        steps = 0\n        while steps < self.connect_steps:\n            step_pos = self._steer(p.position, new_node.position)\n            if not self._in_bounds(step_pos):\n                break\n            if self._point_in_obstacles(step_pos):\n                break\n            if self._has_nearby(other_grid, step_pos, self.dupe_radius):\n                break\n            if not self._edge_free(p.position, step_pos):\n                break\n            # Insert step node (both checks satisfied above)\n            q = Node(step_pos, p, p.cost + self._dist(p.position, step_pos))\n            p.add_child(q)\n            other_tree.append(q)\n            nodes.append(q)\n            edges.append((p, q))\n            self._grid_insert(other_grid, q)\n            if (len(other_tree) % 18) == 0:\n                other_anchors.append(q)\n            # Light compression (depth 1)\n            self._compress_to_ancestors(q, edges, 1)\n            if self._edge_free(q.position, new_node.position):\n                return True, q\n            p = q\n            steps += 1\n        return False, None\n\n    # Paths and finalization\n    def _path_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        return out[::-1]\n\n    def _extract_path(self, a_node, b_node, a_forward=True):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return (pa + pb[::-1]) if a_forward else (pb + pa[::-1])\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _finalize_path(self, path):\n        if not path:\n            return []\n        pruned = self._visibility_prune(path)\n        sm = self._shortcut(pruned)\n        return sm\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        pts = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(pts[-1], path[j]):\n                    pts.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pts.append(path[i + 1])\n                i += 1\n        return pts\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best_len = self._path_len(pts)\n        attempts = 0\n        no_imp = 0\n        while attempts < self.smoothing_iters:\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                attempts += 1\n                continue\n            a, b = pts[i], pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= best_len + 1e-12:\n                    pts = new_pts\n                    best_len = L\n                    no_imp = 0\n                else:\n                    no_imp += 1\n            else:\n                no_imp += 1\n            attempts += 1\n            if no_imp >= self.no_improve_stop:\n                break\n        return pts",
          "objective": -30.407,
          "time_improvement": 59.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 1313.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017756891250610352,
                    "num_nodes_avg": 68.0,
                    "path_length_avg": 190.96923812165352,
                    "smoothness_avg": 0.05722671624562914,
                    "success_improvement": 0.0,
                    "time_improvement": 28.02610000686129,
                    "node_improvement": 82.87584991186098,
                    "length_improvement": -4.67326551570544,
                    "smoothness_improvement": 795.7223790474305,
                    "objective_score": 9.582482587872278
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.050318670272827146,
                    "num_nodes_avg": 153.0,
                    "path_length_avg": 237.57662787878456,
                    "smoothness_avg": 0.08894269470272544,
                    "success_improvement": 0.0,
                    "time_improvement": 69.91438395219414,
                    "node_improvement": 89.71981455351744,
                    "length_improvement": 20.690083349986068,
                    "smoothness_improvement": 2188.5595975346805,
                    "objective_score": 44.331163183323284
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010895967483520508,
                    "num_nodes_avg": 48.0,
                    "path_length_avg": 127.96994568317714,
                    "smoothness_avg": 0.08298968114744198,
                    "success_improvement": 0.0,
                    "time_improvement": 78.41387489862537,
                    "node_improvement": 93.89701207883026,
                    "length_improvement": 15.008455351212966,
                    "smoothness_improvement": 955.622618534398,
                    "objective_score": 37.30734877298738
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SAGE-BiRRT Lite: a simplified, robust bidirectional planner with adaptive corridor sampling, lightweight LOS parent selection, and bounded edge-collision memoization. It grows two trees with grid-hashed nearest lookup, enforces strict node/edge safety, opportunistically rewires to visible ancestors for shorter segments, attempts single-step reciprocal connects, and finalizes with visibility compression plus a few shortcuts for smooth, short paths.",
          "planning_mechanism": "Mechanism: Alternate expanding start/goal trees. Sample via goal bias or ellipse corridor after a first path estimate; steer one step; require node- and edge-free checks; optionally re-parent to the cheapest line-of-sight ancestor within a short lookback; insert; try direct bridge to the other tree\u2019s nearest or add a one-step approach there; on connection, compress by visibility and shortcut using a bounded edge-cache to avoid repeated collision tests.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=8.0,\n        goal_bias=0.25,\n        grid_cell_factor=1.0,\n        min_sep_ratio=0.5,\n        los_lookback_depth=8,\n        edge_cache_capacity=16000,\n        edge_quant=4.0,\n        shortcut_attempts=80\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.min_sep_ratio = float(min_sep_ratio)\n        self.los_lookback_depth = int(los_lookback_depth)\n        self.edge_cache_capacity = int(edge_cache_capacity)\n        self.edge_quant = float(edge_quant)\n        self.shortcut_attempts = int(shortcut_attempts)\n\n    # ------------------------- Public API -------------------------\n    def plan(self, map):\n        # Setup\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if hasattr(map, \"obstacles\") else []\n\n        # Parameters derived\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step_size * self.min_sep_ratio)\n        self.edge_res = max(0.5, min(1.0, self.step_size * 0.5))\n\n        # RNG state\n        self._rng_state = 2463534242\n\n        # Edge cache (key -> (free_bool, tick))\n        self._ecache = {}\n        self._tick = 0\n\n        # Validate start/goal\n        if (not self._within_bounds(self.start)) or (not self._within_bounds(self.goal)):\n            return PlannerResult(False, [], [], [])\n        if self._in_obstacle(self.start) or self._in_obstacle(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early LOS\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._distance(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Trees and structures\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        incumbent_len = None  # activates ellipse corridor sampling once a path is found\n\n        for _ in range(self.max_iter):\n            for side in (0, 1):\n                active_tree = tree_a if side == 0 else tree_b\n                other_tree = tree_b if side == 0 else tree_a\n                active_grid = grid_a if side == 0 else grid_b\n                other_grid = grid_b if side == 0 else grid_a\n                attractor = self.goal if side == 0 else self.start\n\n                # Sample\n                sample = self._guided_sample(attractor, incumbent_len)\n                if sample is None:\n                    continue\n\n                # Nearest and steer\n                nearest = self._nearest_in_grid(active_grid, sample)\n                if nearest is None:\n                    continue\n                new_pos = self._steer(nearest.position, sample)\n\n                # Enforce bounds and node collision before any insertion\n                if not self._within_bounds(new_pos):\n                    continue\n                if self._in_obstacle(new_pos):\n                    continue\n\n                # Edge collision to nearest (both checks enforced before adding)\n                if not self._edge_free(nearest.position, new_pos):\n                    continue\n\n                # Duplicate suppression\n                if self._has_nearby(active_grid, new_pos, self.min_sep):\n                    continue\n\n                # LOS parent selection (short lookback)\n                parent = self._select_parent_los(nearest, new_pos)\n                # Ensure edge from chosen parent is free (and node is free already)\n                if not self._edge_free(parent.position, new_pos):\n                    continue\n\n                # Insert node\n                new_cost = parent.cost + self._distance(parent.position, new_pos)\n                new_node = Node(new_pos, parent=parent, cost=new_cost)\n                parent.add_child(new_node)\n                active_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((parent, new_node))\n                self._grid_insert(active_grid, new_node)\n\n                # Attempt direct bridge to nearest node in the other tree\n                other_near = self._nearest_in_grid(other_grid, new_node.position)\n                if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                    path = self._finalize_path(new_node, other_near)\n                    incumbent_len = self._path_length(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n                # Single-step reciprocal approach from other tree toward new_node\n                if other_near is not None:\n                    mid = self._steer(other_near.position, new_node.position)\n                    if self._within_bounds(mid) and (not self._in_obstacle(mid)) and (not self._has_nearby(other_grid, mid, self.min_sep)):\n                        if self._edge_free(other_near.position, mid):\n                            # Insert reciprocal node (both checks enforced)\n                            q_cost = other_near.cost + self._distance(other_near.position, mid)\n                            q = Node(mid, parent=other_near, cost=q_cost)\n                            other_near.add_child(q)\n                            other_tree.append(q)\n                            nodes.append(q)\n                            edges.append((other_near, q))\n                            self._grid_insert(other_grid, q)\n                            # Try to bridge now\n                            if self._edge_free(new_node.position, q.position):\n                                path = self._finalize_path(new_node, q)\n                                incumbent_len = self._path_length(path)\n                                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # ------------------------- Geometry -------------------------\n    def _distance(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b):\n        d = self._distance(a, b)\n        if d <= 1e-12:\n            return self._clamp(b)\n        if d <= self.step_size:\n            return self._clamp(b)\n        r = self.step_size / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # ------------------------- Obstacles -------------------------\n    def _in_obstacle(self, pos):\n        if self.is_3d:\n            px, py, pz = pos\n            for obs in self.obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in self.obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_hits_obstacle(self, a, b):\n        dist = self._distance(a, b)\n        steps = max(1, int(dist / self.edge_res))\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[k] + (b[k] - a[k]) * t for k in range(self.dims))\n            if self._in_obstacle(p):\n                return True\n        return False\n\n    # ------------------------- Edge cache -------------------------\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] // self.edge_quant) for i in range(self.dims))\n        qb = tuple(int(b[i] // self.edge_quant) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self._ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self._ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self._ecache[key] = (free, self._tick)\n        if len(self._ecache) > self.edge_cache_capacity:\n            self._prune_cache()\n        return free\n\n    def _prune_cache(self):\n        # Remove roughly oldest third\n        if not self._ecache:\n            return\n        # Compute a rough cutoff stamp\n        cutoff = self._tick - max(1000, self.edge_cache_capacity // 3)\n        to_del = []\n        for k, v in self._ecache.items():\n            if v[1] < cutoff:\n                to_del.append(k)\n        if not to_del:\n            # If nothing below cutoff, delete every 4th entry deterministically\n            i = 0\n            for k in list(self._ecache.keys()):\n                if i % 4 == 0:\n                    to_del.append(k)\n                i += 1\n        for k in to_del:\n            if k in self._ecache:\n                del self._ecache[k]\n\n    # ------------------------- Grid NN -------------------------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _nearest_in_grid(self, grid, pos, max_ring=4):\n        base = self._cell_of(pos)\n        best = None\n        best_d = 1e100\n        if self.is_3d:\n            for r in range(0, max_ring + 1):\n                found = False\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            bucket = grid.get((base[0] + dx, base[1] + dy, base[2] + dz))\n                            if bucket:\n                                for n in bucket:\n                                    d = self._distance(n.position, pos)\n                                    if d < best_d:\n                                        best_d = d\n                                        best = n\n                                        found = True\n                if found:\n                    return best\n        else:\n            for r in range(0, max_ring + 1):\n                found = False\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        bucket = grid.get((base[0] + dx, base[1] + dy))\n                        if bucket:\n                            for n in bucket:\n                                d = self._distance(n.position, pos)\n                                if d < best_d:\n                                    best_d = d\n                                    best = n\n                                    found = True\n                if found:\n                    return best\n        # Fallback: scan all buckets\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._distance(n.position, pos)\n                if d < best_d:\n                    best_d = d\n                    best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        r2 = radius * radius\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if bucket:\n                            for n in bucket:\n                                if self._sqdist(n.position, pos) <= r2:\n                                    return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if bucket:\n                        for n in bucket:\n                            if self._sqdist(n.position, pos) <= r2:\n                                return True\n        return False\n\n    def _sqdist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    # ------------------------- Parent selection -------------------------\n    def _select_parent_los(self, nearest, new_pos):\n        best = nearest\n        best_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        depth = 0\n        cur = nearest\n        while cur is not None and depth < self.los_lookback_depth:\n            if self._edge_free(cur.position, new_pos):\n                cand_cost = cur.cost + self._distance(cur.position, new_pos)\n                if cand_cost + 1e-9 < best_cost:\n                    best_cost = cand_cost\n                    best = cur\n            cur = cur.parent\n            depth += 1\n        return best\n\n    # ------------------------- Sampling -------------------------\n    def _guided_sample(self, attractor, incumbent_len):\n        # Try a bounded number of draws to avoid rejection loops\n        for _ in range(24):\n            if incumbent_len is not None and self._distance(self.start, self.goal) > 1e-9:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.05)\n                if p is None:\n                    continue\n            else:\n                if self._rand() < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            if self._within_bounds(p) and (not self._in_obstacle(p)):\n                return p\n        # Fallback to attractor if feasible\n        return attractor if self._within_bounds(attractor) and (not self._in_obstacle(attractor)) else None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        # Rejection sample inside bounding box of ellipse/spheroid\n        cx = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(12):\n            p = tuple(self._clamp(cx[i] + self._rand_range(-ext[i], ext[i])) for i in range(self.dims))\n            if (self._distance(p, f1) + self._distance(p, f2) <= max_sum) and (not self._in_obstacle(p)):\n                return p\n        return None\n\n    # ------------------------- Paths and smoothing -------------------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a, b):\n        pa = self._path_to_root(a)\n        pb = self._path_to_root(b)\n        # Join with a direct bridge assumed free by caller\n        if len(pb) >= 1 and len(pa) >= 1 and self._distance(pa[-1], pb[-1]) <= 1e-9:\n            # same meet point\n            return pa\n        return pa + pb[::-1]\n\n    def _visibility_compress(self, path):\n        if len(path) < 3:\n            return path[:]\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(path[i], path[j]):\n                    out.append(path[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(path[i + 1])\n                i += 1\n        if out[-1] != path[-1]:\n            out.append(path[-1])\n        # Deduplicate consecutive equals\n        dedup = [out[0]]\n        for k in range(1, len(out)):\n            if self._distance(dedup[-1], out[k]) > 1e-9:\n                dedup.append(out[k])\n        return dedup\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        attempts = 0\n        while attempts < self.shortcut_attempts and len(pts) > 2:\n            i = int(self._rand_range(0, max(1, len(pts) - 2)))\n            j = int(self._rand_range(i + 2, len(pts)))\n            if j <= i + 1 or j > len(pts) - 1:\n                attempts += 1\n                continue\n            if self._edge_free(pts[i], pts[j]):\n                del pts[i + 1:j]\n            attempts += 1\n        return pts\n\n    def _finalize_path(self, meet_a, meet_b):\n        raw = self._extract_path(meet_a, meet_b)\n        comp = self._visibility_compress(raw)\n        smooth = self._shortcut(comp)\n        return smooth\n\n    def _path_length(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._distance(path[i - 1], path[i])\n        return L\n\n    # ------------------------- RNG -------------------------\n    def _rand(self):\n        # LCG\n        self._rng_state = (1664525 * self._rng_state + 1013904223) % (1 << 32)\n        return self._rng_state / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()",
          "objective": -30.11927,
          "time_improvement": 58.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 1464.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016434693336486818,
                    "num_nodes_avg": 45.0,
                    "path_length_avg": 185.4900405369072,
                    "smoothness_avg": 0.05374477285348693,
                    "success_improvement": 0.0,
                    "time_improvement": 33.38535682153559,
                    "node_improvement": 88.66784185343742,
                    "length_improvement": -1.6700304960641665,
                    "smoothness_improvement": 741.2224037993084,
                    "objective_score": 12.719700767818718
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02386620044708252,
                    "num_nodes_avg": 104.0,
                    "path_length_avg": 252.71104470421105,
                    "smoothness_avg": 0.09575733855295683,
                    "success_improvement": 0.0,
                    "time_improvement": 85.7303593422133,
                    "node_improvement": 93.01216152657395,
                    "length_improvement": 15.637779393623996,
                    "smoothness_improvement": 2363.9052921907014,
                    "objective_score": 46.9213018997919
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022766900062561036,
                    "num_nodes_avg": 130.0,
                    "path_length_avg": 130.9499221792792,
                    "smoothness_avg": 0.10896870994727119,
                    "success_improvement": 0.0,
                    "time_improvement": 54.896235358243906,
                    "node_improvement": 83.47107438016529,
                    "length_improvement": 13.029296853733896,
                    "smoothness_improvement": 1286.0739472957875,
                    "objective_score": 30.716818456192446
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "SPRINT*: Speed-Prioritized Rewired Informed BiRRT with Grid and Bin Indexing. A bidirectional, cost-aware planner that grows two trees with goal/corridor bias, switches to informed ellipsoidal sampling after the first solution, selects best parents among k-nearest candidates, performs local rewiring with subtree cost updates, and attempts immediate bridging. Spatial hashing for nodes and obstacle binning accelerate nearest queries and exact segment-box checks. Early feasible paths are visibility-compressed and shortcut-smoothed, yielding shorter, smoother routes with less search.",
          "planning_mechanism": "Mechanism: Build obstacle bins and node grids; validate start/goal and early straight-line. Iterate alternating trees: sample (goal/corridor; then informed) within bounds, find nearest via grid rings, steer one step, verify node and edge, insert, then choose a lower-cost parent from k neighbors and rewire nearby nodes if beneficial (with collision-checked edges and cost propagation). Attempt a direct bridge to the opposite tree; on success, extract path without duplicating the meet, apply visibility compression and bounded shortcutting, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=7.0,\n                 goal_bias=0.25,\n                 corridor_bias=0.45,\n                 k_near=8,\n                 rewire_radius_scale=2.5,\n                 dupe_radius_ratio=0.35,\n                 min_sep_ratio=0.2,\n                 connect_steps=2,\n                 smoothing_shortcuts=18):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.k_near = k_near\n        self.rewire_radius_scale = rewire_radius_scale\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.min_sep_ratio = min_sep_ratio\n        self.connect_steps = connect_steps\n        self.smoothing_shortcuts = smoothing_shortcuts\n\n        self.dim = 2\n        self.bounds = None\n        self.start = None\n        self.goal = None\n\n        # Node grid (for nearest and neighbor queries)\n        self.grid_cell = None\n\n        # RNG\n        self._lcg_state = 987654321\n\n        # Obstacle bins\n        self._bins_cell = None\n        self._bins_n = None\n        self._bins = None\n        self._obstacles = None\n\n    # -------------- Planning --------------\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self._obstacles = list(map.obstacles)\n        is_3d = (self.dim == 3)\n\n        # Node grid cell decoupled from bins (stable resolution)\n        self.grid_cell = max(1.0, self.step_size)\n\n        # Build obstacle bins\n        self._build_bins()\n\n        # Validate bounds and collision-free endpoints\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obstacle(self.start) or self._point_in_obstacle(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight line\n        if not self._edge_blocked(self.start, self.goal):\n            s_node = Node(self.start, None, 0.0)\n            g_node = Node(self.goal, s_node, self._dist(self.start, self.goal))\n            s_node.add_child(g_node)\n            return PlannerResult(True, [self.start, self.goal], [s_node, g_node], [(s_node, g_node)])\n\n        # Initialize trees\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        dsg = self._dist(self.start, self.goal)\n        base_corridor = max(self.step_size, 0.2 * dsg)\n\n        best_path = None\n        c_best = float('inf')\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n\n            # Target sampling\n            r = self._rand()\n            if r < self.goal_bias:\n                target = self.goal if active_start else self.start\n            else:\n                if c_best < float('inf'):\n                    target = self._sample_informed(c_best)\n                    if target is None:\n                        # Informed sample failed after retries; fall back to corridor/uniform\n                        target = self._sample_corridor(base_corridor)\n                else:\n                    if r < self.goal_bias + self.corridor_bias:\n                        target = self._sample_corridor(base_corridor)\n                    else:\n                        target = self._sample_free()\n\n            # Nearest and steer\n            nearest = self._nearest_grid(grid_a, tree_a, target)\n            if nearest is None:\n                continue\n            new_pos = self._steer(nearest.position, target, self.step_size)\n\n            # Bounds and collision for node and edge\n            if not self._in_bounds(new_pos):\n                continue\n            if self._point_in_obstacle(new_pos):\n                continue\n            if self._dist(nearest.position, new_pos) < self.step_size * self.min_sep_ratio:\n                continue\n            if self._exists_close(grid_a, new_pos, self.step_size * self.dupe_radius_ratio):\n                continue\n            if self._edge_blocked(nearest.position, new_pos):\n                continue\n\n            # Insert node\n            new_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, new_node)\n\n            # Best-parent selection among k-near (cost-aware)\n            neighbors = self._k_nearest(grid_a, new_node.position, self.k_near,\n                                        self.rewire_radius_scale * self.step_size)\n            best_parent = nearest\n            best_cost = new_node.cost\n            for nb in neighbors:\n                if nb is new_node or nb is nearest:\n                    continue\n                # Candidate parent cost\n                seg_ok = (not self._edge_blocked(nb.position, new_node.position))\n                if not seg_ok:\n                    continue\n                cand_cost = nb.cost + self._dist(nb.position, new_node.position)\n                if cand_cost + 1e-9 < best_cost:\n                    best_parent = nb\n                    best_cost = cand_cost\n            if best_parent is not nearest:\n                # Reparent with collision-checked edge already validated\n                try:\n                    nearest.remove_child(new_node)\n                except:\n                    pass\n                # Update edges (remove old, add new)\n                self._remove_edge(edges, nearest, new_node)\n                best_parent.add_child(new_node)\n                new_node.cost = best_cost\n                edges.append((best_parent, new_node))\n\n            # Local rewiring: try to improve neighbors via new_node\n            for nb in neighbors:\n                if nb is new_node or nb is start_root or nb is goal_root:\n                    continue\n                # Check edge new_node -> nb\n                if self._edge_blocked(new_node.position, nb.position):\n                    continue\n                # Node collision check (existing node, should be free, but enforce contract)\n                if self._point_in_obstacle(nb.position):\n                    continue\n                cand = new_node.cost + self._dist(new_node.position, nb.position)\n                if cand + 1e-9 < nb.cost:\n                    old_parent = nb.parent\n                    if old_parent is not None:\n                        old_parent.remove_child(nb)\n                        self._remove_edge(edges, old_parent, nb)\n                    new_node.add_child(nb)\n                    delta = cand - nb.cost\n                    nb.cost = cand\n                    edges.append((new_node, nb))\n                    self._propagate_cost(nb, delta)\n\n            # Attempt direct bridge to other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            bridged = False\n            if other_near is not None and not self._edge_blocked(new_node.position, other_near.position):\n                path = self._merge_paths(new_node, other_near, active_start)\n                path = self._smooth_path(path)\n                clen = self._polyline_length(path)\n                if clen < c_best:\n                    best_path = path\n                    c_best = clen\n                return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n            # Short, bounded greedy connect (few steps) for robustness\n            p = other_near\n            steps = 0\n            while (not bridged) and (p is not None) and steps < self.connect_steps:\n                nxt = self._steer(p.position, new_node.position, self.step_size)\n                if not self._in_bounds(nxt):\n                    break\n                if self._point_in_obstacle(nxt):\n                    break\n                if self._dist(p.position, nxt) < self.step_size * self.min_sep_ratio:\n                    break\n                if self._edge_blocked(p.position, nxt):\n                    break\n                q = Node(nxt, parent=p, cost=p.cost + self._dist(p.position, nxt))\n                p.add_child(q)\n                tree_b.append(q)\n                edges.append((p, q))\n                self._grid_add(grid_b, q)\n                p = q\n                steps += 1\n                if not self._edge_blocked(new_node.position, p.position):\n                    path = self._merge_paths(new_node, p, active_start)\n                    path = self._smooth_path(path)\n                    clen = self._polyline_length(path)\n                    if clen < c_best:\n                        best_path = path\n                        c_best = clen\n                    return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        # If loop ends without success, return failure or best known (if any)\n        if best_path is not None:\n            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # -------------- RNG --------------\n    def _rand(self):\n        self._lcg_state = (1103515245 * self._lcg_state + 12345) % (1 << 31)\n        return (self._lcg_state & 0x7fffffff) / float(1 << 31)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # -------------- Geometry --------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _polyline_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(pts)):\n            total += self._dist(pts[i - 1], pts[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # -------------- Obstacle bins --------------\n    def _build_bins(self):\n        # Choose bin resolution based on map size and step size (not obstacle count)\n        max_axis = 1.0\n        for i in range(self.dim):\n            if self.bounds[i] > max_axis:\n                max_axis = self.bounds[i]\n        target_bins = int(max_axis / max(1.0, self.step_size * 2.0)) + 1\n        target_bins = max(8, min(48, target_bins))\n        if self.dim == 2:\n            cx = max(self.bounds[0] / target_bins, 1.0)\n            cy = max(self.bounds[1] / target_bins, 1.0)\n            nx = max(int(self.bounds[0] / cx), 1)\n            ny = max(int(self.bounds[1] / cy), 1)\n            self._bins_cell = (cx, cy)\n            self._bins_n = (nx, ny)\n            self._bins = {}\n            for obs in self._obstacles:\n                x, y, w, h = obs\n                i0 = int(x / cx)\n                j0 = int(y / cy)\n                i1 = int((x + w) / cx)\n                j1 = int((y + h) / cy)\n                if i0 < 0: i0 = 0\n                if j0 < 0: j0 = 0\n                if i1 >= nx: i1 = nx - 1\n                if j1 >= ny: j1 = ny - 1\n                for i in range(i0, i1 + 1):\n                    for j in range(j0, j1 + 1):\n                        key = (i, j)\n                        bucket = self._bins.get(key)\n                        if bucket is None:\n                            self._bins[key] = [obs]\n                        else:\n                            bucket.append(obs)\n        else:\n            cx = max(self.bounds[0] / target_bins, 1.0)\n            cy = max(self.bounds[1] / target_bins, 1.0)\n            cz = max(self.bounds[2] / target_bins, 1.0)\n            nx = max(int(self.bounds[0] / cx), 1)\n            ny = max(int(self.bounds[1] / cy), 1)\n            nz = max(int(self.bounds[2] / cz), 1)\n            self._bins_cell = (cx, cy, cz)\n            self._bins_n = (nx, ny, nz)\n            self._bins = {}\n            for obs in self._obstacles:\n                x, y, z, w, h, d = obs\n                i0 = int(x / cx)\n                j0 = int(y / cy)\n                k0 = int(z / cz)\n                i1 = int((x + w) / cx)\n                j1 = int((y + h) / cy)\n                k1 = int((z + d) / cz)\n                if i0 < 0: i0 = 0\n                if j0 < 0: j0 = 0\n                if k0 < 0: k0 = 0\n                if i1 >= nx: i1 = nx - 1\n                if j1 >= ny: j1 = ny - 1\n                if k1 >= nz: k1 = nz - 1\n                for i in range(i0, i1 + 1):\n                    for j in range(j0, j1 + 1):\n                        for k in range(k0, k1 + 1):\n                            key = (i, j, k)\n                            bucket = self._bins.get(key)\n                            if bucket is None:\n                                self._bins[key] = [obs]\n                            else:\n                                bucket.append(obs)\n\n    def _bin_key(self, pos):\n        if self.dim == 2:\n            cx, cy = self._bins_cell\n            nx, ny = self._bins_n\n            i = int(pos[0] / cx)\n            j = int(pos[1] / cy)\n            if i < 0: i = 0\n            if j < 0: j = 0\n            if i >= nx: i = nx - 1\n            if j >= ny: j = ny - 1\n            return (i, j)\n        else:\n            cx, cy, cz = self._bins_cell\n            nx, ny, nz = self._bins_n\n            i = int(pos[0] / cx)\n            j = int(pos[1] / cy)\n            k = int(pos[2] / cz)\n            if i < 0: i = 0\n            if j < 0: j = 0\n            if k < 0: k = 0\n            if i >= nx: i = nx - 1\n            if j >= ny: j = ny - 1\n            if k >= nz: k = nz - 1\n            return (i, j, k)\n\n    def _bin_keys_for_bbox(self, bmin, bmax):\n        if self.dim == 2:\n            cx, cy = self._bins_cell\n            nx, ny = self._bins_n\n            i0 = int(bmin[0] / cx)\n            j0 = int(bmin[1] / cy)\n            i1 = int(bmax[0] / cx)\n            j1 = int(bmax[1] / cy)\n            if i0 < 0: i0 = 0\n            if j0 < 0: j0 = 0\n            if i1 >= nx: i1 = nx - 1\n            if j1 >= ny: j1 = ny - 1\n            for i in range(i0, i1 + 1):\n                for j in range(j0, j1 + 1):\n                    yield (i, j)\n        else:\n            cx, cy, cz = self._bins_cell\n            nx, ny, nz = self._bins_n\n            i0 = int(bmin[0] / cx)\n            j0 = int(bmin[1] / cy)\n            k0 = int(bmin[2] / cz)\n            i1 = int(bmax[0] / cx)\n            j1 = int(bmax[1] / cy)\n            k1 = int(bmax[2] / cz)\n            if i0 < 0: i0 = 0\n            if j0 < 0: j0 = 0\n            if k0 < 0: k0 = 0\n            if i1 >= nx: i1 = nx - 1\n            if j1 >= ny: j1 = ny - 1\n            if k1 >= nz: k1 = nz - 1\n            for i in range(i0, i1 + 1):\n                for j in range(j0, j1 + 1):\n                    for k in range(k0, k1 + 1):\n                        yield (i, j, k)\n\n    def _point_in_obstacle(self, pos):\n        bucket = self._bins.get(self._bin_key(pos))\n        if not bucket:\n            return False\n        if self.dim == 2:\n            px, py = pos\n            for obs in bucket:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        else:\n            px, py, pz = pos\n            for obs in bucket:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        return False\n\n    def _edge_blocked(self, a, b):\n        if self.dim == 2:\n            bmin = (min(a[0], b[0]), min(a[1], b[1]))\n            bmax = (max(a[0], b[0]), max(a[1], b[1]))\n        else:\n            bmin = (min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2]))\n            bmax = (max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2]))\n        seen = {}\n        for key in self._bin_keys_for_bbox(bmin, bmax):\n            bucket = self._bins.get(key)\n            if not bucket:\n                continue\n            for obs in bucket:\n                oid = id(obs)\n                if seen.get(oid) is not None:\n                    continue\n                seen[oid] = True\n                if self._segment_intersects_box(a, b, obs):\n                    return True\n        return False\n\n    def _segment_intersects_box(self, a, b, obs):\n        # Liang-Barsky segment vs AABB\n        t0 = 0.0\n        t1 = 1.0\n        if self.dim == 2:\n            x, y, w, h = obs\n            bmin = (x, y)\n            bmax = (x + w, y + h)\n            for i in range(2):\n                p0 = a[i]\n                p1 = b[i]\n                d = p1 - p0\n                lo = bmin[i]\n                hi = bmax[i]\n                if abs(d) < 1e-12:\n                    if p0 < lo or p0 > hi:\n                        return False\n                else:\n                    inv = 1.0 / d\n                    tA = (lo - p0) * inv\n                    tB = (hi - p0) * inv\n                    if tA > tB:\n                        tA, tB = tB, tA\n                    if tA > t0:\n                        t0 = tA\n                    if tB < t1:\n                        t1 = tB\n                    if t0 > t1:\n                        return False\n            return True\n        else:\n            x, y, z, w, h, dlen = obs\n            bmin = (x, y, z)\n            bmax = (x + w, y + h, z + dlen)\n            for i in range(3):\n                p0 = a[i]\n                p1 = b[i]\n                d = p1 - p0\n                lo = bmin[i]\n                hi = bmax[i]\n                if abs(d) < 1e-12:\n                    if p0 < lo or p0 > hi:\n                        return False\n                else:\n                    inv = 1.0 / d\n                    tA = (lo - p0) * inv\n                    tB = (hi - p0) * inv\n                    if tA > tB:\n                        tA, tB = tB, tA\n                    if tA > t0:\n                        t0 = tA\n                    if tB < t1:\n                        t1 = tB\n                    if t0 > t1:\n                        return False\n            return True\n\n    # -------------- Sampling --------------\n    def _sample_free(self):\n        # Try several times to avoid obstacles\n        for _ in range(64):\n            if self.dim == 2:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            if not self._point_in_obstacle(p):\n                return p\n        # fallback to midpoint clamp\n        mid = tuple((self.start[i] + self.goal[i]) * 0.5 for i in range(self.dim))\n        return self._clamp(mid)\n\n    def _sample_corridor(self, width):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 2:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        if not self._point_in_obstacle(p):\n            return p\n        return self._sample_free()\n\n    def _sample_informed(self, c_best):\n        # Prolate hyperspheroid: foci at start and goal, major axis = c_best\n        c_min = self._dist(self.start, self.goal)\n        if c_best < c_min + 1e-9:\n            return None\n        a = c_best * 0.5\n        f = c_min * 0.5\n        b2 = a * a - f * f\n        if b2 <= 0.0:\n            return None\n        # Build orthonormal basis\n        dir_vec = tuple(self.goal[i] - self.start[i] for i in range(self.dim))\n        dnorm = self._norm(dir_vec)\n        if dnorm < 1e-12:\n            return None\n        e1 = tuple(dir_vec[i] / dnorm for i in range(self.dim))\n        if self.dim == 2:\n            e2 = (-e1[1], e1[0])\n        else:\n            # Choose an arbitrary vector not parallel to e1\n            if abs(e1[0]) < 0.9:\n                v = (1.0, 0.0, 0.0)\n            else:\n                v = (0.0, 1.0, 0.0)\n            e2 = self._normalize(self._cross(e1, v))\n            e3 = self._cross(e1, e2)\n\n        center = tuple((self.start[i] + self.goal[i]) * 0.5 for i in range(self.dim))\n        # Sample within unit ball and scale\n        for _ in range(64):\n            u = self._sample_unit_ball()\n            if self.dim == 2:\n                scaled = (a * u[0], (b2 ** 0.5) * u[1])\n                p = (center[0] + scaled[0] * e1[0] + scaled[1] * e2[0],\n                     center[1] + scaled[0] * e1[1] + scaled[1] * e2[1])\n            else:\n                b = b2 ** 0.5\n                scaled = (a * u[0], b * u[1], b * u[2])\n                p = (center[0] + scaled[0] * e1[0] + scaled[1] * e2[0] + scaled[2] * e3[0],\n                     center[1] + scaled[0] * e1[1] + scaled[1] * e2[1] + scaled[2] * e3[1],\n                     center[2] + scaled[0] * e1[2] + scaled[1] * e2[2] + scaled[2] * e3[2])\n            p = self._clamp(p)\n            if not self._point_in_obstacle(p):\n                return p\n        return None\n\n    def _sample_unit_ball(self):\n        # Rejection sampling in unit ball\n        for _ in range(64):\n            if self.dim == 2:\n                x = self._uniform(-1.0, 1.0)\n                y = self._uniform(-1.0, 1.0)\n                if x * x + y * y <= 1.0:\n                    return (x, y)\n            else:\n                x = self._uniform(-1.0, 1.0)\n                y = self._uniform(-1.0, 1.0)\n                z = self._uniform(-1.0, 1.0)\n                if x * x + y * y + z * z <= 1.0:\n                    return (x, y, z)\n        if self.dim == 2:\n            return (0.0, 0.0)\n        return (0.0, 0.0, 0.0)\n\n    def _norm(self, v):\n        s = 0.0\n        for i in range(self.dim):\n            s += v[i] * v[i]\n        return s ** 0.5\n\n    def _cross(self, a, b):\n        # 3D cross; if 2D is used, this won't be called\n        return (a[1] * b[2] - a[2] * b[1],\n                a[2] * b[0] - a[0] * b[2],\n                a[0] * b[1] - a[1] * b[0])\n\n    def _normalize(self, v):\n        n = (v[0] * v[0] + v[1] * v[1] + v[2] * v[2]) ** 0.5\n        if n < 1e-12:\n            return (0.0, 0.0, 0.0)\n        return (v[0] / n, v[1] / n, v[2] / n)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # -------------- Node grid and neighbors --------------\n    def _grid_key(self, pos):\n        if self.dim == 2:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell))\n        else:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell), int(pos[2] // self.grid_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Expand rings up to a small radius; then fallback scan with early pruning\n        for r in range(0, 3):\n            cand = self._grid_collect_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback scan (rare)\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_collect_ring(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    def _k_nearest(self, grid, pos, k, max_radius):\n        # Approximate k-nearest using grid expansion, bounded radius\n        key = self._grid_key(pos)\n        result = []\n        r_cells = max(1, int(max_radius / self.grid_cell))\n        for r in range(0, r_cells + 1):\n            cand = self._grid_collect_ring(grid, key, r)\n            for n in cand:\n                result.append((self._dist(n.position, pos), n))\n            if len(result) >= k * 2:\n                break\n        if not result:\n            return []\n        # Partial selection without full sort\n        # Simple selection: pick k smallest by scan\n        selected = []\n        for _ in range(min(k, len(result))):\n            besti = 0\n            bestd = result[0][0]\n            for i in range(1, len(result)):\n                if result[i][0] < bestd:\n                    bestd = result[i][0]\n                    besti = i\n            selected.append(result[besti][1])\n            result[besti] = result[-1]\n            result.pop()\n        return selected\n\n    # -------------- Path utilities --------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_paths(self, a_node, b_node, a_is_start_tree):\n        # a_node in active tree, b_node in other tree; build start->goal path\n        if a_is_start_tree:\n            left = self._path_to_root(a_node)        # start -> a_node\n            right = self._path_to_root(b_node)       # goal -> b_node\n            right.reverse()                          # b_node -> goal\n            return left + right\n        else:\n            # Active is goal tree\n            left = self._path_to_root(b_node)        # start -> b_node\n            right = self._path_to_root(a_node)       # goal -> a_node\n            right.reverse()                          # a_node -> goal\n            return left + right\n\n    def _remove_edge(self, edges, parent, child):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is parent and e[1] is child:\n                edges[i] = edges[-1]\n                edges.pop()\n                return\n\n    def _propagate_cost(self, node, delta):\n        # Add delta to node and its subtree\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            # cur.cost already set for root of change; add delta to descendants\n            if cur is not node:\n                cur.cost += delta\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _smooth_path(self, path):\n        if not path or len(path) < 3:\n            return path\n        # Visibility compression\n        pts = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            found = False\n            while j > i + 1:\n                if not self._edge_blocked(path[i], path[j]):\n                    pts.append(path[j])\n                    i = j\n                    found = True\n                    break\n                j -= 1\n            if not found:\n                pts.append(path[i + 1])\n                i += 1\n        # Shortcutting\n        m = len(pts)\n        for _ in range(self.smoothing_shortcuts):\n            m = len(pts)\n            if m < 3:\n                break\n            i = int(self._uniform(0, m - 2))\n            j = int(self._uniform(i + 1, m - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j]):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -29.88626,
          "time_improvement": 47.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1440.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011824226379394532,
                    "num_nodes_avg": 72.2,
                    "path_length_avg": 167.21723063665553,
                    "smoothness_avg": 0.044050448870167,
                    "success_improvement": 0.0,
                    "time_improvement": 52.07293467557154,
                    "node_improvement": 81.81818181818183,
                    "length_improvement": 8.345586161465878,
                    "smoothness_improvement": 589.4851818988797,
                    "objective_score": 23.57665800904539
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03993680477142334,
                    "num_nodes_avg": 186.3,
                    "path_length_avg": 239.37036678493718,
                    "smoothness_avg": 0.0999380528335278,
                    "success_improvement": 0.0,
                    "time_improvement": 76.12171847915337,
                    "node_improvement": 87.48236242693007,
                    "length_improvement": 20.09128167320061,
                    "smoothness_improvement": 2471.478081876573,
                    "objective_score": 47.24867495704924
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.044220805168151855,
                    "num_nodes_avg": 191.7,
                    "path_length_avg": 128.45032976268826,
                    "smoothness_avg": 0.10694552630614515,
                    "success_improvement": 0.0,
                    "time_improvement": 12.393659958425188,
                    "node_improvement": 75.62619198982836,
                    "length_improvement": 14.68940711903338,
                    "smoothness_improvement": 1260.3392007165467,
                    "objective_score": 18.83343826253032
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "IBiHRRT*-Connect: Informed Bidirectional Hash RRT* Connect with cycle-safe rewiring, bounded parent search, and early visibility pruning. It accelerates planning via deduplicated ring-hash nearest neighbors, LOS-bounded parent/rewire radii, exact edge-collision memoization, and a direct/greedy bridge. After the first solution it visibility-prunes and shortcuts for length and smoothness; optional informed sampling focuses subsequent expansions inside the prolate hyperspheroid for faster, shorter improvements.",
          "planning_mechanism": "Alternate growing start/goal trees. Sample goal/informed-biased points (post-solution uses an exact ellipsoid aligned to start\u2013goal). Find a near node via ring-hash; steer one step; choose the lowest-cost LOS parent within a radius; insert only if node and edge are collision-free and grid gate admits; locally rewire cheaper LOS neighbors with ancestor-guarded cost propagation. Attempt to connect the opposite tree directly or via a few greedy steps. On connection, extract the path by parents, visibility-prune, and run shortcut smoothing, then return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=5.0,\n        goal_bias=0.18,\n        grid_cell_factor=2.0,\n        max_per_cell=7,\n        ring_max=3,\n        parent_radius_factor=2.2,\n        rewire_radius_factor=2.0,\n        connect_steps=4,\n        smoothing_iters=120,\n        post_solution_improve_iters=0\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.max_per_cell = max_per_cell\n        self.ring_max = ring_max\n        self.parent_radius_factor = parent_radius_factor\n        self.rewire_radius_factor = rewire_radius_factor\n        self.connect_steps = connect_steps\n        self.smoothing_iters = smoothing_iters\n        self.post_solution_improve_iters = post_solution_improve_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self._lcg_state = 123456789\n        self._edge_cache = {}\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Derived params\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.edge_res = max(0.5, min(1.0, self.step_size * 0.5))\n        parent_radius = max(self.step_size * self.parent_radius_factor, self.step_size + 1e-6)\n        rewire_radius = max(self.step_size * self.rewire_radius_factor, self.step_size + 1e-6)\n        self._edge_cache = {}\n        self._lcg_state = 123456789\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            path = [start, goal]\n            path = self._visibility_prune(path, obstacles, is_3d)\n            path = self._shortcut_smooth(path, obstacles, is_3d, min(60, self.smoothing_iters))\n            nodes = [Node(start), Node(goal)]\n            edges = [(nodes[0], nodes[1])]\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize trees and hashed grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        nodes = [start_root, goal_root]\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n        bestcost_start = {}\n        bestcost_goal = {}\n\n        self._grid_add(grid_start, counts_start, bestcost_start, start_root)\n        self._grid_add(grid_goal, counts_goal, bestcost_goal, goal_root)\n\n        # Informed sampling params\n        c_best = float('inf')\n        c_min = self._dist(start, goal)\n        have_solution = False\n        best_path_pts = []\n        best_end_nodes = (None, None)  # (a_last, b_last)\n\n        total_iters = self.max_iter\n\n        it = 0\n        while it < total_iters:\n            a_is_start = (it % 2 == 0)\n            tree_a = start_tree if a_is_start else goal_tree\n            tree_b = goal_tree if a_is_start else start_tree\n            grid_a = grid_start if a_is_start else grid_goal\n            grid_b = grid_goal if a_is_start else grid_start\n            counts_a = counts_start if a_is_start else counts_goal\n            bestcost_a = bestcost_start if a_is_start else bestcost_goal\n            attractor = goal if a_is_start else start\n\n            # Sample: informed ellipsoid if we have a solution, else mild goal bias\n            if have_solution:\n                x_rand = self._sample_informed(obstacles, is_3d, start, goal, c_best, c_min)\n            else:\n                x_rand = self._sample_biased(obstacles, is_3d, attractor)\n\n            # Nearest and steer\n            nearest = self._nearest_hashed(grid_a, tree_a, x_rand)\n            if nearest is None:\n                it += 1\n                continue\n            new_pos = self._steer(nearest.position, x_rand)\n            if (not self._in_bounds(new_pos)) or self._is_in_obstacle(new_pos, obstacles, is_3d):\n                it += 1\n                continue\n            if self._edge_blocked(nearest.position, new_pos, obstacles, is_3d):\n                it += 1\n                continue\n            if self._near_duplicate(grid_a, new_pos, self.step_size * 0.6):\n                it += 1\n                continue\n\n            # Choose parent among local LOS neighbors within bounded radius\n            parent = self._choose_parent_local(grid_a, new_pos, nearest, obstacles, is_3d, parent_radius)\n            if self._edge_blocked(parent.position, new_pos, obstacles, is_3d):\n                it += 1\n                continue\n\n            new_cost = parent.cost + self._dist(parent.position, new_pos)\n\n            # Grid admission gate\n            key_new = self._grid_key(new_pos)\n            ccount = counts_a.get(key_new, 0)\n            bestc = bestcost_a.get(key_new, float('inf'))\n            # Allow insertion if cell not full or cost improves best seen in cell\n            if ccount >= self.max_per_cell and not (new_cost + 1e-9 < bestc):\n                it += 1\n                continue\n\n            # Insert node\n            a_new = Node(new_pos, parent=parent, cost=new_cost)\n            parent.add_child(a_new)\n            tree_a.append(a_new)\n            nodes.append(a_new)\n            self._grid_add(grid_a, counts_a, bestcost_a, a_new)\n\n            # Local rewiring with ancestor guard\n            self._rewire_local(grid_a, a_new, obstacles, is_3d, rewire_radius)\n\n            # Try to bridge to other tree: direct or greedy connect\n            bridged = False\n            b_near = self._nearest_hashed(grid_b, tree_b, a_new.position)\n            if b_near is not None:\n                # Direct short bridge if feasible\n                if self._dist(b_near.position, a_new.position) <= self.step_size and not self._edge_blocked(b_near.position, a_new.position, obstacles, is_3d):\n                    # Choose better parent side for final short edge by cost\n                    # No need to alter tree structure; path extraction uses parents and the loose bridge\n                    path = self._extract_path_with_bridge(a_new, b_near, a_is_start)\n                    path = self._visibility_prune(path, obstacles, is_3d)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    plen = self._path_length(path)\n                    if plen + 1e-9 < c_best:\n                        c_best = plen\n                        have_solution = True\n                        best_path_pts = path\n                        best_end_nodes = (a_new, b_near) if a_is_start else (b_near, a_new)\n                        if self.post_solution_improve_iters <= 0:\n                            edges = self._collect_edges(nodes)\n                            return PlannerResult(True, best_path_pts, nodes, edges)\n                        total_iters = it + self.post_solution_improve_iters\n                    bridged = True\n\n            # Greedy connect steps from other tree toward a_new\n            if not bridged:\n                current_target = a_new.position\n                for _ in range(self.connect_steps):\n                    b_near = self._nearest_hashed(grid_b, tree_b, current_target)\n                    if b_near is None:\n                        break\n                    step_to = self._steer(b_near.position, current_target)\n                    if (not self._in_bounds(step_to)) or self._is_in_obstacle(step_to, obstacles, is_3d):\n                        break\n                    if self._edge_blocked(b_near.position, step_to, obstacles, is_3d):\n                        break\n                    # Select parent in other tree for the step\n                    b_parent = self._choose_parent_local(grid_b, step_to, b_near, obstacles, is_3d, parent_radius)\n                    if self._edge_blocked(b_parent.position, step_to, obstacles, is_3d):\n                        break\n                    b_new = Node(step_to, parent=b_parent, cost=b_parent.cost + self._dist(b_parent.position, step_to))\n                    b_parent.add_child(b_new)\n                    tree_b.append(b_new)\n                    nodes.append(b_new)\n                    self._grid_add(grid_b, counts_goal if a_is_start else counts_start, bestcost_goal if a_is_start else bestcost_start, b_new)\n                    self._rewire_local(grid_b, b_new, obstacles, is_3d, rewire_radius)\n\n                    # Final short bridge\n                    if self._dist(b_new.position, a_new.position) <= self.step_size and not self._edge_blocked(b_new.position, a_new.position, obstacles, is_3d):\n                        path = self._extract_path_with_bridge(a_new, b_new, a_is_start)\n                        path = self._visibility_prune(path, obstacles, is_3d)\n                        path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                        plen = self._path_length(path)\n                        if plen + 1e-9 < c_best:\n                            c_best = plen\n                            have_solution = True\n                            best_path_pts = path\n                            best_end_nodes = (a_new, b_new) if a_is_start else (b_new, a_new)\n                            if self.post_solution_improve_iters <= 0:\n                                edges = self._collect_edges(nodes)\n                                return PlannerResult(True, best_path_pts, nodes, edges)\n                            total_iters = it + self.post_solution_improve_iters\n                        break\n\n            it += 1\n\n        # Finalize\n        if have_solution:\n            edges = self._collect_edges(nodes)\n            return PlannerResult(True, best_path_pts, nodes, edges)\n        edges = self._collect_edges(nodes)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos):\n        d = self._dist(from_pos, to_pos)\n        if d <= 1e-9:\n            return self._clamp(from_pos)\n        if d <= self.step_size:\n            return self._clamp(to_pos)\n        r = self.step_size / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision and caching\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        hit = self._edge_cache.get(k)\n        if hit is not None:\n            return hit\n        blocked = self._segment_hits(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_hits(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Sampling\n    def _sample_biased(self, obstacles, is_3d, attractor):\n        if self._rand() < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        alpha = 0.25\n        if self.dim == 3:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]),\n                   self._uniform(0.0, self.bounds[2]))\n            p = (alpha * attractor[0] + (1.0 - alpha) * rnd[0],\n                 alpha * attractor[1] + (1.0 - alpha) * rnd[1],\n                 alpha * attractor[2] + (1.0 - alpha) * rnd[2])\n        else:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]))\n            p = (alpha * attractor[0] + (1.0 - alpha) * rnd[0],\n                 alpha * attractor[1] + (1.0 - alpha) * rnd[1])\n        if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        # Fallback uniform free sample\n        while True:\n            if self.dim == 3:\n                q = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                q = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(q) and not self._is_in_obstacle(q, obstacles, is_3d):\n                return q\n\n    def _sample_informed(self, obstacles, is_3d, start, goal, c_best, c_min):\n        # If no improvement possible, fallback\n        if not (c_best < float('inf')) or c_best <= c_min + 1e-9:\n            return self._sample_biased(obstacles, is_3d, goal)\n        # Center and unit major axis a_hat\n        center = tuple((start[i] + goal[i]) * 0.5 for i in range(self.dim))\n        a_vec = tuple(goal[i] - start[i] for i in range(self.dim))\n        a_norm = self._norm(a_vec)\n        if a_norm <= 1e-12:\n            return self._sample_biased(obstacles, is_3d, goal)\n        a_hat = tuple(a_vec[i] / a_norm for i in range(self.dim))\n        # Semi-axes\n        r1 = c_best * 0.5\n        if c_best <= c_min:\n            r2 = 0.0\n        else:\n            r2 = (c_best * c_best - c_min * c_min) ** 0.5 * 0.5\n        # Generate a uniform unit n-ball sample\n        for _ in range(50):\n            if self.dim == 3:\n                x = self._uniform(-1.0, 1.0)\n                y = self._uniform(-1.0, 1.0)\n                z = self._uniform(-1.0, 1.0)\n                r2sq = x * x + y * y + z * z\n                if r2sq > 1.0 or r2sq <= 1e-12:\n                    continue\n                # Scale to ellipsoid axes\n                # Build orthonormal basis [a_hat, v, w]\n                u = (1.0, 0.0, 0.0)\n                if abs(a_hat[0]) > 0.9:\n                    u = (0.0, 1.0, 0.0)\n                v = self._normalize(self._cross(a_hat, u))\n                if self._norm(v) <= 1e-12:\n                    v = (0.0, 0.0, 1.0)\n                w = self._cross(a_hat, v)\n                # Compose point\n                # Map unit ball sample to ellipsoid using radii [r1, r2, r2]\n                # First, a random direction on unit ball is (x,y,z) with |.|<=1; keep distribution via cube sampling\n                # Use as coordinates in basis\n                px = r1 * x\n                py = r2 * y\n                pz = r2 * z\n                ex = center[0] + px * a_hat[0] + py * v[0] + pz * w[0]\n                ey = center[1] + px * a_hat[1] + py * v[1] + pz * w[1]\n                ez = center[2] + px * a_hat[2] + py * v[2] + pz * w[2]\n                p = (ex, ey, ez)\n            else:\n                x = self._uniform(-1.0, 1.0)\n                y = self._uniform(-1.0, 1.0)\n                if x * x + y * y > 1.0:\n                    continue\n                # 2D orthonormal basis: a_hat and its perpendicular\n                perp = (-a_hat[1], a_hat[0])\n                px = r1 * x\n                py = r2 * y\n                ex = center[0] + px * a_hat[0] + py * perp[0]\n                ey = center[1] + px * a_hat[1] + py * perp[1]\n                p = (ex, ey)\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # Fallback\n        return self._sample_biased(obstacles, is_3d, goal)\n\n    def _norm(self, v):\n        s = 0.0\n        for i in range(len(v)):\n            s += v[i] * v[i]\n        return s ** 0.5\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n <= 1e-12:\n            if len(v) == 3:\n                return (1.0, 0.0, 0.0)\n            return (1.0, 0.0)\n        return tuple(v[i] / n for i in range(len(v)))\n\n    def _cross(self, a, b):\n        return (a[1] * b[2] - a[2] * b[1],\n                a[2] * b[0] - a[0] * b[2],\n                a[0] * b[1] - a[1] * b[0])\n\n    # Grid / NN\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, bestcost, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n        bc = bestcost.get(k)\n        if bc is None or node.cost < bc:\n            bestcost[k] = node.cost\n\n    def _ring_cells(self, key, r):\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        yield (key[0] + dx, key[1] + dy, key[2] + dz)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    yield (key[0] + dx, key[1] + dy)\n\n    def _grid_ring_collect_unique(self, grid, key, r):\n        cand = []\n        seen = set()\n        for cell in self._ring_cells(key, r):\n            bucket = grid.get(cell)\n            if bucket:\n                for n in bucket:\n                    nid = id(n)\n                    if nid not in seen:\n                        seen.add(nid)\n                        cand.append(n)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.ring_max + 1):\n            cand = self._grid_ring_collect_unique(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback random subset if grid sparse\n        if not tree:\n            return None\n        tries = min(64, len(tree))\n        for _ in range(tries):\n            idx = int(self._uniform(0, len(tree)))\n            n = tree[idx]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        cand = self._grid_ring_collect_unique(grid, key, 1)\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                return True\n        return False\n\n    # Parent selection among LOS neighbors with bounded radius\n    def _choose_parent_local(self, grid, new_pos, fallback_nearest, obstacles, is_3d, radius_bound):\n        key = self._grid_key(new_pos)\n        best_parent = fallback_nearest\n        best_cost = fallback_nearest.cost + self._dist(fallback_nearest.position, new_pos)\n        max_r = max(1, self.ring_max)\n        for r in range(0, max_r + 1):\n            cand = self._grid_ring_collect_unique(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                if n is fallback_nearest or n is best_parent:\n                    continue\n                dnp = self._dist(n.position, new_pos)\n                if dnp > radius_bound:\n                    continue\n                if self._edge_blocked(n.position, new_pos, obstacles, is_3d):\n                    continue\n                c = n.cost + dnp\n                if c + 1e-12 < best_cost:\n                    best_cost = c\n                    best_parent = n\n        return best_parent\n\n    # Local rewiring with ancestor guard\n    def _rewire_local(self, grid, pivot, obstacles, is_3d, radius):\n        key = self._grid_key(pivot.position)\n        for r in range(0, max(1, self.ring_max) + 1):\n            cand = self._grid_ring_collect_unique(grid, key, r)\n            if not cand:\n                continue\n            for nb in cand:\n                if nb is pivot or nb.parent is pivot:\n                    continue\n                if self._dist(nb.position, pivot.position) > radius:\n                    continue\n                if self._is_ancestor(nb, pivot):\n                    continue\n                if self._edge_blocked(pivot.position, nb.position, obstacles, is_3d):\n                    continue\n                new_cost = pivot.cost + self._dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    old_parent = nb.parent\n                    if old_parent is not None:\n                        try:\n                            old_parent.children.remove(nb)\n                        except Exception:\n                            pass\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    self._propagate_cost_from(nb)\n\n    def _is_ancestor(self, node, potential_child):\n        cur = potential_child\n        while cur is not None:\n            if cur is node:\n                return True\n            cur = cur.parent\n        return False\n\n    def _propagate_cost_from(self, node):\n        queue = [node]\n        qi = 0\n        while qi < len(queue):\n            cur = queue[qi]\n            qi += 1\n            for ch in cur.children:\n                new_c = cur.cost + self._dist(cur.position, ch.position)\n                if abs(new_c - ch.cost) > 1e-12:\n                    ch.cost = new_c\n                    queue.append(ch)\n\n    # Path utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path_with_bridge(self, a_node, b_node, a_is_start_tree):\n        path_a = self._path_to_root(a_node)\n        path_b = self._path_to_root(b_node)\n        if a_is_start_tree:\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        # Deterministic forward pass then random refinements\n        changed = True\n        passes = 0\n        while changed and passes < 3:\n            changed = False\n            i = 0\n            while i < len(pts) - 2:\n                a = pts[i]\n                k = len(pts) - 1\n                improved = False\n                while k > i + 1:\n                    b = pts[k]\n                    if not self._edge_blocked(a, b, obstacles, is_3d):\n                        mid_len = 0.0\n                        for t in range(i + 1, k + 1):\n                            mid_len += self._dist(pts[t - 1], pts[t])\n                        if self._dist(a, b) + 1e-9 < mid_len:\n                            pts = pts[:i + 1] + pts[k:]\n                            changed = True\n                            improved = True\n                            break\n                    k -= 1\n                if not improved:\n                    i += 1\n            passes += 1\n        # Random pair shortcuts\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts\n\n    def _collect_edges(self, nodes):\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        return edges",
          "objective": -29.84512,
          "time_improvement": 32.0,
          "length_improvement": 21.0,
          "smoothness_improvement": 1485.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01609337329864502,
                    "num_nodes_avg": 47.0,
                    "path_length_avg": 148.48852810021452,
                    "smoothness_avg": 0.041946328850586606,
                    "success_improvement": 0.0,
                    "time_improvement": 34.76882726816771,
                    "node_improvement": 88.16419038025687,
                    "length_improvement": 18.611084796972406,
                    "smoothness_improvement": 556.551134422692,
                    "objective_score": 24.38005473074722
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.15710897445678712,
                    "num_nodes_avg": 225.0,
                    "path_length_avg": 230.98780524572462,
                    "smoothness_avg": 0.11927323645742623,
                    "success_improvement": 0.0,
                    "time_improvement": 6.0642847367940815,
                    "node_improvement": 84.88208022576093,
                    "length_improvement": 22.889621993645612,
                    "smoothness_improvement": 2968.9862830893276,
                    "objective_score": 30.397990032672226
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022504901885986327,
                    "num_nodes_avg": 105.0,
                    "path_length_avg": 116.73701153822624,
                    "smoothness_avg": 0.08099784362284458,
                    "success_improvement": 0.0,
                    "time_improvement": 55.41528292555973,
                    "node_improvement": 86.6497139224412,
                    "length_improvement": 22.46883535544535,
                    "smoothness_improvement": 930.2865922436716,
                    "objective_score": 34.75731905215349
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "AURORA-BiRRT*: A*-guided, Unrolled-Rewire, Obstacle-Grid accelerated BiRRT with memoized edges and cell-pair sieve. It couples hashed nearest search, per-cell throttling, duplicate suppression, heuristic parent selection (g+h), bounded rewiring with full cost propagation, multi-step Connect, and quantized edge-collision caching; online LOS compression and cache-aware shortcutting yield smooth, short paths quickly.",
          "planning_mechanism": "Alternate tree growth with k-beam samples. Each beam selects a parent among local candidates minimizing g(parent)+d(parent,qn)+\u03bb\u00b7h(qn,other-tree), enforcing both node and edge validity before insertion. After insertion, LOS-compress to an ancestor, rewire neighbors if cheaper and propagate costs. A limited Connect grows the opposite tree unless a cached blocked cell-pair forbids it; direct edges terminate early. Once an incumbent exists, informed ellipse sampling narrows exploration; final shortcutting and LOS collapse return a concise path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=9.0,\n        collision_res=1.0,\n        beam_k=2,\n        goal_bias=0.2,\n        informed_bias=0.6,\n        grid_cell_factor=1.2,\n        per_cell_cap=6,\n        dupe_radius_ratio=0.45,\n        rewire_radius_factor=2.5,\n        neighbor_cap=24,\n        compress_depth=2,\n        connect_steps=3,\n        edge_cache_capacity=40000,\n        edge_cache_quant=0.8,\n        smoothing_iters=50,\n        no_improve_stop=12\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_res = collision_res\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.informed_bias = informed_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.per_cell_cap = per_cell_cap\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.rewire_radius_factor = rewire_radius_factor\n        self.neighbor_cap = neighbor_cap\n        self.compress_depth = compress_depth\n        self.connect_steps = connect_steps\n        self.edge_cache_capacity = edge_cache_capacity\n        self.edge_cache_quant = edge_cache_quant\n        self.smoothing_iters = smoothing_iters\n        self.no_improve_stop = no_improve_stop\n\n        self._rnd_state = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_from_scene()\n\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n\n        # Edge cache\n        self._tick = 0\n        self.ecache = {}\n        self._last_prune_size = 0\n        self.eq = max(0.25, self.edge_cache_quant)\n        # Collision stepping resolution for fallback sampling checks\n        self.edge_res = max(0.5, self.collision_res)\n\n        # Build obstacle grid\n        self._build_obstacle_grid()\n\n        # Validate endpoints\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        nodes = []\n        edges = []\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        throttles_a, throttles_b = {}, {}\n        anchors_a, anchors_b = [start_root], [goal_root]\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        best_path = None\n        best_len = float('inf')\n        sg = self._dist(self.start, self.goal)\n\n        blocked_pairs = set()\n        anchor_stride = 20\n        max_rings = 4\n\n        for it in range(self.max_iter):\n            side_start = (it % 2 == 0)\n            tree1 = tree_a if side_start else tree_b\n            grid1 = grid_a if side_start else grid_b\n            throttles1 = throttles_a if side_start else throttles_b\n            anchors1 = anchors_a if side_start else anchors_b\n\n            tree2 = tree_b if side_start else tree_a\n            grid2 = grid_b if side_start else grid_a\n            throttles2 = throttles_b if side_start else throttles_a\n            anchors2 = anchors_b if side_start else anchors_a\n\n            attractor = self.goal if side_start else self.start\n\n            progressed = False\n            for _ in range(self.beam_k):\n                sample = self._sample(attractor, best_len, sg)\n                if sample is None:\n                    continue\n                near = self._nearest_hashed(grid1, anchors1, sample, max_rings)\n                if near is None:\n                    continue\n                new_pos = self._steer(near.position, sample)\n                if not self._within_bounds(new_pos):\n                    continue\n                if self._point_in_obstacles(new_pos):\n                    continue\n                if self._has_nearby(grid1, new_pos, self.dupe_radius):\n                    continue\n\n                # Parent selection (A*-guided among local candidates)\n                rewire_r = self._rewire_radius(len(nodes))\n                parents = self._candidate_parents(grid1, anchors1, tree1, new_pos, rewire_r, self.neighbor_cap)\n                best_parent, best_new_cost = None, float('inf')\n                best_score = float('inf')\n                other_near = self._nearest_hashed(grid2, anchors2, new_pos, max_rings)\n                h_term = self._dist(new_pos, other_near.position if other_near else attractor)\n                lam = 0.1\n                for p in parents:\n                    if not self._edge_free(p.position, new_pos):\n                        continue\n                    gc = p.cost + self._dist(p.position, new_pos)\n                    f = gc + lam * h_term\n                    if f + 1e-9 < best_score:\n                        best_score = f\n                        best_parent = p\n                        best_new_cost = gc\n                if best_parent is None:\n                    continue\n\n                # Per-cell cap with cost admission\n                ckey = self._cell_of(new_pos)\n                bucket = grid1.get(ckey)\n                if bucket and len(bucket) >= self.per_cell_cap:\n                    best_bucket_cost = min(n.cost for n in bucket)\n                    if best_new_cost >= best_bucket_cost - 1e-9:\n                        continue\n\n                # Final validity before insertion\n                if self._point_in_obstacles(new_pos):\n                    continue\n                if not self._edge_free(best_parent.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos, best_parent, best_new_cost)\n                best_parent.add_child(new_node)\n                tree1.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                self._grid_insert(grid1, new_node)\n                throttles1[ckey] = throttles1.get(ckey, 0) + 1\n                if (len(tree1) % anchor_stride) == 0:\n                    anchors1.append(new_node)\n                progressed = True\n\n                # LOS compression to ancestors\n                self._compress_to_ancestors(new_node, edges, self.compress_depth)\n\n                # Rewiring around new_node\n                self._rewire_neighbors(grid1, new_node, rewire_r, edges)\n\n                # Try connect to the other tree\n                pair_key = self._pair_key(self._cell_of(new_node.position),\n                                          self._cell_of((other_near.position if other_near else attractor)))\n                if pair_key not in blocked_pairs:\n                    connected, path = self._attempt_connect(new_node, tree2, grid2, throttles2, anchors2, nodes, edges)\n                    if connected:\n                        path = self._shortcut(path)\n                        path = self._los_collapse(path)\n                        best_path = path\n                        best_len = self._path_len(path)\n                        return PlannerResult(True, path, nodes, edges)\n                    else:\n                        blocked_pairs.add(pair_key)\n\n            if not progressed:\n                continue\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= len(self.obstacles) * 2654435761\n        self._rnd_state = (s ^ 0xA5A5A5) & 0xffffffff\n        if self._rnd_state == 0:\n            self._rnd_state = 2463534242\n\n    def _rand(self):\n        self._rnd_state = (1664525 * self._rnd_state + 1013904223) & 0xffffffff\n        return self._rnd_state / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= self.step_size:\n            return self._clamp(b)\n        r = self.step_size / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Sampling\n    def _sample(self, attractor, best_len, sg):\n        for _ in range(24):\n            if best_len < float('inf') and self._rand() < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p and self._within_bounds(p) and not self._point_in_obstacles(p):\n                    return p\n            else:\n                if self._rand() < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n                if self._within_bounds(p) and not self._point_in_obstacles(p):\n                    return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # Node grid (for NN, dupes, neighbors)\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, anchors, pos, max_rings=4):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # fallback scan\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not bucket:\n                            continue\n                        for n in bucket:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((key[0] + dx, key[1] + dy))\n                    if not bucket:\n                        continue\n                    for n in bucket:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    def _candidate_parents(self, grid, anchors, tree, pos, radius, cap):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        if not cand:\n            cand = anchors[:]\n        if len(cand) > cap:\n            # Reservoir-like random subset\n            out = []\n            take = 0\n            for n in cand:\n                take += 1\n                if len(out) < cap:\n                    out.append(n)\n                else:\n                    j = int(self._rand_range(0, take))\n                    if j < len(out):\n                        out[j] = n\n            cand = out\n        return cand\n\n    # Obstacle spatial grid\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    # Edge checks with cache\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.eq) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.eq) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        if len(self.ecache) - self._last_prune_size > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self.ecache:\n            return\n        cutoff = self._tick - 3000\n        to_del = []\n        for k, v in self.ecache.items():\n            if v[1] < cutoff:\n                to_del.append(k)\n        if not to_del:\n            i = 0\n            for k in list(self.ecache.keys()):\n                if (i % 3) == 0:\n                    to_del.append(k)\n                i += 1\n        for k in to_del:\n            if k in self.ecache:\n                del self.ecache[k]\n        self._last_prune_size = len(self.ecache)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Compression and rewiring\n    def _compress_to_ancestors(self, node, edges, depth_limit):\n        depth = 0\n        curp = node.parent\n        while curp is not None and curp.parent is not None and depth < depth_limit:\n            gp = curp.parent\n            if self._edge_free(gp.position, node.position):\n                self._reparent(node, gp, edges)\n                curp = node.parent\n                depth += 1\n            else:\n                break\n\n    def _rewire_radius(self, n_nodes):\n        # simple schedule\n        return max(self.step_size * 1.5, self.rewire_radius_factor * self.step_size)\n\n    def _rewire_neighbors(self, grid, node, radius, edges):\n        key = self._cell_of(node.position)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        neigh = self._grid_ring_nodes(grid, key, r_cells)\n        count = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if d > radius:\n                continue\n            new_cost = node.cost + d\n            if new_cost + 1e-9 < nb.cost and self._edge_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n                count += 1\n                if count >= self.neighbor_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        old_parent = child.parent\n        if old_parent is new_parent:\n            return\n        if old_parent is not None:\n            old_parent.remove_child(child)\n            self._edges_remove(edges, old_parent, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        self._propagate_costs(child)\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                old = ch.cost\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                if abs(ch.cost - old) > 1e-12:\n                    stack.append(ch)\n\n    # Connect attempt\n    def _attempt_connect(self, new_node, other_tree, other_grid, throttles, anchors, nodes, edges):\n        other_near = self._nearest_hashed(other_grid, anchors, new_node.position, 4)\n        if other_near is None:\n            return False, []\n        # Try direct bridge first\n        if self._edge_free(new_node.position, other_near.position):\n            path = self._extract_path(new_node, other_near)\n            return True, self._ensure_bounds_and_valid(path)\n\n        p = other_near\n        steps = 0\n        last_q = None\n        while steps < self.connect_steps:\n            step_pos = self._steer(p.position, new_node.position)\n            if not self._within_bounds(step_pos):\n                break\n            if self._point_in_obstacles(step_pos):\n                break\n            if self._has_nearby(other_grid, step_pos, self.dupe_radius):\n                break\n            if not self._edge_free(p.position, step_pos):\n                break\n            cell = self._cell_of(step_pos)\n            bucket = other_grid.get(cell)\n            if bucket and len(bucket) >= self.per_cell_cap:\n                best_bucket_cost = min(n.cost for n in bucket)\n                new_c = p.cost + self._dist(p.position, step_pos)\n                if new_c >= best_bucket_cost - 1e-9:\n                    break\n\n            q = Node(step_pos, p, p.cost + self._dist(p.position, step_pos))\n            p.add_child(q)\n            other_tree.append(q)\n            nodes.append(q)\n            edges.append((p, q))\n            self._grid_insert(other_grid, q)\n            throttles[cell] = throttles.get(cell, 0) + 1\n            if (len(other_tree) % 20) == 0:\n                anchors.append(q)\n\n            self._compress_to_ancestors(q, edges, 1)\n            # local light rewiring\n            self._rewire_neighbors(other_grid, q, self._rewire_radius(len(nodes)), edges)\n\n            if self._edge_free(new_node.position, q.position):\n                path = self._extract_path(new_node, q)\n                return True, self._ensure_bounds_and_valid(path)\n\n            p = q\n            last_q = q\n            steps += 1\n        return False, []\n\n    def _pair_key(self, c1, c2):\n        return (c1, c2) if c1 <= c2 else (c2, c1)\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return pa + pb[::-1]\n\n    def _ensure_bounds_and_valid(self, path):\n        return [self._clamp(p) for p in path]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # Post smoothing\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        attempts = 0\n        no_improve = 0\n        best_len = self._path_len(pts)\n        while attempts < self.smoothing_iters:\n            i = int(self._rand_range(0, max(1, len(pts) - 2)))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                attempts += 1\n                continue\n            a, b = pts[i], pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= best_len + 1e-12:\n                    pts = new_pts\n                    best_len = L\n                    no_improve = 0\n                else:\n                    no_improve += 1\n            else:\n                no_improve += 1\n            attempts += 1\n            if no_improve >= self.no_improve_stop:\n                break\n        return pts\n\n    def _los_collapse(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = [path[0]]\n        last = path[0]\n        k = 1\n        while k < len(path) - 1:\n            nxt = path[k + 1]\n            if self._edge_free(last, nxt):\n                k += 1\n                continue\n            pts.append(path[k])\n            last = path[k]\n            k += 1\n        pts.append(path[-1])\n        return pts",
          "objective": -29.84258,
          "time_improvement": 46.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1759.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013257336616516114,
                    "num_nodes_avg": 49.0,
                    "path_length_avg": 163.59788282479164,
                    "smoothness_avg": 0.10284552152668414,
                    "success_improvement": 0.0,
                    "time_improvement": 48.00798880221262,
                    "node_improvement": 87.6605389070763,
                    "length_improvement": 10.329408049384693,
                    "smoothness_improvement": 1509.7557445171647,
                    "objective_score": 28.148820192880425
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01610586643218994,
                    "num_nodes_avg": 62.0,
                    "path_length_avg": 241.62656852319907,
                    "smoothness_avg": 0.0921645090196098,
                    "success_improvement": 0.0,
                    "time_improvement": 89.9462328864473,
                    "node_improvement": 95.83417321776524,
                    "length_improvement": 19.338096591802515,
                    "smoothness_improvement": 2271.4592004871693,
                    "objective_score": 49.944023823451545
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.048529839515686034,
                    "num_nodes_avg": 126.0,
                    "path_length_avg": 141.44566627862946,
                    "smoothness_avg": 0.12548275222835503,
                    "success_improvement": 0.0,
                    "time_improvement": 1.0637827328513305,
                    "node_improvement": 83.97965670692943,
                    "length_improvement": 6.058523376571766,
                    "smoothness_improvement": 1496.1313461713685,
                    "objective_score": 11.4349055766553
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "EC-Guide BiRRT with Edge-Cached LOS Compression and Elliptic Focus (EC-GBiRRT). This planner grows two trees from start and goal using a small beam of guided samples, compresses each new extension via multi-ancestor line-of-sight (LOS) with a shared edge-collision memo cache, and attempts a zero-step direct connect to the other tree. After a first path, sampling narrows to a prolate ellipse corridor to accelerate convergence. Early-terminating forward LOS shortcutting finalizes the path. These choices cut repeated collision checks, reduce tree depth, and avoid micro-step connects, improving planning time and path quality.",
          "planning_mechanism": "Each iteration alternates trees: generate a few biased samples, pick a nearby node via a grid hash, steer one step, and validate node/edge. Select the cheapest LOS-ancestor parent using cached edge checks, insert the node, then try a direct LOS link to the other tree\u2019s nearest node; if it succeeds, extract and lightly shortcut the path. A shared bounded edge-cache stores free/blocked results, multi-ancestor compression shortens chains, a per-cell cap limits redundant local growth, and corridor-biased sampling activates once a provisional path exists.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        beam_width=2,\n        goal_bias=0.2,\n        los_lookback_depth=10,\n        min_separation_factor=0.6,\n        grid_cell_factor=1.2,\n        per_cell_cap=12,\n        edge_cache_capacity=20000,\n        shortcut_attempts=60,\n        no_improve_stop=12\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.los_lookback_depth = los_lookback_depth\n        self.min_separation_factor = min_separation_factor\n        self.grid_cell_factor = grid_cell_factor\n        self.per_cell_cap = per_cell_cap\n        self.edge_cache_capacity = edge_cache_capacity\n        self.shortcut_attempts = shortcut_attempts\n        self.no_improve_stop = no_improve_stop\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dims = len(self.bounds)\n        self.is_3d = self.dims == 3\n        self.obstacles = map.obstacles\n        self.start = map.start\n        self.goal = map.goal\n\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n        self.ecache = {}\n        self._tick = 0\n        self._last_prune = 0\n        self.ecache_quant = max(0.5, self.step_size * 0.5)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(self.start, parent=None, cost=0.0)\n        goal_root = Node(self.goal, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        incumbent_len = None\n        best_path = None\n\n        for _ in range(self.max_iter):\n            # Alternate trees each loop\n            for active_tree, active_grid, other_tree, other_grid, attractor in [\n                (tree_a, grid_a, tree_b, grid_b, self.goal),\n                (tree_b, grid_b, tree_a, grid_a, self.start),\n            ]:\n                progress = False\n                for _b in range(self.beam_width):\n                    sample = self._guided_sample(attractor, incumbent_len)\n                    if sample is None:\n                        continue\n\n                    nearest = self._nearest_in_grid(active_grid, sample)\n                    if nearest is None:\n                        continue\n\n                    new_pos = self._steer(nearest.position, sample)\n                    if not self._within_bounds(new_pos):\n                        continue\n                    if self._in_obstacle(new_pos):\n                        continue\n                    # Check edge to nearest; required before any parent selection\n                    if not self._edge_free(nearest.position, new_pos):\n                        continue\n                    # Duplicate suppression\n                    if self._has_nearby(active_grid, new_pos, self.min_separation):\n                        continue\n\n                    # Parent selection via LOS ancestors using cached edge checks\n                    parent = self._select_parent(nearest, new_pos)\n                    if parent is None:\n                        # Safety: though nearest->new_pos was free, parent selection failed; fallback\n                        parent = nearest\n\n                    # Per-cell growth limit; allow insert if bucket light or cost improves the bucket\n                    cell_key = self._cell_of(new_pos)\n                    bucket = active_grid.get(cell_key)\n                    if bucket and len(bucket) >= self.per_cell_cap:\n                        # Allow only if this is significantly cheaper than the best in bucket\n                        best_bucket_cost = min(n.cost for n in bucket)\n                        cand_cost = parent.cost + self._distance(parent.position, new_pos)\n                        if cand_cost >= best_bucket_cost - 1e-6:\n                            continue\n\n                    new_cost = parent.cost + self._distance(parent.position, new_pos)\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node)\n                    progress = True\n\n                    # Attempt direct LOS connect (no micro-steps)\n                    other_near = self._nearest_in_grid(other_grid, new_node.position)\n                    if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                        path_a = self._path_from_root(new_node)\n                        path_b = self._path_from_root(other_near)\n                        # Merge with direct bridge segment ensured free\n                        raw_path = path_a + path_b[::-1]\n                        # Path might duplicate joint if new_node coincides with other_near; dedup\n                        if len(raw_path) >= 2 and self._distance(raw_path[-1], raw_path[-2]) <= 1e-9:\n                            raw_path.pop()  # remove duplicate\n                        smoothed = self._shortcut(raw_path)\n                        final_path = smoothed if smoothed else raw_path\n                        best_path = final_path\n                        incumbent_len = self._path_length(final_path)\n                        return PlannerResult(True, final_path, nodes, edges)\n\n                # If we found no progress from this side in this alternation, continue to the other\n                if not progress:\n                    continue\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # ---------- Geometry and metrics ----------\n    def _distance(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._distance(a, b)\n        if d <= 1e-12:\n            return a\n        if d <= self.step_size:\n            return b\n        r = self.step_size / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n\n    def _path_from_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        length = 0.0\n        for i in range(1, len(path)):\n            length += self._distance(path[i - 1], path[i])\n        return length\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, attractor, incumbent_len):\n        # Corridor-biased sampling if incumbent exists; else mild goal bias\n        # Try limited attempts to avoid heavy rejection\n        for _ in range(20):\n            if incumbent_len is not None and self._distance(self.start, self.goal) > 1e-9:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.05)\n                if p is None:\n                    continue\n            else:\n                if self._rand() < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            if self._within_bounds(p) and not self._in_obstacle(p):\n                return p\n        # Fallback hard-attractor\n        return attractor if self._within_bounds(attractor) and not self._in_obstacle(attractor) else None\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        # Rejection sample in the bounding box of the ellipse/spheroid\n        # Limited attempts for speed; returns None on failure\n        cx = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum_dist\n        # Direction vector and its norm\n        v = tuple(f2[i] - f1[i] for i in range(self.dims))\n        vd = self._distance(f1, f2)\n        # Bounding box extents\n        ext = [half, half, half] if self.is_3d else [half, half]\n        # Try a few samples\n        for _ in range(12):\n            p = tuple(cx[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._within_bounds(p):\n                continue\n            # ellipse condition: dist(p,f1)+dist(p,f2) <= max_sum_dist\n            if self._distance(p, f1) + self._distance(p, f2) <= max_sum_dist and not self._in_obstacle(p):\n                return p\n        return None\n\n    # ---------- Grid spatial hash ----------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _has_nearby(self, grid, pos, radius):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if bucket:\n                            for n in bucket:\n                                if self._distance(n.position, pos) <= radius:\n                                    return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if bucket:\n                        for n in bucket:\n                            if self._distance(n.position, pos) <= radius:\n                                return True\n        return False\n\n    def _nearest_in_grid(self, grid, pos, max_ring=5):\n        cell = self._cell_of(pos)\n        best = None\n        best_d = 1e100\n        if self.is_3d:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if bucket:\n                                for n in bucket:\n                                    d = self._distance(n.position, pos)\n                                    if d < best_d:\n                                        best = n\n                                        best_d = d\n                                        found = True\n                if found:\n                    return best\n        else:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if bucket:\n                            for n in bucket:\n                                d = self._distance(n.position, pos)\n                                if d < best_d:\n                                    best = n\n                                    best_d = d\n                                    found = True\n                if found:\n                    return best\n        # Rare fallback: scan all buckets\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._distance(n.position, pos)\n                if d < best_d:\n                    best = n\n                    best_d = d\n        return best\n\n    # ---------- Obstacles ----------\n    def _in_obstacle(self, pos):\n        if self.is_3d:\n            px, py, pz = pos\n            for obs in self.obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in self.obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.ecache_quant) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.ecache_quant) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]  # True if free, False if blocked\n        # Compute and cache\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        # Bounded pruning\n        if len(self.ecache) - self._last_prune > self.edge_cache_capacity:\n            self._prune_cache()\n        return free\n\n    def _prune_cache(self):\n        # Drop roughly oldest 40%\n        if not self.ecache:\n            return\n        cutoff = self._tick - 2000\n        to_remove = []\n        for k, v in self.ecache.items():\n            if v[1] < cutoff:\n                to_remove.append(k)\n        if not to_remove:\n            # If nothing older than cutoff, remove every 3rd entry to bound size\n            i = 0\n            for k in list(self.ecache.keys()):\n                if i % 3 == 0:\n                    to_remove.append(k)\n                i += 1\n        for k in to_remove:\n            if k in self.ecache:\n                del self.ecache[k]\n        self._last_prune = len(self.ecache)\n\n    def _segment_hits_obstacle(self, a, b):\n        dist = self._distance(a, b)\n        # Resolution tuned for speed while preserving safety\n        resolution = max(0.5, min(1.0, self.step_size * 0.5))\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            p = tuple(a[d] + (b[d] - a[d]) * t for d in range(self.dims))\n            if self._in_obstacle(p):\n                return True\n        return False\n\n    # ---------- Parent selection ----------\n    def _select_parent(self, nearest, new_pos):\n        best = nearest\n        best_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        cur = nearest\n        depth = 0\n        while cur is not None and depth < self.los_lookback_depth:\n            if self._edge_free(cur.position, new_pos):\n                cand = cur.cost + self._distance(cur.position, new_pos)\n                if cand + 1e-9 < best_cost:\n                    best_cost = cand\n                    best = cur\n            cur = cur.parent\n            depth += 1\n        return best\n\n    # ---------- Shortcut smoothing ----------\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        attempts = 0\n        no_improve = 0\n        i = 0\n        while attempts < self.shortcut_attempts and i < len(pts) - 2:\n            improved = False\n            # Try to jump from i to a farther j\n            j = len(pts) - 1\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    # Remove intermediates\n                    del pts[i + 1:j]\n                    improved = True\n                    no_improve = 0\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n                no_improve += 1\n            attempts += 1\n            if no_improve >= self.no_improve_stop:\n                break\n        return pts\n\n    # ---------- Random helpers ----------\n    def _rand(self):\n        # expects 'random' module available\n        return random.random()\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()",
          "objective": -29.11471,
          "time_improvement": 51.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 1571.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02822730541229248,
                    "num_nodes_avg": 65.6,
                    "path_length_avg": 182.96020324956595,
                    "smoothness_avg": 0.05732726413788967,
                    "success_improvement": 0.0,
                    "time_improvement": -10.700544274551492,
                    "node_improvement": 83.48023167967766,
                    "length_improvement": -0.28338659103527,
                    "smoothness_improvement": 797.2961719045505,
                    "objective_score": 0.6062856225361433
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01984243392944336,
                    "num_nodes_avg": 86.6,
                    "path_length_avg": 243.5413235727727,
                    "smoothness_avg": 0.09042567896577892,
                    "success_improvement": 0.0,
                    "time_improvement": 87.61375486797985,
                    "node_improvement": 94.18128065578178,
                    "length_improvement": 18.698896243086562,
                    "smoothness_improvement": 2226.7178507734366,
                    "objective_score": 48.63705346011307
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01169896125793457,
                    "num_nodes_avg": 78.1,
                    "path_length_avg": 133.4682422714018,
                    "smoothness_avg": 0.1405957321950529,
                    "success_improvement": 0.0,
                    "time_improvement": 76.14970532839176,
                    "node_improvement": 90.06993006993007,
                    "length_improvement": 11.356748558062376,
                    "smoothness_improvement": 1688.3673358236224,
                    "objective_score": 38.100797412473064
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "VIVACE-BiRRT*+: Visibility-Integrated, Curvature-Biased, Adaptive-Cached Bidirectional RRT*. It grows two trees with informed/corridor/goal-biased sampling, hashed-grid nearest/nearby queries, and an LRU-quantized edge-collision cache over an obstacle grid. Parent choice minimizes path cost plus a small curvature term (no heuristic in parent cost to keep RRT* optimality), followed by iterative line-of-sight compression to higher ancestors and bounded rewiring with fast subtree cost updates. Bridges select the cheapest visible connection among several neighbors of the opposite tree. The final path is refined by repeat-to-convergence LOS collapse and curvature-aware shortcuts.",
          "planning_mechanism": "Alternate start/goal expansions. For each beam sample: pick a target (informed ellipse if an incumbent exists, else corridor/goal/uniform/bridge hint), find a grid-nearest, steer, pass dupe and per-cell f-gates, then choose a feasible parent within a local radius minimizing gc+d+\u03bc\u00b7turn. Enforce node and edge collision checks before insertion, compress to higher ancestors via LOS, and rewire cheaper neighbors with cycle avoidance and queue-based cost propagation. Attempt multi-near bridging to the other tree and, on a valid connection, merge, run iterative LOS collapse and curvature shortcuts, then return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            # remove from old parent's children\n            i = 0\n            n = len(self.parent.children)\n            while i < n:\n                if self.parent.children[i] is self:\n                    self.parent.children.pop(i)\n                    break\n                i += 1\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=8.0,\n                 grid_cell_factor=1.1,\n                 dupe_radius_ratio=0.5,\n                 parent_radius_factor=2.6,\n                 rewire_radius_factor=2.0,\n                 neighbor_cap=24,\n                 beam_k=2,\n                 goal_bias=0.22,\n                 corridor_bias=0.35,\n                 bridge_bias=0.18,\n                 informed_bias=0.65,\n                 cell_gate_relax=1.08,\n                 cell_expand_limit=3,\n                 edge_cache_capacity=60000,\n                 edge_cache_quant=0.8,\n                 obs_cell_factor=1.2,\n                 smooth_iters=72,\n                 smooth_noimprove=16,\n                 curvature_weight=0.14):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.parent_radius_factor = float(parent_radius_factor)\n        self.rewire_radius_factor = float(rewire_radius_factor)\n        self.neighbor_cap = int(neighbor_cap)\n        self.beam_k = int(beam_k)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.bridge_bias = float(bridge_bias)\n        self.informed_bias = float(informed_bias)\n        self.cell_gate_relax = float(cell_gate_relax)\n        self.cell_expand_limit = int(cell_expand_limit)\n        self.edge_cache_capacity = int(edge_cache_capacity)\n        self.edge_cache_quant = float(edge_cache_quant)\n        self.obs_cell_factor = float(obs_cell_factor)\n        self.smooth_iters = int(smooth_iters)\n        self.smooth_noimprove = int(smooth_noimprove)\n        self.curvature_weight = float(curvature_weight)\n\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_rng()\n\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.parent_radius = max(1.2 * self.step_size, self.parent_radius_factor * self.step_size)\n        self.rewire_radius = max(1.2 * self.step_size, self.rewire_radius_factor * self.step_size)\n        self.connect_radius = 3.5 * self.step_size\n        self.connect_k = 8\n\n        # obstacle grid and edge cache\n        self.obs_cell = max(4.0, self.step_size * self.obs_cell_factor)\n        self._build_obs_grid()\n        self.eq = max(0.25, self.edge_cache_quant)\n        self._tick = 0\n        self.ecache = {}\n        self._last_prune = 0\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # trivial straight connection\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # trees and structures\n        nodes = []\n        edges = []\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n        A, B = [a_root], [b_root]\n        GA, GB = {}, {}\n        self._grid_add(GA, a_root)\n        self._grid_add(GB, b_root)\n        frontierA, frontierB = [a_root], [b_root]\n        gateA, gateB = {}, {}\n        expandA, expandB = {}, {}\n        blocked_pairs = {}\n\n        best_path = None\n        best_len = float('inf')\n        sg = self._dist(self.start, self.goal)\n        corridor_w = max(self.step_size, 0.2 * sg)\n\n        for it in range(self.max_iter):\n            sideA = (it % 2 == 0)\n            T1 = A if sideA else B\n            T2 = B if sideA else A\n            G1 = GA if sideA else GB\n            G2 = GB if sideA else GA\n            frontier1 = frontierA if sideA else frontierB\n            frontier2 = frontierB if sideA else frontierA\n            gate1 = gateA if sideA else gateB\n            expand1 = expandA if sideA else expandB\n            attractor = self.goal if sideA else self.start\n\n            progressed = False\n            best_candidate = None  # (parent, pos, onear)\n            for _ in range(self.beam_k):\n                qrand = self._sample_target(best_len, corridor_w, attractor, G2, frontier2)\n                if qrand is None:\n                    continue\n                qnear = self._nearest(G1, frontier1, qrand)\n                if qnear is None:\n                    continue\n                qnew = self._steer(qnear.position, qrand, self.step_size)\n                if not self._in_bounds(qnew):\n                    continue\n                if self._point_blocked(qnew):\n                    continue\n                if self._has_close(G1, qnew, self.dupe_radius):\n                    continue\n\n                ck = self._cell_key(qnew)\n                g_est = qnear.cost + self._dist(qnear.position, qnew)\n                h_est = self._dist(qnew, attractor)\n                f_est = g_est + h_est\n                prevf = gate1.get(ck, float('inf'))\n                if f_est > prevf * self.cell_gate_relax:\n                    continue\n                if expand1.get(ck, 0) >= self.cell_expand_limit:\n                    continue\n\n                parent, new_cost = self._select_parent(G1, frontier1, qnew)\n                if parent is None:\n                    continue\n\n                # enforce both checks before insertion\n                if self._point_blocked(qnew):\n                    continue\n                if not self._edge_free(parent.position, qnew):\n                    continue\n\n                # keep best by f for this beam\n                onear = self._nearest(G2, frontier2, qnew)\n                fscore = new_cost + self._dist(qnew, attractor)\n                if best_candidate is None or fscore < best_candidate[3]:\n                    best_candidate = (parent, qnew, onear, fscore)\n\n            if best_candidate is None:\n                continue\n\n            parent, qnew, onear, _ = best_candidate\n            # final safety checks before insertion\n            if self._point_blocked(qnew):\n                continue\n            if not self._edge_free(parent.position, qnew):\n                continue\n\n            qnode = Node(qnew, parent, parent.cost + self._dist(parent.position, qnew))\n            qnode.attach(parent)\n            T1.append(qnode)\n            nodes.append(qnode)\n            edges.append((parent, qnode))\n            self._grid_add(G1, qnode)\n            frontier1.append(qnode)\n            if len(frontier1) > 160:\n                del frontier1[:16]\n            ck = self._cell_key(qnew)\n            expand1[ck] = expand1.get(ck, 0) + 1\n            bf = qnode.cost + self._dist(qnew, attractor)\n            if bf < gate1.get(ck, float('inf')):\n                gate1[ck] = bf\n            progressed = True\n\n            # iterative compression to higher ancestors if LOS\n            self._compress_iterative(qnode, edges)\n\n            # local rewiring\n            self._rewire(G1, qnode, edges)\n\n            # attempt multi-near cheapest bridge\n            near_other = self._nearby(G2, qnode.position, self.connect_radius, cap=self.connect_k * 3)\n            if not near_other and onear is not None:\n                near_other = [onear]\n            best_bridge = None  # (other_node, total_cost)\n            for nb in near_other:\n                kp = (self._cell_key(qnode.position), self._cell_key(nb.position))\n                if blocked_pairs.get(kp, 0) >= 2:\n                    continue\n                if self._edge_free(qnode.position, nb.position):\n                    tc = qnode.cost + self._dist(qnode.position, nb.position) + nb.cost\n                    if best_bridge is None or tc < best_bridge[1]:\n                        best_bridge = (nb, tc)\n                else:\n                    blocked_pairs[kp] = blocked_pairs.get(kp, 0) + 1\n\n            if best_bridge is not None:\n                nb = best_bridge[0]\n                path = self._merge_path(qnode, nb, sideA)\n                path = self._los_collapse_repeat(path)\n                path = self._curvature_shortcut(path)\n                L = self._path_len(path)\n                best_len = L\n                best_path = path\n                return PlannerResult(True, path, nodes, edges)\n\n            if not progressed:\n                continue\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            s ^= int(v * 997 + 0.5) + 0x9E3779B97F4A7C15 + (s << 6) + (s >> 2)\n            s &= 0xffffffff\n        s ^= len(self.obstacles) * 2654435761\n        self._rng = s if s != 0 else 2463534242\n\n    def _rand(self):\n        # xorshift32\n        x = self._rng & 0xFFFFFFFF\n        x ^= (x << 13) & 0xFFFFFFFF\n        x ^= (x >> 17) & 0xFFFFFFFF\n        x ^= (x << 5) & 0xFFFFFFFF\n        self._rng = x & 0xFFFFFFFF\n        return (self._rng & 0xFFFFFFFF) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Obstacle grid\n    def _build_obs_grid(self):\n        self.ogrid = {}\n        if self.is3d:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.ogrid.get(k)\n                            if b is None:\n                                self.ogrid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.ogrid.get(k)\n                        if b is None:\n                            self.ogrid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            lst = self.ogrid.get((cx, cy, cz))\n            if not lst:\n                return False\n            px, py, pz = p\n            for i in lst:\n                x, y, z, w, h, d = self.obstacles[i]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            lst = self.ogrid.get((cx, cy))\n            if not lst:\n                return False\n            px, py = p\n            for i in lst:\n                x, y, w, h = self.obstacles[i]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    # Edge cache and collision\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.eq) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.eq) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._seg_hits_any(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        if len(self.ecache) - self._last_prune > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self.ecache:\n            return\n        thr = self._tick - 4000\n        todel = []\n        for k, v in self.ecache.items():\n            if v[1] < thr:\n                todel.append(k)\n        if not todel:\n            i = 0\n            for k in list(self.ecache.keys()):\n                if (i % 3) == 0:\n                    todel.append(k)\n                i += 1\n        for k in todel:\n            if k in self.ecache:\n                del self.ecache[k]\n        self._last_prune = len(self.ecache)\n\n    def _seg_hits_any(self, a, b):\n        if self.is3d:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, mnx) // self.obs_cell)\n            cy0 = int(max(0.0, mny) // self.obs_cell)\n            cz0 = int(max(0.0, mnz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        lst = self.ogrid.get((cx, cy, cz))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, mnx) // self.obs_cell)\n            cy0 = int(max(0.0, mny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    lst = self.ogrid.get((cx, cy))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect(self, p0, p1, bmin, bmax):\n        # Liang-Barsky/slab\n        tmin = 0.0\n        tmax = 1.0\n        n = self.dims\n        for i in range(n):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Node grid\n    def _cell_key(self, pos):\n        if self.is3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, frontier, pos):\n        k = self._cell_key(pos)\n        best = None\n        bd = 1e100\n        for r in range(0, 4):\n            cand = self._grid_ring(grid, k, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bd:\n                        bd = d\n                        best = n\n                if best is not None:\n                    return best\n        # frontier-assisted fallback\n        if frontier:\n            lim = min(24, len(frontier))\n            for i in range(lim):\n                n = frontier[-1 - i]\n                d = self._dist(n.position, pos)\n                if d < bd:\n                    bd = d\n                    best = n\n        return best\n\n    def _has_close(self, grid, pos, radius):\n        k = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell_size) + 1)\n        if self.is3d:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        b = grid.get((k[0] + dx, k[1] + dy, k[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    b = grid.get((k[0] + dx, k[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    def _nearby(self, grid, pos, radius, cap=None):\n        k = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell_size) + 1)\n        lst = self._grid_ring(grid, k, rc)\n        out = []\n        r2 = radius * radius\n        for n in lst:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                out.append(n)\n        if cap is not None and len(out) > cap:\n            # trim by reservoir-like sampling\n            sel = []\n            take = 0\n            for n in out:\n                take += 1\n                if len(sel) < cap:\n                    sel.append(n)\n                else:\n                    j = int(self._rand_range(0, take))\n                    if j < len(sel):\n                        sel[j] = n\n            out = sel\n        return out\n\n    # Sampling\n    def _sample_target(self, best_len, corridor_w, attractor, other_grid, other_frontier):\n        for _ in range(48):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._ellipse_pick(self.start, self.goal, best_len * 1.02)\n                if p and not self._point_blocked(p):\n                    return p\n            else:\n                r2 = self._rand()\n                if r2 < self.goal_bias:\n                    p = attractor\n                elif r2 < self.goal_bias + self.bridge_bias:\n                    # bridge hint toward a random opposite frontier or grid point\n                    seed = self._random_free()\n                    onear = self._nearest(other_grid, other_frontier, seed)\n                    p = onear.position if onear is not None else seed\n                elif r2 < self.goal_bias + self.bridge_bias + self.corridor_bias:\n                    p = self._corridor_pick(corridor_w)\n                else:\n                    p = self._random_free()\n                if p and self._in_bounds(p) and not self._point_blocked(p):\n                    return p\n        return None\n\n    def _random_free(self):\n        for _ in range(40):\n            if self.is3d:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n            else:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n            if not self._point_blocked(p):\n                return p\n        if self.is3d:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5, self.bounds[2] * 0.5)\n        return (self.bounds[0] * 0.5, self.bounds[1] * 0.5)\n\n    def _ellipse_pick(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(36):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._in_bounds(p) and not self._point_blocked(p):\n                return p\n        return None\n\n    def _corridor_pick(self, width):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n        tries = 0\n        while tries < 24:\n            if self.is3d:\n                ox = self._rand_range(-width, width)\n                oy = self._rand_range(-width, width)\n                oz = self._rand_range(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = (base[0] + ox, base[1] + oy, base[2] + oz)\n                else:\n                    tries += 1\n                    continue\n            else:\n                ox = self._rand_range(-width, width)\n                oy = self._rand_range(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = (base[0] + ox, base[1] + oy)\n                else:\n                    tries += 1\n                    continue\n            p = self._clamp(p)\n            if not self._point_blocked(p):\n                return p\n            tries += 1\n        return self._random_free()\n\n    # Parent selection with small curvature bias (no heuristic in cost)\n    def _select_parent(self, grid, frontier, pos):\n        rad = self.parent_radius\n        cand = self._nearby(grid, pos, rad, cap=max(12, self.neighbor_cap))\n        if not cand and frontier:\n            cand = frontier[-min(24, len(frontier)):]\n        best_p = None\n        best_score = float('inf')\n        for p in cand:\n            if not self._edge_free(p.position, pos):\n                continue\n            gc = p.cost + self._dist(p.position, pos)\n            score = gc + self.curvature_weight * self._turn_penalty(p, pos)\n            if score + 1e-12 < best_score:\n                best_score = score\n                best_p = p\n        if best_p is None:\n            return None, float('inf')\n        return best_p, best_p.cost + self._dist(best_p.position, pos)\n\n    def _turn_penalty(self, parent, new_pos):\n        gp = parent.parent\n        if gp is None:\n            return 0.0\n        a = gp.position\n        b = parent.position\n        c = new_pos\n        v1 = tuple(b[i] - a[i] for i in range(self.dims))\n        v2 = tuple(c[i] - b[i] for i in range(self.dims))\n        n1 = 0.0\n        n2 = 0.0\n        dot = 0.0\n        for i in range(self.dims):\n            n1 += v1[i] * v1[i]\n            n2 += v2[i] * v2[i]\n            dot += v1[i] * v2[i]\n        if n1 <= 1e-12 or n2 <= 1e-12:\n            return 0.0\n        cosv = dot / ((n1 ** 0.5) * (n2 ** 0.5))\n        if cosv > 1.0:\n            cosv = 1.0\n        if cosv < -1.0:\n            cosv = -1.0\n        return 1.0 - cosv\n\n    # Compression and rewiring\n    def _compress_iterative(self, node, edges):\n        changed = True\n        while changed:\n            changed = False\n            p = node.parent\n            if p is None or p.parent is None:\n                break\n            gp = p.parent\n            if self._edge_free(gp.position, node.position):\n                oldp = node.parent\n                node.attach(gp)\n                self._remove_edge(edges, oldp, node)\n                edges.append((gp, node))\n                node.cost = gp.cost + self._dist(gp.position, node.position)\n                self._propagate_costs(node)\n                changed = True\n\n    def _rewire(self, grid, node, edges):\n        neigh = self._nearby(grid, node.position, self.rewire_radius, cap=self.neighbor_cap * 2)\n        count = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            new_c = node.cost + d\n            if new_c + 1e-9 < nb.cost and self._edge_free(node.position, nb.position):\n                oldp = nb.parent\n                nb.attach(node)\n                self._remove_edge(edges, oldp, nb)\n                edges.append((node, nb))\n                nb.cost = new_c\n                self._propagate_costs(nb)\n                count += 1\n                if count >= self.neighbor_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _remove_edge(self, edges, p, c):\n        if p is None:\n            return\n        i = 0\n        n = len(edges)\n        while i < n:\n            e = edges[i]\n            if e[0] is p and e[1] is c:\n                edges.pop(i)\n                return\n            i += 1\n\n    def _propagate_costs(self, node):\n        q = [node]\n        head = 0\n        while head < len(q):\n            cur = q[head]\n            head += 1\n            for ch in cur.children:\n                old = ch.cost\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                if abs(ch.cost - old) > 1e-12:\n                    q.append(ch)\n\n    # Merge path\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _merge_path(self, a_side_node, b_side_node, a_is_start_side):\n        if a_is_start_side:\n            pa = self._path_to_root(a_side_node)  # start -> a_node\n            pb = self._path_to_root(b_side_node)  # goal -> b_node\n            # Build start->...->a + bridge + b->...->goal (reverse pb)\n            path = pa + [b_side_node.position] + pb[-2::-1]  # avoid duplicating goal at pb[0]\n            return path\n        else:\n            pa = self._path_to_root(b_side_node)  # start -> b_node\n            pb = self._path_to_root(a_side_node)  # goal -> a_node\n            path = pa + [a_side_node.position] + pb[-2::-1]\n            return path\n\n    # Post-processing\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _los_collapse_once(self, path):\n        if len(path) < 3:\n            return path[:]\n        out = [path[0]]\n        anchor = path[0]\n        i = 1\n        while i < len(path) - 1:\n            nxt = path[i + 1]\n            if self._edge_free(anchor, nxt):\n                i += 1\n                continue\n            out.append(path[i])\n            anchor = path[i]\n            i += 1\n        out.append(path[-1])\n        return out\n\n    def _los_collapse_repeat(self, path):\n        prev_len = -1.0\n        cur = path[:]\n        for _ in range(6):\n            cur = self._los_collapse_once(cur)\n            L = self._path_len(cur)\n            if abs(L - prev_len) < 1e-9:\n                break\n            prev_len = L\n        return cur\n\n    def _curvature_shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best_len = self._path_len(pts)\n        no_imp = 0\n        tries = 0\n        while tries < self.smooth_iters and len(pts) >= 3:\n            # random pair shortcut\n            i = int(self._rand_range(0, max(1, len(pts) - 2)))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(pts[i], pts[j]):\n                cand = pts[:i + 1] + pts[j:]\n                L = self._path_len(cand)\n                if L <= best_len + 1e-12:\n                    pts = cand\n                    best_len = L\n                    no_imp = 0\n                else:\n                    no_imp += 1\n            else:\n                no_imp += 1\n\n            # local curvature corner smoothing\n            if len(pts) >= 3:\n                k = int(self._rand_range(1, len(pts) - 1))\n                a = pts[k - 1]\n                b = pts[k]\n                c = pts[k + 1] if k + 1 < len(pts) else pts[k]\n                mid = tuple(0.5 * (a[t] + c[t]) for t in range(self.dims))\n                if self._in_bounds(mid) and not self._point_blocked(mid):\n                    if self._edge_free(a, mid) and self._edge_free(mid, c):\n                        cand2 = pts[:k] + [mid] + pts[k + 1:]\n                        L2 = self._path_len(cand2)\n                        if L2 <= best_len + 1e-12:\n                            pts = cand2\n                            best_len = L2\n                            no_imp = 0\n                        else:\n                            no_imp += 1\n                    else:\n                        no_imp += 1\n                else:\n                    no_imp += 1\n\n            tries += 1\n            if no_imp >= self.smooth_noimprove:\n                break\n        return pts",
          "objective": -29.06015,
          "time_improvement": 47.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1358.0,
          "node_improvement": 92.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016844749450683594,
                    "num_nodes_avg": 49.0,
                    "path_length_avg": 163.60058133855765,
                    "smoothness_avg": 0.0676529625232086,
                    "success_improvement": 0.0,
                    "time_improvement": 31.723278852017174,
                    "node_improvement": 87.6605389070763,
                    "length_improvement": 10.327928951228857,
                    "smoothness_improvement": 958.915774247722,
                    "objective_score": 20.508319897581075
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04612190723419189,
                    "num_nodes_avg": 77.0,
                    "path_length_avg": 232.8726499838148,
                    "smoothness_avg": 0.07361543148665026,
                    "success_improvement": 0.0,
                    "time_improvement": 72.42363550314752,
                    "node_improvement": 94.82631189948263,
                    "length_improvement": 22.26040656782342,
                    "smoothness_improvement": 1794.1780752036032,
                    "objective_score": 44.054224967656324
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03130025863647461,
                    "num_nodes_avg": 49.0,
                    "path_length_avg": 138.97600341451061,
                    "smoothness_avg": 0.1116587269155452,
                    "success_improvement": 0.0,
                    "time_improvement": 37.99070163762838,
                    "node_improvement": 93.76986649713922,
                    "length_improvement": 7.698755858211411,
                    "smoothness_improvement": 1320.2907645758341,
                    "objective_score": 22.617917829094534
               }
          ],
          "success_rate": 1.0
     }
]