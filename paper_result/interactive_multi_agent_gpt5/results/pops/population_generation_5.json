[
     {
          "operator": "m3",
          "algorithm_description": "BiCon-Lite*: Simplified Bi-directional RRT-Connect with local best-parent and light rewiring. It grows two trees from start and goal using uniform sampling with small goal bias and informed sampling once a path bound is known. Each added node is chosen from a few nearest candidates by lowest path cost if the edge is collision-free; after insertion, nearby nodes can be rewired if cheaper. Trees greedily connect toward each other; upon connection, the path is visibility-pruned and shortcut for length and smoothness.",
          "planning_mechanism": "Alternate expanding start/goal trees. For each iteration: sample a target (uniform, goal-biased, or informed ellipse), steer one step from the nearest node, reject if outside/duplicate/colliding, then pick a best feasible parent among k-nearest to insert. Lightly rewire nearby neighbors if the new route is cheaper (cycle-safe). Attempt a greedy connect from the opposite tree toward the new node by incremental steps; if it reaches within one step and the final edge is free, extract the full path (start-to-A, cross-edge, B-to-goal), then prune and shortcut. Always check node and edge collisions before adding any node or edge.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n\n    def attach(self, new_parent):\n        if new_parent is self.parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            if self not in new_parent.children:\n                new_parent.children.append(self)\n\n    def is_ancestor_of(self, other):\n        cur = other\n        while cur is not None:\n            if cur is self:\n                return True\n            cur = cur.parent\n        return False\n\n    def propagate_cost(self, delta):\n        if delta == 0.0:\n            return\n        self.cost += delta\n        for c in self.children:\n            c.propagate_cost(delta)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=10.0,\n        goal_bias=0.1,\n        informed_bias=0.5,\n        dupe_radius_ratio=0.5,\n        neighbor_radius_factor=2.5,\n        k_near=5,\n        shortcut_attempts=80\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.neighbor_radius_factor = float(neighbor_radius_factor)\n        self.k_near = int(k_near)\n        self.shortcut_attempts = int(shortcut_attempts)\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obstacle(self.start) or self._point_in_obstacle(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        self._seed_rng()\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.neighbor_radius = max(self.step_size * 1.5, self.step_size * self.neighbor_radius_factor)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            edges = [(n0, n1)]\n            return PlannerResult(True, self._finalize_path([self.start, self.goal]), [n0, n1], edges)\n\n        nodes = []\n        edges = []\n\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        A = [a_root]\n        B = [b_root]\n\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            grow_A = (it % 2 == 0)\n            T = A if grow_A else B\n            O = B if grow_A else A\n            attractor = self.goal if grow_A else self.start\n\n            qrand = self._sample(attractor, best_len)\n            if qrand is None:\n                continue\n\n            qnear = self._nearest_in(T, qrand)\n            if qnear is None:\n                continue\n\n            qnew_pos = self._steer(qnear.position, qrand)\n            if not self._in_bounds(qnew_pos):\n                continue\n            if self._point_in_obstacle(qnew_pos):\n                continue\n            if self._has_near_in(T, qnew_pos, self.dupe_radius):\n                continue\n\n            parent = self._best_parent(T, qnew_pos, qnear)\n            if parent is None:\n                continue\n            if not self._edge_free(parent.position, qnew_pos):\n                continue\n\n            qnew_cost = parent.cost + self._dist(parent.position, qnew_pos)\n            qnew = Node(qnew_pos, parent, qnew_cost)\n            T.append(qnew)\n            nodes.append(qnew)\n            edges.append((parent, qnew))\n\n            self._light_rewire(T, qnew, edges)\n\n            ok, last_other, added = self._connect_toward(O, qnew.position, nodes, edges)\n            if ok and last_other is not None:\n                edges.append((last_other, qnew))\n                path = self._extract_path(qnew, last_other)\n                best_len = self._path_len(path)\n                return PlannerResult(True, self._finalize_path(path), nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0xA5A5A5A5\n        for v in self.start + self.goal:\n            s ^= (int(v * 1315423911) + (s << 7) + (s >> 3)) & 0xffffffff\n            s &= 0xffffffff\n        s ^= (len(self.obstacles) * 0x9E3779B9) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            tgt = a\n        elif d <= self.step_size:\n            tgt = b\n        else:\n            r = self.step_size / d\n            tgt = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n        out = tuple(max(0.0, min(tgt[i], self.bounds[i])) for i in range(self.dims))\n        return out\n\n    # Nearest and neighbors\n    def _nearest_in(self, nodes_list, pos):\n        best = None\n        bd = 1e100\n        for n in nodes_list:\n            d = self._dist(n.position, pos)\n            if d < bd:\n                bd = d\n                best = n\n        return best\n\n    def _k_nearest_in(self, nodes_list, pos, k):\n        if not nodes_list:\n            return []\n        pairs = []\n        for n in nodes_list:\n            pairs.append((self._dist(n.position, pos), n))\n        pairs.sort(key=lambda x: x[0])\n        out = [n for _, n in pairs[:max(1, k)]]\n        return out\n\n    def _neighbors_radius(self, nodes_list, pos, radius):\n        out = []\n        r = float(radius)\n        for n in nodes_list:\n            if self._dist(n.position, pos) <= r:\n                out.append(n)\n        return out\n\n    def _has_near_in(self, nodes_list, pos, radius):\n        r = float(radius)\n        for n in nodes_list:\n            if self._dist(n.position, pos) <= r:\n                return True\n        return False\n\n    # Parent selection\n    def _best_parent(self, nodes_list, qpos, fallback):\n        cands = self._k_nearest_in(nodes_list, qpos, self.k_near)\n        if fallback not in cands:\n            cands.append(fallback)\n        best = None\n        best_cost = 1e100\n        for p in cands:\n            if not self._edge_free(p.position, qpos):\n                continue\n            c = p.cost + self._dist(p.position, qpos)\n            if c < best_cost:\n                best_cost = c\n                best = p\n        return best\n\n    # Light rewiring\n    def _light_rewire(self, nodes_list, qnew, edges):\n        nbrs = self._neighbors_radius(nodes_list, qnew.position, self.neighbor_radius)\n        rewired = 0\n        for w in nbrs:\n            if w is qnew or w is qnew.parent:\n                continue\n            if w.is_ancestor_of(qnew):\n                continue\n            d = self._dist(qnew.position, w.position)\n            cand_cost = qnew.cost + d\n            if cand_cost + 1e-12 < w.cost and self._edge_free(qnew.position, w.position):\n                oldp = w.parent\n                self._replace_edge(edges, oldp, w, qnew)\n                w.attach(qnew)\n                delta = cand_cost - w.cost\n                w.propagate_cost(delta)\n                rewired += 1\n                if rewired >= 10:\n                    break\n\n    # Connect toward a target (other tree growth)\n    def _connect_toward(self, tree_nodes, target_pos, all_nodes, edges):\n        if not tree_nodes:\n            return False, None, []\n        cur = self._nearest_in(tree_nodes, target_pos)\n        added = []\n        for _ in range(1000):\n            nxt = self._steer(cur.position, target_pos)\n            if self._dist(cur.position, nxt) <= 1e-9:\n                break\n            if not self._in_bounds(nxt):\n                break\n            if self._point_in_obstacle(nxt):\n                break\n            if self._has_near_in(tree_nodes, nxt, self.dupe_radius):\n                # If very close to some node, snap to the nearest and continue\n                cur = self._nearest_in(tree_nodes, nxt)\n                if self._dist(cur.position, target_pos) <= self.step_size and self._edge_free(cur.position, target_pos):\n                    return True, cur, added\n                continue\n            if not self._edge_free(cur.position, nxt):\n                break\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            q = Node(nxt, cur, new_cost)\n            tree_nodes.append(q)\n            all_nodes.append(q)\n            edges.append((cur, q))\n            added.append(q)\n            cur = q\n            if self._dist(cur.position, target_pos) <= self.step_size and self._edge_free(cur.position, target_pos):\n                return True, cur, added\n        return False, cur, added\n\n    # Collision\n    def _point_in_obstacle(self, p):\n        if self.is3d:\n            px, py, pz = p\n            for x, y, z, w, h, d in self.obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            px, py = p\n            for x, y, w, h in self.obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        if self.is3d:\n            for x, y, z, w, h, d in self.obstacles:\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return False\n            return True\n        else:\n            for x, y, w, h in self.obstacles:\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return False\n            return True\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Edges\n    def _replace_edge(self, edges, old_parent, child, new_parent):\n        if old_parent is not None:\n            rm = -1\n            for i, (u, v) in enumerate(edges):\n                if u is old_parent and v is child:\n                    rm = i\n                    break\n            if rm >= 0:\n                edges.pop(rm)\n        if new_parent is not None:\n            exists = False\n            for u, v in edges:\n                if u is new_parent and v is child:\n                    exists = True\n                    break\n            if not exists:\n                edges.append((new_parent, child))\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        for _ in range(24):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p is not None and not self._point_in_obstacle(p):\n                    return p\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n                if self._in_bounds(p) and not self._point_in_obstacle(p):\n                    return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(16):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._in_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Path ops\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        return pa + pb[::-1]\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(pruned[-1], path[j]):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best_L = self._path_len(pts)\n        tries = 0\n        while tries < attempts and len(pts) > 2:\n            n = len(pts)\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                cand = pts[:i + 1] + pts[j:]\n                L = self._path_len(cand)\n                if L <= best_L + 1e-12:\n                    pts = cand\n                    best_L = L\n            tries += 1\n        return pts\n\n    def _finalize_path(self, path):\n        if not path:\n            return []\n        p = self._visibility_prune(path)\n        p = self._shortcut(p, self.shortcut_attempts)\n        return p",
          "objective": -42.61971,
          "time_improvement": 88.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1715.0,
          "node_improvement": 94.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.005434727668762207,
                    "num_nodes_avg": 33.0,
                    "path_length_avg": 172.03461483544805,
                    "smoothness_avg": 0.051447969062332066,
                    "success_improvement": 0.0,
                    "time_improvement": 77.97145118473429,
                    "node_improvement": 91.68975069252078,
                    "length_improvement": 5.705101545770078,
                    "smoothness_improvement": 705.2724368784732,
                    "objective_score": 30.3408584672747
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.012911844253540038,
                    "num_nodes_avg": 78.0,
                    "path_length_avg": 254.30361579440722,
                    "smoothness_avg": 0.12651907716440625,
                    "success_improvement": 0.0,
                    "time_improvement": 92.27998699936137,
                    "node_improvement": 94.75912114493046,
                    "length_improvement": 15.106133324099327,
                    "smoothness_improvement": 3155.4269834480324,
                    "objective_score": 52.52481101150817
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0025941610336303713,
                    "num_nodes_avg": 30.0,
                    "path_length_avg": 125.19016890049133,
                    "smoothness_avg": 0.10884440067125287,
                    "success_improvement": 0.0,
                    "time_improvement": 94.86067807289716,
                    "node_improvement": 96.18563254926892,
                    "length_improvement": 16.854650731526867,
                    "smoothness_improvement": 1284.492742480391,
                    "objective_score": 44.99345757318722
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SWIFT-Connect: a lean bidirectional RRT-Connect with spatial hashing and duplicate suppression. It alternates tree growth, validates nodes and edges before commitment, greedily connects to the opposite tree, and exits on the first feasible bridge. Lightweight LOS collapse and shortcutting polish the path. The design trades heavy optimization for fast, robust, generalizable solves.",
          "planning_mechanism": "Alternate expanding start and goal trees. For each goal-biased sample, extend the active tree one validated step, then greedily advance the opposite tree toward it with multi-step connect; on a collision-free join, assemble the path and smooth via LOS and random shortcuts. Nearest lookups use a coarse grid; all samples stay within bounds and all nodes/edges are collision-checked before insertion.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            i = 0\n            while i < len(self.parent.children):\n                if self.parent.children[i] is self:\n                    self.parent.children.pop(i)\n                    break\n                i += 1\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=5.0,\n                 goal_bias=0.3,\n                 cell_factor=1.6,\n                 dupe_radius_ratio=0.4,\n                 smooth_shortcuts=80):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.cell_factor = float(cell_factor)\n        self.dupe_ratio = float(dupe_radius_ratio)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._build_obs_grid()\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        self.cell = max(1.0, self.step * self.cell_factor)\n        self.dupe_radius = max(0.5, self.dupe_ratio * self.step)\n\n        self._nodes = []\n        self._edges = []\n        rootA = Node(self.start, None, 0.0)\n        rootB = Node(self.goal, None, 0.0)\n        self._nodes.append(rootA)\n        self._nodes.append(rootB)\n\n        self._gridA = {}\n        self._gridB = {}\n        self._grid_add(self._gridA, rootA)\n        self._grid_add(self._gridB, rootB)\n\n        for it in range(self.max_iter):\n            use_A = (it % 2 == 0)\n            active_grid = self._gridA if use_A else self._gridB\n            other_grid = self._gridB if use_A else self._gridA\n            attractor = self.goal if use_A else self.start\n\n            target = self._sample_target(attractor)\n            if target is None:\n                continue\n\n            new_node = self._extend_one(active_grid, target)\n            if new_node is None:\n                continue\n\n            q_reached, ok = self._connect_greedy(other_grid, new_node.position)\n            if ok and self._edge_free(q_reached.position, new_node.position):\n                join = Node(new_node.position, q_reached, q_reached.cost + self._dist(q_reached.position, new_node.position))\n                join.attach(q_reached)\n                self._nodes.append(join)\n                self._edges.append((q_reached, join))\n                self._grid_add(other_grid, join)\n\n                if use_A:\n                    path1 = self._trace_to_root(new_node)\n                    path2 = self._trace_to_root(q_reached)\n                    path = path1 + list(reversed(path2))\n                else:\n                    path1 = self._trace_to_root(q_reached)\n                    path2 = self._trace_to_root(new_node)\n                    path = path1 + list(reversed(path2))\n\n                path = self._postprocess(path)\n                return PlannerResult(True, path, self._nodes, self._edges)\n\n        return PlannerResult(False, [], self._nodes, self._edges)\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _same_pos(self, a, b, eps=1e-9):\n        for i in range(self.dims):\n            if abs(a[i] - b[i]) > eps:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    def _build_obs_grid(self):\n        self.obs_cell = max(4.0, self.step * 2.0)\n        self._ogrid = {}\n        if self.is3d:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self._ogrid.get(k)\n                            if b is None:\n                                self._ogrid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self._ogrid.get(k)\n                        if b is None:\n                            self._ogrid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _cell_candidates(self, a, b):\n        if self.is3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            out = []\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        lst = self._ogrid.get((cx, cy, cz))\n                        if lst:\n                            out.extend(lst)\n            return out\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            out = []\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    lst = self._ogrid.get((cx, cy))\n                    if lst:\n                        out.extend(lst)\n            return out\n\n    def _point_blocked(self, p):\n        if self.is3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self._ogrid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            x0, y0, z0 = p\n            i = 0\n            while i < len(bucket):\n                x, y, z, w, h, d = self.obstacles[bucket[i]]\n                if x <= x0 <= x + w and y <= y0 <= y + h and z <= z0 <= z + d:\n                    return True\n                i += 1\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self._ogrid.get((cx, cy))\n            if not bucket:\n                return False\n            x0, y0 = p\n            i = 0\n            while i < len(bucket):\n                x, y, w, h = self.obstacles[bucket[i]]\n                if x <= x0 <= x + w and y <= y0 <= y + h:\n                    return True\n                i += 1\n            return False\n\n    def _seg_aabb_hit(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(self.dims):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _edge_free(self, a, b):\n        cand = self._cell_candidates(a, b)\n        if not cand:\n            return True\n        if self.is3d:\n            i = 0\n            while i < len(cand):\n                x, y, z, w, h, d = self.obstacles[cand[i]]\n                if self._seg_aabb_hit(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return False\n                i += 1\n            return True\n        else:\n            i = 0\n            while i < len(cand):\n                x, y, w, h = self.obstacles[cand[i]]\n                if self._seg_aabb_hit(a, b, (x, y), (x + w, y + h)):\n                    return False\n                i += 1\n            return True\n\n    def _cell_key(self, pos):\n        if self.is3d:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is3d:\n            dx = -r\n            while dx <= r:\n                dy = -r\n                while dy <= r:\n                    dz = -r\n                    while dz <= r:\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n                        dz += 1\n                    dy += 1\n                dx += 1\n        else:\n            dx = -r\n            while dx <= r:\n                dy = -r\n                while dy <= r:\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n                    dy += 1\n                dx += 1\n        return out\n\n    def _nearest(self, grid, pos):\n        k = self._cell_key(pos)\n        best = None\n        bd = 1e100\n        max_r = 2\n        r = 0\n        while r <= max_r:\n            cand = self._grid_ring(grid, k, r)\n            if cand:\n                i = 0\n                while i < len(cand):\n                    n = cand[i]\n                    d = self._dist(n.position, pos)\n                    if d < bd:\n                        bd = d\n                        best = n\n                    i += 1\n                if best is not None:\n                    return best\n            r += 1\n        for b in grid.values():\n            i = 0\n            while i < len(b):\n                n = b[i]\n                d = self._dist(n.position, pos)\n                if d < bd:\n                    bd = d\n                    best = n\n                i += 1\n        return best\n\n    def _has_close(self, grid, pos, radius):\n        k = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell) + 1)\n        lst = self._grid_ring(grid, k, rc)\n        r2 = radius * radius\n        i = 0\n        while i < len(lst):\n            n = lst[i]\n            s = 0.0\n            p = n.position\n            j = 0\n            while j < self.dims:\n                d = p[j] - pos[j]\n                s += d * d\n                j += 1\n            if s <= r2:\n                return True\n            i += 1\n        return False\n\n    def _extend_one(self, grid, target):\n        qnear = self._nearest(grid, target)\n        if qnear is None:\n            return None\n        qpos = self._steer(qnear.position, target, self.step)\n        if self._same_pos(qpos, qnear.position):\n            return None\n        if not self._in_bounds(qpos):\n            return None\n        if self._point_blocked(qpos):\n            return None\n        if not self._edge_free(qnear.position, qpos):\n            return None\n        if self._has_close(grid, qpos, self.dupe_radius):\n            return None\n        new_node = Node(qpos, qnear, qnear.cost + self._dist(qnear.position, qpos))\n        new_node.attach(qnear)\n        self._nodes.append(new_node)\n        self._edges.append((qnear, new_node))\n        self._grid_add(grid, new_node)\n        return new_node\n\n    def _connect_greedy(self, grid, target_pos):\n        qnear = self._nearest(grid, target_pos)\n        if qnear is None:\n            return None, False\n        cur = qnear\n        max_steps = max(1, int(self._dist(qnear.position, target_pos) / max(1e-9, self.step)) + 2)\n        if max_steps > 64:\n            max_steps = 64\n        steps = 0\n        while steps < max_steps:\n            if self._dist(cur.position, target_pos) <= self.step and self._edge_free(cur.position, target_pos):\n                return cur, True\n            qpos = self._steer(cur.position, target_pos, self.step)\n            if self._same_pos(qpos, cur.position):\n                break\n            if not self._in_bounds(qpos):\n                break\n            if self._point_blocked(qpos):\n                break\n            if not self._edge_free(cur.position, qpos):\n                break\n            if self._has_close(grid, qpos, self.dupe_radius):\n                break\n            nxt = Node(qpos, cur, cur.cost + self._dist(cur.position, qpos))\n            nxt.attach(cur)\n            self._nodes.append(nxt)\n            self._edges.append((cur, nxt))\n            self._grid_add(grid, nxt)\n            cur = nxt\n            steps += 1\n        return cur, False\n\n    def _sample_target(self, attractor):\n        if self._rand() < self.goal_bias:\n            return attractor\n        return self._random_free()\n\n    def _random_free(self):\n        tries = 64\n        while tries > 0:\n            tries -= 1\n            if self.is3d:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n            else:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n            if not self._point_blocked(p):\n                return p\n        return None\n\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        s = 0.0\n        i = 1\n        while i < len(path):\n            s += self._dist(path[i - 1], path[i])\n            i += 1\n        return s\n\n    def _los_collapse(self, path, rounds=3):\n        if len(path) < 3:\n            return path[:]\n        cur = path[:]\n        r = 0\n        while r < rounds:\n            out = [cur[0]]\n            anchor = cur[0]\n            i = 1\n            while i < len(cur) - 1:\n                if self._edge_free(anchor, cur[i + 1]):\n                    i += 1\n                    continue\n                out.append(cur[i])\n                anchor = cur[i]\n                i += 1\n            out.append(cur[-1])\n            if len(out) == len(cur):\n                break\n            cur = out\n            r += 1\n        return cur\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = path[:]\n        best = self._path_len(pts)\n        t = 0\n        while t < attempts and len(pts) >= 3:\n            n = len(pts)\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j > n - 1:\n                t += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                cand = pts[:i + 1] + pts[j:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    pts = cand\n                    best = L\n            t += 1\n        return pts\n\n    def _postprocess(self, path):\n        p = path[:]\n        p = self._los_collapse(p, rounds=3)\n        p = self._shortcut(p, self.smooth_shortcuts)\n        p = self._los_collapse(p, rounds=2)\n        return p",
          "objective": -41.85803,
          "time_improvement": 74.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1880.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007715272903442383,
                    "num_nodes_avg": 73.0,
                    "path_length_avg": 160.85834898192107,
                    "smoothness_avg": 0.04902467731266237,
                    "success_improvement": 0.0,
                    "time_improvement": 68.72773096737596,
                    "node_improvement": 81.6167212289096,
                    "length_improvement": 11.83098995935377,
                    "smoothness_improvement": 667.3426587338824,
                    "objective_score": 31.05362655949446
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025490784645080568,
                    "num_nodes_avg": 183.3,
                    "path_length_avg": 234.9419709193859,
                    "smoothness_avg": 0.12316192274741442,
                    "success_improvement": 0.0,
                    "time_improvement": 84.75901776753946,
                    "node_improvement": 87.68393469058657,
                    "length_improvement": 21.56960767742916,
                    "smoothness_improvement": 3069.0449822382448,
                    "objective_score": 53.71469484791056
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.015743160247802736,
                    "num_nodes_avg": 173.6,
                    "path_length_avg": 123.84164743815386,
                    "smoothness_avg": 0.15742682886839948,
                    "success_improvement": 0.0,
                    "time_improvement": 68.81104618621191,
                    "node_improvement": 77.92752701843611,
                    "length_improvement": 17.75027447711989,
                    "smoothness_improvement": 1902.4576431662642,
                    "objective_score": 40.80576675796682
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SIMPLE-BiRRT-i: a simplified informed bi-directional RRT with spatial hashing and ghost-connect. It grows two trees from start and goal with small-step steering, hashed nearest search, light duplicate suppression, and early termination upon a valid bridge. It maintains coherence (node/edge checks before add), avoids heavy rewiring/compression, and performs greedy visibility pruning followed by bounded shortcut smoothing for shorter, smoother paths.",
          "planning_mechanism": "Alternate expanding start and goal trees. Each iteration: sample uniformly with goal-bias and optionally inside the informed ellipse if a path bound exists; choose a hashed-nearest parent; steer one step; validate node and edge; insert into the active tree. Try to connect to the opposite tree by direct line or a ghost (non-committal) short-step chain; if feasible, commit the chain, extract the bi-tree path, prune by visibility, shortcut, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        goal_bias=0.15,\n        informed_bias=0.5,\n        dupe_radius_ratio=0.35,\n        connect_radius_factor=3.0,\n        connect_steps=6,\n        smoothing_iters=60,\n        cell_factor=1.0\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.connect_radius_factor = float(connect_radius_factor)\n        self.connect_steps = int(connect_steps)\n        self.smoothing_iters = int(smoothing_iters)\n        self.cell_factor = float(cell_factor)\n        self._rng = 1234567\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_from_scene()\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Direct path early exit\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        self.cell_size = max(1.0, self.step_size * self.cell_factor)\n        self.dupe_radius = max(0.25, self.step_size * self.dupe_radius_ratio)\n        self.connect_radius = max(self.step_size, self.connect_radius_factor * self.step_size)\n\n        # Trees\n        nodes = []\n        edges = []\n\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        nodes.extend([root_a, root_b])\n        edges.extend([])\n\n        tree_a, tree_b = [root_a], [root_b]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, root_a)\n        self._grid_insert(grid_b, root_b)\n\n        best_len = float('inf')  # enables informed sampling when a bound appears\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            tree = tree_a if side_a else tree_b\n            other_tree = tree_b if side_a else tree_a\n            grid = grid_a if side_a else grid_b\n            other_grid = grid_b if side_a else grid_a\n            attractor = self.goal if side_a else self.start\n\n            s = self._sample(attractor, best_len)\n            if s is None:\n                continue\n\n            parent = self._nearest_hashed(grid, tree, s, 2)\n            if parent is None:\n                continue\n\n            new_pos = self._steer(parent.position, s)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n            if self._has_nearby(grid, new_pos, self.dupe_radius):\n                continue\n\n            new_node = Node(new_pos, parent, parent.cost + self._dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(grid, new_node)\n\n            # Try to connect directly to nearest in the opposite tree\n            near_other = self._nearest_hashed(other_grid, other_tree, new_node.position, 2)\n            if near_other is not None:\n                if self._dist(near_other.position, new_node.position) <= self.connect_radius and self._edge_free(near_other.position, new_node.position):\n                    path = self._extract_path(new_node, near_other, side_a)\n                    path = self._finalize_path(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n                # Ghost-connect: plan a short chain without committing, commit only if bridging succeeds\n                ok, chain_positions, last_pos = self._ghost_connect_positions(near_other.position, new_node.position, other_grid)\n                if ok and self._edge_free(last_pos, new_node.position):\n                    # Commit chain into the opposite tree\n                    prev = near_other\n                    for p in chain_positions:\n                        if self._has_nearby(other_grid, p, self.dupe_radius):\n                            prev = self._nearest_hashed(other_grid, other_tree, p, 1)\n                            if prev is None:\n                                prev = near_other\n                            continue\n                        if self._point_in_obstacles(p):\n                            ok = False\n                            break\n                        if not self._edge_free(prev.position, p):\n                            ok = False\n                            break\n                        q = Node(p, prev, prev.cost + self._dist(prev.position, p))\n                        prev.add_child(q)\n                        other_tree.append(q)\n                        nodes.append(q)\n                        edges.append((prev, q))\n                        self._grid_insert(other_grid, q)\n                        prev = q\n                    if ok and self._edge_free(prev.position, new_node.position):\n                        # We do not add a cross-tree edge; extract bi-tree path\n                        path = self._extract_path(new_node, prev, side_a)\n                        L = self._path_len(path)\n                        if L < best_len:\n                            best_len = L\n                        path = self._finalize_path(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1103515245 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 1) * 2654435761\n        if s == 0:\n            s = 1234567\n        self._rng = s & 0x7fffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0x7fffffff\n        return self._rng / float(1 << 31)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= self.step_size:\n            return tuple(b)\n        r = self.step_size / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n\n    # Obstacles\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            px, py, pz = p\n            for o in self.obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            px, py = p\n            for o in self.obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            for o in self.obstacles:\n                x, y, z, w, h, d = o\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            for o in self.obstacles:\n                x, y, w, h = o\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Spatial hashing\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, tree, pos, max_rings):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        any_found = False\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n                    any_found = True\n        if any_found:\n            return best\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n            if p and self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        if r < self.goal_bias:\n            p = attractor\n        else:\n            p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n        if self._in_bounds(p) and not self._point_in_obstacles(p):\n            return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [half] * self.dim\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dim))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # Ghost connect (non-committal)\n    def _ghost_connect_positions(self, from_pos, to_pos, other_grid):\n        chain = []\n        cur = from_pos\n        steps = 0\n        while steps < self.connect_steps:\n            nxt = self._steer(cur, to_pos)\n            if not self._in_bounds(nxt):\n                return False, None, None\n            if self._point_in_obstacles(nxt):\n                return False, None, None\n            if not self._edge_free(cur, nxt):\n                return False, None, None\n            if self._has_nearby(other_grid, nxt, self.dupe_radius):\n                return False, None, None\n            chain.append(nxt)\n            cur = nxt\n            if self._dist(cur, to_pos) <= self.step_size or self._edge_free(cur, to_pos):\n                return True, chain, cur\n            steps += 1\n        return False, None, None\n\n    # Paths and smoothing\n    def _path_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        return out[::-1]\n\n    def _extract_path(self, a_node, b_node, a_forward=True):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return (pa + pb[::-1]) if a_forward else (pb + pa[::-1])\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(pruned[-1], path[j]):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best_L = self._path_len(pts)\n        for _ in range(self.smoothing_iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                continue\n            a, b = pts[i], pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= best_L + 1e-12:\n                    pts = new_pts\n                    best_L = L\n        return pts\n\n    def _finalize_path(self, path):\n        if not path:\n            return []\n        p = self._visibility_prune(path)\n        p = self._shortcut(p)\n        return p",
          "objective": -40.79252,
          "time_improvement": 68.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 2580.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007870960235595702,
                    "num_nodes_avg": 48.0,
                    "path_length_avg": 179.5861954290845,
                    "smoothness_avg": 0.06548709066523807,
                    "success_improvement": 0.0,
                    "time_improvement": 68.09668444484818,
                    "node_improvement": 87.91236464366659,
                    "length_improvement": 1.565960559945877,
                    "smoothness_improvement": 925.0151764044653,
                    "objective_score": 25.993657551444304
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0211273193359375,
                    "num_nodes_avg": 158.0,
                    "path_length_avg": 237.3530114017347,
                    "smoothness_avg": 0.18862965381071545,
                    "success_improvement": 0.0,
                    "time_improvement": 87.36794088130645,
                    "node_improvement": 89.38386078075656,
                    "length_improvement": 20.764732966468724,
                    "smoothness_improvement": 4753.576856997666,
                    "objective_score": 62.437106329261496
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026227736473083497,
                    "num_nodes_avg": 250.0,
                    "path_length_avg": 127.39626037258856,
                    "smoothness_avg": 0.16982997215257256,
                    "success_improvement": 0.0,
                    "time_improvement": 48.039932985286335,
                    "node_improvement": 68.21360457724094,
                    "length_improvement": 15.389469818547017,
                    "smoothness_improvement": 2060.2247102361403,
                    "objective_score": 33.94678533789481
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "FIBER-Connect*: Fast Informed Bi-directional Edge-Refining RRT* with priority-balanced growth, adaptive neighbor/rewire radii, short validated bridges, and online visibility-prune/shortcutting for smooth, compact paths with low search cost.",
          "planning_mechanism": "Per iteration, expand the smaller tree: sample (uniform/goal; informed ellipse after first path), steer one step, validate node and parent edge, pick the lowest-cost parent among nearby neighbors, insert, then locally rewire to reduce cost. Attempt a short, validated bridge to the opposite tree; if blocked, allow at most one assisted hop on the passive tree before retrying. On a bridge, extract the bi-tree path, apply visibility pruning and length-nonincreasing shortcuts, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=5.5,\n        goal_bias=0.25,\n        informed_bias=0.6,\n        grid_cell_factor=1.0,\n        neighbor_base=3.2,\n        rewire_base=2.6,\n        connect_factor=3.0,\n        dupe_ratio=0.45,\n        ring_cap=4,\n        bridge_hops=1,\n        smooth_iters=80\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neighbor_base = float(neighbor_base)\n        self.rewire_base = float(rewire_base)\n        self.connect_factor = float(connect_factor)\n        self.dupe_ratio = float(dupe_ratio)\n        self.ring_cap = int(ring_cap)\n        self.bridge_hops = int(bridge_hops)\n        self.smooth_iters = int(smooth_iters)\n        self._rng = 123456789\n\n    def plan(self, map):\n        # Scene\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        # Validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_rng()\n        # Build obstacle index and ensure start/goal free\n        self._build_obs_index()\n        if self._in_obs(self.start) or self._in_obs(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Straight line early exit\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            edges = [(n0, n1)]\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], edges)\n\n        # Parameters\n        self.space_extent = max(1.0, max(self.bounds))\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius_base = max(0.3, self.dupe_ratio * self.step_size)\n        self.connect_radius = max(self.step_size, self.connect_factor * self.step_size)\n\n        # Trees and spatial hashes\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes = [start_root, goal_root]\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        # Informed sampling bookkeeping\n        have_solution = False\n        best_path = []\n        best_len = 1e100\n        c_min = self._dist(self.start, self.goal)\n\n        for it in range(self.max_iter):\n            # Choose the tree with fewer nodes to keep balance\n            expand_a = (len(tree_a) <= len(tree_b))\n            active_tree = tree_a if expand_a else tree_b\n            passive_tree = tree_b if expand_a else tree_a\n            active_grid = grid_a if expand_a else grid_b\n            passive_grid = grid_b if expand_a else grid_a\n            attractor = self.goal if expand_a else self.start\n\n            # Radii adapt to tree size\n            n_active = max(2, len(active_tree))\n            parent_radius = self._adaptive_radius(n_active, self.neighbor_base)\n            rewire_radius = self._adaptive_radius(n_active, self.rewire_base)\n            dupe_radius = self.dupe_radius_base * (0.35 if have_solution else 1.0)\n\n            # Sample\n            x_rand = self._sample(attractor, have_solution, best_len, c_min)\n            if x_rand is None:\n                continue\n\n            # Nearest and steer\n            nearest = self._nearest(active_grid, x_rand)\n            if nearest is None:\n                continue\n            x_new = self._steer(nearest.position, x_rand, self.step_size)\n            if self._dist2(nearest.position, x_new) < 1e-10:\n                continue\n            if not self._in_bounds(x_new):\n                continue\n            if self._in_obs(x_new):\n                continue\n            if self._has_nearby(active_grid, x_new, dupe_radius):\n                continue\n\n            # Choose lowest-cost parent among neighbors (ties broken by smoother turn)\n            parent, new_cost = self._choose_parent(active_grid, x_new, nearest, parent_radius)\n            if parent is None:\n                continue\n\n            # Validate both checks before adding\n            if self._in_obs(x_new):\n                continue\n            if not self._edge_free(parent.position, x_new):\n                continue\n\n            # Insert node\n            new_node = Node(x_new, parent, new_cost)\n            parent.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            self._grid_insert(active_grid, new_node)\n\n            # Local rewiring\n            self._rewire(new_node, active_grid, rewire_radius)\n\n            # Try a short, validated bridge\n            bnode = self._best_bridge_candidate(passive_grid, new_node.position, self.connect_radius)\n            bridged = None\n            if bnode is not None and self._edge_free(bnode.position, new_node.position):\n                bridged = bnode\n            else:\n                # One assisted hop on passive tree if allowed\n                hops = 0\n                while bridged is None and hops < self.bridge_hops:\n                    hops += 1\n                    near_p = self._nearest(passive_grid, new_node.position)\n                    if near_p is None:\n                        break\n                    x_step = self._steer(near_p.position, new_node.position, self.step_size)\n                    if not self._in_bounds(x_step) or self._in_obs(x_step):\n                        break\n                    if self._has_nearby(passive_grid, x_step, dupe_radius):\n                        break\n                    # Select parent for the hop\n                    hop_parent, hop_cost = self._choose_parent(passive_grid, x_step, near_p, parent_radius)\n                    if hop_parent is None:\n                        break\n                    if not self._edge_free(hop_parent.position, x_step):\n                        break\n                    # Insert hop node in passive tree\n                    hop_node = Node(x_step, hop_parent, hop_cost)\n                    hop_parent.add_child(hop_node)\n                    passive_tree.append(hop_node)\n                    nodes.append(hop_node)\n                    self._grid_insert(passive_grid, hop_node)\n                    # Light rewiring on passive tree\n                    self._rewire(hop_node, passive_grid, rewire_radius)\n                    # Retry direct bridge\n                    if self._edge_free(hop_node.position, new_node.position):\n                        bridged = hop_node\n                        break\n\n            if bridged is not None:\n                path = self._extract_path(new_node, bridged, expand_a)\n                # Visibility prune then length-nonincreasing shortcuts\n                path = self._visibility_prune(path)\n                path = self._shortcut_nonincreasing(path, self.smooth_iters)\n                best_path = path\n                best_len = self._path_len(path)\n                edges = self._collect_edges(nodes)\n                return PlannerResult(True, best_path, nodes, edges)\n\n            # Optional online smoothing of incumbent (if already found, keep improving lightly)\n            if have_solution and best_path:\n                best_path = self._shortcut_nonincreasing(best_path, 4)\n                best_len = self._path_len(best_path)\n\n        # Finalize\n        edges = self._collect_edges(nodes)\n        if best_path:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # -------------------- RNG --------------------\n    def _seed_rng(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 17) * 2654435761\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # -------------------- Geometry --------------------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        d = d2 ** 0.5\n        if d <= step:\n            q = []\n            for i in range(self.dim):\n                v = b[i]\n                if v < 0.0:\n                    v = 0.0\n                if v > self.bounds[i]:\n                    v = self.bounds[i]\n                q.append(v)\n            return tuple(q)\n        r = step / d\n        q = []\n        for i in range(self.dim):\n            v = a[i] + (b[i] - a[i]) * r\n            if v < 0.0:\n                v = 0.0\n            if v > self.bounds[i]:\n                v = self.bounds[i]\n            q.append(v)\n        return tuple(q)\n\n    # -------------------- Obstacles --------------------\n    def _build_obs_index(self):\n        self.obs_cell = max(3.0, self.step_size * 1.3)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, ob in enumerate(self.obstacles):\n                x, y, z, w, h, d = ob\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, ob in enumerate(self.obstacles):\n                x, y, w, h = ob\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _in_obs(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            b = self.obs_grid.get((cx, cy, cz))\n            if not b:\n                return False\n            px, py, pz = p\n            for idx in b:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            b = self.obs_grid.get((cx, cy))\n            if not b:\n                return False\n            px, py = p\n            for idx in b:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        arr = self.obs_grid.get((cx, cy, cz))\n                        if arr:\n                            for idx in arr:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    arr = self.obs_grid.get((cx, cy))\n                    if arr:\n                        for idx in arr:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # -------------------- Spatial hashing --------------------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _neighbors_within(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        out = []\n        r2 = radius * radius\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_of(pos)\n        best = None\n        bestd2 = 1e100\n        got = False\n        for r in range(0, self.ring_cap + 1):\n            cand = []\n            if self.is_3d:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                            if b:\n                                cand.extend(b)\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy))\n                        if b:\n                            cand.extend(b)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n                    got = True\n            if got:\n                return best\n        # Fallback random probe\n        buckets = list(grid.values())\n        tries = 0\n        while tries < 32 and buckets:\n            b = buckets[int(self._rand_range(0, len(buckets)))]\n            if b:\n                n = b[int(self._rand_range(0, len(b)))]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            tries += 1\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        ns = self._neighbors_within(grid, pos, radius)\n        return len(ns) > 0\n\n    # -------------------- Parent selection and rewiring --------------------\n    def _choose_parent(self, grid, new_pos, fallback, radius):\n        cand = self._neighbors_within(grid, new_pos, radius)\n        if fallback not in cand:\n            cand.append(fallback)\n        best = None\n        best_cost = 1e100\n        best_smooth = -1.0\n        for n in cand:\n            if not self._edge_free(n.position, new_pos):\n                continue\n            c = n.cost + self._dist(n.position, new_pos)\n            if c + 1e-12 < best_cost:\n                best_cost = c\n                best = n\n                best_smooth = self._smooth_score(n, new_pos)\n            elif abs(c - best_cost) <= 1e-12:\n                sc = self._smooth_score(n, new_pos)\n                if sc > best_smooth:\n                    best_smooth = sc\n                    best = n\n        if best is None:\n            return None, None\n        return best, best_cost\n\n    def _smooth_score(self, parent, new_pos):\n        # Cosine of turn angle; higher is smoother. If no grandparent, neutral.\n        if parent.parent is None:\n            return 0.0\n        a = parent.parent.position\n        b = parent.position\n        c = new_pos\n        ab = tuple(b[i] - a[i] for i in range(self.dim))\n        bc = tuple(c[i] - b[i] for i in range(self.dim))\n        nab = self._dist(a, b)\n        nbc = self._dist(b, c)\n        if nab <= 1e-12 or nbc <= 1e-12:\n            return 0.0\n        dot = 0.0\n        for i in range(self.dim):\n            dot += ab[i] * bc[i]\n        cosang = dot / (nab * nbc)\n        if cosang < -1.0:\n            cosang = -1.0\n        if cosang > 1.0:\n            cosang = 1.0\n        return cosang\n\n    def _rewire(self, pivot, grid, radius):\n        neighbors = self._neighbors_within(grid, pivot.position, radius)\n        for nb in neighbors:\n            if nb is pivot or nb.parent is pivot:\n                continue\n            # prevent cycles: if nb is ancestor of pivot, skip\n            if self._is_ancestor(nb, pivot):\n                continue\n            if not self._edge_free(pivot.position, nb.position):\n                continue\n            new_c = pivot.cost + self._dist(pivot.position, nb.position)\n            if new_c + 1e-12 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    try:\n                        oldp.children.remove(nb)\n                    except:\n                        pass\n                pivot.add_child(nb)\n                nb.cost = new_c\n                self._propagate_cost(nb)\n\n    def _is_ancestor(self, node, potential_child):\n        cur = potential_child\n        while cur is not None:\n            if cur is node:\n                return True\n            cur = cur.parent\n        return False\n\n    def _propagate_cost(self, node):\n        # Update subtree costs after rewiring\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if newc + 1e-12 < ch.cost:\n                    ch.cost = newc\n                stack.append(ch)\n\n    # -------------------- Bridging and paths --------------------\n    def _best_bridge_candidate(self, grid_other, pos, radius):\n        cand = self._neighbors_within(grid_other, pos, radius)\n        if not cand:\n            return None\n        best = None\n        bestd2 = 1e100\n        for n in cand:\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd2:\n                bestd2 = d2\n                best = n\n        return best\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node, a_from_start):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if a_from_start:\n            return pa + list(reversed(pb))\n        else:\n            return pb + list(reversed(pa))\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(pruned[-1], path[j]):\n                    # Accept only if not longer than original subpath\n                    seg = self._dist(pruned[-1], path[j])\n                    walk = 0.0\n                    for k in range(i + 1, j + 1):\n                        walk += self._dist(path[k - 1], path[k])\n                    if seg + 1e-9 <= walk:\n                        pruned.append(path[j])\n                        i = j\n                        advanced = True\n                        break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _shortcut_nonincreasing(self, path, iters):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        bestL = self._path_len(pts)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                newL = self._path_len(new_pts)\n                if newL <= bestL + 1e-12:\n                    pts = new_pts\n                    bestL = newL\n        return pts\n\n    def _collect_edges(self, nodes):\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        return edges\n\n    # -------------------- Sampling --------------------\n    def _sample(self, attractor, informed, best_len, c_min):\n        r = self._rand()\n        if informed and best_len < 1e99 and r < self.informed_bias:\n            p = self._informed_sample(self.start, self.goal, best_len * 1.01, c_min)\n            if p is not None and self._in_bounds(p) and not self._in_obs(p):\n                return p\n        if r < self.goal_bias:\n            p = attractor\n            return p if self._in_bounds(p) and not self._in_obs(p) else None\n        # Uniform\n        p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n        if self._in_bounds(p) and not self._in_obs(p):\n            return p\n        return None\n\n    def _informed_sample(self, f1, f2, c_best, c_min):\n        if not (c_best > c_min + 1e-9):\n            return None\n        center = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        a_vec = tuple(f2[i] - f1[i] for i in range(self.dim))\n        a_len = self._dist((0.0,) * self.dim, a_vec)\n        if a_len <= 1e-12:\n            return None\n        a_hat = tuple(a_vec[i] / a_len for i in range(self.dim))\n        r1 = 0.5 * c_best\n        r2_sq = max(0.0, 0.25 * (c_best * c_best - c_min * c_min))\n        if self.is_3d:\n            # Build orthonormal basis [a_hat, v, w]\n            # Simple fixed aux and cross to form basis\n            u = (1.0, 0.0, 0.0) if abs(a_hat[0]) < 0.9 else (0.0, 1.0, 0.0)\n            v = self._normalize(self._cross(a_hat, u))\n            w = self._cross(a_hat, v)\n            for _ in range(32):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                z = self._rand_range(-1.0, 1.0)\n                if x * x + y * y + z * z > 1.0:\n                    continue\n                px = r1 * x\n                r2 = (r2_sq ** 0.5)\n                py = r2 * y\n                pz = r2 * z\n                ex = center[0] + px * a_hat[0] + py * v[0] + pz * w[0]\n                ey = center[1] + px * a_hat[1] + py * v[1] + pz * w[1]\n                ez = center[2] + px * a_hat[2] + py * v[2] + pz * w[2]\n                p = (ex, ey, ez)\n                if self._in_bounds(p) and not self._in_obs(p):\n                    return p\n            return None\n        else:\n            # 2D ellipse with axes r1, r2\n            perp = (-a_hat[1], a_hat[0])\n            for _ in range(32):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                if x * x + y * y > 1.0:\n                    continue\n                r2 = (r2_sq ** 0.5)\n                px = r1 * x\n                py = r2 * y\n                ex = center[0] + px * a_hat[0] + py * perp[0]\n                ey = center[1] + px * a_hat[1] + py * perp[1]\n                p = (ex, ey)\n                if self._in_bounds(p) and not self._in_obs(p):\n                    return p\n            return None\n\n    def _normalize(self, v):\n        n = self._dist((0.0,) * len(v), v)\n        if n <= 1e-12:\n            return v\n        return tuple(v[i] / n for i in range(len(v)))\n\n    def _cross(self, a, b):\n        return (a[1] * b[2] - a[2] * b[1],\n                a[2] * b[0] - a[0] * b[2],\n                a[0] * b[1] - a[1] * b[0])\n\n    # -------------------- Radii --------------------\n    def _adaptive_radius(self, n, base_mult):\n        # Decays with n; lower-bounded by 1.5*step_size\n        decay = (1.0 / (n ** (1.0 / max(2, self.dim))))\n        r = base_mult * self.step_size * 0.5 + self.space_extent * 0.05 * decay\n        return max(1.5 * self.step_size, r)",
          "objective": -40.1344,
          "time_improvement": 63.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1814.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012674951553344726,
                    "num_nodes_avg": 45.0,
                    "path_length_avg": 153.35894992834636,
                    "smoothness_avg": 0.03846541732582647,
                    "success_improvement": 0.0,
                    "time_improvement": 48.6246954693179,
                    "node_improvement": 88.66784185343742,
                    "length_improvement": 15.941529416200709,
                    "smoothness_improvement": 502.0673101398352,
                    "objective_score": 26.66266284121497
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05657989978790283,
                    "num_nodes_avg": 140.0,
                    "path_length_avg": 233.83827885399037,
                    "smoothness_avg": 0.11832797178444796,
                    "success_improvement": 0.0,
                    "time_improvement": 66.17078448590458,
                    "node_improvement": 90.5932943626957,
                    "length_improvement": 21.93805185687287,
                    "smoothness_improvement": 2944.6639422069725,
                    "objective_score": 47.73738617092995
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013706851005554199,
                    "num_nodes_avg": 79.0,
                    "path_length_avg": 115.01768024557694,
                    "smoothness_avg": 0.16483033391240323,
                    "success_improvement": 0.0,
                    "time_improvement": 72.84520158496316,
                    "node_improvement": 89.95549904640814,
                    "length_improvement": 23.61073333426484,
                    "smoothness_improvement": 1996.6296808560942,
                    "objective_score": 46.003148880328325
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "FENRIR-Connect: A fast, cost-aware BiRRT*-Connect variant with spatial hashing for nodes and obstacles, adaptive neighbor radius, duplicate suppression, and exact seam insertion. It prioritizes early direct-visibility connections, chooses lowest-cost parents, incrementally rewires local neighbors, and finishes with light visibility pruning plus a few randomized shortcuts for short, smooth paths at low planning time.",
          "planning_mechanism": "Alternate expansion from start and goal: sample (goal-biased; informed ellipse after first path), steer one step, pick the best-cost parent within an adaptive radius, add only if node and edge are collision-free, locally rewire cheaper neighbors, then greedily connect the opposite tree and insert the exact meeting point if visible; upon connection, extract and finalize the path via visibility pruning and brief shortcut smoothing, then return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=5.5,\n        connect_mult=2.2,\n        goal_bias=0.14,\n        grid_cell_factor=1.8,\n        rewire_base=2.6,\n        dup_radius_factor=0.35,\n        smooth_attempts=120\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_step = float(step_size * connect_mult)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.rewire_base = float(rewire_base)\n        self.dup_factor = float(dup_radius_factor)\n        self.smooth_attempts = int(max(0, smooth_attempts))\n        self._rng = 88172645463393265 % (1 << 32)\n\n    # ------------------ Public API ------------------\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n\n        # Spatial params\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_radius = max(0.5, self.dup_factor * self.step)\n\n        # Build obstacle bins\n        self._build_obs_bins()\n\n        # Start/goal validity\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Direct visibility\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            final = self._finalize_path(path)\n            return PlannerResult(True, final, nodes, edges)\n\n        # Initialize trees and node grids\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        Ta, Tb = [root_a], [root_b]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, root_a)\n        self._grid_add(Gb, root_b)\n        nodes.extend([root_a, root_b])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            # Alternate expansion\n            active_from_start = (it % 2 == 0)\n            tree = Ta if active_from_start else Tb\n            other_tree = Tb if active_from_start else Ta\n            grid = Ga if active_from_start else Gb\n            other_grid = Gb if active_from_start else Ga\n            attractor = self.goal if active_from_start else self.start\n\n            s = self._sample(attractor, best_len)\n            if s is None:\n                continue\n\n            near = self._nearest(grid, s)\n            if near is None:\n                continue\n\n            newp = self._steer(near.position, s, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(grid, newp, self.dup_radius):\n                continue\n\n            # Parent selection within adaptive radius\n            radius = self._rewire_radius(len(tree))\n            parent, new_cost = self._best_parent(grid, near, newp, radius)\n            if parent is None:\n                continue\n\n            # Strict checks before adding node/edge\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, new_cost)\n            parent.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(grid, nn)\n\n            # Local rewiring\n            self._rewire_neighbors(grid, nn, radius, edges)\n\n            # Greedy connect other tree toward nn; insert exact meeting if visible\n            meet, reached = self._connect_toward(other_tree, other_grid, nn.position, nodes, edges)\n            if reached:\n                if active_from_start:\n                    pa = self._trace_to_root(nn)        # start -> ... -> meet\n                    pb = self._trace_to_root(meet)      # goal  -> ... -> meet\n                    path = pa + pb[-2::-1]\n                else:\n                    pa = self._trace_to_root(meet)      # start -> ... -> meet\n                    pb = self._trace_to_root(nn)        # goal  -> ... -> meet\n                    path = pa + pb[-2::-1]\n\n                path = self._dedup(path)\n                best_len = self._path_len(path)\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # ------------------ RNG ------------------\n    def _seed_from_scene(self):\n        s = 2166136261 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= q\n            s = (s * 16777619) & 0xffffffff\n        s ^= ((len(self.obstacles) + 97) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        # 32-bit LCG\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------------ Geometry ------------------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a[i] for i in range(self.dim))\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # ------------------ Spatial hash (nodes) ------------------\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, ring):\n        out = []\n        if self.is3:\n            for dx in range(-ring, ring + 1):\n                for dy in range(-ring, ring + 1):\n                    for dz in range(-ring, ring + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-ring, ring + 1):\n                for dy in range(-ring, ring + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        k = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        for r in range(0, 4):\n            cand = self._grid_collect(grid, k, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found = True\n            if found:\n                return best\n        # fallback scan\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_radius(self, grid, pos, radius):\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        k = self._cell_key(pos)\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((k[0] + dx, k[1] + dy, k[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((k[0] + dx, k[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        neigh = self._neighbors_radius(grid, pos, radius)\n        return len(neigh) > 0\n\n    # ------------------ Obstacles and collision ------------------\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.25)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        # Collect candidate obstacles via bin bounds\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_overlap(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_overlap(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_overlap(self, p0, p1, bmin, bmax):\n        # Slab method\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            q = p1[i]\n            d = q - p\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t0 = (mn - p) * inv\n                t1 = (mx - p) * inv\n                if t0 > t1:\n                    tt = t0\n                    t0 = t1\n                    t1 = tt\n                if t0 > tmin:\n                    tmin = t0\n                if t1 < tmax:\n                    tmax = t1\n                if tmin > tmax:\n                    return False\n        return True\n\n    # ------------------ Parenting and rewiring ------------------\n    def _rewire_radius(self, n_nodes):\n        # Smooth decay with tree size; keep generous early radius\n        base = max(self.step * 1.5, self.step * self.rewire_base)\n        scale = 1.0 / (1.0 + 0.002 * n_nodes)\n        # dimension-aware shrink\n        exp = 1.0 / float(self.dim if self.dim > 0 else 1)\n        r = base * (scale ** exp)\n        return max(self.step * 1.25, r)\n\n    def _best_parent(self, grid, near, newp, radius):\n        parent = None\n        best = 1e100\n        neigh = self._neighbors_radius(grid, newp, radius)\n        if not neigh:\n            neigh = [near]\n        for n in neigh:\n            if not self._edge_free(n.position, newp):\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c < best:\n                best = c\n                parent = n\n        return parent, best if parent is not None else (None, None)\n\n    def _rewire_neighbors(self, grid, pivot, radius, edges):\n        neigh = self._neighbors_radius(grid, pivot.position, radius)\n        for nb in neigh:\n            if nb is pivot or nb.parent is None:\n                continue\n            cand = pivot.cost + self._dist(pivot.position, nb.position)\n            if cand + 1e-12 < nb.cost and self._edge_free(pivot.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, (oldp, nb))\n                pivot.add_child(nb)\n                nb.cost = cand\n                edges.append((pivot, nb))\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _remove_edge(self, edges, e):\n        # remove first match\n        for i in range(len(edges)):\n            if edges[i][0] is e[0] and edges[i][1] is e[1]:\n                edges.pop(i)\n                return\n\n    # ------------------ Connect other tree ------------------\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n\n        # Direct connect if visible\n        if self._edge_free(cur.position, target_pos):\n            # Insert exact meeting if not too close\n            if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    nc = Node(target_pos, cur, cur.cost + self._dist(cur.position, target_pos))\n                    cur.add_child(nc)\n                    tree.append(nc)\n                    nodes.append(nc)\n                    edges.append((cur, nc))\n                    self._grid_add(grid, nc)\n                    return nc, True\n            return cur, True\n\n        # Greedy bounded stepping\n        steps = 0\n        limit = 64\n        here = cur\n        while steps < limit:\n            nxt = self._steer(here.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                break\n            if not self._edge_free(here.position, nxt):\n                break\n            if self._too_close(grid, nxt, self.dup_radius * 0.75):\n                break\n            nn = Node(nxt, here, here.cost + self._dist(here.position, nxt))\n            here.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((here, nn))\n            self._grid_add(grid, nn)\n            here = nn\n            steps += 1\n            if self._edge_free(here.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                    if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                        meet = Node(target_pos, here, here.cost + self._dist(here.position, target_pos))\n                        here.add_child(meet)\n                        tree.append(meet)\n                        nodes.append(meet)\n                        edges.append((here, meet))\n                        self._grid_add(grid, meet)\n                        return meet, True\n                return here, True\n\n        # Final direct try\n        if self._edge_free(here.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    meet = Node(target_pos, here, here.cost + self._dist(here.position, target_pos))\n                    here.add_child(meet)\n                    tree.append(meet)\n                    nodes.append(meet)\n                    edges.append((here, meet))\n                    self._grid_add(grid, meet)\n                    return meet, True\n            return here, True\n\n        return here, False\n\n    # ------------------ Sampling ------------------\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.6:\n            p = self._sample_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            if self._in_bounds(attractor) and (not self._point_in_obstacles(attractor)):\n                return attractor\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(32):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum + 1e-9:\n                return p\n        return None\n\n    # ------------------ Path utilities ------------------\n    def _trace_to_root(self, node):\n        cur = node\n        pts = []\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        n = len(cur)\n        tries = 0\n        while tries < attempts and n > 2:\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cur = cur[:i + 1] + cur[j:]\n                n = len(cur)\n            tries += 1\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._visibility_prune(path)\n        p1 = self._shortcut(p0, max(20, self.smooth_attempts))\n        p2 = self._visibility_prune(p1)\n        return self._dedup(p2)",
          "objective": -40.03655,
          "time_improvement": 75.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1190.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.00911562442779541,
                    "num_nodes_avg": 42.0,
                    "path_length_avg": 160.0835385997664,
                    "smoothness_avg": 0.0506179669795133,
                    "success_improvement": 0.0,
                    "time_improvement": 63.051694596676235,
                    "node_improvement": 89.42331906320827,
                    "length_improvement": 12.255675807468933,
                    "smoothness_improvement": 692.2811019039884,
                    "objective_score": 29.73031937300417
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02603757381439209,
                    "num_nodes_avg": 162.0,
                    "path_length_avg": 231.3416199523067,
                    "smoothness_avg": 0.08683134390642434,
                    "success_improvement": 0.0,
                    "time_improvement": 84.43209162029012,
                    "node_improvement": 89.11509776254786,
                    "length_improvement": 22.77150846059685,
                    "smoothness_improvement": 2134.233020801344,
                    "objective_score": 49.66369766645187
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010724067687988281,
                    "num_nodes_avg": 75.0,
                    "path_length_avg": 117.01222962601585,
                    "smoothness_avg": 0.06631602341986054,
                    "success_improvement": 0.0,
                    "time_improvement": 78.75442753856959,
                    "node_improvement": 90.46408137317228,
                    "length_improvement": 22.286048606012514,
                    "smoothness_improvement": 743.5349229609544,
                    "objective_score": 40.715632039983156
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SAGE-Connect: A simplified adaptive BiRRT-Connect with local cost-aware parenting and light rewiring. It uses a uniform spatial hash for nearest/neighbor queries, coarse obstacle binning for fast collision checks, adaptive rewire radius, and minimal biased/informed sampling. It inserts only strictly node- and edge-free states, creates the exact meeting node to reduce kinks, and applies a compact densify+shortcut+visibility smoother for short, smooth paths.",
          "planning_mechanism": "Alternate growth from start/goal trees: sample (uniform with small goal bias; ellipse after first solution), steer one step, choose the best-cost parent among nearby nodes, add after node+edge checks, locally rewire cheaper neighbors, then greedily extend the opposite tree toward the new node and insert the exact meeting point; upon connection, extract, densify, shortcut, visibility-prune, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=6.0,\n        connect_mult=2.0,\n        goal_bias=0.12,\n        grid_cell_factor=1.6,\n        rewire_base=2.2,\n        smooth_iters=120\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_mult = float(connect_mult)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.rewire_base = float(rewire_base)\n        self.smooth_iters = int(max(0, smooth_iters))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.connect_step = max(self.step, self.step * self.connect_mult)\n        self.dup_radius = max(0.5, 0.4 * self.step)\n\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            Ta = tree_a if active_start else tree_b\n            Tb = tree_b if active_start else tree_a\n            Ga = grid_a if active_start else grid_b\n            Gb = grid_b if active_start else grid_a\n            attractor = self.goal if active_start else self.start\n\n            sample = self._sample(attractor, best_len)\n            if sample is None:\n                continue\n\n            na = self._nearest(Ga, sample)\n            if na is None:\n                continue\n\n            newp = self._steer(na.position, sample, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(Ga, newp, self.dup_radius):\n                continue\n            if not self._edge_free(na.position, newp):\n                continue\n\n            rew_rad = self._adaptive_rewire_radius(len(Ta))\n            parent, new_cost = self._choose_parent(Ga, newp, na, rew_rad)\n\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, new_cost)\n            parent.add_child(nn)\n            Ta.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(Ga, nn)\n\n            self._local_rewire(Ga, nn, rew_rad, edges)\n\n            meet_node, reached = self._connect_toward(Tb, Gb, nn.position, nodes, edges)\n            if reached:\n                if active_start:\n                    pa = self._trace_to_root(nn)        # start -> ... -> nn\n                    pb = self._trace_to_root(meet_node) # goal  -> ... -> nn\n                    path = pa + pb[-2::-1]              # avoid duplicate nn\n                else:\n                    pa = self._trace_to_root(meet_node) # start -> ... -> nn\n                    pb = self._trace_to_root(nn)        # goal  -> ... -> nn\n                    path = pa + pb[-2::-1]\n\n                path = self._dedup(path)\n                best_len = self._path_len(path)\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0x9E3779B9 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= (q ^ (q >> 13) ^ ((q << 7) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 13) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial hash\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found_any = False\n        for r in range(0, 4):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found_any = True\n            if found_any:\n                return best\n        # fallback\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors_in_radius(grid, pos, radius)) > 0\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.2)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Parenting and rewiring\n    def _choose_parent(self, grid, newp, fallback, radius):\n        parent = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        neigh = self._neighbors_in_radius(grid, newp, radius)\n        for n in neigh:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                parent = n\n                best_cost = c\n        return parent, best_cost\n\n    def _local_rewire(self, grid, nn, radius, edges):\n        neigh = self._neighbors_in_radius(grid, nn.position, radius)\n        for nb in neigh:\n            if nb is nn or nb is nn.parent:\n                continue\n            cand = nn.cost + self._dist(nn.position, nb.position)\n            if cand + 1e-12 < nb.cost and self._edge_free(nn.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, (oldp, nb))\n                nn.add_child(nb)\n                nb.cost = cand\n                edges.append((nn, nb))\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _remove_edge(self, edges, e):\n        try:\n            idx = edges.index(e)\n            edges.pop(idx)\n        except:\n            pass\n\n    def _adaptive_rewire_radius(self, n_nodes):\n        # Shrink with tree size without log; simple exponential decay\n        base = max(self.step * 1.2, self.step * self.rewire_base)\n        decay = pow(0.5, n_nodes / 2500.0)\n        return max(self.step * 1.2, base * decay)\n\n    # BiRRT-Connect growth from other tree toward target; insert exact meeting node if visible\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < 64:\n            if self._edge_free(cur.position, target_pos):\n                # Insert the exact meeting point for a clean junction\n                if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                    if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        cur.add_child(nn)\n                        tree.append(nn)\n                        nodes.append(nn)\n                        edges.append((cur, nn))\n                        self._grid_add(grid, nn)\n                        return nn, True\n                # If too close, treat current as meeting node\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            if self._too_close(grid, nxt, self.dup_radius * 0.75):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n        # Final try after capped steps\n        if self._edge_free(cur.position, target_pos):\n            if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    cur.add_child(nn)\n                    tree.append(nn)\n                    nodes.append(nn)\n                    edges.append((cur, nn))\n                    self._grid_add(grid, nn)\n                    return nn, True\n            return cur, True\n        return cur, False\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.55:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Path utilities\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _densify(self, pts, seg_len):\n        if len(pts) < 2:\n            return pts[:]\n        out = [pts[0]]\n        for i in range(1, len(pts)):\n            a = out[-1]\n            b = pts[i]\n            d = self._dist(a, b)\n            if d <= seg_len * 1.05:\n                out.append(b)\n                continue\n            nseg = int(d / seg_len)\n            if nseg < 1:\n                out.append(b)\n                continue\n            for k in range(1, nseg + 1):\n                t = k / float(nseg + 1)\n                inter = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n                if self._edge_free(out[-1], inter):\n                    out.append(inter)\n                else:\n                    break\n            if self._edge_free(out[-1], b):\n                out.append(b)\n            else:\n                out.append(b)\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._densify(path, seg_len=max(1.0, 0.5 * self.step))\n        p1 = self._shortcut(p0, self.smooth_iters)\n        p2 = self._visibility_prune(p1)\n        p3 = self._shortcut(p2, max(20, self.smooth_iters // 2))\n        return self._dedup(p3)",
          "objective": -39.95809,
          "time_improvement": 69.0,
          "length_improvement": 21.0,
          "smoothness_improvement": 1361.0,
          "node_improvement": 85.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008446240425109863,
                    "num_nodes_avg": 40.0,
                    "path_length_avg": 154.00203649529243,
                    "smoothness_avg": 0.0463463750398735,
                    "success_improvement": 0.0,
                    "time_improvement": 65.76490472936995,
                    "node_improvement": 89.92697053638882,
                    "length_improvement": 15.589043478498803,
                    "smoothness_improvement": 625.4214121382626,
                    "objective_score": 32.21000456660158
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02304682731628418,
                    "num_nodes_avg": 136.0,
                    "path_length_avg": 230.09301068249903,
                    "smoothness_avg": 0.08849989105200873,
                    "success_improvement": 0.0,
                    "time_improvement": 86.220263890156,
                    "node_improvement": 90.86205738090439,
                    "length_improvement": 23.188330174083777,
                    "smoothness_improvement": 2177.1659406631616,
                    "objective_score": 50.66490697481287
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02282891273498535,
                    "num_nodes_avg": 204.0,
                    "path_length_avg": 115.03810237530747,
                    "smoothness_avg": 0.10863321186734835,
                    "success_improvement": 0.0,
                    "time_improvement": 54.77338134763434,
                    "node_improvement": 74.06230133502861,
                    "length_improvement": 23.597169928095134,
                    "smoothness_improvement": 1281.8064364830614,
                    "objective_score": 36.99934854356269
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "BLITZ-BiRRT: Ultra-fast bidirectional RRT-Connect with hashed k-nearest parenting, single-hop connection, and capped leaf-only rewiring. It minimizes work per iteration, avoids chain growth in the passive tree, uses fast-decaying neighbor radii, and finishes with quick visibility pruning and few shortcuts.",
          "planning_mechanism": "Alternate expansions from start and goal: sample with goal/informed bias, steer one step, pick the best parent among k local hashed neighbors, insert after node and edge checks, optionally rewire a few leaf neighbors, then attempt a single line-of-sight connect from the opposite tree by inserting only the exact meeting node. On success, extract and quickly prune/shortcut the path; else continue.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=7.5,\n        goal_bias=0.2,\n        grid_cell_factor=1.6,\n        k_near=8,\n        ring_cap=2,\n        rewire_k=3,\n        smooth_iters=50\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.k_near = int(max(1, k_near))\n        self.ring_cap = int(max(1, ring_cap))\n        self.rewire_k = int(max(0, rewire_k))\n        self.smooth_iters = int(max(0, smooth_iters))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_radius = max(0.5, 0.45 * self.step)\n\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            Ta = tree_a if active_start else tree_b\n            Tb = tree_b if active_start else tree_a\n            Ga = grid_a if active_start else grid_b\n            Gb = grid_b if active_start else grid_a\n            attractor = self.goal if active_start else self.start\n\n            sample = self._sample(attractor, best_len)\n            if sample is None:\n                continue\n\n            near = self._nearest_limited(Ga, sample)\n            if near is None:\n                continue\n\n            newp = self._steer(near.position, sample, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(Ga, newp, self.dup_radius):\n                continue\n\n            parent, pcost = self._choose_parent_knn(Ga, newp, near, len(Ta))\n            if parent is None:\n                continue\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, pcost)\n            parent.add_child(nn)\n            Ta.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(Ga, nn)\n\n            if self.rewire_k > 0:\n                self._leaf_rewire(Ga, nn, self.rewire_k, edges)\n\n            meet_node, reached = self._try_direct_connect(Tb, Gb, nn.position, nodes, edges)\n            if reached:\n                if active_start:\n                    pa = self._trace_to_root(nn)\n                    pb = self._trace_to_root(meet_node)\n                    path = pa + pb[-2::-1]\n                else:\n                    pa = self._trace_to_root(meet_node)\n                    pb = self._trace_to_root(nn)\n                    path = pa + pb[-2::-1]\n\n                path = self._dedup(path)\n                best_len = self._path_len(path)\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0x9E3779B9 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= (q ^ (q >> 13) ^ ((q << 7) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 17) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(min(max(a[i], 0.0), self.bounds[i]) for i in range(self.dim))\n        if d2 <= step * step:\n            tgt = b\n        else:\n            d = d2 ** 0.5\n            r = step / d\n            tgt = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n        return tuple(min(max(tgt[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # Spatial hash grid\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest_limited(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        for r in range(0, self.ring_cap + 1):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found = True\n            if found:\n                return best\n        # fallback limited scan\n        cnt = 0\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                cnt += 1\n                if cnt >= 128:\n                    return best\n        return best\n\n    def _k_nearest_limited(self, grid, pos, k):\n        key = self._cell_key(pos)\n        cand = []\n        for r in range(0, self.ring_cap + 1):\n            cand.extend(self._grid_collect_ring(grid, key, r))\n            if len(cand) >= k:\n                break\n        if len(cand) < k:\n            for lst in grid.values():\n                cand.extend(lst)\n                if len(cand) >= 4 * k:\n                    break\n        # select k closest\n        scored = []\n        seen = set()\n        for n in cand:\n            if n in seen:\n                continue\n            seen.add(n)\n            scored.append((self._dist2(n.position, pos), n))\n        scored.sort(key=lambda x: x[0])\n        out = []\n        for i in range(min(k, len(scored))):\n            out.append(scored[i][1])\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell) + 1)\n        r2 = radius * radius\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                return True\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            return True\n        return False\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.2)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Parenting and lightweight rewiring\n    def _parent_radius(self, n_nodes):\n        base = self.step * 2.0\n        decay = pow(0.35, n_nodes / 2000.0)\n        return max(self.step * 1.1, base * decay)\n\n    def _choose_parent_knn(self, grid, newp, fallback, n_nodes):\n        cand = self._k_nearest_limited(grid, newp, self.k_near)\n        if fallback not in cand:\n            cand.append(fallback)\n        scored = []\n        for n in cand:\n            c = n.cost + self._dist(n.position, newp)\n            scored.append((c, n))\n        scored.sort(key=lambda x: x[0])\n        for c, n in scored:\n            if self._edge_free(n.position, newp):\n                return n, c\n        # fallback if none visible\n        if self._edge_free(fallback.position, newp):\n            return fallback, fallback.cost + self._dist(fallback.position, newp)\n        return None, 0.0\n\n    def _leaf_rewire(self, grid, nn, k, edges):\n        neigh = self._k_nearest_limited(grid, nn.position, k + 2)\n        for nb in neigh:\n            if nb is nn or nb is nn.parent:\n                continue\n            if len(nb.children) != 0:\n                continue\n            cand_cost = nn.cost + self._dist(nn.position, nb.position)\n            if cand_cost + 1e-12 < nb.cost and self._edge_free(nn.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, (oldp, nb))\n                nn.add_child(nb)\n                nb.cost = cand_cost\n                edges.append((nn, nb))\n\n    def _remove_edge(self, edges, e):\n        try:\n            idx = edges.index(e)\n            edges.pop(idx)\n        except:\n            pass\n\n    # Single-hop connect\n    def _try_direct_connect(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest_limited(grid, target_pos)\n        if cur is None:\n            return None, False\n        if self._edge_free(cur.position, target_pos):\n            if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    cur.add_child(nn)\n                    tree.append(nn)\n                    nodes.append(nn)\n                    edges.append((cur, nn))\n                    self._grid_add(grid, nn)\n                    return nn, True\n                return cur, True\n        return cur, False\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.6:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(20):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Path utilities\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._visibility_prune(path)\n        p2 = self._shortcut(p1, self.smooth_iters)\n        return self._dedup(p2)",
          "objective": -39.63489,
          "time_improvement": 74.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1481.0,
          "node_improvement": 91.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0037497520446777345,
                    "num_nodes_avg": 34.0,
                    "path_length_avg": 158.58377479850697,
                    "smoothness_avg": 0.06862027615570403,
                    "success_improvement": 0.0,
                    "time_improvement": 84.80115269876273,
                    "node_improvement": 91.4379249559305,
                    "length_improvement": 13.07772011221747,
                    "smoothness_improvement": 974.0563331514488,
                    "objective_score": 38.157259542716545
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028076863288879393,
                    "num_nodes_avg": 111.0,
                    "path_length_avg": 232.17028789754096,
                    "smoothness_avg": 0.0872747392675918,
                    "success_improvement": 0.0,
                    "time_improvement": 83.21279707599672,
                    "node_improvement": 92.54182624470873,
                    "length_improvement": 22.494875248593353,
                    "smoothness_improvement": 2145.641902808952,
                    "objective_score": 49.18897378599979
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02327275276184082,
                    "num_nodes_avg": 98.0,
                    "path_length_avg": 128.55489761473706,
                    "smoothness_avg": 0.11192261290302685,
                    "success_improvement": 0.0,
                    "time_improvement": 53.89408482264104,
                    "node_improvement": 87.53973299427845,
                    "length_improvement": 14.619958130688596,
                    "smoothness_improvement": 1323.6473748585636,
                    "objective_score": 31.55843719949829
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "FALCON-IRRTConnect: Fast Adaptive Local-Optimal RRT-Connect with hashed neighbors and obstacle-binned collisions. It couples rapid bidirectional connect growth for early success with light, radius-limited RRT*-style parent selection and bounded local rewiring. Coarse obstacle binning and cached segment tests cut collision cost; a uniform grid hash enables sublinear nearest/neighbor queries. After a connection, a compact shortcut + visibility + elastic refinement shortens and smooths the path.",
          "planning_mechanism": "Alternate expanding start/goal trees: sample (goal/informed biased), steer one step, pick best-cost parent from nearby nodes, add only if node- and edge-free, and locally rewire cheaper neighbors. Then greedily extend the opposite tree toward the new node, inserting the exact meeting node when visible. On success, extract the path and run shortcut, visibility prune, and elastic smoothing; return the improved path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5200,\n        step_size=5.5,\n        connect_mult=2.4,\n        goal_bias=0.14,\n        grid_cell_factor=1.5,\n        dup_radius_factor=0.38,\n        rewire_base=2.0,\n        rewire_decay=3200.0,\n        neighbor_cap=14,\n        smooth_iters=140,\n        elastic_sweeps=20\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_step = float(connect_mult) * self.step\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dup_radius_factor = float(dup_radius_factor)\n        self.rewire_base = float(rewire_base)\n        self.rewire_decay = float(rewire_decay)\n        self.neighbor_cap = int(neighbor_cap)\n        self.smooth_iters = int(max(0, smooth_iters))\n        self.elastic_sweeps = int(max(0, elastic_sweeps))\n        self._rng = 123456789\n\n    # --------- Public API ----------\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        # RNG seed from scene\n        self._seed_from_scene()\n\n        # Spatial hashing and parameters\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_radius = max(0.5, self.dup_radius_factor * self.step)\n\n        # Collision acceleration and caches\n        self._build_obs_bins()\n        self._edge_cache = {}  # canonical (a,b) -> bool (True if hits obstacle)\n        self._free_cache = {}  # canonical (a,b) -> bool (True if free)\n\n        # Validate start and goal\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight-line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            final = self._finalize_path(path)\n            return PlannerResult(True, final, nodes, edges)\n\n        # Initialize trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        Ta, Tb = [start_root], [goal_root]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, start_root)\n        self._grid_add(Gb, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = Ta if active_start else Tb\n            tree_b = Tb if active_start else Ta\n            grid_a = Ga if active_start else Gb\n            grid_b = Gb if active_start else Ga\n            attractor = self.goal if active_start else self.start\n\n            # Sampling with goal and informed elliptical bias\n            sample = self._sample(attractor, best_len)\n            if sample is None:\n                continue\n\n            # Nearest and steer\n            na = self._nearest(grid_a, sample)\n            if na is None:\n                continue\n            newp = self._steer(na.position, sample, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(grid_a, newp, self.dup_radius):\n                continue\n            # Edge collision check parent->newp before adding\n            if not self._edge_free(na.position, newp):\n                continue\n\n            # Cost-aware parent selection within adaptive radius\n            rew_rad = self._adaptive_rewire_radius(len(tree_a))\n            parent, new_cost = self._choose_parent(grid_a, newp, na, rew_rad)\n\n            # Validate chosen parent again (node+edge)\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._in_bounds(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            # Insert node\n            nn = Node(newp, parent, new_cost)\n            parent.add_child(nn)\n            tree_a.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(grid_a, nn)\n\n            # Local bounded rewiring\n            self._local_rewire(grid_a, nn, rew_rad, edges, cap=self.neighbor_cap)\n\n            # Try to greedily connect opposite tree toward new point\n            meet_node, reached = self._connect_toward(tree_b, grid_b, nn.position, nodes, edges)\n            if reached:\n                # Build full path with exact meeting node if inserted\n                if active_start:\n                    pa = self._trace_to_root(nn)\n                    pb = self._trace_to_root(meet_node)\n                    path = pa + pb[-2::-1]\n                else:\n                    pa = self._trace_to_root(meet_node)\n                    pb = self._trace_to_root(nn)\n                    path = pa + pb[-2::-1]\n\n                path = self._dedup(path)\n                best_len = self._path_len(path)\n\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # --------- RNG ----------\n    def _seed_from_scene(self):\n        s = 0x9E3779B9 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= (q ^ (q >> 13) ^ ((q << 7) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 17) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # --------- Geometry ----------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # --------- Spatial hash ----------\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        for r in range(0, 4):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found = True\n            if found:\n                return best\n        # fallback scan\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius, cap=None):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n                                if cap is not None and len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n                            if cap is not None and len(out) >= cap:\n                                return out\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        nb = self._neighbors_in_radius(grid, pos, radius, cap=1)\n        return len(nb) > 0\n\n    # --------- Obstacles / collision ----------\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.2)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy1, iy0 - 1, -1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        key = self._canon_seg(a, b)\n        val = self._free_cache.get(key)\n        if val is not None:\n            return val\n        blk = self._edge_hits_any(a, b)\n        res = not blk\n        self._free_cache[key] = res\n        self._edge_cache[key] = blk\n        return res\n\n    def _edge_hits_any(self, a, b):\n        key = self._canon_seg(a, b)\n        cached = self._edge_cache.get(key)\n        if cached is not None:\n            return cached\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                self._edge_cache[key] = False\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    self._edge_cache[key] = True\n                    return True\n            self._edge_cache[key] = False\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                self._edge_cache[key] = False\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    self._edge_cache[key] = True\n                    return True\n            self._edge_cache[key] = False\n            return False\n\n    def _canon_seg(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # --------- Parenting / rewiring ----------\n    def _adaptive_rewire_radius(self, n_nodes):\n        base = max(self.step * 1.2, self.step * self.rewire_base)\n        decay = pow(0.5, n_nodes / max(1.0, self.rewire_decay))\n        return max(self.step * 1.2, base * decay)\n\n    def _choose_parent(self, grid, newp, fallback, radius):\n        parent = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        neigh = self._neighbors_in_radius(grid, newp, radius, cap=self.neighbor_cap * 2)\n        for n in neigh:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                parent = n\n                best_cost = c\n        return parent, best_cost\n\n    def _local_rewire(self, grid, nn, radius, edges, cap=14):\n        neigh = self._neighbors_in_radius(grid, nn.position, radius, cap=cap)\n        for nb in neigh:\n            if nb is nn or nb is nn.parent:\n                continue\n            cand_cost = nn.cost + self._dist(nn.position, nb.position)\n            if cand_cost + 1e-12 < nb.cost and self._edge_free(nn.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, (oldp, nb))\n                nn.add_child(nb)\n                nb.cost = cand_cost\n                edges.append((nn, nb))\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _remove_edge(self, edges, e):\n        try:\n            idx = edges.index(e)\n            edges.pop(idx)\n        except:\n            pass\n\n    # --------- BiRRT-Connect toward target ----------\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < 64:\n            # If direct visibility, insert exact meeting node if valid\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                    if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        # Ensure node and edge checks before adding\n                        if (not self._point_in_obstacles(nn.position)) and self._edge_free(cur.position, nn.position):\n                            cur.add_child(nn)\n                            tree.append(nn)\n                            nodes.append(nn)\n                            edges.append((cur, nn))\n                            self._grid_add(grid, nn)\n                            return nn, True\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if self._too_close(grid, nxt, self.dup_radius * 0.75):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            # Checks before adding (node+edge already ensured above)\n            if self._point_in_obstacles(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                return cur, False\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n        # Final visibility attempt\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    if (not self._point_in_obstacles(nn.position)) and self._edge_free(cur.position, nn.position):\n                        cur.add_child(nn)\n                        tree.append(nn)\n                        nodes.append(nn)\n                        edges.append((cur, nn))\n                        self._grid_add(grid, nn)\n                        return nn, True\n            return cur, True\n        return cur, False\n\n    # --------- Sampling ----------\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.6:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(28):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # --------- Path utilities ----------\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _elastic_refine(self, pts, sweeps):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(sweeps):\n            changed = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                b = cur[i + 1]\n                # Try corner cut first\n                if self._edge_free(a, b):\n                    cur = cur[:i] + cur[i + 1:]\n                    changed = True\n                    break\n                # Try small relaxation toward midpoint\n                mid = tuple(0.5 * (a[k] + b[k]) for k in range(self.dim))\n                if self._in_bounds(mid) and (not self._point_in_obstacles(mid)):\n                    if self._edge_free(a, mid) and self._edge_free(mid, b):\n                        cur[i] = mid\n                        changed = True\n            if not changed:\n                break\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._shortcut(path, self.smooth_iters)\n        p2 = self._visibility_prune(p1)\n        p3 = self._elastic_refine(p2, self.elastic_sweeps)\n        return self._dedup(p3)",
          "objective": -39.28686,
          "time_improvement": 58.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 2409.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013451361656188964,
                    "num_nodes_avg": 62.0,
                    "path_length_avg": 158.49463611924995,
                    "smoothness_avg": 0.04911862032665335,
                    "success_improvement": 0.0,
                    "time_improvement": 45.4776770916583,
                    "node_improvement": 84.38680433140266,
                    "length_improvement": 13.126578434811004,
                    "smoothness_improvement": 668.8130709033614,
                    "objective_score": 24.8633155429009
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027135133743286133,
                    "num_nodes_avg": 156.0,
                    "path_length_avg": 245.64654428530534,
                    "smoothness_avg": 0.20810072097894103,
                    "success_improvement": 0.0,
                    "time_improvement": 83.77585872639358,
                    "node_improvement": 89.51824228986092,
                    "length_improvement": 17.996112973824765,
                    "smoothness_improvement": 5254.581439678919,
                    "objective_score": 62.203332600607524
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02812962532043457,
                    "num_nodes_avg": 229.0,
                    "path_length_avg": 122.99494476089357,
                    "smoothness_avg": 0.11045249123540399,
                    "success_improvement": 0.0,
                    "time_improvement": 44.27207935962878,
                    "node_improvement": 70.8836617927527,
                    "length_improvement": 18.312614079707338,
                    "smoothness_improvement": 1304.9475357594947,
                    "objective_score": 30.79392993451051
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "AURORA-BiRRT*: Adaptive Unified Rewire-Optimized Receding-Envelope BiRRT with Curvature-Aware Smoothing. It grows two trees with adaptive step sizing in clutter, dynamic-radius best-parent selection, bounded rewiring, and multi-step micro-bridging. Sampling blends goal, corridor, and informed prolate-ellipse regions using an incumbent path. A voxelized obstacle index accelerates exact slab-based segment-AABB checks. On connection, visibility compression, probabilistic shortcuts, and an angle-aware elastic smoother produce shorter, smoother paths quickly and robustly.",
          "planning_mechanism": "Alternate expanding start/goal trees. Each iteration: biased target sampling (goal/corridor/informed/uniform), ring-hash nearest, adaptive steer with local clutter feedback, and strict node+edge collision checks. Select a least-cost parent from radius-limited neighbors, insert, then leap to a visible ancestor and rewire a few cheaper neighbors. Attempt direct or multi-step micro-bridge to the opposite tree. Maintain an incumbent best length to focus informed sampling. On success, assemble and postprocess the path (visibility prune, bounded shortcuts, curvature-aware elastic smoothing) and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        pts = []\n        cur = self\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=7.0,\n        goal_bias=0.2,\n        corridor_bias=0.4,\n        informed_bias=0.5,\n        grid_cell_factor=1.25,\n        dupe_radius_factor=0.35,\n        connect_factor=2.75,\n        rewire_radius_mult=2.0,\n        neighbor_cap=48,\n        bridge_trials=2,\n        rewire_cap=8,\n        shortcut_trials=120,\n        smooth_iters=18\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dupe_radius_factor = float(dupe_radius_factor)\n        self.connect_factor = float(connect_factor)\n        self.rewire_radius_mult = float(rewire_radius_mult)\n        self.neighbor_cap = int(neighbor_cap)\n        self.bridge_trials = int(max(0, bridge_trials))\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.shortcut_trials = int(max(0, shortcut_trials))\n        self.smooth_iters = int(max(0, smooth_iters))\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if getattr(map, \"obstacles\", None) else []\n\n        # Validate endpoints\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_rng()\n        self._build_obs_index()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if self._segment_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Derived params\n        self.cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_r = max(0.5, self.step_size * self.dupe_radius_factor)\n        self.connect_dist = max(self.step_size, self.connect_factor * self.step_size)\n        self.corridor_w = max(self.step_size, 0.2 * self._dist(self.start, self.goal))\n\n        # Trees and grids\n        nodes = []\n        edges = []\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_put(Ga, a_root)\n        self._grid_put(Gb, b_root)\n\n        best_len = float('inf')\n        best_path = None\n\n        for it in range(self.max_iter):\n            grow_a = (it % 2 == 0)\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            attractor = self.goal if grow_a else self.start\n\n            target = self._sample_target(attractor, best_len)\n            if target is None:\n                continue\n\n            near = self._nearest(G, target, T)\n            if near is None:\n                continue\n\n            new_pos = self._steer_adaptive(near.position, target)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._point_blocked(new_pos):\n                continue\n            if self._has_duplicate(G, new_pos, self.dupe_r):\n                continue\n\n            parent, new_cost = self._choose_parent(G, T, new_pos)\n            if parent is None:\n                continue\n            if self._point_blocked(new_pos) or not self._segment_free(parent.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            T.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_put(G, new_node)\n\n            # Ancestor visibility leap\n            self._ancestor_leap(new_node, edges)\n\n            # Local bounded rewiring\n            self._rewire_local(G, new_node, edges)\n\n            # Try to connect to the opposite tree\n            other = self._nearest(Gopp, new_node.position, Topp)\n            connected = False\n            end_node = None\n            if other is not None:\n                if self._dist(new_node.position, other.position) <= self.connect_dist and self._segment_free(new_node.position, other.position):\n                    connected = True\n                    end_node = other\n                else:\n                    # Micro-bridge steps from the opposite tree\n                    head = other\n                    for _ in range(self.bridge_trials):\n                        step_p = self._steer_adaptive(head.position, new_node.position)\n                        if not self._in_bounds(step_p) or self._point_blocked(step_p):\n                            break\n                        if self._has_duplicate(Gopp, step_p, self.dupe_r):\n                            break\n                        if not self._segment_free(head.position, step_p):\n                            break\n                        q = Node(step_p, head, head.cost + self._dist(head.position, step_p))\n                        head.add_child(q)\n                        Topp.append(q)\n                        nodes.append(q)\n                        edges.append((head, q))\n                        self._grid_put(Gopp, q)\n                        self._ancestor_leap(q, edges)\n                        self._rewire_local(Gopp, q, edges)\n                        head = q\n                        if self._segment_free(new_node.position, head.position):\n                            connected = True\n                            end_node = head\n                            break\n\n            if connected and end_node is not None:\n                path = self._assemble(new_node, end_node, grow_a)\n                path = self._postprocess(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Maintain incumbent for informed sampling\n            if other is not None and self._segment_free(new_node.position, other.position):\n                tmp = self._assemble(new_node, other, grow_a)\n                L = self._path_len(tmp)\n                if L < best_len:\n                    best_len = L\n                    best_path = tmp\n\n        if best_path is not None:\n            best_path = self._postprocess(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            s = (s * 2654435761 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 13) * 1103515245\n        self._rng = s if s != 0 else 2463534242\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry and bounds\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer_adaptive(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        # Base step\n        step = self.step_size if d > self.step_size else d\n        # Estimate local clutter by obstacle index buckets overlapped by tentative step box\n        dirv = tuple((b[i] - a[i]) / d for i in range(self.dims))\n        trial = tuple(a[i] + dirv[i] * step for i in range(self.dims))\n        clutter = self._box_bucket_density(a, trial)\n        if clutter > 10 and step > 0.5 * self.step_size:\n            step *= 0.6\n            trial = tuple(a[i] + dirv[i] * step for i in range(self.dims))\n            clutter = self._box_bucket_density(a, trial)\n            if clutter > 14 and step > 0.3 * self.step_size:\n                step *= 0.6\n                trial = tuple(a[i] + dirv[i] * step for i in range(self.dims))\n        return self._clamp(trial)\n\n    # Sampling\n    def _sample_target(self, attractor, best_len):\n        for _ in range(16):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._sample_informed(best_len * 1.02)\n                if p is not None and not self._point_blocked(p):\n                    return p\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attractor\n            elif r < self.goal_bias + self.corridor_bias:\n                t = self._rand()\n                base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n                if self.dims == 3:\n                    p = (self._rand_range(base[0] - self.corridor_w, base[0] + self.corridor_w),\n                         self._rand_range(base[1] - self.corridor_w, base[1] + self.corridor_w),\n                         self._rand_range(base[2] - self.corridor_w, base[2] + self.corridor_w))\n                else:\n                    p = (self._rand_range(base[0] - self.corridor_w, base[0] + self.corridor_w),\n                         self._rand_range(base[1] - self.corridor_w, base[1] + self.corridor_w))\n            else:\n                if self.dims == 3:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n            p = self._clamp(p)\n            if not self._point_blocked(p):\n                return p\n        return None\n\n    def _sample_informed(self, max_sum):\n        c = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        # Axis-aligned rejection in prolate envelope\n        for _ in range(24):\n            if self.dims == 3:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half),\n                     self._rand_range(c[2] - half, c[2] + half))\n            else:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half))\n            if self._in_bounds(p) and (self._dist(p, self.start) + self._dist(p, self.goal)) <= max_sum:\n                return p\n        return None\n\n    # Node grid\n    def _cell_of(self, pos):\n        return tuple(int(pos[i] // self.cell) for i in range(self.dims))\n\n    def _grid_put(self, grid, node):\n        k = self._cell_of(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _ring_nodes(self, grid, key, r):\n        out = []\n        if self.dims == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos, tree):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        for r in range(0, 4):\n            cand = self._ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback limited scan\n        if not tree:\n            return None\n        step = max(1, len(tree) // 64)\n        for i in range(0, len(tree), step):\n            n = tree[i]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, cap):\n        key = self._cell_of(pos)\n        r = max(1, int(radius // self.cell) + 1)\n        cand = self._ring_nodes(grid, key, r)\n        out = []\n        rr = radius * radius\n        for n in cand:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= rr:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _has_duplicate(self, grid, pos, radius):\n        return len(self._neighbors(grid, pos, radius, self.neighbor_cap)) > 0\n\n    # Parent selection and optimization\n    def _choose_parent(self, grid, tree, new_pos):\n        n = max(1, len(tree))\n        # RRT* radius ~ (log(n)/n)^{1/d} scaled\n        base = (self.rewire_radius_mult * self.step_size)\n        dyn_r = max(self.step_size, base * ((1.0 + self._log1p(n)) / n) ** (1.0 / max(1, self.dims)))\n        neigh = self._neighbors(grid, new_pos, dyn_r, self.neighbor_cap)\n        if not neigh:\n            # fallback to nearest in tree\n            near = None\n            bestd = 1e100\n            for m in tree:\n                d = self._dist(m.position, new_pos)\n                if d < bestd:\n                    bestd = d\n                    near = m\n            neigh = [near] if near is not None else []\n        best_p = None\n        best_c = 1e100\n        for p in neigh:\n            d = self._dist(p.position, new_pos)\n            gc = p.cost + d\n            if gc + 1e-9 < best_c and self._segment_free(p.position, new_pos):\n                best_c = gc\n                best_p = p\n        if best_p is None:\n            return None, None\n        return best_p, best_c\n\n    def _log1p(self, x):\n        # simple series for small x; adequate for our integer n\n        return 0.5 if x <= 1.0 else self._fast_log(x + 1.0)\n\n    def _fast_log(self, x):\n        # crude monotonic approximation using change-of-base and piecewise\n        y = 0.0\n        t = x\n        while t > 2.718281828:\n            t *= 0.367879441  # divide by e\n            y += 1.0\n        # linear tail\n        return y + (t - 1.0) / 2.718281828\n\n    def _ancestor_leap(self, node, edges):\n        curp = node.parent\n        if curp is None:\n            return\n        bestp = curp\n        bestc = node.cost\n        anc = curp.parent\n        while anc is not None:\n            if self._segment_free(anc.position, node.position):\n                c = anc.cost + self._dist(anc.position, node.position)\n                if c + 1e-9 < bestc:\n                    bestc = c\n                    bestp = anc\n            anc = anc.parent\n        if bestp is not curp:\n            self._reparent(node, bestp, edges)\n\n    def _rewire_local(self, grid, node, edges):\n        radius = max(self.step_size, self.rewire_radius_mult * self.step_size)\n        neigh = self._neighbors(grid, node.position, radius, self.neighbor_cap)\n        improvements = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if node.cost + d + 1e-9 < nb.cost and self._segment_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n                improvements += 1\n                if improvements >= self.rewire_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        if child.parent is new_parent:\n            return\n        if not self._segment_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._remove_edge(edges, old, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        # propagate cost to subtree\n        stack = [child]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if abs(newc - ch.cost) > 1e-12:\n                    ch.cost = newc\n                    stack.append(ch)\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is p and e[1] is c:\n                edges.pop(i)\n                return\n\n    # Obstacles and collision\n    def _build_obs_index(self):\n        # Cell size for obstacle spatial index\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.dims == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obs_grid.get(key)\n                            if b is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obs_grid.get(key)\n                        if b is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_blocked(self, p):\n        if self.dims == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _segment_free(self, a, b):\n        return not self._segment_hits(a, b)\n\n    def _box_bucket_density(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            s = 0\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obs_grid.get((i, j, k))\n                        if bkt:\n                            s += len(bkt)\n            return s\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            s = 0\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obs_grid.get((i, j))\n                    if bkt:\n                        s += len(bkt)\n            return s\n\n    def _segment_hits(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obs_grid.get((i, j, k))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit3d(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obs_grid.get((i, j))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit2d(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit2d(self, p0, p1, bmin, bmax):\n        # Slab method\n        t0, t1 = 0.0, 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _seg_box_hit3d(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Path assembly and postprocess\n    def _assemble(self, u, v, a_side):\n        pu = u.path_from_root()\n        pv = v.path_from_root()\n        if a_side:\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _postprocess(self, path):\n        if len(path) < 2:\n            return path[:]\n        p = self._visibility_prune(path)\n        p = self._shortcut(p, self.shortcut_trials)\n        p = self._elastic_angle_smooth(p, self.smooth_iters)\n        return p\n\n    def _visibility_prune(self, path):\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._segment_free(out[-1], path[j]):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i + 1])\n                i += 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = list(path)\n        best = self._path_len(pts)\n        n = len(pts)\n        fail = 0\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1:\n                fail += 1\n                if fail > 24:\n                    break\n                continue\n            a, b = pts[i], pts[j - 1]\n            if self._segment_free(a, b):\n                cand = pts[:i + 1] + pts[j - 1:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    pts = cand\n                    best = L\n                    n = len(pts)\n                    fail = 0\n                else:\n                    fail += 1\n            else:\n                fail += 1\n            if fail > 48:\n                break\n        return pts\n\n    def _elastic_angle_smooth(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return path[:]\n        pts = list(path)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                b = pts[i]\n                c = pts[i + 1]\n                # Angle-aware midpoint pull\n                mid = tuple(0.25 * a[k] + 0.5 * b[k] + 0.25 * c[k] for k in range(self.dims))\n                if self._point_blocked(mid):\n                    continue\n                if self._segment_free(a, mid) and self._segment_free(mid, c):\n                    if mid != b:\n                        pts[i] = mid\n                        moved = True\n                # Try skip if possible\n                if self._segment_free(a, c):\n                    pts[i] = c  # will be removed next pass by neighbors\n                    moved = True\n            # Compact duplicates\n            comp = [pts[0]]\n            for p in pts[1:]:\n                if p != comp[-1]:\n                    comp.append(p)\n            pts = comp\n            if not moved:\n                break\n            if len(pts) < 3:\n                break\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        return pts",
          "objective": -39.0221,
          "time_improvement": 68.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1312.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009383320808410645,
                    "num_nodes_avg": 51.0,
                    "path_length_avg": 148.31907804876715,
                    "smoothness_avg": 0.03583382190014427,
                    "success_improvement": 0.0,
                    "time_improvement": 61.966642474939334,
                    "node_improvement": 87.15688743389575,
                    "length_improvement": 18.703963055278603,
                    "smoothness_improvement": 460.8771271269766,
                    "objective_score": 32.11675621128384
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.043584227561950684,
                    "num_nodes_avg": 172.0,
                    "path_length_avg": 228.72791182641134,
                    "smoothness_avg": 0.08818936081319215,
                    "success_improvement": 0.0,
                    "time_improvement": 73.9409183696743,
                    "node_improvement": 88.44319021702614,
                    "length_improvement": 23.644039464437803,
                    "smoothness_improvement": 2169.175773952521,
                    "objective_score": 47.21457805932758
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01668705940246582,
                    "num_nodes_avg": 82.0,
                    "path_length_avg": 122.67227871244054,
                    "smoothness_avg": 0.1106371606216832,
                    "success_improvement": 0.0,
                    "time_improvement": 66.9410768359495,
                    "node_improvement": 89.57406230133503,
                    "length_improvement": 18.526913505383728,
                    "smoothness_improvement": 1307.2965167220898,
                    "objective_score": 37.73495373762554
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "FLASH-Connect: a fast, low-dispersion, edge-cached BiRRT-Connect with hash-grid nearest search, per-cell caps, and one-shot limited connection. It minimizes planning time by deterministic Halton sampling, bounded tree growth without rewiring, immediate bridge attempts, and lightweight post-shortcutting.",
          "planning_mechanism": "Alternate expansion from start and goal trees toward a Halton-guided target. Each step inserts only if both the node and edge are collision-free and not too close to existing nodes. After insertion, attempt a direct bridge to the opposite tree; if blocked, perform at most a couple of connect steps on the other tree, again validating both node and edge per step. An LRU-like edge-collision cache accelerates repeated checks. On success, return immediately after quick line-of-sight collapse and a few shortcut passes.",
          "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = tuple(position)\n        self.parent = parent\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=9.0,\n        goal_bias=0.2,\n        grid_cell_factor=1.25,\n        per_cell_cap=8,\n        dupe_radius_ratio=0.5,\n        connect_steps=2,\n        edge_cache_capacity=30000,\n        edge_cache_quant=1.0,\n        smoothing_iters=20\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.per_cell_cap = int(per_cell_cap)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.connect_steps = int(connect_steps)\n        self.edge_cache_capacity = int(edge_cache_capacity)\n        self.edge_cache_quant = float(edge_cache_quant)\n        self.smoothing_iters = int(smoothing_iters)\n        # internal states\n        self._rnd_state = 2463534242\n        self._hidx = 1\n\n    def plan(self, map):\n        # Scene setup\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # seed RNG deterministically from scene\n        self._seed_from_scene()\n\n        # build spatial indices\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self._build_obstacle_grid()\n\n        # quick endpoint checks\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # edge cache\n        self._tick = 0\n        self._ecache = {}\n        self._ecache_last_prune = 0\n\n        # early straight line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None)\n            n1 = Node(self.goal, n0)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # trees and grids\n        nodes = []\n        edges = []\n\n        root_a = Node(self.start, None)\n        root_b = Node(self.goal, None)\n        nodes.extend([root_a, root_b])\n\n        tree_a = [root_a]\n        tree_b = [root_b]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, root_a)\n        self._grid_insert(grid_b, root_b)\n\n        # main loop\n        for it in range(self.max_iter):\n            grow_from_a = (it % 2 == 0)\n            source_tree = tree_a if grow_from_a else tree_b\n            source_grid = grid_a if grow_from_a else grid_b\n            target_tree = tree_b if grow_from_a else tree_a\n            target_grid = grid_b if grow_from_a else grid_a\n            attractor = self.goal if grow_from_a else self.start\n\n            q_rand = self._sample(attractor)\n            if q_rand is None:\n                continue\n\n            near = self._nearest(source_grid, q_rand)\n            if near is None:\n                continue\n\n            q_new = self._steer_valid(near.position, q_rand)\n            if q_new is None:\n                continue\n            if self._has_nearby(source_grid, q_new, self.dupe_radius):\n                continue\n\n            # per-cell cap\n            ckey = self._cell_of(q_new)\n            bucket = source_grid.get(ckey)\n            if bucket and len(bucket) >= self.per_cell_cap:\n                continue\n\n            # Insertion (both node and edge already validated in _steer_valid)\n            new_node = Node(q_new, near)\n            source_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((near, new_node))\n            self._grid_insert(source_grid, new_node)\n\n            # Try to connect to opposite tree\n            other_near = self._nearest(target_grid, new_node.position)\n            if other_near is not None:\n                # direct bridge\n                if self._edge_free(new_node.position, other_near.position):\n                    path = self._assemble_path(new_node, other_near)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # limited connect steps\n                p = other_near\n                steps = 0\n                while steps < self.connect_steps:\n                    step_pos = self._steer_once(p.position, new_node.position)\n                    if step_pos is None:\n                        break\n                    if self._has_nearby(target_grid, step_pos, self.dupe_radius):\n                        break\n                    cell2 = self._cell_of(step_pos)\n                    buck2 = target_grid.get(cell2)\n                    if buck2 and len(buck2) >= self.per_cell_cap:\n                        break\n                    q2 = Node(step_pos, p)\n                    target_tree.append(q2)\n                    nodes.append(q2)\n                    edges.append((p, q2))\n                    self._grid_insert(target_grid, q2)\n                    if self._edge_free(new_node.position, q2.position):\n                        path = self._assemble_path(new_node, q2)\n                        path = self._postprocess(path)\n                        return PlannerResult(True, path, nodes, edges)\n                    p = q2\n                    steps += 1\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG and Halton\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= len(self.obstacles) * 2654435761\n        s ^= int(self.step_size * 1000) & 0xffffffff\n        self._rnd_state = (s ^ 0x9E3779B9) & 0xffffffff\n        if self._rnd_state == 0:\n            self._rnd_state = 2463534242\n        self._hidx = 1\n\n    def _rand(self):\n        self._rnd_state = (1664525 * self._rnd_state + 1013904223) & 0xffffffff\n        return self._rnd_state / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _vdc(self, n, base):\n        v = 0.0\n        denom = 1.0\n        while n > 0:\n            n, r = divmod(n, base)\n            denom *= base\n            v += r / denom\n        return v\n\n    def _halton_point(self, idx):\n        bases = (2, 3, 5)\n        if self.dims == 2:\n            x = self._vdc(idx, bases[0]) * self.bounds[0]\n            y = self._vdc(idx, bases[1]) * self.bounds[1]\n            return (x, y)\n        else:\n            x = self._vdc(idx, bases[0]) * self.bounds[0]\n            y = self._vdc(idx, bases[1]) * self.bounds[1]\n            z = self._vdc(idx, bases[2]) * self.bounds[2]\n            return (x, y, z)\n\n    # Sampling with goal bias and Halton fallback\n    def _sample(self, attractor):\n        for _ in range(24):\n            if self._rand() < self.goal_bias:\n                p = attractor\n            else:\n                # Halton with tiny jitter to avoid grid alignment with obstacles\n                p = self._halton_point(self._hidx)\n                self._hidx += 1\n                jitter = 0.001 * self.cell_size\n                if self.dims == 2:\n                    p = (min(max(p[0] + self._rand_range(-jitter, jitter), 0.0), self.bounds[0]),\n                         min(max(p[1] + self._rand_range(-jitter, jitter), 0.0), self.bounds[1]))\n                else:\n                    p = (min(max(p[0] + self._rand_range(-jitter, jitter), 0.0), self.bounds[0]),\n                         min(max(p[1] + self._rand_range(-jitter, jitter), 0.0), self.bounds[1]),\n                         min(max(p[2] + self._rand_range(-jitter, jitter), 0.0), self.bounds[2]))\n            if self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer_once(self, a, b):\n        # Try to step toward b by at most step_size\n        d = self._dist(a, b)\n        if d < 1e-12:\n            return None\n        r = min(1.0, self.step_size / d)\n        q = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n        if not self._within_bounds(q):\n            return None\n        if self._point_in_obstacles(q):\n            return None\n        if not self._edge_free(a, q):\n            return None\n        return q\n\n    def _steer_valid(self, a, b):\n        # Fast attempt: if target within 1.5*step and edge is free, go there; else single step\n        d = self._dist(a, b)\n        max_jump = 1.5 * self.step_size\n        if d <= max_jump:\n            q = b\n            # clamp to bounds\n            q = tuple(min(max(q[i], 0.0), self.bounds[i]) for i in range(self.dims))\n            if not self._point_in_obstacles(q) and self._edge_free(a, q):\n                return q\n        # try normal step\n        q = self._steer_once(a, b)\n        if q is not None:\n            return q\n        # last attempt: slightly shorter step to sneak around grazing edges\n        if d > 1e-9:\n            r = min(1.0, (0.6 * self.step_size) / d)\n            q2 = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n            if self._within_bounds(q2) and (not self._point_in_obstacles(q2)) and self._edge_free(a, q2):\n                return q2\n        return None\n\n    # Node grid utilities\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_of(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 4):\n            cand = self._grid_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback: scan grid buckets\n        for b in grid.values():\n            for n in b:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    # Obstacle grid\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 2.0)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            x0, y0, z0 = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= x0 <= x + w and y <= y0 <= y + h and z <= z0 <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            x0, y0 = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= x0 <= x + w and y <= y0 <= y + h:\n                    return True\n            return False\n\n    # Edge collision with cache\n    def _edge_key(self, a, b):\n        q = max(0.25, self.edge_cache_quant)\n        qa = tuple(int(a[i] / q) for i in range(self.dims))\n        qb = tuple(int(b[i] / q) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self._ecache.get(key)\n        if hit is not None:\n            # refresh LRU tick\n            self._tick += 1\n            self._ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self._ecache[key] = (free, self._tick)\n        if len(self._ecache) - self._ecache_last_prune > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self._ecache:\n            return\n        cutoff = self._tick - 4000\n        to_del = []\n        for k, v in self._ecache.items():\n            if v[1] < cutoff:\n                to_del.append(k)\n        if not to_del:\n            i = 0\n            for k in list(self._ecache.keys()):\n                if (i % 3) == 0:\n                    to_del.append(k)\n                i += 1\n        for k in to_del:\n            if k in self._ecache:\n                del self._ecache[k]\n        self._ecache_last_prune = len(self._ecache)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x0, y0, z0, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x0, y0, z0), (x0 + w, y0 + h, z0 + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x0, y0, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x0, y0), (x0 + w, y0 + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect(self, p0, p1, bmin, bmax):\n        # slab intersection for 2D/3D segment vs AABB\n        tmin = 0.0\n        tmax = 1.0\n        n = self.dims\n        for i in range(n):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Path assembly and postprocess\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _assemble_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return pa + pb[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _los_collapse(self, path):\n        if len(path) < 3:\n            return path[:]\n        out = [path[0]]\n        last = 0\n        k = 1\n        while k < len(path) - 1:\n            if self._edge_free(path[last], path[k + 1]):\n                k += 1\n                continue\n            out.append(path[k])\n            last = k\n            k += 1\n        out.append(path[-1])\n        return out\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best = self._path_len(pts)\n        n = len(pts)\n        iters = min(self.smoothing_iters, max(1, n - 2))\n        for t in range(iters):\n            i = (t % (n - 2))\n            j = min(n - 1, i + 2 + (t % max(1, (n - i - 1))))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= best + 1e-12:\n                    pts = new_pts\n                    best = L\n                    n = len(pts)\n        return pts\n\n    def _postprocess(self, path):\n        p = self._los_collapse(path)\n        p = self._shortcut(p)\n        return p",
          "objective": -38.51088,
          "time_improvement": 67.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1919.0,
          "node_improvement": 85.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01389298439025879,
                    "num_nodes_avg": 79.0,
                    "path_length_avg": 164.28407730787757,
                    "smoothness_avg": 0.04754812951617681,
                    "success_improvement": 0.0,
                    "time_improvement": 43.68765033257988,
                    "node_improvement": 80.10576680936792,
                    "length_improvement": 9.953293979757886,
                    "smoothness_improvement": 644.2314793440236,
                    "objective_score": 22.299428884348814
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.015888690948486328,
                    "num_nodes_avg": 96.0,
                    "path_length_avg": 256.1129773273841,
                    "smoothness_avg": 0.12192815124399099,
                    "success_improvement": 0.0,
                    "time_improvement": 90.5001254447587,
                    "node_improvement": 93.54968756299134,
                    "length_improvement": 14.502116364807549,
                    "smoothness_improvement": 3037.299152805466,
                    "objective_score": 51.03780321633946
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016379070281982423,
                    "num_nodes_avg": 140.0,
                    "path_length_avg": 121.59420940833631,
                    "smoothness_avg": 0.17113765919663135,
                    "success_improvement": 0.0,
                    "time_improvement": 67.55123758529757,
                    "node_improvement": 82.19961856325493,
                    "length_improvement": 19.24291580502608,
                    "smoothness_improvement": 2076.858392913151,
                    "objective_score": 42.195412723170676
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "IBEX-Lite: Informed BiRRT* with Elastic Micro-Connect. It blends fast bidirectional growth, visibility-based best-parent insertion with light rewiring, obstacle-binned collision checks, and a commit-only micro-bridge to connect trees. After connection it runs multi-pass visibility compression, shortcutting, and safe corner rounding. The design targets high success, short and smooth paths with low planning time.",
          "planning_mechanism": "Alternate growing the two trees (balanced), sampling via goal/corridor-biased free points. For each sample: pick a nearby anchor with a hash grid, steer one step, and select the least-cost visible parent among local neighbors with a small turn-angle penalty; insert only after node and edge checks, then lightly rewire neighbors. Probe the opposite tree: first try direct LOS; else simulate a few greedy steps; if a connector exists, commit the whole micro-bridge and return the assembled, smoothed path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            # detach from old parent\n            i = 0\n            while i < len(self.parent.children):\n                if self.parent.children[i] is self:\n                    self.parent.children.pop(i)\n                    break\n                i += 1\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=6.0,\n                 goal_bias=0.3,\n                 corridor_bias=0.25,\n                 grid_cell_factor=1.8,\n                 neighbor_radius_factor=2.2,\n                 dupe_radius_ratio=0.3,\n                 k_rewire=4,\n                 connect_hops=3,\n                 edge_res=0.8,\n                 smooth_shortcuts=80,\n                 smooth_rounds=6):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.cell_factor = float(grid_cell_factor)\n        self.nei_factor = float(neighbor_radius_factor)\n        self.dupe_ratio = float(dupe_radius_ratio)\n        self.k_rewire = int(max(0, k_rewire))\n        self.connect_hops = int(max(1, connect_hops))\n        self.edge_res = float(edge_res)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self.smooth_rounds = int(max(0, smooth_rounds))\n        self._rng = 123456789\n\n    def plan(self, map):\n        # Setup\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", [])) if getattr(map, \"obstacles\", None) is not None else []\n\n        self._seed_rng()\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], [], [])\n        # Build obstacle bins before collision tests\n        self._build_obs_bins()\n\n        # Validate endpoints\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        nodes = []\n        edges = []\n\n        # Early straight-line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Derived spatial params\n        self.cell = max(1.0, self.step * self.cell_factor)\n        self.nei_radius = max(1.5 * self.step, self.step * self.nei_factor)\n        self.dupe_radius = max(0.35, self.step * self.dupe_ratio)\n\n        # Initialize two trees and grids\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        A, B = [a_root], [b_root]\n        nodes.extend([a_root, b_root])\n        GA, GB = {}, {}\n        self._grid_add(GA, a_root)\n        self._grid_add(GB, b_root)\n        frontierA, frontierB = [a_root], [b_root]\n\n        for it in range(self.max_iter):\n            # Balanced alternating\n            if it % 3 == 2:\n                growA = (len(A) <= len(B))\n            else:\n                growA = (it % 2 == 0)\n\n            T = A if growA else B\n            O = B if growA else A\n            G = GA if growA else GB\n            GO = GB if growA else GA\n            frontier = frontierA if growA else frontierB\n            frontierO = frontierB if growA else frontierA\n            attract = self.goal if growA else self.start\n\n            target = self._sample_target(attract)\n            if target is None:\n                continue\n\n            # nearest anchor\n            qnear = self._nearest(G, frontier, target, max_rings=2)\n            if qnear is None:\n                qnear = T[-1]\n\n            qnew_pos = self._steer(qnear.position, target, self.step)\n            if (not self._in_bounds(qnew_pos)) or self._point_blocked(qnew_pos):\n                continue\n            if self._has_close(G, qnew_pos, self.dupe_radius):\n                continue\n\n            parent, bestc = self._choose_parent(G, qnew_pos, qnear)\n            if parent is None:\n                continue\n\n            # Both checks before insertion\n            if self._point_blocked(qnew_pos):\n                continue\n            if not self._edge_free(parent.position, qnew_pos):\n                continue\n\n            qnode = Node(qnew_pos, parent, bestc)\n            qnode.attach(parent)\n            T.append(qnode)\n            nodes.append(qnode)\n            edges.append((parent, qnode))\n            self._grid_add(G, qnode)\n            frontier.append(qnode)\n            if len(frontier) > 160:\n                del frontier[:16]\n\n            # Local light rewiring\n            if self.k_rewire > 0:\n                self._rewire_local(qnode, G, edges, k=self.k_rewire)\n\n            # Try to connect to opposite tree\n            other_near = self._nearest(GO, frontierO, qnode.position, max_rings=2)\n            if other_near is not None:\n                # Direct bridge\n                if self._edge_free(qnode.position, other_near.position):\n                    path = self._assemble_path(qnode, other_near, growA)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # Elastic micro-bridge (commit only if it completes)\n                qlast = self._micro_bridge(O, GO, other_near, qnode.position)\n                if qlast is not None and self._edge_free(qnode.position, qlast.position):\n                    path = self._assemble_path(qnode, qlast, growA)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            s ^= (int(v * 2654435761) & 0xffffffff)\n            s = (s * 1664525 + 1013904223) & 0xffffffff\n        s ^= len(self.obstacles) * 374761393\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        # xorshift32\n        x = self._rng & 0xffffffff\n        x ^= (x << 13) & 0xffffffff\n        x ^= (x >> 17) & 0xffffffff\n        x ^= (x << 5) & 0xffffffff\n        self._rng = x & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Obstacle bins and collisions\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self._obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self._obin.get(key)\n                            if lst is None:\n                                self._obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self._obin.get(key)\n                        if lst is None:\n                            self._obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_bucket(self, p):\n        if self.is3:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell),\n                                   int(p[2] // self.obs_cell)))\n        else:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell)))\n\n    def _point_blocked(self, p):\n        bucket = self._point_bucket(p)\n        if not bucket:\n            return False\n        if self.is3:\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _seg_box_intersect(self, a, b, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(self.dim):\n            p = a[i]\n            d = b[i] - a[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _edge_free(self, a, b):\n        # Quickly reject with obstacle bin candidate list based on segment bbox coverage\n        if self.is3:\n            mn = (min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2]))\n            mx = (max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2]))\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            iz0 = int(max(0.0, mn[2]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mx[2]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self._obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return True\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            mn = (min(a[0], b[0]), min(a[1], b[1]))\n            mx = (max(a[0], b[0]), max(a[1], b[1]))\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self._obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return True\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    # Grid utilities\n    def _cell_key(self, pos):\n        if self.is3:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, frontier, pos, max_rings=2):\n        kk = self._cell_key(pos)\n        best = None\n        bd = 1e100\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring(grid, kk, r)\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bd:\n                        bd = d2\n                        best = n\n                if best is not None:\n                    return best\n        # fallback to recent frontier\n        if frontier:\n            lim = min(24, len(frontier))\n            for i in range(lim):\n                n = frontier[-1 - i]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bd:\n                    bd = d2\n                    best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, cap=20):\n        kk = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((kk[0] + dx, kk[1] + dy, kk[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n                                if len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((kk[0] + dx, kk[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n                            if len(out) >= cap:\n                                return out\n        return out\n\n    def _has_close(self, grid, pos, radius):\n        ns = self._neighbors(grid, pos, radius, cap=6)\n        return len(ns) > 0\n\n    # Parent selection with small turn penalty\n    def _choose_parent(self, grid, new_pos, fallback):\n        cand = self._neighbors(grid, new_pos, self.nei_radius, cap=24)\n        if fallback not in cand:\n            cand.append(fallback)\n        best = None\n        best_cost = 1e100\n        for p in cand:\n            d = self._dist(p.position, new_pos)\n            if d > 1.6 * self.step:\n                continue\n            if not self._edge_free(p.position, new_pos):\n                continue\n            c = p.cost + d\n            # Turn penalty: prefer smoother joins\n            if p.parent is not None:\n                u = tuple(p.position[i] - p.parent.position[i] for i in range(self.dim))\n                v = tuple(new_pos[i] - p.position[i] for i in range(self.dim))\n                nu = max(1e-12, self._dist((0.0,) * self.dim, u))\n                nv = max(1e-12, self._dist((0.0,) * self.dim, v))\n                dot = 0.0\n                for i in range(self.dim):\n                    dot += u[i] * v[i]\n                cosang = max(-1.0, min(1.0, dot / (nu * nv)))\n                # angle in [0, pi]; penalty scaled by step\n                ang = (1.0 - cosang)  # cheaper than acos, monotonic\n                c += 0.08 * self.step * ang\n            if c < best_cost:\n                best_cost = c\n                best = p\n        return best, best_cost\n\n    # Light rewiring around a new node\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                edges.pop(i)\n                return\n\n    def _propagate_delta(self, node, delta):\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    def _rewire_local(self, new_node, grid, edges, k=4):\n        neigh = self._neighbors(grid, new_node.position, self.nei_radius, cap=32)\n        if not neigh:\n            return\n        # Prefer closest neighbors\n        neigh.sort(key=lambda n: self._dist2(n.position, new_node.position))\n        count = 0\n        for nb in neigh:\n            if count >= k:\n                break\n            if nb is new_node or nb is new_node.parent:\n                continue\n            if self._is_ancestor(nb, new_node):\n                continue\n            # Both checks before adding new edge\n            if self._point_blocked(nb.position):\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            cand_cost = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand_cost + 1e-9 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    # detach from old parent\n                    i = 0\n                    while i < len(oldp.children):\n                        if oldp.children[i] is nb:\n                            oldp.children.pop(i)\n                            break\n                        i += 1\n                    self._remove_edge(edges, oldp, nb)\n                nb.attach(new_node)\n                edges.append((new_node, nb))\n                delta = cand_cost - nb.cost\n                nb.cost = cand_cost\n                self._propagate_delta(nb, delta)\n                count += 1\n\n    # Micro-bridge: simulate a few steps on opposite tree, commit only if connection completes\n    def _micro_bridge(self, tree, grid, near_node, target_pos):\n        cur = near_node.position\n        chain = []\n        success = False\n        last = None\n        for _ in range(self.connect_hops):\n            nxt = self._steer(cur, target_pos, self.step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                break\n            if self._has_close(grid, nxt, self.dupe_radius * 0.7):\n                break\n            if not self._edge_free(cur, nxt):\n                break\n            chain.append(nxt)\n            cur = nxt\n            # if we can close the final link to target, mark success\n            if self._edge_free(cur, target_pos):\n                success = True\n                last = cur\n                break\n        if not success or last is None:\n            return None\n        # Commit the chain to the opposite tree with both checks on each segment\n        prev = near_node\n        for p in chain:\n            if self._point_blocked(p):\n                return None\n            if not self._edge_free(prev.position, p):\n                return None\n            nn = Node(p, prev, prev.cost + self._dist(prev.position, p))\n            nn.attach(prev)\n            tree.append(nn)\n            self._grid_add(grid, nn)\n            prev = nn\n        return prev\n\n    # Sampling\n    def _sample_target(self, attract):\n        for _ in range(28):\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attract\n            elif r < self.goal_bias + self.corridor_bias:\n                p = self._corridor_point()\n            else:\n                if self.is3:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        return None\n\n    def _corridor_point(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step, 0.08 * sg)\n        if self.is3:\n            return self._clamp((base[0] + self._rand_range(-w, w),\n                                base[1] + self._rand_range(-w, w),\n                                base[2] + self._rand_range(-w, w)))\n        else:\n            return self._clamp((base[0] + self._rand_range(-w, w),\n                                base[1] + self._rand_range(-w, w)))\n\n    # Path assembly and utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _assemble_path(self, a_end, b_end, a_side_grew):\n        if a_side_grew:\n            pa = self._path_to_root(a_end)\n            pb = self._path_to_root(b_end)\n            if pa and pb and pa[0] == pb[-1]:\n                pb = pb[:-1]\n            return pa + pb[::-1]\n        else:\n            pa = self._path_to_root(a_end)\n            pb = self._path_to_root(b_end)\n            if pa and pb and pb[0] == pa[-1]:\n                pa = pa[:-1]\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # Smoothing\n    def _vis_collapse(self, pts, passes=2):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            i = 0\n            changed = False\n            while i < len(cur) - 2:\n                j = len(cur) - 1\n                while j > i + 1:\n                    if self._edge_free(cur[i], cur[j]):\n                        if j > i + 1:\n                            del cur[i + 1:j]\n                            changed = True\n                        break\n                    j -= 1\n                i += 1\n            if not changed:\n                break\n        return cur\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            n = len(cur)\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j > n - 1:\n                tries += 1\n                continue\n            a, b = cur[i], cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-12 <= bestL:\n                    cur = cand\n                    bestL = L\n            tries += 1\n        return cur\n\n    def _round_corners(self, pts, passes):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                c = cur[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                if (not self._in_bounds(mid)) or self._point_blocked(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if cur[i] != mid:\n                        cur[i] = mid\n                        moved = True\n            if not moved:\n                break\n        return cur\n\n    def _postprocess(self, path):\n        if len(path) < 3:\n            return path[:]\n        p = self._vis_collapse(path, passes=2)\n        p = self._shortcut(p, self.smooth_shortcuts)\n        p = self._round_corners(p, self.smooth_rounds)\n        return p",
          "objective": -37.68839,
          "time_improvement": 61.0,
          "length_improvement": 21.0,
          "smoothness_improvement": 1336.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011586189270019531,
                    "num_nodes_avg": 61.0,
                    "path_length_avg": 150.2550697876198,
                    "smoothness_avg": 0.041941448754662616,
                    "success_improvement": 0.0,
                    "time_improvement": 53.03776905243485,
                    "node_improvement": 84.63863006799295,
                    "length_improvement": 17.64281530546121,
                    "smoothness_improvement": 556.4747503241836,
                    "objective_score": 29.279393650628094
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03080716133117676,
                    "num_nodes_avg": 131.0,
                    "path_length_avg": 228.48646410685174,
                    "smoothness_avg": 0.08768701591384163,
                    "success_improvement": 0.0,
                    "time_improvement": 81.58034736794089,
                    "node_improvement": 91.19801115366526,
                    "length_improvement": 23.72464166291407,
                    "smoothness_improvement": 2156.250077867826,
                    "objective_score": 49.490139597469835
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026394367218017578,
                    "num_nodes_avg": 112.0,
                    "path_length_avg": 116.65576078031737,
                    "smoothness_avg": 0.10957624060714707,
                    "success_improvement": 0.0,
                    "time_improvement": 47.70981892140697,
                    "node_improvement": 85.75969485060394,
                    "length_improvement": 22.5227982401031,
                    "smoothness_improvement": 1293.8016924461601,
                    "objective_score": 34.29563308271475
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "BASIL-RRT: Bi-directional Adaptive Simplified Informed Lite with Rewire and Visibility. Two trees grow toward each other with simple grid-accelerated nearest search, duplicate suppression, best-parent selection, visibility jumps to higher ancestors, and light local rewiring. Guided sampling uses corridor and informed-ellipse biases to shorten routes. On connection, deterministic visibility compression, shortcutting, and elastic smoothing yield short, smooth paths efficiently.",
          "planning_mechanism": "Initialize bidirectional trees and spatial hashes. Repeat: sample a biased target (goal/corridor/informed/uniform), pick the nearest via grid, steer by a fixed step, and validate both node and edge. Choose the least-cost feasible parent from nearby nodes, insert, then visibility-jump to a visible ancestor and locally rewire cheaper neighbors. Probe the opposite tree for a direct or short bridge; if connected, assemble the path and postprocess with visibility compression, randomized shortcuts, and elastic smoothing. Maintain an incumbent best path for informed sampling.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=7.0,\n        goal_bias=0.15,\n        corridor_bias=0.45,\n        informed_bias=0.5,\n        cell_size_factor=1.2,\n        dupe_ratio=0.3,\n        connect_dist_factor=2.5,\n        rewire_mult=2.5,\n        neighbor_cap=32,\n        shortcuts=120,\n        elastic_iters=10\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.cell_size_factor = float(cell_size_factor)\n        self.dupe_ratio = float(dupe_ratio)\n        self.connect_dist_factor = float(connect_dist_factor)\n        self.rewire_mult = float(rewire_mult)\n        self.neighbor_cap = int(neighbor_cap)\n        self.shortcuts = int(max(0, shortcuts))\n        self.elastic_iters = int(max(0, elastic_iters))\n        self._rnd = 2463534242\n\n    # Public entry\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if getattr(map, \"obstacles\", None) else []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        self._seed_from_scene()\n        self._build_obstacle_grid()\n\n        # Endpoint validity\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Parameters\n        self.cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_ratio)\n        self.connect_dist = max(self.step_size, self.connect_dist_factor * self.step_size)\n        corridor_w = max(self.step_size, 0.2 * self._dist(self.start, self.goal))\n\n        # Trees and grids\n        nodes = []\n        edges = []\n\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_insert(Ga, a_root)\n        self._grid_insert(Gb, b_root)\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            T = Ta if side_a else Tb\n            G = Ga if side_a else Gb\n            T_opp = Tb if side_a else Ta\n            G_opp = Gb if side_a else Ga\n            attractor = self.goal if side_a else self.start\n\n            # Target sampling\n            target = self._sample_target(attractor, best_len, corridor_w)\n            if target is None:\n                continue\n\n            # Nearest and steer\n            near = self._nearest_grid(G, target)\n            if near is None:\n                continue\n            new_pos = self._steer(near.position, target)\n            if not self._within_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if self._has_nearby(G, new_pos, self.dupe_radius):\n                continue\n\n            # Best-parent selection with local neighbors\n            parent, new_cost = self._choose_parent(T, G, new_pos)\n            if parent is None:\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            # Insert node\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            T.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(G, new_node)\n\n            # Visibility jump to a cheaper visible ancestor\n            self._visibility_jump(new_node, edges)\n\n            # Local rewiring (length/cost reduction)\n            self._rewire_neighbors(G, new_node, edges)\n\n            # Try connect to opposite tree\n            other_near = self._nearest_grid(G_opp, new_node.position)\n            if other_near is not None:\n                dno = self._dist(new_node.position, other_near.position)\n                if dno <= self.connect_dist and self._edge_free(new_node.position, other_near.position):\n                    path = self._assemble_path(new_node, other_near, side_a)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # One-step probe from opposite tree\n                step_p = self._steer(other_near.position, new_node.position)\n                if self._within_bounds(step_p) and not self._point_in_obstacles(step_p):\n                    if not self._has_nearby(G_opp, step_p, self.dupe_radius):\n                        if self._edge_free(other_near.position, step_p):\n                            q = Node(step_p, other_near, other_near.cost + self._dist(other_near.position, step_p))\n                            other_near.add_child(q)\n                            T_opp.append(q)\n                            nodes.append(q)\n                            edges.append((other_near, q))\n                            self._grid_insert(G_opp, q)\n                            self._visibility_jump(q, edges)\n                            self._rewire_neighbors(G_opp, q, edges)\n                            if self._edge_free(new_node.position, q.position):\n                                path = self._assemble_path(new_node, q, side_a)\n                                path = self._postprocess(path)\n                                return PlannerResult(True, path, nodes, edges)\n\n            # Maintain incumbent best for informed sampling\n            if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                tmp = self._assemble_path(new_node, other_near, side_a)\n                L = self._path_len(tmp)\n                if L < best_len:\n                    best_len = L\n                    best_path = tmp\n\n        if best_path is not None:\n            best_path = self._postprocess(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 1) * 2654435761\n        self._rnd = (s ^ 0x9E3779B9) & 0xffffffff\n        if self._rnd == 0:\n            self._rnd = 2463534242\n\n    def _rand(self):\n        self._rnd = (1664525 * self._rnd + 1013904223) & 0xffffffff\n        return self._rnd / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= self.step_size:\n            return self._clamp(b)\n        r = self.step_size / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Sampling\n    def _sample_target(self, attractor, best_len, corridor_w):\n        for _ in range(16):\n            if best_len < float('inf') and self._rand() < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p is not None and not self._point_in_obstacles(p):\n                    return p\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attractor\n            elif r < self.goal_bias + self.corridor_bias:\n                t = self._rand()\n                base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n                if self.dims == 3:\n                    p = (self._rand_range(base[0] - corridor_w, base[0] + corridor_w),\n                         self._rand_range(base[1] - corridor_w, base[1] + corridor_w),\n                         self._rand_range(base[2] - corridor_w, base[2] + corridor_w))\n                else:\n                    p = (self._rand_range(base[0] - corridor_w, base[0] + corridor_w),\n                         self._rand_range(base[1] - corridor_w, base[1] + corridor_w))\n            else:\n                p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            p = self._clamp(p)\n            if not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if self._within_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Node spatial grid\n    def _cell_of(self, pos, cell=None):\n        cs = self.cell_size if cell is None else cell\n        if self.dims == 3:\n            return (int(pos[0] // cs), int(pos[1] // cs), int(pos[2] // cs))\n        return (int(pos[0] // cs), int(pos[1] // cs))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _nearest_grid(self, grid, pos):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        # Expand rings up to 3\n        for r in range(0, 4):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback: scan all buckets\n        for b in grid.values():\n            for n in b:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.dims == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _neighbors_within_radius(self, grid, pos, radius, cap):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        out = []\n        rr = radius * radius\n        for n in cand:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= rr:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _has_nearby(self, grid, pos, radius):\n        neigh = self._neighbors_within_radius(grid, pos, radius, self.neighbor_cap)\n        return len(neigh) > 0\n\n    # Parent selection and optimization\n    def _choose_parent(self, tree, grid, new_pos):\n        n = len(tree)\n        # Dynamic radius ~ n^{-1/d}\n        dyn_r = max(self.step_size, self.rewire_mult * self.step_size * (1.0 / (1.0 + n)) ** (1.0 / max(1, self.dims)))\n        neigh = self._neighbors_within_radius(grid, new_pos, dyn_r, self.neighbor_cap)\n        if not neigh:\n            near = None\n            bestd = 1e100\n            for m in tree:\n                d = self._dist(m.position, new_pos)\n                if d < bestd:\n                    bestd = d\n                    near = m\n            neigh = [near] if near is not None else []\n        best_parent = None\n        best_cost = 1e100\n        for p in neigh:\n            d = self._dist(p.position, new_pos)\n            if d > dyn_r + 1e-9:\n                continue\n            if not self._edge_free(p.position, new_pos):\n                continue\n            gc = p.cost + d\n            if gc < best_cost:\n                best_cost = gc\n                best_parent = p\n        if best_parent is None:\n            return None, None\n        return best_parent, best_cost\n\n    def _visibility_jump(self, node, edges):\n        cur_parent = node.parent\n        if cur_parent is None:\n            return\n        best_parent = cur_parent\n        best_cost = node.cost\n        anc = cur_parent.parent\n        while anc is not None:\n            if self._edge_free(anc.position, node.position):\n                c = anc.cost + self._dist(anc.position, node.position)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best_parent = anc\n            anc = anc.parent\n        if best_parent is not cur_parent:\n            self._reparent(node, best_parent, edges)\n\n    def _rewire_neighbors(self, grid, node, edges):\n        # Use same dynamic radius as parent selection from this node's tree size (approx via node.cost order not needed)\n        radius = max(self.step_size, self.rewire_mult * self.step_size * 0.9)\n        neigh = self._neighbors_within_radius(grid, node.position, radius, self.neighbor_cap)\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if node.cost + d + 1e-9 < nb.cost and self._edge_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        if child.parent is new_parent:\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old_parent = child.parent\n        if old_parent is not None:\n            old_parent.remove_child(child)\n            self._edges_remove(edges, old_parent, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        self._propagate_costs(child)\n\n    def _edges_remove(self, edges, parent, child):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is parent and e[1] is child:\n                edges.pop(i)\n                break\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if abs(newc - ch.cost) > 1e-12:\n                    ch.cost = newc\n                    stack.append(ch)\n\n    # Obstacles\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.dims == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.dims == 3:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Path assembly and post-process\n    def _assemble_path(self, u, v, side_a):\n        # u in current tree, v in opposite\n        pu = u.path_from_root()\n        pv = v.path_from_root()\n        if side_a:\n            # start -> u then v -> goal\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _postprocess(self, path):\n        if len(path) < 2:\n            return path[:]\n        p = self._visibility_compress(path)\n        p = self._shortcut(p, self.shortcuts)\n        p = self._elastic(p, self.elastic_iters)\n        return p\n\n    def _visibility_compress(self, path):\n        out = [path[0]]\n        anchor = path[0]\n        i = 1\n        while i < len(path):\n            far = i\n            j = i\n            while j < len(path):\n                if self._edge_free(anchor, path[j]):\n                    far = j\n                    j += 1\n                else:\n                    break\n            out.append(path[far])\n            anchor = path[far]\n            i = far + 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = path[:]\n        best = self._path_len(pts)\n        n = len(pts)\n        noimp = 0\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j > n:\n                noimp += 1\n                if noimp > 16:\n                    break\n                continue\n            a, b = pts[i], pts[j - 1]\n            if self._edge_free(a, b):\n                candidate = pts[:i + 1] + pts[j - 1:]\n                L = self._path_len(candidate)\n                if L <= best + 1e-12:\n                    pts = candidate\n                    best = L\n                    n = len(pts)\n                    noimp = 0\n                else:\n                    noimp += 1\n            else:\n                noimp += 1\n            if noimp > 24:\n                break\n        return pts\n\n    def _elastic(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return path[:]\n        pts = list(path)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dims))\n                if self._point_in_obstacles(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if mid != pts[i]:\n                        pts[i] = mid\n                        moved = True\n            if not moved:\n                break\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        return pts",
          "objective": -37.60553,
          "time_improvement": 63.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1737.0,
          "node_improvement": 84.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01027677059173584,
                    "num_nodes_avg": 56.0,
                    "path_length_avg": 152.97087548687767,
                    "smoothness_avg": 0.05880624031240139,
                    "success_improvement": 0.0,
                    "time_improvement": 58.34522786771023,
                    "node_improvement": 85.89775875094435,
                    "length_improvement": 16.154239167002743,
                    "smoothness_improvement": 820.4453606838263,
                    "objective_score": 31.298338663933844
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.048004674911499026,
                    "num_nodes_avg": 233.0,
                    "path_length_avg": 260.1076340388263,
                    "smoothness_avg": 0.1240816945243068,
                    "success_improvement": 0.0,
                    "time_improvement": 71.29792559985403,
                    "node_improvement": 84.34455418934354,
                    "length_improvement": 13.168584974709937,
                    "smoothness_improvement": 3092.7113725425193,
                    "objective_score": 44.754085527494766
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021122431755065917,
                    "num_nodes_avg": 136.0,
                    "path_length_avg": 118.36585536678952,
                    "smoothness_avg": 0.1098386556019516,
                    "success_improvement": 0.0,
                    "time_improvement": 58.154110224750575,
                    "node_improvement": 82.70820089001907,
                    "length_improvement": 21.38703484172179,
                    "smoothness_improvement": 1297.1395918106139,
                    "objective_score": 36.764151931511314
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "ABLE-RRT: Adaptive Best-Parent Light Elastic Bidirectional RRT-Connect. Two grids grow start/goal trees with mixture-biased sampling. Each extension selects a locally optimal parent within one-step radius to reduce path cost, enforces strict node/edge collision checks, and performs greedy connect to the opposite tree. AABB-pruned edge checks accelerate collision tests. Upon connection, a light two-stage smoother (visibility compression + shortcutting + optional rubber-band) improves length and smoothness while keeping runtime low.",
          "planning_mechanism": "Initialize bidirectional trees and coarse grids. Each iteration: sample (goal/corridor/uniform), find a near node via grid, propose a one-step point, choose the best parent among nearby nodes that can reach it collision-free, then insert. Greedily connect the other tree toward the new node; if a short, collision-free bridge closes the gap, assemble the path and apply lightweight smoothing.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=7.0,\n        goal_bias=0.20,\n        corridor_bias=0.40,\n        cell_size_factor=2.0,\n        edge_resolution=1.0,\n        dupe_radius_ratio=0.40,\n        neighbor_radius_ratio=1.25,\n        smooth_shortcuts=80,\n        rubber_iters=6\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.cell_size_factor = float(cell_size_factor)\n        self.edge_resolution = float(edge_resolution)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.neighbor_radius_ratio = float(neighbor_radius_ratio)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self.rubber_iters = int(max(0, rubber_iters))\n\n    def plan(self, map):\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        obstacles = list(map.obstacles)\n\n        # Validate start/goal\n        if not self._within_bounds(start, bounds) or not self._within_bounds(goal, bounds):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight line\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_resolution):\n            n0 = Node(start, None, 0.0)\n            n1 = Node(goal, n0, self._distance(start, goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [start, goal], [n0, n1], [(n0, n1)])\n\n        # Init trees and grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n        cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        grid_start, grid_goal = {}, {}\n        self._grid_insert(grid_start, start_root.position, start_root, cell_size, dim)\n        self._grid_insert(grid_goal, goal_root.position, goal_root, cell_size, dim)\n\n        dsg = self._distance(start, goal)\n        corridor_w = max(self.step_size, 0.18 * dsg)\n        dupe_radius = max(0.5, self.dupe_radius_ratio * self.step_size)\n        neighbor_radius = max(self.step_size, self.neighbor_radius_ratio * self.step_size)\n\n        for it in range(self.max_iter):\n            # Alternate growth\n            if it % 2 == 0:\n                grow_tree, grow_grid, grow_root = start_tree, grid_start, start_root\n                other_tree, other_grid, other_root = goal_tree, grid_goal, goal_root\n                other_root_pos = goal\n                a_is_start_side = True\n            else:\n                grow_tree, grow_grid, grow_root = goal_tree, grid_goal, goal_root\n                other_tree, other_grid, other_root = start_tree, grid_start, start_root\n                other_root_pos = start\n                a_is_start_side = False\n\n            target = self._sample_target(bounds, obstacles, is_3d, start, goal, corridor_w, other_root_pos)\n            a_near = self._nearest_from_grid(grow_tree, grow_grid, target, cell_size, dim)\n\n            # Propose a one-step point\n            proposed = self._steer(a_near.position, target, self.step_size)\n            if not self._within_bounds(proposed, bounds):\n                continue\n            if self._is_in_obstacle(proposed, obstacles, is_3d):\n                continue\n            if self._exists_close(grow_grid, proposed, dupe_radius, cell_size, dim):\n                continue\n\n            # Choose best parent among neighbors that can reach proposed within one step\n            candidates = self._neighbors_within_radius(grow_grid, proposed, neighbor_radius, cell_size, dim)\n            if a_near not in candidates:\n                candidates.append(a_near)\n            best_parent = None\n            best_cost = float('inf')\n            for cand in candidates:\n                dcp = self._distance(cand.position, proposed)\n                if dcp > self.step_size + 1e-9:\n                    continue\n                if self._is_edge_in_obstacle(cand.position, proposed, obstacles, is_3d, self.edge_resolution):\n                    continue\n                cost = cand.cost + dcp\n                if cost < best_cost:\n                    best_cost = cost\n                    best_parent = cand\n            if best_parent is None:\n                continue\n\n            # Commit new node (both node and edge already validated)\n            new_node = Node(proposed, best_parent, best_cost)\n            best_parent.add_child(new_node)\n            grow_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            self._grid_insert(grow_grid, new_node.position, new_node, cell_size, dim)\n\n            # Greedy connect from the other tree toward new_node\n            b_near = self._nearest_from_grid(other_tree, other_grid, new_node.position, cell_size, dim)\n            b_last = self._greedy_extend(other_tree, other_grid, b_near, new_node.position,\n                                         nodes, edges, obstacles, is_3d, bounds, cell_size, dim)\n            if b_last is None:\n                continue\n\n            # Try final short bridge\n            if self._distance(b_last.position, new_node.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(b_last.position, new_node.position, obstacles, is_3d, self.edge_resolution):\n                    edges.append((b_last, new_node))\n                    # Assemble path\n                    if a_is_start_side:\n                        pa = new_node.path_from_root()\n                        pb = b_last.path_from_root()\n                        raw_path = pa + pb[::-1]\n                    else:\n                        pa = new_node.path_from_root()\n                        pb = b_last.path_from_root()\n                        raw_path = pb + pa[::-1]\n                    # Smooth\n                    path = self._compress_visibility(raw_path, obstacles, is_3d)\n                    path = self._shortcut_path(path, obstacles, is_3d, bounds, self.smooth_shortcuts)\n                    path = self._rubber_band(path, obstacles, is_3d, self.rubber_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---- Geometry utilities ----\n    def _distance(self, a, b):\n        s = 0.0\n        for i in range(len(a)):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p, bounds):\n        for i in range(len(bounds)):\n            if p[i] < 0.0 or p[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._distance(from_pos, to_pos)\n        if d <= step:\n            return tuple(to_pos[i] for i in range(len(to_pos)))\n        r = step / (d + 1e-12)\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    # ---- Sampling ----\n    def _sample_target(self, bounds, obstacles, is_3d, start, goal, corridor_w, other_root_pos):\n        import random  # Local import to avoid global requirement; acceptable inline\n        r = random.random()\n        if r < self.goal_bias:\n            return other_root_pos\n        elif r < self.goal_bias + self.corridor_bias:\n            t = random.random()\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(len(bounds)))\n            if len(bounds) == 3:\n                return (\n                    self._clamp(base[0] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[0]),\n                    self._clamp(base[1] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[1]),\n                    self._clamp(base[2] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[2]),\n                )\n            else:\n                return (\n                    self._clamp(base[0] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[0]),\n                    self._clamp(base[1] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[1]),\n                )\n        else:\n            # rejection sample in free space\n            for _ in range(32):\n                if len(bounds) == 3:\n                    p = (random.uniform(0.0, bounds[0]),\n                         random.uniform(0.0, bounds[1]),\n                         random.uniform(0.0, bounds[2]))\n                else:\n                    p = (random.uniform(0.0, bounds[0]),\n                         random.uniform(0.0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback (may be occupied; extension will reject)\n            if len(bounds) == 3:\n                return (random.uniform(0.0, bounds[0]),\n                        random.uniform(0.0, bounds[1]),\n                        random.uniform(0.0, bounds[2]))\n            else:\n                return (random.uniform(0.0, bounds[0]),\n                        random.uniform(0.0, bounds[1]))\n\n    def _clamp(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # ---- Collision utilities ----\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for x, y, z, w, h, d in obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for x, y, w, h in obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _seg_aabb_overlap(self, a, b, obs, is_3d):\n        if is_3d:\n            x, y, z, w, h, d = obs\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            if maxx < x or minx > x + w or maxy < y or miny > y + h or maxz < z or minz > z + d:\n                return False\n            return True\n        else:\n            x, y, w, h = obs\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            if maxx < x or minx > x + w or maxy < y or miny > y + h:\n                return False\n            return True\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._distance(a, b)\n        steps = int(max(1, d / max(1e-9, resolution)))\n        # Pre-filter obstacles by segment AABB overlap\n        relevant = []\n        for obs in obstacles:\n            if self._seg_aabb_overlap(a, b, obs, is_3d):\n                relevant.append(obs)\n        if not relevant:\n            return False\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(len(a)))\n            if self._is_in_obstacle(p, relevant, is_3d):\n                return True\n        return False\n\n    # ---- Grid NN and neighborhood ----\n    def _cell_index(self, pos, cell_size, dim):\n        if dim == 2:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size))\n        else:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size), int(pos[2] // cell_size))\n\n    def _grid_insert(self, grid, pos, node, cell_size, dim):\n        idx = self._cell_index(pos, cell_size, dim)\n        bucket = grid.get(idx)\n        if bucket is None:\n            grid[idx] = [node]\n        else:\n            bucket.append(node)\n\n    def _nearest_from_grid(self, tree, grid, point, cell_size, dim, max_rings=3):\n        if len(tree) < 32:\n            best = None\n            bestd = float('inf')\n            for n in tree:\n                d = self._distance(n.position, point)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            return best\n        center = self._cell_index(point, cell_size, dim)\n        best = None\n        bestd = float('inf')\n        found = False\n        for r in range(0, max_rings + 1):\n            cand = []\n            if dim == 2:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        idx = (center[0] + dx, center[1] + dy)\n                        if idx in grid:\n                            cand.extend(grid[idx])\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            idx = (center[0] + dx, center[1] + dy, center[2] + dz)\n                            if idx in grid:\n                                cand.extend(grid[idx])\n            if cand:\n                for n in cand:\n                    d = self._distance(n.position, point)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                        found = True\n            if found:\n                break\n        if best is None:\n            # fallback linear\n            best = tree[0]\n            bestd = self._distance(best.position, point)\n            for n in tree:\n                d = self._distance(n.position, point)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors_within_radius(self, grid, point, radius, cell_size, dim):\n        cells = int(radius / max(1e-9, cell_size)) + 1\n        center = self._cell_index(point, cell_size, dim)\n        out = []\n        if dim == 2:\n            for dx in range(-cells, cells + 1):\n                for dy in range(-cells, cells + 1):\n                    idx = (center[0] + dx, center[1] + dy)\n                    if idx in grid:\n                        out.extend(grid[idx])\n        else:\n            for dx in range(-cells, cells + 1):\n                for dy in range(-cells, cells + 1):\n                    for dz in range(-cells, cells + 1):\n                        idx = (center[0] + dx, center[1] + dy, center[2] + dz)\n                        if idx in grid:\n                            out.extend(grid[idx])\n        # filter by true distance\n        rr = radius * radius\n        fil = []\n        for n in out:\n            s = 0.0\n            p = n.position\n            for i in range(dim):\n                d = p[i] - point[i]\n                s += d * d\n            if s <= rr:\n                fil.append(n)\n        return fil\n\n    def _exists_close(self, grid, pos, radius, cell_size, dim):\n        neigh = self._neighbors_within_radius(grid, pos, radius, cell_size, dim)\n        return len(neigh) > 0\n\n    # ---- Extend/connect ----\n    def _greedy_extend(self, tree, grid, from_node, target_pos, nodes, edges, obstacles, is_3d, bounds, cell_size, dim):\n        current = from_node\n        last_new = None\n        while True:\n            step_pos = self._steer(current.position, target_pos, self.step_size)\n            if not self._within_bounds(step_pos, bounds):\n                break\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                break\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d, self.edge_resolution):\n                break\n            new_node = Node(step_pos, current, current.cost + self._distance(current.position, step_pos))\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node.position, new_node, cell_size, dim)\n            last_new = new_node\n            current = new_node\n            if self._distance(current.position, target_pos) <= self.step_size:\n                break\n        return last_new\n\n    # ---- Smoothing ----\n    def _compress_visibility(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        last = path[0]\n        i = 1\n        while i < len(path):\n            far = i\n            j = i\n            while j < len(path):\n                if self._is_edge_in_obstacle(last, path[j], obstacles, is_3d, self.edge_resolution):\n                    break\n                far = j\n                j += 1\n            out.append(path[far])\n            last = path[far]\n            i = far + 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds, attempts):\n        if len(path) < 3:\n            return list(path)\n        import random\n        pts = list(path)\n        n = len(pts)\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_resolution):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts\n\n    def _rubber_band(self, path, obstacles, is_3d, iters):\n        if len(path) < 3 or iters <= 0:\n            return list(path)\n        pts = list(path)\n        for _ in range(iters):\n            changed = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(len(a)))\n                if self._is_in_obstacle(mid, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(a, mid, obstacles, is_3d, self.edge_resolution):\n                    continue\n                if self._is_edge_in_obstacle(mid, c, obstacles, is_3d, self.edge_resolution):\n                    continue\n                if mid != pts[i]:\n                    pts[i] = mid\n                    changed = True\n            if not changed:\n                break\n        return pts",
          "objective": -37.59775,
          "time_improvement": 66.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1905.0,
          "node_improvement": 85.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009185576438903808,
                    "num_nodes_avg": 64.4,
                    "path_length_avg": 170.56202690395023,
                    "smoothness_avg": 0.04785735504538155,
                    "success_improvement": 0.0,
                    "time_improvement": 62.768158532802346,
                    "node_improvement": 83.782422563586,
                    "length_improvement": 6.512250325673065,
                    "smoothness_improvement": 649.0715303700621,
                    "objective_score": 25.983155407094852
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027295637130737304,
                    "num_nodes_avg": 154.6,
                    "path_length_avg": 240.5028644826979,
                    "smoothness_avg": 0.12901280114279629,
                    "success_improvement": 0.0,
                    "time_improvement": 83.67989348599582,
                    "node_improvement": 89.61230934623397,
                    "length_improvement": 19.713221344549247,
                    "smoothness_improvement": 3219.5922975687886,
                    "objective_score": 53.02986234037223
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02437562942504883,
                    "num_nodes_avg": 141.5,
                    "path_length_avg": 127.88160399822759,
                    "smoothness_avg": 0.15294445433893913,
                    "success_improvement": 0.0,
                    "time_improvement": 51.70916332215004,
                    "node_improvement": 82.00890019071836,
                    "length_improvement": 15.067127691977475,
                    "smoothness_improvement": 1845.4421700060007,
                    "objective_score": 33.7802364618615
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "FLASH-Connect-Lite: Fast Lattice-Hashed Spatially-Indexed BiRRT-Connect. It accelerates planning with a uniform spatial hash for obstacles and nodes, greedy multi-step RRT-Connect extensions, bounded per-cell admissions, near-duplicate suppression, and collision-check caching. The spatial hash prunes obstacle checks to local bins, drastically reducing segment and point collision costs; greedy connect minimizes iterations and edge tests; and early visibility pruning plus bounded shortcutting quickly yields usable, smooth paths.",
          "planning_mechanism": "Alternate extending start/goal trees: sample with goal bias, find a near node via lattice-hash rings, and greedily extend multiple steps toward the sample while enforcing in-bounds, node-collision, and edge-collision checks and skipping near-duplicates/excess cells. After each insertion, attempt a greedy connect from the opposite tree toward the new node; on first line-of-sight bridge, extract the path, visibility-prune, and shortcut-smooth, then stop. Obstacle and node queries use a spatial hash; edge checks use cached segment results.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        goal_bias=0.35,\n        grid_cell_factor=1.8,\n        max_per_cell=6,\n        min_sep_factor=0.6,\n        ring_max=3,\n        min_nn_candidates=16,\n        connect_max_steps=48,\n        smoothing_iters=40\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.max_per_cell = max_per_cell\n        self.min_sep_factor = min_sep_factor\n        self.ring_max = ring_max\n        self.min_nn_candidates = min_nn_candidates\n        self.connect_max_steps = connect_max_steps\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        self._lcg_state = 2463534242\n\n        # Spatial indices and caches\n        self._obs_grid = {}\n        self._obs_cell = 4.0\n        self._edge_cache = {}\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        self.is_3d = is_3d\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Parameters derived from map/step\n        self.edge_res = max(0.5, min(1.0, self.step_size * 0.5))\n        self.nn_cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.3, self.step_size * self.min_sep_factor)\n        self._obs_cell = max(2.0, self.step_size)  # coarse but effective for pruning\n\n        # Reset RNG and caches\n        self._lcg_state = 2463534242\n        self._edge_cache = {}\n\n        # Build obstacle spatial hash\n        self._build_obs_grid(obstacles, is_3d)\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start) or self._is_in_obstacle(goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line attempt\n        if not self._edge_blocked(start, goal):\n            path = [start, goal]\n            path = self._visibility_prune(path)\n            path = self._shortcut_smooth(path, min(10, self.smoothing_iters))\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Initialize trees and their spatial hashes\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n\n        self._grid_add(grid_start, counts_start, start_root)\n        self._grid_add(grid_goal, counts_goal, goal_root)\n\n        # Main planning loop\n        for it in range(self.max_iter):\n            a_is_start = (it % 2 == 0)\n            tree_a = start_tree if a_is_start else goal_tree\n            tree_b = goal_tree if a_is_start else start_tree\n            grid_a = grid_start if a_is_start else grid_goal\n            grid_b = grid_goal if a_is_start else grid_start\n            counts_a = counts_start if a_is_start else counts_goal\n            counts_b = counts_goal if a_is_start else counts_start\n            attractor = goal if a_is_start else start\n\n            # Sample target with goal bias\n            target = self._guided_sample(attractor)\n\n            # Greedy extend Tree A toward target (multi-step RRT-Connect style)\n            new_node = self._extend_greedy(tree_a, grid_a, counts_a, nodes, edges, target)\n            if new_node is None:\n                continue\n\n            # Attempt fast direct bridge to Tree B\n            other_near = self._nearest_hashed(grid_b, tree_b, new_node.position)\n            if other_near is not None and not self._edge_blocked(new_node.position, other_near.position):\n                path = self._extract_path(new_node, other_near, a_is_start)\n                path = self._visibility_prune(path)\n                path = self._shortcut_smooth(path, self.smoothing_iters)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Otherwise greedy-connect Tree B toward new_node\n            hit_node = self._connect_greedy(tree_b, grid_b, counts_b, nodes, edges, new_node.position)\n            if hit_node is not None:\n                # Final LOS check between the connection endpoints\n                if not self._edge_blocked(new_node.position, hit_node.position):\n                    path = self._extract_path(new_node, hit_node, a_is_start)\n                    path = self._visibility_prune(path)\n                    path = self._shortcut_smooth(path, self.smoothing_iters)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG utilities\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry helpers\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer_step(self, from_pos, to_pos):\n        d = self._dist(from_pos, to_pos)\n        if d <= 1e-9:\n            return self._clamp(from_pos)\n        if d <= self.step_size:\n            return self._clamp(to_pos)\n        r = self.step_size / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Obstacle spatial hash\n    def _obs_key(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self._obs_cell), int(pos[1] // self._obs_cell), int(pos[2] // self._obs_cell))\n        else:\n            return (int(pos[0] // self._obs_cell), int(pos[1] // self._obs_cell))\n\n    def _build_obs_grid(self, obstacles, is_3d):\n        self._obs_grid = {}\n        if is_3d:\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                x2, y2, z2 = x + w, y + h, z + d\n                ix0 = int(x // self._obs_cell)\n                iy0 = int(y // self._obs_cell)\n                iz0 = int(z // self._obs_cell)\n                ix1 = int(x2 // self._obs_cell)\n                iy1 = int(y2 // self._obs_cell)\n                iz1 = int(z2 // self._obs_cell)\n                for ix in range(ix0, ix1 + 1):\n                    for iy in range(iy0, iy1 + 1):\n                        for iz in range(iz0, iz1 + 1):\n                            key = (ix, iy, iz)\n                            bucket = self._obs_grid.get(key)\n                            if bucket is None:\n                                self._obs_grid[key] = [obs]\n                            else:\n                                bucket.append(obs)\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                x2, y2 = x + w, y + h\n                ix0 = int(x // self._obs_cell)\n                iy0 = int(y // self._obs_cell)\n                ix1 = int(x2 // self._obs_cell)\n                iy1 = int(y2 // self._obs_cell)\n                for ix in range(ix0, ix1 + 1):\n                    for iy in range(iy0, iy1 + 1):\n                        key = (ix, iy)\n                        bucket = self._obs_grid.get(key)\n                        if bucket is None:\n                            self._obs_grid[key] = [obs]\n                        else:\n                            bucket.append(obs)\n\n    def _is_in_obstacle(self, pos):\n        if self.is_3d:\n            px, py, pz = pos\n            key = self._obs_key(pos)\n            bucket = self._obs_grid.get(key)\n            if not bucket:\n                return False\n            for obs in bucket:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            key = self._obs_key(pos)\n            bucket = self._obs_grid.get(key)\n            if not bucket:\n                return False\n            for obs in bucket:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_hits(self, a, b):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p):\n                return True\n        return False\n\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked(self, a, b):\n        k = self._edge_key(a, b)\n        cached = self._edge_cache.get(k)\n        if cached is not None:\n            return cached\n        blocked = self._segment_hits(a, b)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    # Node spatial hash (for NN and duplicate suppression)\n    def _grid_key(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.nn_cell), int(pos[1] // self.nn_cell), int(pos[2] // self.nn_cell))\n        else:\n            return (int(pos[0] // self.nn_cell), int(pos[1] // self.nn_cell))\n\n    def _grid_add(self, grid, counts, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n\n    def _grid_ring_cells(self, key, r):\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        yield (key[0] + dx, key[1] + dy, key[2] + dz)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    yield (key[0] + dx, key[1] + dy)\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        seen = set()\n        total = 0\n        for r in range(0, self.ring_max + 1):\n            for cell in self._grid_ring_cells(key, r):\n                bucket = grid.get(cell)\n                if not bucket:\n                    continue\n                for n in bucket:\n                    if id(n) in seen:\n                        continue\n                    seen.add(id(n))\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                    total += 1\n            if total >= self.min_nn_candidates and best is not None:\n                break\n        if best is not None:\n            return best\n        # Fallback random subset if grid empty\n        if not tree:\n            return None\n        trials = min(48, len(tree))\n        for _ in range(trials):\n            idx = int(self._uniform(0, len(tree)))\n            n = tree[idx]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r = max(1, int(radius // self.nn_cell) + 1)\n        rr = radius\n        for rad in range(0, r + 1):\n            for cell in self._grid_ring_cells(key, rad):\n                bucket = grid.get(cell)\n                if not bucket:\n                    continue\n                for n in bucket:\n                    if self._dist(n.position, pos) <= rr:\n                        return True\n        return False\n\n    # Sampling\n    def _sample_free(self):\n        while True:\n            if self.is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p):\n                return p\n\n    def _guided_sample(self, attractor):\n        if self._rand() < self.goal_bias:\n            if not self._is_in_obstacle(attractor):\n                return attractor\n        # Blend toward attractor\n        alpha = 0.25\n        if self.is_3d:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]),\n                   self._uniform(0.0, self.bounds[2]))\n            p = tuple(alpha * attractor[i] + (1.0 - alpha) * rnd[i] for i in range(3))\n        else:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]))\n            p = tuple(alpha * attractor[i] + (1.0 - alpha) * rnd[i] for i in range(2))\n        if self._in_bounds(p) and not self._is_in_obstacle(p):\n            return p\n        return self._sample_free()\n\n    # Greedy extend for active tree (multi-step)\n    def _extend_greedy(self, tree, grid, counts, nodes_all, edges_all, target):\n        nearest = self._nearest_hashed(grid, tree, target)\n        if nearest is None:\n            return None\n        cur = nearest\n        last_added = None\n        for _ in range(self.connect_max_steps):\n            new_pos = self._steer_step(cur.position, target)\n            if not self._in_bounds(new_pos):\n                break\n            if self._is_in_obstacle(new_pos):\n                break\n            if self._edge_blocked(cur.position, new_pos):\n                break\n            # Per-cell capacity and near-duplicate suppression\n            key = self._grid_key(new_pos)\n            if counts.get(key, 0) >= self.max_per_cell:\n                # Try to step further without adding\n                if self._dist(new_pos, target) <= 1e-6:\n                    break\n                # advance origin for next attempt to same cur to see if farther step is viable\n                # but keep cur to avoid skipping collision guarantee; attempt another step\n                # however, to prevent infinite loops if target within step, break\n                cur_to_target = self._dist(cur.position, target)\n                if cur_to_target <= self.step_size + 1e-9:\n                    break\n                # Try to leap one more step ahead\n                leap_pos = self._steer_step(new_pos, target)\n                if not self._in_bounds(leap_pos) or self._is_in_obstacle(leap_pos) or self._edge_blocked(cur.position, leap_pos):\n                    break\n                new_pos = leap_pos  # accept leap if valid\n                key = self._grid_key(new_pos)\n                if counts.get(key, 0) >= self.max_per_cell:\n                    # still crowded; skip insertion this round\n                    if self._dist(new_pos, target) <= self.step_size:\n                        break\n                    continue\n            if self._near_duplicate(grid, new_pos, self.min_sep):\n                if self._dist(new_pos, target) <= self.step_size:\n                    break\n                # continue stepping without adding\n                cur_to_target = self._dist(cur.position, target)\n                if cur_to_target <= self.step_size + 1e-9:\n                    break\n                continue\n\n            # Insert node\n            new_cost = cur.cost + self._dist(cur.position, new_pos)\n            new_node = Node(new_pos, parent=cur, cost=new_cost)\n            cur.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_all.append((cur, new_node))\n            self._grid_add(grid, counts, new_node)\n            last_added = new_node\n            cur = new_node\n\n            # Stop if we got close enough to target\n            if self._dist(new_pos, target) <= self.step_size * 0.5:\n                break\n        return last_added\n\n    # Greedy connect from the opposite tree toward a target point; return last added if progressed\n    def _connect_greedy(self, tree, grid, counts, nodes_all, edges_all, target):\n        nearest = self._nearest_hashed(grid, tree, target)\n        if nearest is None:\n            return None\n        cur = nearest\n        last_added = None\n        for _ in range(self.connect_max_steps):\n            new_pos = self._steer_step(cur.position, target)\n            if not self._in_bounds(new_pos):\n                break\n            if self._is_in_obstacle(new_pos):\n                break\n            if self._edge_blocked(cur.position, new_pos):\n                break\n            key = self._grid_key(new_pos)\n            if counts.get(key, 0) >= self.max_per_cell:\n                cur_to_target = self._dist(cur.position, target)\n                if cur_to_target <= self.step_size + 1e-9:\n                    break\n                # attempt to continue without adding\n                continue\n            if self._near_duplicate(grid, new_pos, self.min_sep):\n                cur_to_target = self._dist(cur.position, target)\n                if cur_to_target <= self.step_size + 1e-9:\n                    break\n                continue\n            # Insert node\n            new_cost = cur.cost + self._dist(cur.position, new_pos)\n            new_node = Node(new_pos, parent=cur, cost=new_cost)\n            cur.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_all.append((cur, new_node))\n            self._grid_add(grid, counts, new_node)\n            last_added = new_node\n            cur = new_node\n\n            # If close enough to target, stop\n            if self._dist(new_pos, target) <= self.step_size * 0.5:\n                break\n        return last_added\n\n    # Path extraction and post-processing\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j]):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -37.29529,
          "time_improvement": 53.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 2507.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015715956687927246,
                    "num_nodes_avg": 50.0,
                    "path_length_avg": 159.74438521735743,
                    "smoothness_avg": 0.04853181796198822,
                    "success_improvement": 0.0,
                    "time_improvement": 36.29860773549004,
                    "node_improvement": 87.40871317048602,
                    "length_improvement": 12.441571150596545,
                    "smoothness_improvement": 659.628339634622,
                    "objective_score": 21.65266670917805
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07348463535308838,
                    "num_nodes_avg": 114.0,
                    "path_length_avg": 256.59359164084896,
                    "smoothness_avg": 0.19309266417859872,
                    "success_improvement": 0.0,
                    "time_improvement": 56.06341517653498,
                    "node_improvement": 92.34025398105221,
                    "length_improvement": 14.341673473257,
                    "smoothness_improvement": 4868.413328339737,
                    "objective_score": 49.76609527861338
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016176486015319826,
                    "num_nodes_avg": 81.0,
                    "path_length_avg": 125.19551263187705,
                    "smoothness_avg": 0.1646340240175897,
                    "success_improvement": 0.0,
                    "time_improvement": 67.95257957997248,
                    "node_improvement": 89.70120788302607,
                    "length_improvement": 16.851101679581618,
                    "smoothness_improvement": 1994.132633484155,
                    "objective_score": 40.467098049161486
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "AERO-Connect-R*: Adaptive Elliptic Rewired Connect BiRRT with Hash-Grids. It couples bidirectional RRT-Connect growth (greedy multi-step connect) with lightweight RRT* local optimization (best-parent selection and bounded rewiring), uses adaptive informed sampling (goal/corridor \u2192 ellipse after first incumbent), and fast slab-based collision via obstacle bins. A two-stage path refiner (visibility + shortcut + corner-round) improves length and smoothness at negligible cost.",
          "planning_mechanism": "Mechanism: Alternate expanding start/goal trees. Each iteration: draw a guided sample (goal/corridor/uniform; switch to ellipse once a path is known), pick an anchor via multi-ring hash-grid nearest, steer one step, validate node/edge, choose cheapest parent among nearby anchors, insert and locally rewire. Then greedily connect the opposite tree toward the new node with multiple validated steps; on meeting, extract the path and run refinements, then return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.25,\n                 corridor_bias=0.35,\n                 ellipse_bias=0.55,\n                 grid_cell_factor=1.7,\n                 neighbor_radius_factor=2.4,\n                 min_sep_ratio=0.4,\n                 k_parent=6,\n                 k_rewire=6,\n                 connect_mult=1.8,\n                 smoothing_attempts=120):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.ellipse_bias = float(ellipse_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neigh_factor = float(neighbor_radius_factor)\n        self.min_sep_ratio = float(min_sep_ratio)\n        self.k_parent = int(max(1, k_parent))\n        self.k_rewire = int(max(0, k_rewire))\n        self.connect_mult = float(connect_mult)\n        self.smoothing_attempts = int(max(0, smoothing_attempts))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self._is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Spatial parameters\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.neigh_radius = max(self.step * 1.2, self.step * self.neigh_factor)\n        self.min_sep = max(0.5, self.step * self.min_sep_ratio)\n        self.connect_step = max(self.step, self.step * self.connect_mult)\n\n        # Initialize RNG seed\n        self._seed()\n\n        # Build obstacle bins before any collision checks\n        self._build_obs_bins()\n\n        # Validate start/goal\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Trivial straight-line solution\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._smooth_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize two trees and their grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = self.goal if active_start else self.start\n\n            # Guided sampling with informed ellipse once best path exists\n            sp = self._guided_sample(root_other, best_len)\n            if sp is None:\n                continue\n\n            # Nearest anchor in active tree\n            anchor = self._nearest_grid(grid_a, sp)\n            if anchor is None:\n                anchor = tree_a[-1]\n\n            # Steer one step toward sample\n            newp = self._steer(anchor.position, sp, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(grid_a, newp, self.min_sep):\n                continue\n            if not self._edge_free(anchor.position, newp):\n                continue\n\n            # Best-parent selection (local RRT*)\n            neigh = self._neighbors(grid_a, newp, self.neigh_radius)\n            if not neigh:\n                neigh = [anchor]\n            # Sort few closest anchors\n            neigh = sorted(neigh, key=lambda n: self._dist2(n.position, newp))[:self.k_parent]\n            parent = anchor\n            bestc = anchor.cost + self._dist(anchor.position, newp)\n            for nb in neigh:\n                gc = nb.cost + self._dist(nb.position, newp)\n                if gc + 1e-12 < bestc and self._edge_free(nb.position, newp):\n                    parent = nb\n                    bestc = gc\n\n            # Final checks before adding node/edge\n            if self._point_in_obstacles(newp) or (not self._edge_free(parent.position, newp)):\n                continue\n\n            nn = Node(newp, parent, bestc)\n            parent.add_child(nn)\n            tree_a.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(grid_a, nn)\n\n            # Bounded local rewiring\n            if self.k_rewire > 0:\n                self._rewire_lite(nn, grid_a, edges)\n\n            # Greedy multi-step connect from the opposite tree toward nn\n            other_near = self._nearest_grid(grid_b, nn.position)\n            meet_b = other_near\n            connected = False\n            cur = other_near\n            if cur is not None:\n                while True:\n                    # If we are close and direct edge is free, consider connected\n                    if self._dist(cur.position, nn.position) <= self.connect_step and self._edge_free(cur.position, nn.position):\n                        connected = True\n                        meet_b = cur\n                        break\n                    # Otherwise extend the other tree by a connect step\n                    nxtp = self._steer(cur.position, nn.position, self.connect_step)\n                    if (not self._in_bounds(nxtp)) or self._point_in_obstacles(nxtp):\n                        break\n                    if not self._edge_free(cur.position, nxtp):\n                        break\n                    # Add the node to the opposite tree (both checks already passed)\n                    cn = Node(nxtp, cur, cur.cost + self._dist(cur.position, nxtp))\n                    cur.add_child(cn)\n                    tree_b.append(cn)\n                    nodes.append(cn)\n                    edges.append((cur, cn))\n                    self._grid_add(grid_b, cn)\n                    cur = cn\n                    meet_b = cur\n                    # Loop continues until blocked or within direct reach\n\n            if connected:\n                # Extract full path (do not insert a cross-edge to preserve tree structures)\n                path = self._extract_path(nn, meet_b)\n                L = self._path_len(path)\n                if best_len is None or L + 1e-9 < best_len:\n                    best_len = L\n                path = self._smooth_path(path)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- RNG ----------\n    def _seed(self):\n        s = 0x9E3779B97F4A7C15 & 0xffffffff\n        for v in self.start + self.goal:\n            zv = int(v * 1315423911) & 0xffffffff\n            s ^= ((zv ^ (zv << 13) ^ (zv >> 17)) & 0xffffffff)\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # ---------- Spatial hash for nodes ----------\n    def _cell_key(self, p):\n        if self._is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self._is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            cand.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        cand.extend(lst)\n        return cand\n\n    def _nearest_grid(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback scan\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self._is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors(grid, pos, radius)) > 0\n\n    # ---------- Obstacles: binning and collision ----------\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self._is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obin.get(key)\n                            if b is None:\n                                self.obin[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obin.get(key)\n                        if b is None:\n                            self.obin[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self._is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self._is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # ---------- Rewiring ----------\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _erase_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                del edges[i]\n                break\n\n    def _propagate_cost(self, node, delta):\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    def _rewire_lite(self, new_node, grid, edges):\n        neigh = self._neighbors(grid, new_node.position, self.neigh_radius)\n        if not neigh:\n            return\n        neigh = sorted(neigh, key=lambda n: self._dist2(n.position, new_node.position))[:self.k_rewire]\n        for nb in neigh:\n            if nb is new_node or nb is new_node.parent:\n                continue\n            if self._is_ancestor(nb, new_node):\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            cand = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand + 1e-9 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._erase_edge(edges, oldp, nb)\n                new_node.add_child(nb)\n                edges.append((new_node, nb))\n                delta = cand - nb.cost\n                nb.cost = cand\n                self._propagate_cost(nb, delta)\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, target_root, incumbent_len):\n        tries = 20\n        while tries > 0:\n            tries -= 1\n            r = self._rand()\n            if incumbent_len is not None and r < self.ellipse_bias:\n                p = self._sample_in_ellipse(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                r2 = self._rand()\n                if r2 < self.goal_bias:\n                    p = target_root\n                elif r2 < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_point()\n                else:\n                    if self._is3:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]),\n                             self._rand_range(0.0, self.bounds[2]))\n                    else:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _corridor_point(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step, 0.07 * sg)\n        if self._is3:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            oz = self._rand_range(-w, w)\n            return self._clamp((base[0] + ox, base[1] + oy, base[2] + oz))\n        else:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            return self._clamp((base[0] + ox, base[1] + oy))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(16):\n            if self._is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if not self._in_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # ---------- Paths and smoothing ----------\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, meet_a, meet_b):\n        # meet_a is in active tree; meet_b is in the opposite tree\n        path_a = self._trace_to_root(meet_a)\n        # path_b: from meet_b up to its root\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # Concatenate without adding a cross edge to preserve structures\n        return path_a + path_b\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _prune_collinear(self, pts, cos_eps=0.999):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        for i in range(1, len(pts) - 1):\n            a = out[-1]\n            b = pts[i]\n            c = pts[i + 1]\n            v1 = tuple(b[j] - a[j] for j in range(self.dim))\n            v2 = tuple(c[j] - b[j] for j in range(self.dim))\n            n1 = sum(v1[j] * v1[j] for j in range(self.dim)) ** 0.5\n            n2 = sum(v2[j] * v2[j] for j in range(self.dim)) ** 0.5\n            if n1 < 1e-9 or n2 < 1e-9:\n                continue\n            cosang = sum(v1[j] * v2[j] for j in range(self.dim)) / (n1 * n2)\n            if cosang < cos_eps:\n                out.append(b)\n        out.append(pts[-1])\n        return out\n\n    def _vis_collapse(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = pts[:]\n        i = 0\n        while i < len(out) - 2:\n            j = len(out) - 1\n            collapsed = False\n            while j > i + 1:\n                if self._edge_free(out[i], out[j]):\n                    del out[i + 1:j]\n                    collapsed = True\n                    break\n                j -= 1\n            if not collapsed:\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        stall = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 1, len(cur) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-9 <= bestL:\n                    cur = cand\n                    bestL = L\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            tries += 1\n            if stall > 24:\n                break\n        return cur\n\n    def _round_corners(self, pts, passes=2):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            i = 1\n            while i < len(cur) - 1:\n                a = cur[i - 1]\n                c = cur[i + 1]\n                # propose midpoint between a and c\n                mid = tuple(0.5 * (a[j] + c[j]) for j in range(self.dim))\n                if self._in_bounds(mid) and (not self._point_in_obstacles(mid)):\n                    if self._edge_free(a, mid) and self._edge_free(mid, c):\n                        cur[i] = mid\n                i += 1\n        return cur\n\n    def _smooth_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._prune_collinear(path)\n        p1 = self._vis_collapse(p0)\n        p2 = self._shortcut(p1, self.smoothing_attempts)\n        p3 = self._round_corners(p2, passes=2)\n        return p3",
          "objective": -37.18079,
          "time_improvement": 73.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1385.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009148359298706055,
                    "num_nodes_avg": 41.0,
                    "path_length_avg": 160.05130696013703,
                    "smoothness_avg": 0.047923416631070685,
                    "success_improvement": 0.0,
                    "time_improvement": 62.919010542245815,
                    "node_improvement": 89.67514479979855,
                    "length_improvement": 12.273342479892806,
                    "smoothness_improvement": 650.1055376411265,
                    "objective_score": 29.490236338815063
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.039803075790405276,
                    "num_nodes_avg": 172.0,
                    "path_length_avg": 240.87765654308606,
                    "smoothness_avg": 0.0896202009366,
                    "success_improvement": 0.0,
                    "time_improvement": 76.20167525773196,
                    "node_improvement": 88.44319021702614,
                    "length_improvement": 19.588104967000366,
                    "smoothness_improvement": 2205.992320920289,
                    "objective_score": 45.64332716212125
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.00955343246459961,
                    "num_nodes_avg": 74.0,
                    "path_length_avg": 136.5410158564313,
                    "smoothness_avg": 0.11001885368701667,
                    "success_improvement": 0.0,
                    "time_improvement": 81.07358629325219,
                    "node_improvement": 90.59122695486332,
                    "length_improvement": 9.315958652640234,
                    "smoothness_improvement": 1299.4316981518023,
                    "objective_score": 36.40880957031881
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SIBiRRT-Connect-Lite: A streamlined balanced informed BiRRT-Connect with light neighbor parent selection, grid-accelerated proximity/collision, and two-phase shortcut refinement for faster search, shorter paths, and improved smoothness.",
          "planning_mechanism": "Per iteration, expand the smaller tree: sample from a mixed distribution (uniform/corridor/goal; ellipse after a first solution), steer one bounded step, validate node and edge, pick the cheapest feasible parent among the nearest few neighbors, insert, then greedily connect the opposite tree toward it until blocked. On connection, extract and shortcut the path and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=6.0,\n        goal_bias=0.25,\n        corridor_bias=0.35,\n        grid_cell_factor=1.0,\n        min_sep_ratio=0.3,\n        neighbor_radius_factor=2.0,\n        neighbor_cap=6,\n        connect_steps=32,\n        shortcut_attempts=80\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.min_sep_ratio = min_sep_ratio\n        self.neighbor_radius_factor = neighbor_radius_factor\n        self.neighbor_cap = neighbor_cap\n        self.connect_steps = connect_steps\n        self.shortcut_attempts = shortcut_attempts\n        self._rnd_state = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step_size * self.min_sep_ratio)\n        self.neighbor_radius = max(self.step_size * 1.2, self.step_size * self.neighbor_radius_factor)\n\n        self._seed_from_scene()\n\n        nodes = []\n        edges = []\n\n        if (not self._within_bounds(self.start)) or (not self._within_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._build_obstacle_grid()\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        incumbent_len = None\n\n        for _ in range(self.max_iter):\n            if len(tree_a) <= len(tree_b):\n                active_tree, active_grid = tree_a, grid_a\n                passive_tree, passive_grid = tree_b, grid_b\n                attractor = self.goal\n            else:\n                active_tree, active_grid = tree_b, grid_b\n                passive_tree, passive_grid = tree_a, grid_a\n                attractor = self.start\n\n            s = self._sample(attractor, incumbent_len)\n            if s is None:\n                continue\n\n            nearest = self._nearest_in_grid(active_grid, s)\n            if nearest is None:\n                continue\n\n            new_pos = self._steer(nearest.position, s, self.step_size)\n            if not self._within_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if self._has_nearby(active_grid, new_pos, self.min_sep):\n                continue\n\n            parent, new_cost = self._choose_parent_light(active_grid, nearest, new_pos)\n            if parent is None:\n                continue\n\n            if self._point_in_obstacles(new_pos):\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(active_grid, new_node)\n\n            meet = self._connect_toward(passive_tree, passive_grid, new_node.position, nodes, edges)\n            if meet is not None and self._edge_free(meet.position, new_node.position):\n                path = self._extract_path(new_node, meet)\n                incumbent_len = self._path_len(path)\n                path = self._shortcut(path)\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0x7fffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0x7fffffff\n        self._rnd_state = (s ^ 0x9E3779B9) & 0x7fffffff\n        if self._rnd_state == 0:\n            self._rnd_state = 123456789\n\n    def _rand(self):\n        self._rnd_state = (1103515245 * self._rnd_state + 12345) & 0x7fffffff\n        return self._rnd_state / 2147483647.0\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            q = []\n            for i in range(self.dims):\n                q.append(self._clamp_val(b[i], 0.0, self.bounds[i]))\n            return tuple(q)\n        d = d2 ** 0.5\n        r = step / d\n        q = []\n        for i in range(self.dims):\n            v = a[i] + (b[i] - a[i]) * r\n            q.append(self._clamp_val(v, 0.0, self.bounds[i]))\n        return tuple(q)\n\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_in_grid(self, grid, pos, max_ring=4):\n        key = self._cell_of(pos)\n        best = None\n        bestd2 = 1e100\n        for r in range(0, max_ring + 1):\n            cand = self._ring_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            if best is not None:\n                return best\n        buckets = list(grid.values())\n        if not buckets:\n            return None\n        trials = 0\n        while trials < 24:\n            b = buckets[int(self._rand() * len(buckets)) % max(1, len(buckets))]\n            if b:\n                n = b[int(self._rand() * len(b)) % max(1, len(b))]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            trials += 1\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        rc = int(radius // self.cell_size) + 1\n        r2 = radius * radius\n        for n in self._ring_collect(grid, key, rc):\n            if self._dist2(n.position, pos) <= r2:\n                return True\n        return False\n\n    def _nearby_nodes(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        rc = int(radius // self.cell_size) + 1\n        r2 = radius * radius\n        out = []\n        for n in self._ring_collect(grid, key, rc):\n            if self._dist2(n.position, pos) <= r2:\n                out.append(n)\n        return out\n\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            b = self.obs_grid.get((cx, cy, cz))\n            if not b:\n                return False\n            px, py, pz = p\n            for idx in b:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            b = self.obs_grid.get((cx, cy))\n            if not b:\n                return False\n            px, py = p\n            for idx in b:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _choose_parent_light(self, grid, nearest, new_pos):\n        neigh = self._nearby_nodes(grid, new_pos, self.neighbor_radius)\n        if nearest not in neigh:\n            neigh.append(nearest)\n        neigh.sort(key=lambda n: self._dist2(n.position, new_pos))\n        cand = neigh[:max(1, self.neighbor_cap)]\n        best_parent = None\n        best_cost = 1e100\n        for n in cand:\n            if not self._edge_free(n.position, new_pos):\n                continue\n            c = n.cost + self._dist(n.position, new_pos)\n            if c + 1e-9 < best_cost:\n                best_cost = c\n                best_parent = n\n        if best_parent is None:\n            return None, None\n        return best_parent, best_cost\n\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        near = self._nearest_in_grid(grid, target_pos)\n        if near is None:\n            return None\n        cur = near\n        steps = 0\n        while steps < self.connect_steps:\n            nxt = self._steer(cur.position, target_pos, self.step_size)\n            if self._dist2(cur.position, nxt) < (self.min_sep * self.min_sep * 0.25):\n                break\n            if not self._within_bounds(nxt):\n                break\n            if self._point_in_obstacles(nxt):\n                break\n            if self._has_nearby(grid, nxt, self.min_sep):\n                break\n            if not self._edge_free(cur.position, nxt):\n                break\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            q = Node(nxt, cur, new_cost)\n            cur.add_child(q)\n            tree.append(q)\n            nodes.append(q)\n            edges.append((cur, q))\n            self._grid_insert(grid, q)\n            cur = q\n            steps += 1\n            if self._dist2(cur.position, target_pos) <= (self.step_size * self.step_size) and self._edge_free(cur.position, target_pos):\n                return cur\n        return None\n\n    def _sample(self, attractor, incumbent_len):\n        for _ in range(20):\n            r = self._rand()\n            if incumbent_len is not None and r < 0.55:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                elif r < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_sample()\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            if p is not None and self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        if self._within_bounds(attractor) and not self._point_in_obstacles(attractor):\n            return attractor\n        return None\n\n    def _corridor_sample(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n        dsg = self._dist(self.start, self.goal)\n        width = max(self.step_size, 0.08 * dsg)\n        if self.is_3d:\n            return (\n                self._clamp_val(base[0] + self._rand_range(-width, width), 0.0, self.bounds[0]),\n                self._clamp_val(base[1] + self._rand_range(-width, width), 0.0, self.bounds[1]),\n                self._clamp_val(base[2] + self._rand_range(-width, width), 0.0, self.bounds[2]),\n            )\n        else:\n            return (\n                self._clamp_val(base[0] + self._rand_range(-width, width), 0.0, self.bounds[0]),\n                self._clamp_val(base[1] + self._rand_range(-width, width), 0.0, self.bounds[1]),\n            )\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum_dist\n        ext = [max(self.step_size, half)] * self.dims\n        for _ in range(18):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._within_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum_dist and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        pb.reverse()\n        if pa and pb and pa[-1] == pb[0]:\n            pb = pb[1:]\n        return pa + pb\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        i = 0\n        while i < len(pts) - 2:\n            j = len(pts) - 1\n            improved = False\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    del pts[i + 1:j]\n                    improved = True\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n        attempts = 0\n        while attempts < self.shortcut_attempts and len(pts) > 2:\n            i = int(self._rand_range(0, len(pts) - 2))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                attempts += 1\n                continue\n            if self._edge_free(pts[i], pts[j]):\n                pts = pts[:i + 1] + pts[j:]\n            attempts += 1\n        return pts",
          "objective": -37.09124,
          "time_improvement": 61.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1377.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011144709587097169,
                    "num_nodes_avg": 49.0,
                    "path_length_avg": 150.61019244127573,
                    "smoothness_avg": 0.04827733550563596,
                    "success_improvement": 0.0,
                    "time_improvement": 54.82721598316178,
                    "node_improvement": 87.6605389070763,
                    "length_improvement": 17.448166951713837,
                    "smoothness_improvement": 655.6451365752101,
                    "objective_score": 30.195290648852886
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04703662395477295,
                    "num_nodes_avg": 160.0,
                    "path_length_avg": 222.69131300634007,
                    "smoothness_avg": 0.08728289130799861,
                    "success_improvement": 0.0,
                    "time_improvement": 71.87672486543198,
                    "node_improvement": 89.24947927165222,
                    "length_improvement": 25.65922990444059,
                    "smoothness_improvement": 2145.851660680297,
                    "objective_score": 47.68781370569543
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02253601551055908,
                    "num_nodes_avg": 116.0,
                    "path_length_avg": 125.1119046359757,
                    "smoothness_avg": 0.11227318427452833,
                    "success_improvement": 0.0,
                    "time_improvement": 55.35364337006359,
                    "node_improvement": 85.2511125238398,
                    "length_improvement": 16.906630129474358,
                    "smoothness_improvement": 1328.1066168275754,
                    "objective_score": 33.39060417284157
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "INSTAR-BiRRT*: Informed-Indexed Star-Rewire Bidirectional Planner. A bidirectional, obstacle-indexed RRT with local best-parent selection, limited RRT*-style rewiring, cached edge checks, and informed corridor sampling that tightens after the first solution. It enforces strict node and edge collision checks before any insertion, caps connect steps, and maintains coherent trees/edges. On connection, it performs visibility compression, endpoint-inclusive shortcutting, and elastic smoothing for shorter, smoother paths while keeping runtime low.",
          "planning_mechanism": "Mechanism: Build start/goal trees with a spatial node grid and an obstacle cell index. Each iteration alternates trees, samples goal/corridor/informed/uniform targets using LCG RNG, gathers near candidates from grid rings, selects the cheapest collision-free parent, and inserts a single node after both node and edge checks. It then locally rewires cheaper neighbors (edge-checked) and attempts a bounded greedy connect on the opposite tree with commit-per-step checks. A cached, AABB-prefiltered edge tester accelerates validation. Upon bridge closure, it assembles the path and applies visibility compression, endpoint-inclusive random shortcuts, and elastic smoothing.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=7000,\n        step_size=6.0,\n        goal_bias=0.22,\n        corridor_bias=0.40,\n        grid_cell_factor=1.3,\n        neighbor_radius_ratio=1.5,\n        rewire_radius_ratio=1.8,\n        dupe_radius_ratio=0.30,\n        connect_hops=6,\n        edge_resolution=0.9,\n        shortcut_attempts=120,\n        elastic_iters=8\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neighbor_radius_ratio = float(neighbor_radius_ratio)\n        self.rewire_radius_ratio = float(rewire_radius_ratio)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.connect_hops = int(connect_hops)\n        self.edge_resolution = float(edge_resolution)\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.elastic_iters = int(max(0, elastic_iters))\n        # runtime fields\n        self.bounds = None\n        self.dim = 2\n        self.is_3d = False\n        self.start = None\n        self.goal = None\n        self.obstacles = None\n        self.grid_cell = 1.0\n        self.obs_cell = 4.0\n        self.edge_res = 1.0\n        self.cache_bin = 1.0\n        self._free_edge_cache = None\n        self._blocked_edge_cache = None\n        self.obs_index = None\n\n    # ---- Public API ----\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles)\n\n        # Parameterize\n        self.grid_cell = max(1.0, self.grid_cell_factor * self.step_size)\n        self.obs_cell = max(4.0, 1.2 * self.step_size)\n        self.edge_res = max(0.5, min(self.edge_resolution, self.step_size))\n        self.cache_bin = max(1.0, self.edge_res)\n\n        # Validate start/goal\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._build_obstacle_index()\n        if self._is_point_blocked_indexed(self.start) or self._is_point_blocked_indexed(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct LOS\n        self._free_edge_cache, self._blocked_edge_cache = set(), set()\n        if not self._is_edge_blocked_cached(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._distance(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Initialize trees, grids, edges\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree, goal_tree = [start_root], [goal_root]\n        grid_start, grid_goal = {}, {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n        edges = []\n\n        # RNG init\n        self._lcg_state = 2463534242\n\n        # Sampling parameters\n        dsg = self._distance(self.start, self.goal)\n        corridor_w = max(self.step_size, 0.2 * dsg)\n        dupe_radius = max(0.5, self.dupe_radius_ratio * self.step_size)\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            # Alternate sides\n            if it % 2 == 0:\n                grow_tree, grow_grid, grow_root_pos = start_tree, grid_start, self.start\n                other_tree, other_grid, other_root_pos = goal_tree, grid_goal, self.goal\n                start_side_active = True\n            else:\n                grow_tree, grow_grid, grow_root_pos = goal_tree, grid_goal, self.goal\n                other_tree, other_grid, other_root_pos = start_tree, grid_start, self.start\n                start_side_active = False\n\n            # Dynamic radii (light dependence on current tree size)\n            nA = max(1, len(grow_tree))\n            neighbor_radius = max(self.step_size, self.neighbor_radius_ratio * self.step_size * (1.0 + 0.15 * (1.0 / (1.0 + nA / 300.0))))\n            rewire_radius = max(self.step_size, self.rewire_radius_ratio * self.step_size * (1.0 + 0.10 * (1.0 / (1.0 + nA / 300.0))))\n\n            # Target sampling (goal / informed corridor / uniform)\n            r = self._rand()\n            if r < self.goal_bias:\n                target = other_root_pos\n            else:\n                # informed corridor tightens once a path exists\n                use_informed = best_len < float('inf') and self._rand() < self.corridor_bias\n                if use_informed:\n                    width = max(self.step_size, 0.25 * (best_len - dsg) + 0.15 * dsg)\n                    target = self._sample_corridor(self.start, self.goal, width)\n                elif self._rand() < self.corridor_bias:\n                    target = self._sample_corridor(self.start, self.goal, corridor_w)\n                else:\n                    target = self._sample_free()\n\n            # Choose near set and best parent\n            near_candidates = self._nearest_candidates(grow_tree, grow_grid, target, min_k=16, max_rings=4)\n            if not near_candidates:\n                near_candidates = [self._nearest_linear(grow_tree, target)]\n            base_parent = self._best_near(near_candidates, target)\n            proposed = self._steer(base_parent.position, target, self.step_size)\n            if not self._within_bounds(proposed):\n                continue\n            if self._is_point_blocked_indexed(proposed):\n                continue\n            if self._exists_close(grow_grid, proposed, dupe_radius):\n                continue\n\n            # Best-parent selection within neighbor radius (strict node+edge checks)\n            neighbors = self._neighbors_within_radius(grow_grid, proposed, neighbor_radius)\n            if base_parent not in neighbors:\n                neighbors.append(base_parent)\n            best_parent = None\n            best_cost = float('inf')\n            for cand in neighbors:\n                dcp = self._distance(cand.position, proposed)\n                if dcp > self.step_size + 1e-9:\n                    continue\n                if self._is_edge_blocked_cached(cand.position, proposed):\n                    continue\n                cost = cand.cost + dcp\n                if cost < best_cost:\n                    best_cost = cost\n                    best_parent = cand\n            if best_parent is None:\n                continue\n\n            # Commit new node (both checks enforced)\n            new_node = self._commit_node(grow_tree, grow_grid, edges, best_parent, proposed, best_cost)\n            if new_node is None:\n                continue\n\n            # Local rewiring (limited) with strict edge checks\n            self._local_rewire(new_node, grow_grid, edges, rewire_radius, max_rewires=16)\n\n            # Attempt immediate direct bridge to nearest of other tree\n            other_near = self._nearest_from_grid(other_tree, other_grid, new_node.position, max_rings=3)\n            if other_near is not None and not self._is_edge_blocked_cached(new_node.position, other_near.position):\n                # Bridge and finish\n                edges.append((other_near, new_node))\n                raw_path = self._assemble_path(start_root, goal_root, new_node, other_near, start_side_active)\n                best_len = self._path_length(raw_path)\n                path = self._postprocess(raw_path)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Greedy bounded connect on the other tree toward new_node\n            if other_near is None:\n                other_near = self._nearest_linear(other_tree, new_node.position)\n            last_b = self._bounded_connect(other_tree, other_grid, other_near, new_node.position, edges, self.connect_hops)\n            if last_b is not None:\n                # Try final bridge\n                if not self._is_edge_blocked_cached(last_b.position, new_node.position):\n                    edges.append((last_b, new_node))\n                    raw_path = self._assemble_path(start_root, goal_root, new_node, last_b, start_side_active)\n                    best_len = self._path_length(raw_path)\n                    path = self._postprocess(raw_path)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---- RNG ----\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---- Geometry ----\n    def _distance(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_pos(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._distance(from_pos, to_pos)\n        if d <= step:\n            return self._clamp_pos(to_pos)\n        r = step / (d + 1e-12)\n        return self._clamp_pos(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---- Obstacle index and collision ----\n    def _build_obstacle_index(self):\n        self.obs_index = {}\n        if self.is_3d:\n            for oi, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                minx = int(x // self.obs_cell)\n                maxx = int((x + w) // self.obs_cell)\n                miny = int(y // self.obs_cell)\n                maxy = int((y + h) // self.obs_cell)\n                minz = int(z // self.obs_cell)\n                maxz = int((z + d) // self.obs_cell)\n                for cx in range(minx, maxx + 1):\n                    for cy in range(miny, maxy + 1):\n                        for cz in range(minz, maxz + 1):\n                            key = (cx, cy, cz)\n                            bucket = self.obs_index.get(key)\n                            if bucket is None:\n                                self.obs_index[key] = [oi]\n                            else:\n                                bucket.append(oi)\n        else:\n            for oi, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                minx = int(x // self.obs_cell)\n                maxx = int((x + w) // self.obs_cell)\n                miny = int(y // self.obs_cell)\n                maxy = int((y + h) // self.obs_cell)\n                for cx in range(minx, maxx + 1):\n                    for cy in range(miny, maxy + 1):\n                        key = (cx, cy)\n                        bucket = self.obs_index.get(key)\n                        if bucket is None:\n                            self.obs_index[key] = [oi]\n                        else:\n                            bucket.append(oi)\n\n    def _obs_cell_key(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.obs_cell), int(pos[1] // self.obs_cell), int(pos[2] // self.obs_cell))\n        else:\n            return (int(pos[0] // self.obs_cell), int(pos[1] // self.obs_cell))\n\n    def _obs_candidates_for_segment(self, a, b, pad):\n        if self.is_3d:\n            mins = (min(a[0], b[0]) - pad, min(a[1], b[1]) - pad, min(a[2], b[2]) - pad)\n            maxs = (max(a[0], b[0]) + pad, max(a[1], b[1]) + pad, max(a[2], b[2]) + pad)\n            minc = (int(mins[0] // self.obs_cell), int(mins[1] // self.obs_cell), int(mins[2] // self.obs_cell))\n            maxc = (int(maxs[0] // self.obs_cell), int(maxs[1] // self.obs_cell), int(maxs[2] // self.obs_cell))\n            seen = set()\n            cand = []\n            for cx in range(minc[0], maxc[0] + 1):\n                for cy in range(minc[1], maxc[1] + 1):\n                    for cz in range(minc[2], maxc[2] + 1):\n                        bucket = self.obs_index.get((cx, cy, cz))\n                        if bucket:\n                            for oi in bucket:\n                                if oi not in seen:\n                                    seen.add(oi)\n                                    cand.append(oi)\n            return cand\n        else:\n            mins = (min(a[0], b[0]) - pad, min(a[1], b[1]) - pad)\n            maxs = (max(a[0], b[0]) + pad, max(a[1], b[1]) + pad)\n            minc = (int(mins[0] // self.obs_cell), int(mins[1] // self.obs_cell))\n            maxc = (int(maxs[0] // self.obs_cell), int(maxs[1] // self.obs_cell))\n            seen = set()\n            cand = []\n            for cx in range(minc[0], maxc[0] + 1):\n                for cy in range(minc[1], maxc[1] + 1):\n                    bucket = self.obs_index.get((cx, cy))\n                    if bucket:\n                        for oi in bucket:\n                            if oi not in seen:\n                                seen.add(oi)\n                                cand.append(oi)\n            return cand\n\n    def _is_point_blocked_indexed(self, pos):\n        key = self._obs_cell_key(pos)\n        bucket = self.obs_index.get(key)\n        if not bucket:\n            return False\n        if self.is_3d:\n            px, py, pz = pos\n            for oi in bucket:\n                x, y, z, w, h, d = self.obstacles[oi]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for oi in bucket:\n                x, y, w, h = self.obstacles[oi]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_blocked_cached(self, a, b):\n        key = self._edge_key_q(a, b)\n        if key in self._blocked_edge_cache:\n            return True\n        if key in self._free_edge_cache:\n            return False\n        blocked = self._is_edge_blocked_filtered(a, b)\n        if blocked:\n            self._blocked_edge_cache.add(key)\n            return True\n        else:\n            self._free_edge_cache.add(key)\n            return False\n\n    def _is_edge_blocked_filtered(self, a, b):\n        d = self._distance(a, b)\n        steps = int(max(1, d / max(1e-9, self.edge_res)))\n        cand = self._obs_candidates_for_segment(a, b, pad=self.edge_res)\n        if not cand:\n            return False\n        if steps <= 1:\n            mid = tuple((a[i] + b[i]) * 0.5 for i in range(self.dim))\n            return self._is_point_blocked_in_list(mid, cand) or self._is_point_blocked_in_list(a, cand) or self._is_point_blocked_in_list(b, cand)\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_point_blocked_in_list(p, cand):\n                return True\n        return False\n\n    def _is_point_blocked_in_list(self, pos, cand_idx):\n        if not cand_idx:\n            return False\n        if self.is_3d:\n            px, py, pz = pos\n            for oi in cand_idx:\n                x, y, z, w, h, d = self.obstacles[oi]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for oi in cand_idx:\n                x, y, w, h = self.obstacles[oi]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    # ---- Sampling ----\n    def _sample_free(self):\n        for _ in range(64):\n            if self.is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_point_blocked_indexed(p):\n                return p\n        # fallback within bounds (may be blocked; extension will reject)\n        if self.is_3d:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]),\n                    self._uniform(0.0, self.bounds[2]))\n        else:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]))\n\n    def _sample_corridor(self, a, b, width):\n        t = self._rand()\n        base = tuple(a[i] + t * (b[i] - a[i]) for i in range(self.dim))\n        if self.is_3d:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_point_blocked_indexed(p):\n            return p\n        return self._sample_free()\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # ---- Node grid and nearest ----\n    def _grid_key(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell), int(pos[2] // self.grid_cell))\n        else:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _nearest_from_grid(self, tree, grid, point, max_rings=4):\n        # ring search with early exit only if enough candidates seen; else fallback\n        cand = self._collect_ring(grid, point, max_rings)\n        if cand:\n            best = cand[0]\n            bestd = self._distance(best.position, point)\n            for n in cand:\n                d = self._distance(n.position, point)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            return best\n        return self._nearest_linear(tree, point)\n\n    def _nearest_linear(self, tree, point):\n        best = tree[0]\n        bestd = self._distance(best.position, point)\n        for n in tree:\n            d = self._distance(n.position, point)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _collect_ring(self, grid, point, max_rings):\n        center = self._grid_key(point)\n        out = []\n        # grow rings\n        for r in range(0, max_rings + 1):\n            if self.is_3d:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            k = (center[0] + dx, center[1] + dy, center[2] + dz)\n                            if k in grid:\n                                out.extend(grid[k])\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        k = (center[0] + dx, center[1] + dy)\n                        if k in grid:\n                            out.extend(grid[k])\n        return out\n\n    def _nearest_candidates(self, tree, grid, point, min_k=16, max_rings=4):\n        cand = []\n        center = self._grid_key(point)\n        for r in range(0, max_rings + 1):\n            if self.is_3d:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            k = (center[0] + dx, center[1] + dy, center[2] + dz)\n                            if k in grid:\n                                cand.extend(grid[k])\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        k = (center[0] + dx, center[1] + dy)\n                        if k in grid:\n                            cand.extend(grid[k])\n            if len(cand) >= min_k:\n                break\n        if not cand and tree:\n            cand = tree[:min(min_k, len(tree))]\n        return cand\n\n    def _neighbors_within_radius(self, grid, point, radius):\n        cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        center = self._grid_key(point)\n        out = []\n        if self.is_3d:\n            for dx in range(-cells, cells + 1):\n                for dy in range(-cells, cells + 1):\n                    for dz in range(-cells, cells + 1):\n                        k = (center[0] + dx, center[1] + dy, center[2] + dz)\n                        if k in grid:\n                            out.extend(grid[k])\n        else:\n            for dx in range(-cells, cells + 1):\n                for dy in range(-cells, cells + 1):\n                    k = (center[0] + dx, center[1] + dy)\n                    if k in grid:\n                        out.extend(grid[k])\n        # distance filter\n        rr = radius * radius\n        fil = []\n        for n in out:\n            s = 0.0\n            p = n.position\n            for i in range(self.dim):\n                d = p[i] - point[i]\n                s += d * d\n            if s <= rr:\n                fil.append(n)\n        return fil\n\n    def _exists_close(self, grid, pos, radius):\n        return len(self._neighbors_within_radius(grid, pos, radius)) > 0\n\n    def _best_near(self, nodes, target):\n        best = nodes[0]\n        bestd = self._distance(best.position, target)\n        for n in nodes:\n            d = self._distance(n.position, target)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    # ---- Commit/rewire/connect ----\n    def _commit_node(self, tree, grid, edges, parent, pos, cost):\n        if not self._within_bounds(pos):\n            return None\n        if self._is_point_blocked_indexed(pos):\n            return None\n        if self._is_edge_blocked_cached(parent.position, pos):\n            return None\n        new_node = Node(pos, parent, cost)\n        parent.add_child(new_node)\n        tree.append(new_node)\n        self._grid_add(grid, new_node)\n        edges.append((parent, new_node))\n        return new_node\n\n    def _local_rewire(self, new_node, grid, edges, radius, max_rewires=16):\n        # try to improve nearby neighbors' costs via new_node\n        neigh = self._neighbors_within_radius(grid, new_node.position, radius)\n        count = 0\n        for nb in neigh:\n            if nb is new_node or nb is new_node.parent:\n                continue\n            d = self._distance(new_node.position, nb.position)\n            if d <= 1e-9 or d > radius + 1e-9:\n                continue\n            new_cost = new_node.cost + d\n            if new_cost + 1e-9 < nb.cost:\n                # enforce both checks\n                if self._is_edge_blocked_cached(new_node.position, nb.position):\n                    continue\n                if self._is_point_blocked_indexed(nb.position):  # redundant but explicit\n                    continue\n                old_parent = nb.parent\n                if old_parent is None:\n                    continue\n                # apply rewire\n                self._remove_child(old_parent, nb)\n                self._remove_edge(edges, old_parent, nb)\n                new_node.add_child(nb)\n                nb.parent = new_node\n                delta = new_cost - nb.cost\n                nb.cost = new_cost\n                self._propagate_cost(nb, delta)\n                edges.append((new_node, nb))\n                count += 1\n                if count >= max_rewires:\n                    break\n\n    def _remove_child(self, parent, child):\n        if child in parent.children:\n            parent.children.remove(child)\n\n    def _remove_edge(self, edges, parent, child):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is parent and e[1] is child:\n                del edges[i]\n                return\n\n    def _propagate_cost(self, node, delta):\n        # BFS propagate cost changes to subtree\n        q = [node]\n        while q:\n            cur = q.pop()\n            for ch in cur.children:\n                ch.cost += delta\n                q.append(ch)\n\n    def _bounded_connect(self, tree, grid, from_node, target_pos, edges, max_hops):\n        current = from_node\n        last_new = None\n        hops = 0\n        while hops < max_hops:\n            step_pos = self._steer(current.position, target_pos, self.step_size)\n            if not self._within_bounds(step_pos):\n                break\n            if self._is_point_blocked_indexed(step_pos):\n                break\n            if self._is_edge_blocked_cached(current.position, step_pos):\n                break\n            # commit (strict checks already done)\n            new_cost = current.cost + self._distance(current.position, step_pos)\n            nxt = Node(step_pos, current, new_cost)\n            current.add_child(nxt)\n            tree.append(nxt)\n            self._grid_add(grid, nxt)\n            edges.append((current, nxt))\n            last_new = nxt\n            current = nxt\n            hops += 1\n            if self._distance(current.position, target_pos) <= self.step_size:\n                break\n        return last_new\n\n    # ---- Path assembly and post-processing ----\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _assemble_path(self, start_root, goal_root, a_node, b_node, a_is_start_side):\n        if a_is_start_side:\n            pa = self._path_to_root(a_node)  # start -> a_node\n            pb = self._path_to_root(b_node)  # goal -> b_node\n            return pa + pb[::-1]\n        else:\n            pa = self._path_to_root(a_node)  # goal-side growth\n            pb = self._path_to_root(b_node)\n            return pb + pa[::-1]\n\n    def _path_length(self, path):\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._distance(path[i - 1], path[i])\n        return total\n\n    def _visibility_compress(self, path):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            jumped = False\n            while j > i + 1:\n                if not self._is_edge_blocked_cached(path[i], path[j]):\n                    out.append(path[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(path[i + 1])\n                i += 1\n        if out[-1] != path[-1]:\n            out.append(path[-1])\n        # de-dup\n        ded = [out[0]]\n        for k in range(1, len(out)):\n            if self._distance(ded[-1], out[k]) > 1e-9:\n                ded.append(out[k])\n        return ded\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return list(path)\n        pts = list(path)\n        for _ in range(attempts):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_blocked_cached(a, b):\n                pts = pts[:i + 1] + pts[j:]\n        return pts\n\n    def _elastic(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return list(path)\n        pts = list(path)\n        for _ in range(iters):\n            changed = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                if self._is_point_blocked_indexed(mid):\n                    continue\n                if self._is_edge_blocked_cached(a, mid):\n                    continue\n                if self._is_edge_blocked_cached(mid, c):\n                    continue\n                if self._distance(pts[i], mid) > 1e-9:\n                    pts[i] = mid\n                    changed = True\n            if not changed:\n                break\n        return pts\n\n    def _postprocess(self, raw_path):\n        p = self._visibility_compress(raw_path)\n        p = self._shortcut(p, self.shortcut_attempts)\n        p = self._elastic(p, self.elastic_iters)\n        return p",
          "objective": -36.94679,
          "time_improvement": 62.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1876.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01455528736114502,
                    "num_nodes_avg": 56.0,
                    "path_length_avg": 153.05488117915178,
                    "smoothness_avg": 0.04323917072604063,
                    "success_improvement": 0.0,
                    "time_improvement": 41.00314170328443,
                    "node_improvement": 85.89775875094435,
                    "length_improvement": 16.108194315911927,
                    "smoothness_improvement": 576.7869172246149,
                    "objective_score": 24.84979368665556
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04361860752105713,
                    "num_nodes_avg": 170.0,
                    "path_length_avg": 244.2123677023688,
                    "smoothness_avg": 0.12207511882177972,
                    "success_improvement": 0.0,
                    "time_improvement": 73.92036253535261,
                    "node_improvement": 88.57757172613049,
                    "length_improvement": 18.474882397693065,
                    "smoothness_improvement": 3041.0807344384375,
                    "objective_score": 48.466441871413814
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014497733116149903,
                    "num_nodes_avg": 74.0,
                    "path_length_avg": 135.28177456457792,
                    "smoothness_avg": 0.16586943691668363,
                    "success_improvement": 0.0,
                    "time_improvement": 71.27837604096456,
                    "node_improvement": 90.59122695486332,
                    "length_improvement": 10.15228676006259,
                    "smoothness_improvement": 2009.8469943719351,
                    "objective_score": 37.5241198401866
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SAGE-BRRT: Simple Adaptive Grid-Enhanced BiRRT with Local Rewire and On-the-fly Visibility. Two trees grow toward each other using grid-accelerated nearest search and informed/corridor-biased sampling. Each insertion selects the least-cost feasible parent among nearby nodes, performs ancestor visibility compression, and locally rewires neighbors. A probe-then-commit connect adds at most one node on the opposite tree per iteration and bridges if a short direct link is free. Obstacle checks use a spatial hash for fast node and edge validation. On success, a lightweight visibility pass, shortcutting, and elastic smoothing return a short, smooth path quickly.",
          "planning_mechanism": "Initialize bidirectional trees, node-grid, and obstacle-grid. Iterate: sample a target (goal/corridor/informed/uniform), find a near node via grid rings, steer by a fixed step, and validate node (inside-bounds, not in obstacles) and edge (segment-obstacle free). Choose the best feasible parent within a local radius; insert the node, then optionally compress to a visible ancestor and rewire nearby nodes if cheaper. Probe the other tree: try a direct bridge; else simulate one feasible step toward the new node and commit at most one opposite-node; if the short bridge becomes free, assemble the path. Maintain an incumbent path for informed sampling. After connection, run visibility compression, shortcutting, and elastic smoothing, then return the result.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=7.0,\n        goal_bias=0.18,\n        corridor_bias=0.35,\n        informed_bias=0.55,\n        cell_size_factor=1.6,\n        dupe_radius_ratio=0.45,\n        rewire_radius_factor=2.0,\n        neighbor_cap=24,\n        connect_steps=1,\n        smooth_shortcuts=80,\n        rubber_iters=8\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.cell_size_factor = float(cell_size_factor)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.rewire_radius_factor = float(rewire_radius_factor)\n        self.neighbor_cap = int(neighbor_cap)\n        self.connect_steps = int(connect_steps)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self.rubber_iters = int(max(0, rubber_iters))\n\n        self._rnd = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_from_scene()\n\n        # Build obstacle spatial hash\n        self._build_obstacle_grid()\n\n        # Validate endpoints\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Setup structures\n        self.cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.rewire_radius = max(self.step_size * 1.25, self.rewire_radius_factor * self.step_size)\n\n        nodes = []\n        edges = []\n\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        tree_a, tree_b = [a_root], [b_root]\n        grid_a, grid_b = {}, {}\n        anchors_a, anchors_b = [a_root], [b_root]\n        self._grid_insert(grid_a, a_root)\n        self._grid_insert(grid_b, b_root)\n\n        best_path = None\n        best_len = float('inf')\n\n        # Corridor width for biased sampling\n        sg = self._dist(self.start, self.goal)\n        corridor_w = max(self.step_size, 0.2 * sg)\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            tree1 = tree_a if side_a else tree_b\n            grid1 = grid_a if side_a else grid_b\n            anchors1 = anchors_a if side_a else anchors_b\n\n            tree2 = tree_b if side_a else tree_a\n            grid2 = grid_b if side_a else grid_a\n            anchors2 = anchors_b if side_a else anchors_a\n\n            attractor = self.goal if side_a else self.start\n\n            # Sample a target\n            target = self._sample_target(attractor, best_len, corridor_w)\n            if target is None:\n                continue\n\n            # Find near node and steer\n            near = self._nearest_hashed(grid1, anchors1, target, 3)\n            if near is None:\n                continue\n            new_pos = self._steer(near.position, target)\n\n            # Validity checks for node and edge\n            if not self._within_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if self._has_nearby(grid1, new_pos, self.dupe_radius):\n                continue\n\n            # Select best parent among local candidates\n            parent, new_cost = self._choose_parent(grid1, anchors1, tree1, new_pos)\n            if parent is None:\n                continue\n\n            # Node collision already checked; ensure edge is free\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            # Insert node\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(grid1, new_node)\n            if (len(tree1) % 24) == 0:\n                anchors1.append(new_node)\n\n            # Optional: compress to visible ancestor (one hop)\n            gp = parent.parent\n            if gp is not None:\n                if self._edge_free(gp.position, new_node.position):\n                    self._reparent(new_node, gp, edges)\n\n            # Local rewiring\n            self._rewire_neighbors(grid1, new_node, self.rewire_radius, edges)\n\n            # Try to connect the other tree\n            other_near = self._nearest_hashed(grid2, anchors2, new_node.position, 3)\n            if other_near is not None:\n                # Direct bridge\n                if self._edge_free(new_node.position, other_near.position):\n                    path = self._assemble_path(new_node, other_near, side_a)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # Probe-then-commit: at most one step on the other tree\n                committed = None\n                steps = 0\n                probe_from = other_near\n                while steps < self.connect_steps:\n                    step_p = self._steer(probe_from.position, new_node.position)\n                    if not self._within_bounds(step_p):\n                        break\n                    if self._point_in_obstacles(step_p):\n                        break\n                    if self._has_nearby(grid2, step_p, self.dupe_radius):\n                        break\n                    if not self._edge_free(probe_from.position, step_p):\n                        break\n                    # Commit this single step\n                    q = Node(step_p, probe_from, probe_from.cost + self._dist(probe_from.position, step_p))\n                    probe_from.add_child(q)\n                    tree2.append(q)\n                    nodes.append(q)\n                    edges.append((probe_from, q))\n                    self._grid_insert(grid2, q)\n                    if (len(tree2) % 24) == 0:\n                        anchors2.append(q)\n                    # Light local optimize\n                    self._compress_one(q, edges)\n                    self._rewire_neighbors(grid2, q, self.rewire_radius, edges)\n                    committed = q\n                    break\n                # If committed, try short bridge\n                if committed is not None:\n                    if self._edge_free(new_node.position, committed.position):\n                        path = self._assemble_path(new_node, committed, side_a)\n                        path = self._postprocess(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n            # Maintain best incumbent (for informed sampling)\n            if best_path is None:\n                # Try a temporary connection via NN if possible (no commit)\n                if other_near is not None:\n                    if self._edge_free(new_node.position, other_near.position):\n                        tmp = self._assemble_path(new_node, other_near, side_a)\n                        L = self._path_len(tmp)\n                        if L < best_len:\n                            best_len = L\n                            best_path = tmp\n\n        if best_path is not None:\n            best_path = self._postprocess(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG utilities\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 1) * 2654435761\n        self._rnd = (s ^ 0x9E3779B9) & 0xffffffff\n        if self._rnd == 0:\n            self._rnd = 2463534242\n\n    def _rand(self):\n        self._rnd = (1664525 * self._rnd + 1013904223) & 0xffffffff\n        return self._rnd / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= self.step_size:\n            return self._clamp(b)\n        r = self.step_size / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Sampling\n    def _sample_target(self, attractor, best_len, corridor_w):\n        for _ in range(24):\n            if best_len < float('inf') and self._rand() < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p is not None and not self._point_in_obstacles(p):\n                    return p\n            else:\n                r = self._rand()\n                if r < self.goal_bias:\n                    p = attractor\n                elif r < self.goal_bias + self.corridor_bias:\n                    t = self._rand()\n                    base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n                    if self.is_3d:\n                        p = (\n                            self._clamp((base[0] + self._rand_range(-corridor_w, corridor_w),\n                                         base[1] + self._rand_range(-corridor_w, corridor_w),\n                                         base[2] + self._rand_range(-corridor_w, corridor_w)))[0],\n                            self._clamp((base[0] + self._rand_range(-corridor_w, corridor_w),\n                                         base[1] + self._rand_range(-corridor_w, corridor_w),\n                                         base[2] + self._rand_range(-corridor_w, corridor_w)))[1],\n                            self._clamp((base[0] + self._rand_range(-corridor_w, corridor_w),\n                                         base[1] + self._rand_range(-corridor_w, corridor_w),\n                                         base[2] + self._rand_range(-corridor_w, corridor_w)))[2]\n                        )\n                        p = (min(max(base[0] + self._rand_range(-corridor_w, corridor_w), 0.0), self.bounds[0]),\n                             min(max(base[1] + self._rand_range(-corridor_w, corridor_w), 0.0), self.bounds[1]),\n                             min(max(base[2] + self._rand_range(-corridor_w, corridor_w), 0.0), self.bounds[2]))\n                    else:\n                        p = (min(max(base[0] + self._rand_range(-corridor_w, corridor_w), 0.0), self.bounds[0]),\n                             min(max(base[1] + self._rand_range(-corridor_w, corridor_w), 0.0), self.bounds[1]))\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n                if self._within_bounds(p) and not self._point_in_obstacles(p):\n                    return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._within_bounds(p):\n                return p\n        return None\n\n    # Node grid\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, anchors, pos, max_rings=3):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # Fallback: scan grid buckets\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors_within_radius(self, grid, pos, radius, cap):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        # Filter and cap\n        out = []\n        rr = radius * radius\n        for n in cand:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= rr:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _has_nearby(self, grid, pos, radius):\n        neigh = self._neighbors_within_radius(grid, pos, radius, self.neighbor_cap)\n        return len(neigh) > 0\n\n    # Parent selection\n    def _choose_parent(self, grid, anchors, tree, new_pos):\n        neigh = self._neighbors_within_radius(grid, new_pos, self.rewire_radius, self.neighbor_cap)\n        if not neigh:\n            # include a nearest fallback\n            near = None\n            bestd = 1e100\n            for n in tree:\n                d = self._dist(n.position, new_pos)\n                if d < bestd:\n                    bestd = d\n                    near = n\n            if near is None:\n                return None, None\n            neigh = [near]\n        best_parent = None\n        best_cost = 1e100\n        for p in neigh:\n            d = self._dist(p.position, new_pos)\n            if d > self.step_size + 1e-9:\n                continue\n            if not self._edge_free(p.position, new_pos):\n                continue\n            gc = p.cost + d\n            if gc < best_cost:\n                best_cost = gc\n                best_parent = p\n        if best_parent is None:\n            return None, None\n        return best_parent, best_cost\n\n    # Obstacle spatial hash\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Local optimization helpers\n    def _compress_one(self, node, edges):\n        p = node.parent\n        if p is None or p.parent is None:\n            return\n        gp = p.parent\n        if self._edge_free(gp.position, node.position):\n            self._reparent(node, gp, edges)\n\n    def _rewire_neighbors(self, grid, node, radius, edges):\n        neigh = self._neighbors_within_radius(grid, node.position, radius, self.neighbor_cap)\n        count = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            new_cost = node.cost + d\n            if new_cost + 1e-9 < nb.cost and self._edge_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n                count += 1\n                if count >= self.neighbor_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        old_parent = child.parent\n        if old_parent is new_parent:\n            return\n        if old_parent is not None:\n            old_parent.remove_child(child)\n            self._edges_remove(edges, old_parent, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        self._propagate_costs(child)\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                old = ch.cost\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                if abs(ch.cost - old) > 1e-12:\n                    stack.append(ch)\n\n    # Path assembly and post-processing\n    def _assemble_path(self, new_node, other_node, side_a):\n        if side_a:\n            pa = new_node.path_from_root()\n            pb = other_node.path_from_root()\n            if pa and pb and pa[0] == pb[-1]:\n                pb = pb[:-1]\n            return pa + pb[::-1]\n        else:\n            pa = new_node.path_from_root()\n            pb = other_node.path_from_root()\n            if pa and pb and pb[0] == pa[-1]:\n                pa = pa[:-1]\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _postprocess(self, path):\n        if len(path) < 3:\n            return path[:]\n        p = self._visibility_compress(path)\n        p = self._shortcut(p, self.smooth_shortcuts)\n        p = self._rubber_band(p, self.rubber_iters)\n        return p\n\n    def _visibility_compress(self, path):\n        out = [path[0]]\n        last = path[0]\n        i = 1\n        while i < len(path):\n            far = i\n            j = i\n            while j < len(path):\n                if self._edge_free(last, path[j]):\n                    far = j\n                    j += 1\n                else:\n                    break\n            out.append(path[far])\n            last = path[far]\n            i = far + 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = path[:]\n        best_len = self._path_len(pts)\n        n = len(pts)\n        tries = 0\n        noimp = 0\n        stop = 12\n        while tries < attempts and n >= 3:\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j > n:\n                tries += 1\n                continue\n            a, b = pts[i], pts[j - 1]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j - 1:]\n                L = self._path_len(new_pts)\n                if L <= best_len + 1e-12:\n                    pts = new_pts\n                    best_len = L\n                    n = len(pts)\n                    noimp = 0\n                else:\n                    noimp += 1\n            else:\n                noimp += 1\n            tries += 1\n            if noimp >= stop:\n                break\n        return pts\n\n    def _rubber_band(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return path[:]\n        pts = list(path)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dims))\n                if self._point_in_obstacles(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if mid != pts[i]:\n                        pts[i] = mid\n                        moved = True\n            if not moved:\n                break\n        return pts",
          "objective": -36.91755,
          "time_improvement": 60.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 2316.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016495347023010254,
                    "num_nodes_avg": 71.0,
                    "path_length_avg": 170.6218692301367,
                    "smoothness_avg": 0.05965294648609013,
                    "success_improvement": 0.0,
                    "time_improvement": 33.13950960050793,
                    "node_improvement": 82.12037270209015,
                    "length_improvement": 6.479449798427921,
                    "smoothness_improvement": 833.6981509539397,
                    "objective_score": 17.99801351397883
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03120548725128174,
                    "num_nodes_avg": 138.0,
                    "path_length_avg": 245.4887822432574,
                    "smoothness_avg": 0.18956585497977163,
                    "success_improvement": 0.0,
                    "time_improvement": 81.34218764255085,
                    "node_improvement": 90.72767587180005,
                    "length_improvement": 18.048778484388976,
                    "smoothness_improvement": 4777.665987395928,
                    "objective_score": 59.12025332037828
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01702072620391846,
                    "num_nodes_avg": 92.0,
                    "path_length_avg": 132.8506469498789,
                    "smoothness_avg": 0.1130542551758292,
                    "success_improvement": 0.0,
                    "time_improvement": 66.28004574080119,
                    "node_improvement": 88.30260648442466,
                    "length_improvement": 11.766925963888978,
                    "smoothness_improvement": 1338.0417810394658,
                    "objective_score": 33.63437820577107
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Mini-BiRRT Connect-Lite: a simplified, robust bi-directional RRT-Connect with strict node/edge collision checks, lightweight grid-accelerated nearest/duplicate queries, and fast post-processing (visibility prune + random shortcut). It favors generalization by avoiding heavy rewiring or complex heuristics while delivering short, smooth paths quickly.",
          "planning_mechanism": "Alternate expansions from start and goal: sample with modest goal bias, steer a fixed step to a collision-free node, add only if unique, then attempt a greedy, strictly-validated connect to the opposite tree (no partial commits on failure). On success, merge roots-to-meet path, prune by line-of-sight, and shortcut to reduce length and kinks.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=3500,\n                 step_size=6.0,\n                 goal_bias=0.2,\n                 grid_scale=1.0,\n                 dupe_radius_ratio=0.5,\n                 connect_steps=14,\n                 shortcut_attempts=64):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_scale = float(grid_scale)\n        self.dupe_ratio = float(dupe_radius_ratio)\n        self.connect_steps = int(max(1, connect_steps))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self._rng = 1469598103934665603  # 64-bit state\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if getattr(map, 'obstacles', None) else []\n\n        nodes, edges = [], []\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._build_obs_grid()\n\n        if self._point_in_obs(self.start) or self._point_in_obs(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        self.node_cell = max(1.0, self.step * self.grid_scale)\n        self.dupe_radius = max(0.4 * self.step, self.step * self.dupe_ratio)\n\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        tree_a, tree_b = [a_root], [b_root]\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, a_root)\n        self._grid_add(grid_b, b_root)\n        nodes.extend([a_root, b_root])\n\n        for it in range(self.max_iter):\n            expand_a = (it % 2 == 0)\n            tree = tree_a if expand_a else tree_b\n            other_tree = tree_b if expand_a else tree_a\n            grid = grid_a if expand_a else grid_b\n            other_grid = grid_b if expand_a else grid_a\n            attractor = self.goal if expand_a else self.start\n\n            q_rand = self._sample(attractor)\n            if q_rand is None:\n                continue\n\n            parent = self._nearest(grid, q_rand, tree)\n            if parent is None:\n                continue\n\n            q_new = self._steer(parent.position, q_rand, self.step)\n            if (not self._in_bounds(q_new)) or self._point_in_obs(q_new):\n                continue\n            if self._exists_close(grid, q_new, self.dupe_radius):\n                continue\n            if not self._edge_free(parent.position, q_new):\n                continue\n\n            new_node = Node(q_new, parent, parent.cost + self._dist(parent.position, q_new))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(grid, new_node)\n\n            other_near = self._nearest(other_grid, new_node.position, other_tree)\n\n            if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                path = self._merge_path(new_node, other_near, expand_a)\n                path = self._finalize_path(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            if other_near is not None:\n                ok, commit_pts, last = self._simulate_connect(other_near.position, new_node.position, self.connect_steps)\n                if ok:\n                    prev = other_near\n                    commit_ok = True\n                    for p in commit_pts:\n                        if (not self._in_bounds(p)) or self._point_in_obs(p):\n                            commit_ok = False\n                            break\n                        if not self._edge_free(prev.position, p):\n                            commit_ok = False\n                            break\n                        n2 = Node(p, prev, prev.cost + self._dist(prev.position, p))\n                        prev.add_child(n2)\n                        other_tree.append(n2)\n                        nodes.append(n2)\n                        edges.append((prev, n2))\n                        self._grid_add(other_grid, n2)\n                        prev = n2\n                    if commit_ok and self._edge_free(prev.position, new_node.position):\n                        path = self._merge_path(new_node, prev, expand_a)\n                        path = self._finalize_path(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._rng ^= (self._rng << 13) & ((1 << 64) - 1)\n        self._rng ^= (self._rng >> 7)\n        self._rng ^= (self._rng << 17) & ((1 << 64) - 1)\n        return ((self._rng & ((1 << 53) - 1)) / float(1 << 53))\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-16:\n            return tuple(a)\n        if d2 <= step * step:\n            tgt = b\n        else:\n            d = d2 ** 0.5\n            r = step / d\n            tgt = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n        return tuple(min(max(tgt[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # Node grid\n    def _grid_key(self, pos):\n        if self.is3:\n            return (int(pos[0] // self.node_cell), int(pos[1] // self.node_cell), int(pos[2] // self.node_cell))\n        else:\n            return (int(pos[0] // self.node_cell), int(pos[1] // self.node_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos, fallback_list):\n        key = self._grid_key(pos)\n        best, bestd = None, 1e100\n        for r in range(0, 3):\n            cand = self._ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd, best = d2, n\n                if best is not None:\n                    return best\n        for n in fallback_list:\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd, best = d2, n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius // self.node_cell) + 1\n        r2 = radius * radius\n        cand = self._ring_collect(grid, key, r_cells)\n        out = []\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                out.append(n)\n        return out\n\n    def _exists_close(self, grid, pos, radius):\n        return len(self._neighbors_in_radius(grid, pos, radius)) > 0\n\n    # Obstacles\n    def _build_obs_grid(self):\n        self.og_cell = max(3.0, self.step * 1.5)\n        self.ogrid = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.og_cell)\n                cy0 = int(max(0.0, y) // self.og_cell)\n                cz0 = int(max(0.0, z) // self.og_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.og_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.og_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.og_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.ogrid.get(k)\n                            if b is None:\n                                self.ogrid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.og_cell)\n                cy0 = int(max(0.0, y) // self.og_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.og_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.og_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.ogrid.get(k)\n                        if b is None:\n                            self.ogrid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _bucket_candidates(self, a, b):\n        if self.is3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.og_cell)\n            cy0 = int(max(0.0, miny) // self.og_cell)\n            cz0 = int(max(0.0, minz) // self.og_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.og_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.og_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.og_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.ogrid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            return cand\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.og_cell)\n            cy0 = int(max(0.0, miny) // self.og_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.og_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.og_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.ogrid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            return cand\n\n    def _point_in_obs(self, p):\n        if self.is3:\n            cx = int(p[0] // self.og_cell)\n            cy = int(p[1] // self.og_cell)\n            cz = int(p[2] // self.og_cell)\n            bucket = self.ogrid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if (ox <= x <= ox + w) and (oy <= y <= oy + h) and (oz <= z <= oz + d):\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.og_cell)\n            cy = int(p[1] // self.og_cell)\n            bucket = self.ogrid.get((cx, cy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if (ox <= x <= ox + w) and (oy <= y <= oy + h):\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        cand = self._bucket_candidates(a, b)\n        if not cand:\n            return False\n        if self.is3:\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(self.dim):\n            d = p1[i] - p0[i]\n            if abs(d) < 1e-12:\n                if p0[i] < bmin[i] or p0[i] > bmax[i]:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (bmin[i] - p0[i]) * inv\n                tB = (bmax[i] - p0[i]) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Sampling\n    def _sample(self, attractor):\n        for _ in range(12):\n            if self._rand() < self.goal_bias:\n                p = attractor\n            else:\n                if self.is3:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(p) and (not self._point_in_obs(p)):\n                return p\n        return None\n\n    # Connect and path utilities\n    def _simulate_connect(self, start_pos, target_pos, steps):\n        pts = []\n        cur = start_pos\n        for _ in range(steps):\n            nxt = self._steer(cur, target_pos, self.step)\n            if (not self._in_bounds(nxt)) or self._point_in_obs(nxt):\n                return False, [], cur\n            if not self._edge_free(cur, nxt):\n                return False, [], cur\n            pts.append(nxt)\n            cur = nxt\n            if self._edge_free(cur, target_pos):\n                return True, pts, cur\n        if self._edge_free(cur, target_pos):\n            return True, pts, cur\n        return False, pts, cur\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_path(self, a_end, b_end, a_forward):\n        pa = self._path_to_root(a_end)\n        pb = self._path_to_root(b_end)\n        if a_forward:\n            return pa + pb[::-1]\n        else:\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _vis_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-12 <= bestL:\n                    cur = cand\n                    bestL = L\n            tries += 1\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._vis_prune(path)\n        p1 = self._shortcut(p0, self.shortcut_attempts)\n        p2 = self._vis_prune(p1)\n        return p2",
          "objective": -36.76802,
          "time_improvement": 65.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1882.0,
          "node_improvement": 83.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013627099990844726,
                    "num_nodes_avg": 84.7,
                    "path_length_avg": 174.56569007096033,
                    "smoothness_avg": 0.048326840248883916,
                    "success_improvement": 0.0,
                    "time_improvement": 44.76535796186469,
                    "node_improvement": 78.67036011080333,
                    "length_improvement": 4.317779101732099,
                    "smoothness_improvement": 656.4199933083113,
                    "objective_score": 19.302374816140222
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0202009916305542,
                    "num_nodes_avg": 136.8,
                    "path_length_avg": 237.0938391096177,
                    "smoothness_avg": 0.1283977633324745,
                    "success_improvement": 0.0,
                    "time_improvement": 87.92179374600857,
                    "node_improvement": 90.80830477726265,
                    "length_improvement": 20.851252137438184,
                    "smoothness_improvement": 3203.76693171538,
                    "objective_score": 54.90612406484238
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018436336517333986,
                    "num_nodes_avg": 164.0,
                    "path_length_avg": 130.18358877739544,
                    "smoothness_avg": 0.1482704890864588,
                    "success_improvement": 0.0,
                    "time_improvement": 63.47556404916617,
                    "node_improvement": 79.14812460267005,
                    "length_improvement": 13.538259010389897,
                    "smoothness_improvement": 1785.9896769906786,
                    "objective_score": 36.09557300593718
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "AURORA-IBiRRT* (Adaptive Unified Rewire-Connect Optimal Bi-directional RRT with Elastic Smoothing): A bidirectional, informed, grid-accelerated RRT* variant that symmetrically guides samples toward the opposite root, selects best parents by accumulated cost with ancestor compression, performs bounded local rewiring, and attempts multi-neighbor lazy connects with short validated chains. It uses obstacle-binned collision checks and maintains coherent trees. The resulting path is refined by visibility collapse and an elastic-band smoother that can accept tiny length increases for large curvature reductions, followed by opportunistic shortcutting.",
          "planning_mechanism": "Alternate expanding start and goal trees. Each iteration: draw a guided sample (goal/corridor/uniform, switch to informed ellipse after an incumbent), gated by a symmetric cone using the active root-to-target direction; steer; pick a best-cost parent from k-near via spatial hash, compress to a visible ancestor, validate node and edge, insert, then locally rewire neighbors. Try to connect to k near nodes in the opposite tree by direct line-of-sight or a short, validated step chain; on success, extract a bi-tree path, visibility-collapse, apply elastic smoothing with curvature-aware acceptance, shortcut, re-smooth, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children) - 1, -1, -1):\n            if self.children[i] is child:\n                del self.children[i]\n                break\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=6.5,\n                 goal_bias=0.22,\n                 corridor_bias=0.28,\n                 ellipse_bias=0.55,\n                 grid_cell_factor=1.6,\n                 neighbor_radius_factor=2.2,\n                 k_parent=8,\n                 k_rewire=8,\n                 connect_radius_factor=2.8,\n                 connect_steps=4,\n                 smoothing_attempts=80,\n                 elastic_iters=24,\n                 min_sep_ratio=0.22):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.ellipse_bias = float(ellipse_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neigh_factor = float(neighbor_radius_factor)\n        self.k_parent = int(max(1, k_parent))\n        self.k_rewire = int(max(0, k_rewire))\n        self.connect_radius_factor = float(connect_radius_factor)\n        self.connect_steps = int(max(1, connect_steps))\n        self.smoothing_attempts = int(max(0, smoothing_attempts))\n        self.elastic_iters = int(max(0, elastic_iters))\n        self.min_sep_ratio = float(min_sep_ratio)\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self._is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if hasattr(map, \"obstacles\") and map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n\n        # Spatial parameters\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.neigh_radius = max(self.step * 1.2, self.step * self.neigh_factor)\n        self.min_sep = max(0.25, self.step * self.min_sep_ratio)\n        self.cstep = max(self.step, 1.5 * self.step)\n        self.connect_radius = max(self.step, self.connect_radius_factor * self.step)\n\n        # Build obstacle bins for fast collision lookups\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early trivial solution\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize trees and spatial grids\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        Ta, Tb = [a_root], [b_root]\n        nodes.extend([a_root, b_root])\n        GA, GB = {}, {}\n\n        self._grid_add(GA, a_root)\n        self._grid_add(GB, b_root)\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            # Choose active/other trees\n            if (it & 1) == 0:\n                A, B = Ta, Tb\n                GAct, GOth = GA, GB\n                root_act, root_oth = self.start, self.goal\n            else:\n                A, B = Tb, Ta\n                GAct, GOth = GB, GA\n                root_act, root_oth = self.goal, self.start\n\n            # Sample with symmetric cone gating\n            sp = self._guided_sample(root_act, root_oth, best_len)\n            if sp is None:\n                continue\n\n            # Nearest and steering\n            anchor = self._nearest(GAct, sp)\n            newp = self._steer(anchor.position, sp, self.step)\n\n            # Prechecks\n            if (not self._in_bounds(newp)) or self._point_blocked(newp):\n                continue\n            if self._too_close(GAct, newp, self.min_sep):\n                continue\n\n            # Best parent among k nearest\n            neigh = self._neighbors(GAct, newp, self.neigh_radius)\n            cands = self._k_nearest(neigh if neigh else [anchor], newp, self.k_parent)\n            parent, gbest = None, 1e100\n            for nb in cands:\n                if not self._edge_free(nb.position, newp):\n                    continue\n                gc = nb.cost + self._dist(nb.position, newp)\n                if gc < gbest:\n                    parent, gbest = nb, gc\n\n            if parent is None:\n                continue\n\n            # Ancestor compression (up to 4 hops) if visible and cheaper\n            hops = 0\n            anc = parent\n            while anc is not None and anc.parent is not None and hops < 4:\n                up = anc.parent\n                if self._edge_free(up.position, newp):\n                    gc = up.cost + self._dist(up.position, newp)\n                    if gc + 1e-12 < gbest:\n                        parent, gbest = up, gc\n                anc = up\n                hops += 1\n\n            # Both checks before adding\n            if self._point_blocked(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, gbest)\n            parent.add_child(nn)\n            A.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(GAct, nn)\n\n            # Lite local rewiring\n            if self.k_rewire > 0:\n                self._rewire_local(nn, GAct, edges)\n\n            # Multi-neighbor lazy connect to other tree\n            meet_node = None\n            near_o = self._neighbors(GOth, nn.position, self.connect_radius)\n            if not near_o:\n                near_o = [self._nearest(GOth, nn.position)]\n\n            # Evaluate multiple meet candidates and pick the best path length\n            best_meet = None\n            best_meet_len = 1e100\n            best_chain = None\n\n            for cand in self._k_nearest(near_o, nn.position, min(6, max(1, len(near_o)))):\n                if cand is None:\n                    continue\n                # Direct line of sight\n                if self._edge_free(cand.position, nn.position):\n                    # estimate length\n                    L = self._estimate_bipath_len(nn, cand)\n                    if L < best_meet_len:\n                        best_meet_len = L\n                        best_meet = cand\n                        best_chain = None\n                    continue\n                # Short validated chain from cand towards nn (do not bloat if fails)\n                ok, chain_positions = self._ghost_chain_positions(cand.position, nn.position, self.connect_steps, self.cstep)\n                if ok:\n                    # If last in chain connects to nn, this is a candidate; we will later commit it\n                    lastp = chain_positions[-1] if chain_positions else cand.position\n                    if self._edge_free(lastp, nn.position):\n                        # Estimate using chain\n                        L = self._estimate_bipath_len(nn, cand)  # rough estimate; acceptable\n                        if L < best_meet_len:\n                            best_meet_len = L\n                            best_meet = cand\n                            best_chain = chain_positions\n\n            if best_meet is not None:\n                # If a chain was proposed, commit it with both checks at each step\n                commit_target = best_meet\n                if best_chain:\n                    prev = best_meet\n                    okc = True\n                    for p in best_chain:\n                        if (not self._in_bounds(p)) or self._point_blocked(p):\n                            okc = False\n                            break\n                        if not self._edge_free(prev.position, p):\n                            okc = False\n                            break\n                        # Add node into B\n                        nb = Node(p, prev, prev.cost + self._dist(prev.position, p))\n                        prev.add_child(nb)\n                        B.append(nb)\n                        nodes.append(nb)\n                        edges.append((prev, nb))\n                        self._grid_add(GOth, nb)\n                        prev = nb\n                    if okc:\n                        commit_target = prev\n                    else:\n                        commit_target = best_meet\n\n                # Final snap check (do not add cross-edge; we only use it for path extraction)\n                if self._edge_free(commit_target.position, nn.position):\n                    path = self._extract_path(nn, commit_target, forward_from_a=(root_act == self.start))\n                    rawL = self._path_len(path)\n                    if best_len is None or rawL < best_len:\n                        best_len = rawL\n                    path = self._finalize_path(path)\n                    return PlannerResult(True, path, Ta + Tb, edges)\n\n        return PlannerResult(False, [], Ta + Tb, edges)\n\n    # ---------- RNG ----------\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            iv = int((v + 0.5) * 1103515245) & 0xffffffff\n            s ^= (iv + 0x9E3779B9 + ((s << 6) & 0xffffffff) + (s >> 2))\n            s &= 0xffffffff\n        s ^= (len(self.obstacles) + 1) * 2654435761 & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _randu(self):\n        # xorshift32\n        x = self._rng\n        x ^= (x << 13) & 0xffffffff\n        x ^= (x >> 17) & 0xffffffff\n        x ^= (x << 5) & 0xffffffff\n        self._rng = x & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._randu()\n\n    # ---------- Geometry ----------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # ---------- Spatial hashing ----------\n    def _cell_key(self, p):\n        if self._is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _neighbors(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        span = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self._is3:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        # expanding rings up to 3; fallback scan\n        for r in range(0, 4):\n            cand = []\n            if self._is3:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                            if lst:\n                                cand += lst\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy))\n                        if lst:\n                            cand += lst\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                if best is not None:\n                    return best\n        # fallback\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _k_nearest(self, nodes, pos, k):\n        # Partial selection by squared distance\n        if not nodes:\n            return []\n        buf = []\n        for nd in nodes:\n            buf.append((self._dist2(nd.position, pos), nd))\n        buf.sort(key=lambda t: t[0])\n        out = []\n        m = min(k, len(buf))\n        for i in range(m):\n            out.append(buf[i][1])\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        neigh = self._neighbors(grid, pos, radius)\n        return len(neigh) > 0\n\n    # ---------- Obstacles & collision ----------\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.6)\n        self.obin = {}\n        if self._is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            self._obin_add((i, j, k), idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        self._obin_add((i, j), idx)\n\n    def _obin_add(self, key, idx):\n        lst = self.obin.get(key)\n        if lst is None:\n            self.obin[key] = [idx]\n        else:\n            lst.append(idx)\n\n    def _bucket_candidates(self, a, b):\n        if self._is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self.obin.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            return cand\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self.obin.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            return cand\n\n    def _point_blocked(self, p):\n        if self._is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            lst = self.obin.get((ix, iy, iz))\n            if not lst:\n                return False\n            x, y, z = p\n            for idx in lst:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            lst = self.obin.get((ix, iy))\n            if not lst:\n                return False\n            x, y = p\n            for idx in lst:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        cand = self._bucket_candidates(a, b)\n        if not cand:\n            return True\n        if self._is3:\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            q = p1[i]\n            d = q - p\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # ---------- Rewiring ----------\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                del edges[i]\n                break\n\n    def _propagate_cost(self, node, delta):\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    def _rewire_local(self, new_node, grid, edges):\n        neigh = self._neighbors(grid, new_node.position, self.neigh_radius)\n        if not neigh:\n            return\n        cands = self._k_nearest(neigh, new_node.position, self.k_rewire)\n        for nb in cands:\n            if nb is new_node or nb is new_node.parent:\n                continue\n            # avoid cycles\n            cur = new_node\n            cyc = False\n            while cur is not None:\n                if cur is nb:\n                    cyc = True\n                    break\n                cur = cur.parent\n            if cyc:\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            cand_cost = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand_cost + 1e-9 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, oldp, nb)\n                new_node.add_child(nb)\n                edges.append((new_node, nb))\n                delta = cand_cost - nb.cost\n                nb.cost = cand_cost\n                self._propagate_cost(nb, delta)\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, root_act, root_oth, incumbent_len):\n        tries = 20\n        while tries > 0:\n            tries -= 1\n            r = self._randu()\n            if incumbent_len is not None and r < self.ellipse_bias:\n                p = self._sample_in_ellipse(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                r2 = self._randu()\n                if r2 < self.goal_bias:\n                    p = root_oth\n                elif r2 < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_point()\n                else:\n                    if self._is3:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]),\n                             self._rand_range(0.0, self.bounds[2]))\n                    else:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]))\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            # Symmetric cone gating: gate by direction from active root toward opposite root\n            v_to_p = tuple(p[i] - root_act[i] for i in range(self.dim))\n            v_to_oth = tuple(root_oth[i] - root_act[i] for i in range(self.dim))\n            if self._cos_align(v_to_p, v_to_oth) < -0.1 and self._randu() < 0.5:\n                continue\n            return p\n        return None\n\n    def _cos_align(self, a, b):\n        na, nb, dp = 0.0, 0.0, 0.0\n        for i in range(self.dim):\n            na += a[i] * a[i]\n            nb += b[i] * b[i]\n            dp += a[i] * b[i]\n        if na <= 1e-18 or nb <= 1e-18:\n            return 1.0\n        return dp / ((na ** 0.5) * (nb ** 0.5))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(20):\n            if self._is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            if self._dist(p, f1) + self._dist(p, f2) <= max_sum + 1e-9:\n                return p\n        return None\n\n    def _corridor_point(self):\n        t = self._randu()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step, 0.06 * sg)\n        if self._is3:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            oz = self._rand_range(-w, w)\n            p = (base[0] + ox, base[1] + oy, base[2] + oz)\n        else:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            p = (base[0] + ox, base[1] + oy)\n        return self._clamp(p)\n\n    # ---------- Connect helpers ----------\n    def _ghost_chain_positions(self, from_pos, to_pos, steps, step_len):\n        chain = []\n        cur = from_pos\n        for _ in range(steps):\n            nxt = self._steer(cur, to_pos, step_len)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                return False, None\n            if not self._edge_free(cur, nxt):\n                return False, None\n            chain.append(nxt)\n            cur = nxt\n            if self._edge_free(cur, to_pos):\n                break\n        if not chain:\n            return False, None\n        return True, chain\n\n    def _estimate_bipath_len(self, a_node, b_node):\n        # rough: cost to a_node + cost from b_node to its root + distance between\n        L = a_node.cost + b_node.cost + self._dist(a_node.position, b_node.position)\n        return L\n\n    # ---------- Paths and smoothing ----------\n    def _trace(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, a_node, b_node, forward_from_a=True):\n        pa = self._trace(a_node)\n        # b_node toward its root\n        pb = []\n        cur = b_node\n        while cur is not None:\n            pb.append(cur.position)\n            cur = cur.parent\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return (pa + pb) if forward_from_a else (pb[::-1] + pa[::-1])\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_collapse(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            progressed = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    progressed = True\n                    break\n                j -= 1\n            if not progressed:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _elastic_smooth(self, pts, iters=24, w=0.5, max_len_increase=0.005):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(iters):\n            changed = False\n            for k in range(1, len(cur) - 1):\n                a = cur[k - 1]\n                b = cur[k]\n                c = cur[k + 1]\n                mid = tuple(0.5 * (a[i] + c[i]) for i in range(self.dim))\n                q = tuple((1.0 - w) * b[i] + w * mid[i] for i in range(self.dim))\n                if (not self._in_bounds(q)) or self._point_blocked(q):\n                    continue\n                # Check edges\n                if not (self._edge_free(a, q) and self._edge_free(q, c)):\n                    continue\n                # Length and curvature criteria\n                oldL = self._dist(a, b) + self._dist(b, c)\n                newL = self._dist(a, q) + self._dist(q, c)\n                len_ok = (newL <= oldL * (1.0 + max_len_increase) + 1e-12)\n\n                curv_old = self._corner_cost(a, b, c)\n                curv_new = self._corner_cost(a, q, c)\n                # Accept if not longer, or tiny increase buys meaningful curvature reduction\n                if len_ok and (newL <= oldL + 1e-12 or curv_new + 1e-12 < 0.85 * curv_old):\n                    cur[k] = q\n                    changed = True\n            if not changed:\n                break\n        return cur\n\n    def _corner_cost(self, a, b, c):\n        # 1 - cosine of angle at b, scaled by segment lengths to de-emphasize tiny edges\n        v1 = tuple(b[i] - a[i] for i in range(self.dim))\n        v2 = tuple(c[i] - b[i] for i in range(self.dim))\n        n1 = (sum(v1[i] * v1[i] for i in range(self.dim))) ** 0.5\n        n2 = (sum(v2[i] * v2[i] for i in range(self.dim))) ** 0.5\n        if n1 < 1e-9 or n2 < 1e-9:\n            return 0.0\n        cosang = sum(v1[i] * v2[i] for i in range(self.dim)) / (n1 * n2)\n        if cosang > 1.0:\n            cosang = 1.0\n        if cosang < -1.0:\n            cosang = -1.0\n        return 1.0 - cosang\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a, b = cur[i], cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-9 <= bestL:\n                    cur = cand\n                    bestL = L\n            tries += 1\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path[:]\n        p1 = self._visibility_collapse(path)\n        p2 = self._elastic_smooth(p1, iters=self.elastic_iters, w=0.55, max_len_increase=0.006)\n        p3 = self._shortcut(p2, self.smoothing_attempts)\n        p4 = self._elastic_smooth(p3, iters=max(8, self.elastic_iters // 2), w=0.5, max_len_increase=0.004)\n        return p4",
          "objective": -36.64471,
          "time_improvement": 59.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1360.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011651158332824707,
                    "num_nodes_avg": 58.0,
                    "path_length_avg": 156.0637914065294,
                    "smoothness_avg": 0.04615392285067924,
                    "success_improvement": 0.0,
                    "time_improvement": 52.77443034280418,
                    "node_improvement": 85.39410727776378,
                    "length_improvement": 14.458962941052569,
                    "smoothness_improvement": 622.4091174607547,
                    "objective_score": 27.619752454776567
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022267484664916994,
                    "num_nodes_avg": 102.0,
                    "path_length_avg": 225.72102057026777,
                    "smoothness_avg": 0.08695574697277104,
                    "success_improvement": 0.0,
                    "time_improvement": 86.68623414834413,
                    "node_improvement": 93.14654303567829,
                    "length_improvement": 24.64782631430452,
                    "smoothness_improvement": 2137.434001302351,
                    "objective_score": 51.481736039597706
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03081855773925781,
                    "num_nodes_avg": 127.0,
                    "path_length_avg": 119.0787979417283,
                    "smoothness_avg": 0.11165176730825668,
                    "success_improvement": 0.0,
                    "time_improvement": 38.94500476348596,
                    "node_improvement": 83.8525111252384,
                    "length_improvement": 20.913532330124678,
                    "smoothness_improvement": 1320.2022388848293,
                    "objective_score": 30.83263202154474
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "LITE-BiRRT*: Lightweight Informed Two-Tree RRT* with grid NN, ancestor line-of-sight compression, capped local rewiring, and safe lazy-bridge connection. It emphasizes simple, general mechanisms: uniform+goal+ellipse sampling, adaptive RRT* neighbor radius, duplicate suppression, and minimal smoothing (LOS+shortcuts) for fast, short, smooth paths.",
          "planning_mechanism": "Alternate expanding the start/goal trees. For each guided sample, steer a fixed step, pick a cheapest parent among neighbors (cost plus mild turn penalty), validate node and edge, insert, then compress to any visible ancestor and rewire nearby nodes within an adaptive radius. Try to connect to the opposite tree directly or via a lazy simulated bridge (commit only on success). On success, merge, visibility-prune, and shortcut the path, then return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=3500,\n                 step_size=7.0,\n                 goal_bias=0.2,\n                 informed_bias=0.6,\n                 node_grid_factor=1.0,\n                 dupe_radius_ratio=0.4,\n                 neighbor_gamma=2.1,\n                 rewire_cap=18,\n                 connect_steps=7,\n                 shortcut_attempts=90,\n                 angle_weight=0.12):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.node_grid_factor = float(node_grid_factor)\n        self.dupe_ratio = float(dupe_radius_ratio)\n        self.gamma = float(neighbor_gamma)\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_steps = int(max(1, connect_steps))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.angle_w = float(angle_weight)\n        self._rng = 123456789\n\n    # ------------- Planning -------------\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        # Basic validation\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Build obstacle grid\n        self._build_obs_grid()\n\n        # Start/goal must be free\n        if self._point_in_obs(self.start) or self._point_in_obs(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early direct\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Node grid and dupes\n        self.node_cell = max(1.0, self.step * self.node_grid_factor)\n        self.dupe_radius = max(0.5, self.step * self.dupe_ratio)\n\n        # Init trees\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_len = float('inf')\n        sg = self._dist(self.start, self.goal)\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            tree = tree_a if side_a else tree_b\n            other_tree = tree_b if side_a else tree_a\n            grid = grid_a if side_a else grid_b\n            other_grid = grid_b if side_a else grid_a\n            attractor = self.goal if side_a else self.start\n\n            # Sample\n            q_rand = self._sample(best_len, sg, attractor)\n            if q_rand is None:\n                continue\n\n            # Nearest\n            parent0 = self._nearest_grid(grid, q_rand, tree)\n            if parent0 is None:\n                continue\n\n            # Steer\n            q_new = self._steer(parent0.position, q_rand, self.step)\n            if (not self._in_bounds(q_new)) or self._point_in_obs(q_new):\n                continue\n            if self._exists_close(grid, q_new, self.dupe_radius):\n                continue\n\n            # Choose parent among neighbors within adaptive radius\n            radius = self._rewire_radius(len(nodes))\n            nb = self._neighbors_in_radius(grid, q_new, radius)\n            parent, new_cost = self._choose_parent(nb, q_new)\n            if parent is None:\n                # fallback to nearest if edge is free\n                if self._edge_free(parent0.position, q_new):\n                    parent = parent0\n                    new_cost = parent.cost + self._dist(parent.position, q_new)\n                else:\n                    continue\n\n            # Final checks before node/edge add\n            if self._point_in_obs(q_new) or (not self._edge_free(parent.position, q_new)):\n                continue\n\n            # Insert node\n            nn = Node(q_new, parent, new_cost)\n            parent.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(grid, nn)\n\n            # Ancestor LOS compression\n            self._compress_to_visible_ancestor(nn, edges)\n\n            # Local rewiring\n            if self.rewire_cap > 0:\n                self._rewire_neighbors(grid, nn, radius, edges, self.rewire_cap)\n\n            # Try direct connect to nearest in other tree\n            other_near = self._nearest_grid(other_grid, nn.position, other_tree)\n            if other_near is not None and self._edge_free(nn.position, other_near.position):\n                path = self._merge_nodes_to_path(nn, other_near, side_a)\n                best_len = self._path_len(path)\n                path = self._finalize_path(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Lazy bridge (simulate first, commit on success)\n            if other_near is not None:\n                ok, pts = self._lazy_bridge_sim(other_near.position, nn.position, self.connect_steps)\n                if ok and pts:\n                    prev = other_near\n                    # Commit nodes on other tree side; validate each step (both checks)\n                    commit_ok = True\n                    for p in pts:\n                        if self._point_in_obs(p) or (not self._edge_free(prev.position, p)):\n                            commit_ok = False\n                            break\n                        q = Node(p, prev, prev.cost + self._dist(prev.position, p))\n                        prev.add_child(q)\n                        other_tree.append(q)\n                        nodes.append(q)\n                        edges.append((prev, q))\n                        self._grid_add(other_grid, q)\n                        prev = q\n                    if commit_ok and self._edge_free(prev.position, nn.position):\n                        path = self._merge_nodes_to_path(nn, prev, side_a)\n                        best_len = self._path_len(path)\n                        path = self._finalize_path(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # ------------- RNG -------------\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------- Geometry -------------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _vec(self, a, b):\n        return tuple(b[i] - a[i] for i in range(self.dim))\n\n    def _cos(self, u, v):\n        du = 0.0\n        dv = 0.0\n        dot = 0.0\n        for i in range(self.dim):\n            ui = u[i]\n            vi = v[i]\n            dot += ui * vi\n            du += ui * ui\n            dv += vi * vi\n        if du <= 1e-18 or dv <= 1e-18:\n            return 1.0\n        c = dot / ((du ** 0.5) * (dv ** 0.5))\n        if c < -1.0:\n            return -1.0\n        if c > 1.0:\n            return 1.0\n        return c\n\n    # ------------- Node grid (NN, neighbors, dupes) -------------\n    def _grid_key(self, pos):\n        if self.is3:\n            return (int(pos[0] // self.node_cell), int(pos[1] // self.node_cell), int(pos[2] // self.node_cell))\n        return (int(pos[0] // self.node_cell), int(pos[1] // self.node_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _ring_nodes(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_grid(self, grid, pos, tree_fallback=None):\n        key = self._grid_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 4):\n            cand = self._ring_nodes(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n            if best is not None:\n                return best\n        if tree_fallback:\n            for n in tree_fallback:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius // self.node_cell) + 1\n        r2 = radius * radius\n        out = []\n        cand = self._ring_nodes(grid, key, r_cells)\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                out.append(n)\n        return out\n\n    def _exists_close(self, grid, pos, radius):\n        nb = self._neighbors_in_radius(grid, pos, radius)\n        return len(nb) > 0\n\n    # ------------- Obstacles and collisions -------------\n    def _build_obs_grid(self):\n        self.obs_cell = max(3.0, self.step * 1.5)\n        self.ogrid = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.ogrid.get(k)\n                            if b is None:\n                                self.ogrid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.ogrid.get(k)\n                        if b is None:\n                            self.ogrid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obs(self, p):\n        if self.is3:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.ogrid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.ogrid.get((cx, cy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.ogrid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.ogrid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # ------------- Parent selection, compression, rewiring -------------\n    def _choose_parent(self, neighbors, q_new):\n        best = None\n        best_cost = 1e100\n        for n in neighbors:\n            # edge check for candidate parent\n            if not self._edge_free(n.position, q_new):\n                continue\n            base = n.cost + self._dist(n.position, q_new)\n            pen = 0.0\n            if n.parent is not None:\n                u = self._vec(n.parent.position, n.position)\n                v = self._vec(n.position, q_new)\n                c = self._cos(u, v)\n                pen = self.angle_w * self.step * max(0.0, 1.0 - c)\n            cst = base + pen\n            if cst < best_cost:\n                best_cost = cst\n                best = n\n        if best is None:\n            return None, None\n        return best, best_cost\n\n    def _reparent(self, child, new_parent, edges):\n        if child is new_parent or child.parent is new_parent:\n            return\n        # Both checks before edge change\n        if self._point_in_obs(child.position) or self._point_in_obs(new_parent.position):\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            try:\n                old.children.remove(child)\n            except:\n                pass\n            self._edges_remove(edges, old, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        # propagate\n        stack = list(child.children)\n        while stack:\n            n = stack.pop()\n            n.cost = n.parent.cost + self._dist(n.parent.position, n.position)\n            if n.children:\n                for c in n.children:\n                    stack.append(c)\n\n    def _compress_to_visible_ancestor(self, node, edges):\n        curp = node.parent\n        if curp is None:\n            return\n        anc = curp.parent\n        best = curp\n        bestc = node.cost\n        while anc is not None:\n            if self._edge_free(anc.position, node.position):\n                c = anc.cost + self._dist(anc.position, node.position)\n                if c + 1e-12 < bestc:\n                    bestc = c\n                    best = anc\n            anc = anc.parent\n        if best is not curp:\n            self._reparent(node, best, edges)\n\n    def _rewire_neighbors(self, grid, node, radius, edges, cap):\n        neigh = self._neighbors_in_radius(grid, node.position, radius)\n        cnt = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            # avoid cycles\n            if self._is_ancestor(nb, node):\n                continue\n            if not self._edge_free(node.position, nb.position):\n                continue\n            new_cost = node.cost + self._dist(node.position, nb.position)\n            if new_cost + 1e-12 < nb.cost:\n                self._reparent(nb, node, edges)\n                cnt += 1\n                if cnt >= cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _rewire_radius(self, n_nodes):\n        if n_nodes <= 2:\n            return 3.0 * self.step\n        ln = self._ln(max(2.0, float(n_nodes)))\n        r_star = self.gamma * ((ln / float(n_nodes)) ** (1.0 / float(self.dim)))\n        r = r_star * self.step\n        if r < 1.2 * self.step:\n            r = 1.2 * self.step\n        if r > 4.0 * self.step:\n            r = 4.0 * self.step\n        return r\n\n    def _ln(self, x):\n        # stable approximation: ln(x) \u2248 2 * atanh((x-1)/(x+1)) with truncated series\n        y = (x - 1.0) / (x + 1.0)\n        y2 = y * y\n        s = y\n        p = y\n        for k in range(1, 7):\n            p *= y2\n            s += p / (2 * k + 1)\n        return 2.0 * s\n\n    # ------------- Sampling -------------\n    def _sample(self, best_len, sg, attractor):\n        for _ in range(24):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.01)\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                else:\n                    if self.is3:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]),\n                             self._rand_range(0.0, self.bounds[2]))\n                    else:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]))\n            if p is not None and self._in_bounds(p) and (not self._point_in_obs(p)):\n                return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if self._in_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and (not self._point_in_obs(p)):\n                return p\n        return None\n\n    # ------------- Bridge and path utilities -------------\n    def _lazy_bridge_sim(self, a_from, b_to, steps):\n        curr = a_from\n        pts = []\n        for _ in range(steps):\n            nxt = self._steer(curr, b_to, self.step)\n            if self._point_in_obs(nxt) or (not self._edge_free(curr, nxt)):\n                return False, []\n            pts.append(nxt)\n            curr = nxt\n            if self._edge_free(curr, b_to):\n                return True, pts\n        return False, []\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_nodes_to_path(self, a_end, b_end, a_forward):\n        pa = self._path_to_root(a_end)\n        pb = self._path_to_root(b_end)\n        # pa: from its root to a_end, pb: from its root to b_end\n        # We want: path from start to goal\n        if a_forward:\n            # pa starts at start, pb starts at goal; go pa + reversed(pb)\n            return pa + pb[::-1]\n        else:\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        stall = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-12 <= bestL:\n                    cur = cand\n                    bestL = L\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            tries += 1\n            if stall > 64:\n                break\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._visibility_prune(path)\n        p1 = self._shortcut(p0, self.shortcut_attempts)\n        p2 = self._visibility_prune(p1)\n        return p2",
          "objective": -36.35153,
          "time_improvement": 69.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1656.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01191093921661377,
                    "num_nodes_avg": 62.1,
                    "path_length_avg": 169.98648258417646,
                    "smoothness_avg": 0.051656131335479825,
                    "success_improvement": 0.0,
                    "time_improvement": 51.72146205651587,
                    "node_improvement": 84.36162175774363,
                    "length_improvement": 6.827715287424435,
                    "smoothness_improvement": 708.5306284848467,
                    "objective_score": 23.155720931833656
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02790379524230957,
                    "num_nodes_avg": 145.0,
                    "path_length_avg": 245.55157959153934,
                    "smoothness_avg": 0.11152056945517788,
                    "success_improvement": 0.0,
                    "time_improvement": 83.31627474682966,
                    "node_improvement": 90.25734058993481,
                    "length_improvement": 18.02781492201101,
                    "smoothness_improvement": 2769.5045771011437,
                    "objective_score": 49.65909426276122
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014263558387756347,
                    "num_nodes_avg": 99.0,
                    "path_length_avg": 132.33636885589763,
                    "smoothness_avg": 0.12503219506376403,
                    "success_improvement": 0.0,
                    "time_improvement": 71.7423022586528,
                    "node_improvement": 87.41258741258741,
                    "length_improvement": 12.108484986620105,
                    "smoothness_improvement": 1490.4002922944414,
                    "objective_score": 36.23978313104011
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "HASTE-BiRRT: Hashed, Anytime, Saturation\u2011Throttled, Efficient BiRRT-Connect. It accelerates bidirectional RRT with cached collision tests, hashed nearest search with leader fallbacks, per-cell growth throttling, and duplicate-suppressed commit-only connections. A light visibility prune plus brief shortcutting refines the path while keeping postprocessing costs low.",
          "planning_mechanism": "Alternate expanding start/goal trees with goal-biased sampling; find nearest via grid rings, else leader-guided buckets; steer one step and validate with cached edge checks; suppress inserts in saturated/duplicate cells; attempt a single, commit-only direct bridge to the opposite tree, skipping known-blocked cell pairs; upon success, extract start-to-goal path, visibility-prune, then run a few shortcuts; terminate on success or iteration cap.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=7.0,\n                 goal_bias=0.25,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=40,\n                 max_per_cell=6,\n                 search_r_max=2,\n                 leader_stride=25):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n        self.max_per_cell = max_per_cell\n        self.search_r_max = search_r_max\n        self.leader_stride = leader_stride\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        # Caches\n        self._edge_blocked_cache = set()   # quantized blocked segments (safe to reuse only for blocked)\n        self._edge_exact_cache = {}        # exact endpoint pairs -> bool\n        self._connect_blocked_cells = set()  # (cellA, cellB) pairs known to fail direct connect\n\n    # ------------- Public API -------------\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Parameters derived\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size * 2.5)\n        self.edge_res = max(0.5, self.collision_step)\n\n        # Reset caches\n        self._edge_blocked_cache = set()\n        self._edge_exact_cache = {}\n        self._connect_blocked_cells = set()\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            path = [start, goal]\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Initialize trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Grids and counts\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n        self._grid_add(grid_start, counts_start, start_root)\n        self._grid_add(grid_goal, counts_goal, goal_root)\n\n        # Leaders\n        leaders_start = [start_root]\n        leaders_goal = [goal_root]\n        inserted_since_leader_start = 0\n        inserted_since_leader_goal = 0\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            grid_a = grid_start if active_start else grid_goal\n            counts_a = counts_start if active_start else counts_goal\n            leaders_a = leaders_start if active_start else leaders_goal\n\n            tree_b = goal_tree if active_start else start_tree\n            grid_b = grid_goal if active_start else grid_start\n            counts_b = counts_goal if active_start else counts_start\n            leaders_b = leaders_goal if active_start else leaders_start\n\n            root_other = goal if active_start else start\n\n            # Sample with goal/opposite-root bias\n            if self._rand() < self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest lookup\n            nearest = self._nearest_hashed(grid_a, leaders_a, tree_a, x_rand)\n            if nearest is None:\n                continue\n\n            # Steer\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Per-cell throttling and duplicate suppression\n            key_new = self._grid_key(new_pos)\n            if self._cell_count(counts_a, key_new) >= self.max_per_cell:\n                continue\n            if self._near_duplicate(grid_a, new_pos, dup_radius=0.7 * self.step_size):\n                continue\n\n            # Insert node and edge\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, counts_a, new_node)\n\n            # Leader sampling\n            if active_start:\n                inserted_since_leader_start += 1\n                if inserted_since_leader_start >= self.leader_stride:\n                    leaders_start.append(new_node)\n                    inserted_since_leader_start = 0\n            else:\n                inserted_since_leader_goal += 1\n                if inserted_since_leader_goal >= self.leader_stride:\n                    leaders_goal.append(new_node)\n                    inserted_since_leader_goal = 0\n\n            # Try commit-only direct connection to the other tree (with cell-pair de-dup)\n            other_near = self._nearest_hashed(grid_b, leaders_b, tree_b, new_node.position)\n            if other_near is not None:\n                pair_key = (self._grid_key(new_node.position), self._grid_key(other_near.position))\n                if pair_key not in self._connect_blocked_cells:\n                    if not self._edge_blocked(new_node.position, other_near.position, obstacles, is_3d):\n                        path = self._extract_path(new_node, other_near, a_is_start_tree=active_start)\n                        path = self._visibility_prune(path, obstacles, is_3d)\n                        path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                        return PlannerResult(True, path, start_tree + goal_tree, edges)\n                    else:\n                        # cache blocked cell pair to avoid repeating futile checks\n                        self._connect_blocked_cells.add(pair_key)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ------------- Random -------------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------- Geometry -------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ------------- Collision & caches -------------\n    def _quant(self, p, q=1.5):\n        # Quantize for blocked-segment cache; coarse to avoid false frees; safe for blocked reuse only\n        if self.dim == 3:\n            return (int(p[0] // q), int(p[1] // q), int(p[2] // q))\n        else:\n            return (int(p[0] // q), int(p[1] // q))\n\n    def _seg_key_exact(self, a, b):\n        # Canonicalize order for undirected segment\n        if a <= b:\n            return (a, b)\n        else:\n            return (b, a)\n\n    def _seg_key_quant_blocked(self, a, b):\n        qa = self._quant(a)\n        qb = self._quant(b)\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        # Exact cache check\n        k_exact = self._seg_key_exact(a, b)\n        cached = self._edge_exact_cache.get(k_exact)\n        if cached is not None:\n            return cached\n        # Blocked quantized cache\n        kq = self._seg_key_quant_blocked(a, b)\n        if kq in self._edge_blocked_cache:\n            self._edge_exact_cache[k_exact] = True\n            return True\n        # Compute\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res)\n        # Update caches\n        self._edge_exact_cache[k_exact] = blocked\n        if blocked:\n            self._edge_blocked_cache.add(kq)\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ------------- Sampling -------------\n    def _sample_free(self, obstacles, is_3d):\n        # Rejection sampling within bounds until a free point is found\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ------------- Grid / NN -------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n\n    def _cell_count(self, counts, key):\n        return counts.get(key, 0)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, leaders, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Local rings\n        for r in range(0, self.search_r_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Leader fallback\n        if leaders:\n            lead_best = None\n            lead_bestd = float('inf')\n            for n in leaders:\n                d = self._dist(n.position, pos)\n                if d < lead_bestd:\n                    lead_bestd = d\n                    lead_best = n\n            if lead_best is not None:\n                # Search around leader cell for neighbors\n                lk = self._grid_key(lead_best.position)\n                for r in range(0, min(2, self.search_r_max) + 1):\n                    cand = self._grid_ring_collect(grid, lk, r)\n                    for n in cand:\n                        d = self._dist(n.position, pos)\n                        if d < bestd:\n                            bestd = d\n                            best = n\n                if best is not None:\n                    return best\n        # Sparse random subset fallback (avoid full scan)\n        if tree:\n            trials = min(64, len(tree))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(tree)))\n                n = tree[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            if best is not None:\n                return best\n        return None\n\n    def _near_duplicate(self, grid, pos, dup_radius):\n        key = self._grid_key(pos)\n        r = 1\n        cand = self._grid_ring_collect(grid, key, r)\n        rr = dup_radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # ------------- Path -------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            # start-tree path to meet, then meet->goal via reversed goal-tree path\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -35.78786,
          "time_improvement": 66.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1772.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016536712646484375,
                    "num_nodes_avg": 67.3,
                    "path_length_avg": 176.25078259592178,
                    "smoothness_avg": 0.05067539409595988,
                    "success_improvement": 0.0,
                    "time_improvement": 35.1470831615236,
                    "node_improvement": 83.05212792747419,
                    "length_improvement": 3.3941531868009323,
                    "smoothness_improvement": 693.1799609813568,
                    "objective_score": 16.046516665444422
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023010659217834472,
                    "num_nodes_avg": 105.2,
                    "path_length_avg": 247.25890321415372,
                    "smoothness_avg": 0.1191098532602342,
                    "success_improvement": 0.0,
                    "time_improvement": 85.63605318102866,
                    "node_improvement": 92.93153262111133,
                    "length_improvement": 17.45786115419664,
                    "smoothness_improvement": 2964.7823157454163,
                    "objective_score": 50.989444225553655
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.011754655838012695,
                    "num_nodes_avg": 94.4,
                    "path_length_avg": 127.41557160345823,
                    "smoothness_avg": 0.13822063405561777,
                    "success_improvement": 0.0,
                    "time_improvement": 76.0361625858193,
                    "node_improvement": 87.99745708836618,
                    "length_improvement": 15.376644218505373,
                    "smoothness_improvement": 1658.156262801516,
                    "objective_score": 40.327616620856595
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Bounded BiRRT-Connect with Grid-Accelerated Nearest and Lightweight Shortcutting: a time-capped, bidirectional RRT-Connect that uses a coarse spatial grid for fast nearest-neighbor queries, commits only validated steps, attempts a single greedy bridge per iteration, and applies a brief shortcut smoother to the first found path for quality without heavy rewiring or anytime overhead.",
          "planning_mechanism": "Mechanism: Alternate growing start/goal trees with one extend loop toward a biased sample; each successful extension triggers a greedy extend from the opposite tree toward the new node. Both node and edge collisions are strictly checked before every insertion and the final bridge. Nearest queries use a bucket grid with limited ring expansion and linear fallback. On success, a bounded-time shortcut pass improves path length/smoothness; the planner enforces a hard time limit and returns the best (first) feasible path promptly.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=6.0,\n        goal_sample_rate=0.15,\n        bridge_bias_rate=0.30,\n        cell_size_factor=2.0,\n        time_limit_sec=12.0,\n        edge_resolution=1.0,\n        smooth_attempts=80,\n        smooth_time_frac=0.2\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.bridge_bias_rate = bridge_bias_rate\n        self.cell_size_factor = cell_size_factor\n        self.time_limit_sec = time_limit_sec\n        self.edge_resolution = edge_resolution\n        self.smooth_attempts = smooth_attempts\n        self.smooth_time_frac = smooth_time_frac\n\n    def plan(self, map):\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Validate start/goal feasibility\n        if self._is_in_obstacle(start_position, obstacles, is_3d) or self._is_in_obstacle(goal_position, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Initialize trees and spatial grids\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root = Node(goal_position, parent=None, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        grid_start = {}\n        grid_goal = {}\n        self._grid_insert(grid_start, start_root.position, start_root, cell_size, dim)\n        self._grid_insert(grid_goal, goal_root.position, goal_root, cell_size, dim)\n\n        start_time = time.time()\n\n        # Early straight-line check\n        if not self._is_edge_in_obstacle(start_position, goal_position, obstacles, is_3d, self.edge_resolution):\n            edges.append((start_root, goal_root))\n            direct_path = [start_position, goal_position]\n            return PlannerResult(True, direct_path, start_tree + goal_tree, edges)\n\n        # Main loop\n        for it in range(self.max_iter):\n            if time.time() - start_time >= self.time_limit_sec:\n                return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n            # Alternate tree growth\n            if it % 2 == 0:\n                grow_tree, grow_grid = start_tree, grid_start\n                other_tree, other_grid = goal_tree, grid_goal\n                a_is_start_side = True\n                other_root_pos = goal_root.position\n            else:\n                grow_tree, grow_grid = goal_tree, grid_goal\n                other_tree, other_grid = start_tree, grid_start\n                a_is_start_side = False\n                other_root_pos = start_root.position\n\n            sample = self._sample(bounds, obstacles, is_3d, other_root_pos)\n\n            # Extend grow_tree toward sample\n            a_near = self._nearest_from_grid(grow_tree, grow_grid, sample, cell_size, dim)\n            a_last = self._extend(grow_tree, grow_grid, a_near, sample, nodes, edges, obstacles, is_3d, bounds, cell_size, dim)\n            if a_last is None:\n                continue\n\n            # Greedy connect: extend other_tree toward the new node\n            b_near = self._nearest_from_grid(other_tree, other_grid, a_last.position, cell_size, dim)\n            b_last = self._extend(other_tree, other_grid, b_near, a_last.position, nodes, edges, obstacles, is_3d, bounds, cell_size, dim)\n            if b_last is None:\n                continue\n\n            # Attempt final short bridge\n            if self._distance(b_last.position, a_last.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(b_last.position, a_last.position, obstacles, is_3d, self.edge_resolution):\n                    edges.append((b_last, a_last))\n                    # Extract and smooth path\n                    final_path = self._assemble_path(a_last, b_last, a_is_start_side)\n                    remaining = max(0.0, self.time_limit_sec - (time.time() - start_time))\n                    budget = min(remaining, self.time_limit_sec * self.smooth_time_frac)\n                    final_path = self._shortcut_path(final_path, obstacles, is_3d, bounds, budget, self.smooth_attempts)\n                    return PlannerResult(True, final_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---- Utilities ----\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _within_bounds(self, p, bounds):\n        for i in range(len(bounds)):\n            if p[i] < 0.0 or p[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step_size):\n        d = self._distance(from_pos, to_pos)\n        if d <= step_size:\n            return to_pos\n        r = step_size / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    def _sample(self, bounds, obstacles, is_3d, other_root_pos):\n        # Bias toward the opposite root\n        if random.random() < self.bridge_bias_rate:\n            return other_root_pos\n        # Mild goal bias to encourage meeting/goal attraction\n        if random.random() < self.goal_sample_rate:\n            return other_root_pos\n        # Uniform rejection sampling in free space\n        dim = len(bounds)\n        for _ in range(30):\n            pt = tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n        # Fallback: last sample even if occupied (extend will reject)\n        return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n\n    def _extend(self, tree, grid, nearest_node, target_pos, nodes, edges, obstacles, is_3d, bounds, cell_size, dim):\n        current = nearest_node\n        last_new = None\n        while True:\n            step_pos = self._steer(current.position, target_pos, self.step_size)\n            if not self._within_bounds(step_pos, bounds):\n                break\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                break\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d, self.edge_resolution):\n                break\n            # Both node and edge are valid \u2192 commit\n            new_node = Node(step_pos)\n            new_node.cost = current.cost + self._distance(current.position, step_pos)\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node.position, new_node, cell_size, dim)\n            last_new = new_node\n            current = new_node\n            # Stop if reached target (within one step)\n            if self._distance(current.position, target_pos) <= self.step_size:\n                break\n        return last_new\n\n    def _assemble_path(self, a_node, b_node, a_is_start_side):\n        if a_is_start_side:\n            pa = a_node.path_from_root()   # start -> ... -> a\n            pb = b_node.path_from_root()   # goal  -> ... -> b\n            return pa + pb[::-1]           # start ... a, b ... goal\n        else:\n            pa = a_node.path_from_root()   # goal  -> ... -> a\n            pb = b_node.path_from_root()   # start -> ... -> b\n            return pb + pa[::-1]           # start ... b, a ... goal\n\n    # ---- Spatial grid for approximate nearest ----\n    def _cell_index(self, pos, cell_size, dim):\n        if dim == 2:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size))\n        else:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size), int(pos[2] // cell_size))\n\n    def _grid_insert(self, grid, pos, node, cell_size, dim):\n        idx = self._cell_index(pos, cell_size, dim)\n        if idx in grid:\n            grid[idx].append(node)\n        else:\n            grid[idx] = [node]\n\n    def _nearest_from_grid(self, tree, grid, point, cell_size, dim, max_rings=3):\n        # For small trees, just do linear scan\n        if len(tree) < 32:\n            return min(tree, key=lambda n: self._distance(n.position, point))\n\n        center = self._cell_index(point, cell_size, dim)\n        best = None\n        # Expand rings until some candidates found, then pick nearest among them\n        for r in range(0, max_rings + 1):\n            candidates = []\n            if dim == 2:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        idx = (center[0] + dx, center[1] + dy)\n                        if idx in grid:\n                            candidates.extend(grid[idx])\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            idx = (center[0] + dx, center[1] + dy, center[2] + dz)\n                            if idx in grid:\n                                candidates.extend(grid[idx])\n            if candidates:\n                best = min(candidates, key=lambda n: self._distance(n.position, point))\n                break\n\n        if best is None:\n            # Fallback to linear scan if grid empty nearby\n            best = min(tree, key=lambda n: self._distance(n.position, point))\n        return best\n\n    # ---- Collision utilities ----\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist / max(1e-6, resolution)))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    # ---- Path shortcutting ----\n    def _shortcut_path(self, path, obstacles, is_3d, bounds, time_budget, attempts):\n        if len(path) < 3:\n            return path\n        start_t = time.time()\n        pts = list(path)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and (time.time() - start_t) <= time_budget:\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            # Keep within bounds and collision-free\n            if not self._segment_within_bounds(a, b, bounds):\n                tries += 1\n                continue\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_resolution):\n                # Apply shortcut\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n            tries += 1\n        return pts\n\n    def _segment_within_bounds(self, a, b, bounds):\n        # The interpolated segment is within bounds if endpoints are; checks along the way via edge collision\n        for d in range(len(bounds)):\n            if a[d] < 0.0 or a[d] > bounds[d]:\n                return False\n            if b[d] < 0.0 or b[d] > bounds[d]:\n                return False\n        return True",
          "objective": -35.38986,
          "time_improvement": 79.0,
          "length_improvement": 6.0,
          "smoothness_improvement": 1571.0,
          "node_improvement": 81.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009288859367370606,
                    "num_nodes_avg": 87.5,
                    "path_length_avg": 179.7819366813108,
                    "smoothness_avg": 0.041891929272141075,
                    "success_improvement": 0.0,
                    "time_improvement": 63.57137981686718,
                    "node_improvement": 77.96524804835055,
                    "length_improvement": 1.4586716778820132,
                    "smoothness_improvement": 555.6996628894441,
                    "objective_score": 22.725115266236582
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009074711799621582,
                    "num_nodes_avg": 124.9,
                    "path_length_avg": 251.58839597257443,
                    "smoothness_avg": 0.10077141463831178,
                    "success_improvement": 0.0,
                    "time_improvement": 94.3352914641303,
                    "node_improvement": 91.6078747564335,
                    "length_improvement": 16.01255185389636,
                    "smoothness_improvement": 2492.9210813599107,
                    "objective_score": 50.372723958376454
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01003124713897705,
                    "num_nodes_avg": 215.4,
                    "path_length_avg": 148.33090891427284,
                    "smoothness_avg": 0.13860849885025553,
                    "success_improvement": 0.0,
                    "time_improvement": 79.54962026854608,
                    "node_improvement": 72.6128417037508,
                    "length_improvement": 1.4856730579993105,
                    "smoothness_improvement": 1663.0898743601072,
                    "objective_score": 33.07173928716395
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SWIFT-IRRT*: Simple Weighted Informed Rapidly-exploring bi-Trees with capped rewiring and ancestor compression. It grows two coherent trees with ring-hash nearest search, informed/corridor sampling after the first path, adaptive LOS-extended steering, bounded cost-aware parent choice, and tiny local rewiring. Every insertion performs multi-hop visible-ancestor compression and then attempts a short greedy bridge to the opposite tree. A minimal post-processor applies visibility pruning, shortcuts, and elastic averaging for smoothness. Mandatory node and edge collision checks are enforced before any insertion or reparenting for robustness.",
          "planning_mechanism": "Alternate start/goal expansions. Each step: sample (goal/informed/corridor/uniform), find near via hashed rings, steer with LOS-long step, validate node and parent edge, admit via per-cell gate, insert, compress to a visible ancestor, lightly rewire neighbors, then try a direct/greedy bridge to the other tree. On connection, assemble by parents and refine, then return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        pts.reverse()\n        return pts\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step=6.0,\n        long_step_factor=2.0,\n        goal_bias=0.15,\n        corridor_bias=0.35,\n        informed_bias=0.5,\n        grid_cell_factor=1.6,\n        cell_cap=8,\n        ring_max=3,\n        neighbor_radius_factor=3.0,\n        rewire_cap=16,\n        connect_attempts=4,\n        shortcut_attempts=80,\n        smooth_passes=6\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step)\n        self.long_step = float(step * long_step_factor)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.cell_cap = int(cell_cap)\n        self.ring_max = int(ring_max)\n        self.neighbor_radius_factor = float(neighbor_radius_factor)\n        self.rewire_cap = int(rewire_cap)\n        self.connect_attempts = int(connect_attempts)\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.smooth_passes = int(max(0, smooth_passes))\n        self._rng = 1234567\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed()\n        self._build_obs_index()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        if self.start == self.goal:\n            n0 = Node(self.start, None, 0.0)\n            return PlannerResult(True, [self.start], [n0], [])\n\n        # Early straight path\n        if self._edge_free(self.start, self.goal):\n            a = Node(self.start, None, 0.0)\n            b = Node(self.goal, a, self._dist(self.start, self.goal))\n            a.add_child(b)\n            return PlannerResult(True, [self.start, self.goal], [a, b], [(a, b)])\n\n        # Structures\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        nodes = []\n        edges = []\n\n        ra = Node(self.start, None, 0.0)\n        rb = Node(self.goal, None, 0.0)\n        nodes.extend([ra, rb])\n\n        tree_a, tree_b = [ra], [rb]\n        grid_a, grid_b = {}, {}\n        count_a, count_b = {}, {}\n        bestcost_a, bestcost_b = {}, {}\n\n        self._grid_add(grid_a, count_a, bestcost_a, ra)\n        self._grid_add(grid_b, count_b, bestcost_b, rb)\n\n        c_best = float('inf')\n        sg = self._dist(self.start, self.goal)\n        corridor_w = max(self.step, 0.2 * sg)\n\n        for it in range(self.max_iter):\n            forward = (it % 2 == 0)\n            tree = tree_a if forward else tree_b\n            other_tree = tree_b if forward else tree_a\n            grid = grid_a if forward else grid_b\n            other_grid = grid_b if forward else grid_a\n            counts = count_a if forward else count_b\n            bestcost = bestcost_a if forward else bestcost_b\n            attractor = self.goal if forward else self.start\n\n            target = self._sample_target(attractor, c_best, corridor_w)\n            if target is None:\n                continue\n\n            nearest = self._nearest(grid, tree, target)\n            if nearest is None:\n                continue\n\n            new_pos = self._steer_extended(nearest.position, target)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._point_blocked(new_pos):\n                continue\n            if not self._edge_free(nearest.position, new_pos):\n                continue\n\n            # Parent selection among local LOS neighbors\n            ncount = len(tree)\n            r_near = self._adaptive_radius(ncount)\n            parent = self._choose_parent(grid, new_pos, nearest, r_near)\n            if parent is None:\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            new_cost = parent.cost + self._dist(parent.position, new_pos)\n\n            # Per-cell gate: admit if cell under cap or improves best cost in cell\n            key = self._cell_of(new_pos)\n            cc = counts.get(key, 0)\n            bc = bestcost.get(key, float('inf'))\n            if cc >= self.cell_cap and not (new_cost + 1e-9 < bc):\n                continue\n\n            # Insert after mandatory checks\n            q = Node(new_pos, parent, new_cost)\n            parent.add_child(q)\n            tree.append(q)\n            nodes.append(q)\n            edges.append((parent, q))\n            self._grid_add(grid, counts, bestcost, q)\n\n            # Multi-hop visible ancestor compression (bounded)\n            self._compress_ancestor(q, edges, 3)\n\n            # Lightweight local rewiring\n            self._rewire_lite(grid, q, r_near, edges)\n\n            # Attempt connection\n            other_near = self._nearest(other_grid, other_tree, q.position)\n            if other_near is not None:\n                if self._edge_free(q.position, other_near.position):\n                    path = self._assemble_path(q, other_near, forward)\n                    path = self._refine(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # Greedy short chain from other tree toward q\n                prev = other_near\n                steps = 0\n                while steps < self.connect_attempts:\n                    steps += 1\n                    step_to = self._steer(prev.position, q.position)\n                    if not self._in_bounds(step_to) or self._point_blocked(step_to):\n                        break\n                    if not self._edge_free(prev.position, step_to):\n                        break\n                    # parent choice in other tree for the step\n                    b_parent = self._choose_parent(other_grid, step_to, prev, r_near)\n                    if b_parent is None:\n                        break\n                    if not self._edge_free(b_parent.position, step_to):\n                        break\n                    b_new = Node(step_to, b_parent, b_parent.cost + self._dist(b_parent.position, step_to))\n                    b_parent.add_child(b_new)\n                    other_tree.append(b_new)\n                    nodes.append(b_new)\n                    edges.append((b_parent, b_new))\n                    self._grid_add(other_grid, count_b if forward else count_a, bestcost_b if forward else bestcost_a, b_new)\n                    self._compress_ancestor(b_new, edges, 2)\n                    self._rewire_lite(other_grid, b_new, r_near, edges)\n                    prev = b_new\n                    if self._edge_free(prev.position, q.position):\n                        path = self._assemble_path(q, prev, forward)\n                        L = self._path_len(path)\n                        if L < c_best:\n                            c_best = L\n                        path = self._refine(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n            # Update incumbent bound via provisional visible link if any\n            if other_near is not None and self._edge_free(q.position, other_near.position):\n                tmp = self._assemble_path(q, other_near, forward)\n                L = self._path_len(tmp)\n                if L < c_best:\n                    c_best = L\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed(self):\n        v = 2166136261\n        for t in self.start + self.goal:\n            v ^= int(t * 10007 + 0.5) & 0xffffffff\n            v *= 16777619\n            v &= 0xffffffff\n        v ^= (len(self.obstacles) + 1) * 2654435761 & 0xffffffff\n        self._rng = (v ^ 0x9E3779B9) & 0xffffffff\n        if self._rng == 0:\n            self._rng = 1234567\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= self.step:\n            return tuple(self._clamp_all(b))\n        r = self.step / d\n        return tuple(self._clamp_all(self._lerp(a, b, r)))\n\n    def _steer_extended(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        # If within long step and segment is free, jump to target\n        if d <= self.long_step and self._edge_free(a, b):\n            return tuple(self._clamp_all(b))\n        return self._steer(a, b)\n\n    def _clamp_all(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # Sampling\n    def _sample_target(self, attractor, c_best, corridor_w):\n        for _ in range(24):\n            r = self._rand()\n            if c_best < float('inf') and r < self.informed_bias:\n                p = self._sample_ellipse(self.start, self.goal, c_best * 1.01)\n                if p and not self._point_blocked(p):\n                    return p\n            elif r < self.goal_bias:\n                if not self._point_blocked(attractor):\n                    return attractor\n            elif r < self.goal_bias + self.corridor_bias:\n                t = self._rand()\n                base = self._lerp(self.start, self.goal, t)\n                w = corridor_w\n                if self.is_3d:\n                    q = (self._rand_range(base[0] - w, base[0] + w),\n                         self._rand_range(base[1] - w, base[1] + w),\n                         self._rand_range(base[2] - w, base[2] + w))\n                else:\n                    q = (self._rand_range(base[0] - w, base[0] + w),\n                         self._rand_range(base[1] - w, base[1] + w))\n                q = self._clamp_all(q)\n                if not self._point_blocked(q):\n                    return q\n            else:\n                q = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n                if not self._point_blocked(q):\n                    return q\n        return None\n\n    def _sample_ellipse(self, f1, f2, max_sum):\n        center = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        for _ in range(28):\n            if self.is_3d:\n                p = (center[0] + self._rand_range(-half, half),\n                     center[1] + self._rand_range(-half, half),\n                     center[2] + self._rand_range(-half, half))\n            else:\n                p = (center[0] + self._rand_range(-half, half),\n                     center[1] + self._rand_range(-half, half))\n            if not self._in_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and not self._point_blocked(p):\n                return p\n        return None\n\n    # Node grid\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, counts, bestcost, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n        counts[key] = counts.get(key, 0) + 1\n        bc = bestcost.get(key)\n        if bc is None or node.cost < bc:\n            bestcost[key] = node.cost\n\n    def _ring_cells(self, key, r):\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        yield (key[0] + dx, key[1] + dy, key[2] + dz)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    yield (key[0] + dx, key[1] + dy)\n\n    def _nearest(self, grid, tree, pos):\n        key = self._cell_of(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, self.ring_max + 1):\n            cand = []\n            seen = set()\n            for cell in self._ring_cells(key, r):\n                b = grid.get(cell)\n                if b:\n                    for n in b:\n                        nid = id(n)\n                        if nid not in seen:\n                            seen.add(nid)\n                            cand.append(n)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan if grid sparse\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _neighbors_within(self, grid, pos, radius, cap):\n        key = self._cell_of(pos)\n        r_cells = int(max(1, radius // self.cell) + 1)\n        cand = []\n        seen = set()\n        for cell in self._ring_cells(key, r_cells):\n            b = grid.get(cell)\n            if b:\n                for n in b:\n                    nid = id(n)\n                    if nid in seen:\n                        continue\n                    seen.add(nid)\n                    # filter by metric radius\n                    d2 = 0.0\n                    p = n.position\n                    for i in range(self.dim):\n                        di = p[i] - pos[i]\n                        d2 += di * di\n                    if d2 <= radius * radius:\n                        cand.append(n)\n                        if len(cand) >= cap:\n                            return cand\n        return cand\n\n    def _choose_parent(self, grid, new_pos, fallback_near, radius):\n        best = fallback_near\n        best_cost = fallback_near.cost + self._dist(fallback_near.position, new_pos)\n        neigh = self._neighbors_within(grid, new_pos, radius, 48)\n        for n in neigh:\n            if n is fallback_near:\n                continue\n            if not self._edge_free(n.position, new_pos):\n                continue\n            c = n.cost + self._dist(n.position, new_pos)\n            if c + 1e-12 < best_cost:\n                best_cost = c\n                best = n\n        return best\n\n    def _adaptive_radius(self, ncount):\n        r_min = 1.25 * self.step\n        r_max = self.neighbor_radius_factor * self.step\n        t = ncount / (ncount + 200.0)\n        return r_max * (1.0 - t) + r_min * t\n\n    # Obstacles and collision\n    def _build_obs_index(self):\n        self.obs_cell = max(4.0, self.step * 2.0)\n        self.obs_grid = {}\n        if self.is_3d:\n            for i, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            lst = self.obs_grid.get(k)\n                            if lst is None:\n                                self.obs_grid[k] = [i]\n                            else:\n                                lst.append(i)\n        else:\n            for i, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        lst = self.obs_grid.get(k)\n                        if lst is None:\n                            self.obs_grid[k] = [i]\n                        else:\n                            lst.append(i)\n\n    def _point_blocked(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            lst = self.obs_grid.get((cx, cy, cz))\n            if not lst:\n                return False\n            x, y, z = p\n            for idx in lst:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            lst = self.obs_grid.get((cx, cy))\n            if not lst:\n                return False\n            x, y = p\n            for idx in lst:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        # Collect candidate obstacle cells overlapping the segment AABB\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        lst = self.obs_grid.get((cx, cy, cz))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    lst = self.obs_grid.get((cx, cy))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        # Slab method\n        t0 = 0.0\n        t1 = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tmin = (mn - p) * inv\n                tmax = (mx - p) * inv\n                if tmin > tmax:\n                    tmin, tmax = tmax, tmin\n                if tmin > t0:\n                    t0 = tmin\n                if tmax < t1:\n                    t1 = tmax\n                if t0 > t1:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        t0 = 0.0\n        t1 = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tmin = (mn - p) * inv\n                tmax = (mx - p) * inv\n                if tmin > tmax:\n                    tmin, tmax = tmax, tmin\n                if tmin > t0:\n                    t0 = tmin\n                if tmax < t1:\n                    t1 = tmax\n                if t0 > t1:\n                    return False\n        return True\n\n    # Optimization and rewiring\n    def _compress_ancestor(self, node, edges, hop_limit):\n        hops = 0\n        curp = node.parent\n        while hops < hop_limit and curp is not None and curp.parent is not None:\n            anc = curp.parent\n            if self._edge_free(anc.position, node.position):\n                newc = anc.cost + self._dist(anc.position, node.position)\n                if newc + 1e-9 < node.cost:\n                    self._reparent(node, anc, edges)\n                    curp = anc\n                    hops += 1\n                    continue\n            break\n\n    def _rewire_lite(self, grid, pivot, radius, edges):\n        neigh = self._neighbors_within(grid, pivot.position, radius, 64)\n        changed = 0\n        for nb in neigh:\n            if nb is pivot or nb.parent is pivot:\n                continue\n            # Avoid cycles\n            if self._is_ancestor(nb, pivot):\n                continue\n            if not self._edge_free(pivot.position, nb.position):\n                continue\n            newc = pivot.cost + self._dist(pivot.position, nb.position)\n            if newc + 1e-9 < nb.cost:\n                self._reparent(nb, pivot, edges)\n                changed += 1\n                if changed >= self.rewire_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        old = child.parent\n        if old is new_parent:\n            return\n        if old is not None:\n            old.remove_child(child)\n            self._remove_edge(edges, old, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        # propagate to subtree\n        stack = [child]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if abs(newc - ch.cost) > 1e-12:\n                    ch.cost = newc\n                    stack.append(ch)\n\n    def _remove_edge(self, edges, parent, child):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is parent and e[1] is child:\n                edges.pop(i)\n                return\n\n    # Path ops\n    def _assemble_path(self, a_leaf, b_leaf, a_forward):\n        pa = a_leaf.path_to_root()\n        pb = b_leaf.path_to_root()\n        if a_forward:\n            # pa: start->a, pb: goal->b\n            return pa + list(reversed(pb))\n        else:\n            return pb + list(reversed(pa))\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _refine(self, path):\n        if len(path) < 2:\n            return path[:]\n        p = self._vis_prune(path)\n        p = self._shortcuts(p, self.shortcut_attempts)\n        p = self._elastic(p, self.smooth_passes)\n        return p\n\n    def _vis_prune(self, path):\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], path[j]):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i + 1])\n                i += 1\n        return out\n\n    def _shortcuts(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return list(path)\n        pts = list(path)\n        for _ in range(attempts):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                continue\n            a, b = pts[i], pts[j]\n            if self._edge_free(a, b):\n                pts = pts[:i + 1] + pts[j:]\n        return pts\n\n    def _elastic(self, path, passes):\n        if len(path) < 3 or passes <= 0:\n            return list(path)\n        pts = list(path)\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                if self._point_blocked(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if pts[i] != mid:\n                        pts[i] = mid\n                        moved = True\n            if not moved:\n                break\n        return pts",
          "objective": -35.31946,
          "time_improvement": 61.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1602.0,
          "node_improvement": 84.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013038015365600586,
                    "num_nodes_avg": 73.0,
                    "path_length_avg": 178.87796007012008,
                    "smoothness_avg": 0.06096979653695013,
                    "success_improvement": 0.0,
                    "time_improvement": 47.153091113260764,
                    "node_improvement": 81.6167212289096,
                    "length_improvement": 1.954155582901718,
                    "smoothness_improvement": 854.3097138355535,
                    "objective_score": 19.589969252897028
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.061648321151733396,
                    "num_nodes_avg": 274.0,
                    "path_length_avg": 238.88305888509913,
                    "smoothness_avg": 0.12088627621200972,
                    "success_improvement": 0.0,
                    "time_improvement": 63.14036698293951,
                    "node_improvement": 81.58973325270443,
                    "length_improvement": 20.25395907654673,
                    "smoothness_improvement": 3010.490957800335,
                    "objective_score": 46.146940329811564
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014161467552185059,
                    "num_nodes_avg": 93.0,
                    "path_length_avg": 115.61722002198334,
                    "smoothness_avg": 0.08192767618050695,
                    "success_improvement": 0.0,
                    "time_improvement": 71.94455557408153,
                    "node_improvement": 88.17546090273363,
                    "length_improvement": 23.212547561791958,
                    "smoothness_improvement": 942.1139937440369,
                    "objective_score": 40.22146517801982
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "FIBER-Connect*: Fast Informed Bidirectional RRT*-Connect with Cached Collisions and Local Rewiring \u2014 a bidirectional planner that blends informed sampling, grid-accelerated near/nearest, per-cell cost gating, limited RRT* rewiring, and multi-step connect-extend bridging; it maintains an edge-collision cache and applies visibility pruning plus shortcuts for short, smooth paths with low planning time.",
          "planning_mechanism": "Alternate expanding the two trees; sample with goal/line bias and informed-ellipsoid once a path exists; find nearest via grid rings, steer, and validate; select the lowest-cost parent among radius neighbors (LOS) and insert under per-cell cost gates; locally rewire a few neighbors to reduce path cost; then attempt multi-step connect from the opposite tree toward the new node and bridge on first free LOS; upon success, extract start\u2192meetA + meetB\u2192goal, visibility-prune and shortcut, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.22,\n                 line_bias=0.30,\n                 informed_tries=80,\n                 grid_cell_factor=1.5,\n                 max_per_cell=6,\n                 duplicate_radius_factor=0.5,\n                 rewire_k=10,\n                 rewire_depth=5,\n                 neighbor_radius_factor=3.0,\n                 connect_steps=6,\n                 smoothing_iters=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.informed_tries = informed_tries\n        self.grid_cell_factor = grid_cell_factor\n        self.max_per_cell = max_per_cell\n        self.duplicate_radius_factor = duplicate_radius_factor\n        self.rewire_k = rewire_k\n        self.rewire_depth = rewire_depth\n        self.neighbor_radius_factor = neighbor_radius_factor\n        self.connect_steps = connect_steps\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        self.edge_res = max(0.5, min(1.0, 0.5 * self.step_size))\n        self.cell_size = max(1.0, self.grid_cell_factor * self.step_size)\n        self.min_sep = max(0.3, self.duplicate_radius_factor * self.step_size)\n\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.append(g)\n            return PlannerResult(True, [start, goal], [s, g], [(s, g)])\n\n        s_root = Node(start, None, 0.0)\n        g_root = Node(goal, None, 0.0)\n\n        start_tree = [s_root]\n        goal_tree = [g_root]\n        nodes = [s_root, g_root]\n        edges = []\n\n        grid_s = {}\n        grid_g = {}\n        counts_s = {}\n        counts_g = {}\n        bestcost_s = {}\n        bestcost_g = {}\n\n        self._grid_add(grid_s, counts_s, bestcost_s, s_root)\n        self._grid_add(grid_g, counts_g, bestcost_g, g_root)\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_s if active_start else grid_g\n            grid_b = grid_g if active_start else grid_s\n            counts_a = counts_s if active_start else counts_g\n            counts_b = counts_g if active_start else counts_s\n            bestcost_a = bestcost_s if active_start else bestcost_g\n            bestcost_b = bestcost_g if active_start else bestcost_s\n            root_other = goal if active_start else start\n\n            x_rand = self._sample(obstacles, is_3d, start, goal, best_len, root_other)\n\n            n_near = self._nearest(grid_a, tree_a, x_rand)\n            x_new = self._steer(n_near.position, x_rand)\n            if not self._in_bounds(x_new):\n                continue\n            if self._is_in_obstacle(x_new, obstacles, is_3d):\n                continue\n            if self._edge_blocked(n_near.position, x_new, obstacles, is_3d):\n                continue\n            if self._near_duplicate(grid_a, x_new, self.min_sep):\n                continue\n\n            r_near = max(self.neighbor_radius_factor * self.step_size, self.step_size)\n            neigh = self._near(grid_a, x_new, r_near)\n            parent, new_cost = self._choose_parent(neigh, n_near, x_new, obstacles, is_3d)\n\n            key_new = self._grid_key(x_new)\n            ccount = counts_a.get(key_new, 0)\n            bestc = bestcost_a.get(key_new, float('inf'))\n            if ccount >= self.max_per_cell and not (new_cost + 1e-12 < bestc):\n                continue\n\n            new_node = Node(x_new, None, new_cost)\n            new_node.attach(parent)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(grid_a, counts_a, bestcost_a, new_node)\n\n            if neigh:\n                self._rewire(new_node, neigh, obstacles, is_3d, edges)\n\n            meet_b, bridged = self._connect_toward(tree_b, grid_b, counts_b, bestcost_b, new_node.position, obstacles, is_3d)\n            if meet_b is None:\n                meet_candidate = self._nearest(grid_b, tree_b, new_node.position)\n                if meet_candidate is not None and not self._edge_blocked(new_node.position, meet_candidate.position, obstacles, is_3d):\n                    meet_b = meet_candidate\n                    bridged = True\n\n            if bridged and meet_b is not None:\n                if active_start:\n                    a = new_node\n                    b = meet_b\n                else:\n                    a = meet_b\n                    b = new_node\n                if not self._edge_blocked(a.position, b.position, obstacles, is_3d):\n                    edges.append((a, b))\n                    path = self._extract_path(a, b)\n                    path = self._visibility_prune(path, obstacles, is_3d)\n                    path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _uniform_point(self):\n        if self.dim == 3:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]),\n                    self._uniform(0.0, self.bounds[2]))\n        else:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]))\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos):\n        d = self._dist(from_pos, to_pos)\n        if d <= 1e-12:\n            return self._clamp(from_pos)\n        if d <= self.step_size:\n            return self._clamp(to_pos)\n        r = self.step_size / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _segment_hits(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        if k in self._edge_cache:\n            return self._edge_cache[k]\n        blocked = self._segment_hits(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, bestcost, node):\n        k = self._grid_key(node.position)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n        counts[k] = counts.get(k, 0) + 1\n        prev = bestcost.get(k, None)\n        if prev is None or node.cost < prev:\n            bestcost[k] = node.cost\n\n    def _grid_collect_ring(self, grid, key, r):\n        cand = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        return cand\n\n    def _nearest(self, grid, nodes, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        cand_total = []\n        r = 0\n        max_r = 4\n        while r <= max_r and len(cand_total) < 12:\n            cand_total.extend(self._grid_collect_ring(grid, key, r))\n            r += 1\n        if cand_total:\n            for n in cand_total:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            return best\n        if nodes:\n            trials = min(64, len(nodes))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(nodes)))\n                n = nodes[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _near(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        rng = int(max(1, radius // self.cell_size)) + 1\n        cand = []\n        if self.dim == 3:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        cand = self._grid_collect_ring(grid, key, 1)\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                return True\n        return False\n\n    def _choose_parent(self, neighbors, fallback_near, new_pos, obstacles, is_3d):\n        best_parent = fallback_near\n        best_cost = fallback_near.cost + self._dist(fallback_near.position, new_pos)\n        for n in neighbors:\n            if n is fallback_near:\n                continue\n            if not self._edge_blocked(n.position, new_pos, obstacles, is_3d):\n                c = n.cost + self._dist(n.position, new_pos)\n                if c + 1e-12 < best_cost:\n                    best_cost = c\n                    best_parent = n\n        return best_parent, best_cost\n\n    def _can_rewire(self, node, new_parent):\n        cur = new_parent\n        while cur is not None:\n            if cur is node:\n                return False\n            cur = cur.parent\n        return True\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                edges.pop(i)\n                break\n\n    def _propagate_cost(self, node, edges, depth):\n        if depth <= 0:\n            return\n        for ch in node.children:\n            old = ch.cost\n            ch.cost = node.cost + self._dist(node.position, ch.position)\n            if abs(ch.cost - old) > 1e-12:\n                self._propagate_cost(ch, edges, depth - 1)\n\n    def _rewire(self, new_node, neighbors, obstacles, is_3d, edges):\n        if not neighbors:\n            return\n        cand = []\n        for n in neighbors:\n            if n is new_node or n is new_node.parent:\n                continue\n            cand.append((self._dist(n.position, new_node.position), n))\n        cand.sort(key=lambda t: t[0])\n        limit = min(self.rewire_k, len(cand))\n        for i in range(limit):\n            n = cand[i][1]\n            if not self._can_rewire(n, new_node):\n                continue\n            if self._edge_blocked(new_node.position, n.position, obstacles, is_3d):\n                continue\n            new_cost = new_node.cost + self._dist(new_node.position, n.position)\n            if new_cost + 1e-12 < n.cost:\n                old_parent = n.parent\n                n.attach(new_node)\n                n.cost = new_cost\n                if old_parent is not None:\n                    self._remove_edge(edges, old_parent, n)\n                edges.append((new_node, n))\n                self._propagate_cost(n, edges, self.rewire_depth)\n\n    def _extend_toward(self, tree, grid, counts, bestcost, target_pos, obstacles, is_3d):\n        current = self._nearest(grid, tree, target_pos)\n        last = current\n        for _ in range(self.connect_steps):\n            nxt = self._steer(current.position, target_pos)\n            if not self._in_bounds(nxt):\n                break\n            if self._is_in_obstacle(nxt, obstacles, is_3d):\n                break\n            if self._edge_blocked(current.position, nxt, obstacles, is_3d):\n                break\n            if self._near_duplicate(grid, nxt, self.min_sep):\n                break\n            r_near = max(self.neighbor_radius_factor * self.step_size, self.step_size)\n            neigh = self._near(grid, nxt, r_near)\n            parent, new_cost = self._choose_parent(neigh, current, nxt, obstacles, is_3d)\n            key_new = self._grid_key(nxt)\n            ccount = counts.get(key_new, 0)\n            bestc = bestcost.get(key_new, float('inf'))\n            if ccount >= self.max_per_cell and not (new_cost + 1e-12 < bestc):\n                break\n            newn = Node(nxt, None, new_cost)\n            newn.attach(parent)\n            tree.append(newn)\n            self._grid_add(grid, counts, bestcost, newn)\n            last = newn\n            current = newn\n            if self._dist(nxt, target_pos) <= self.step_size:\n                break\n        return last\n\n    def _connect_toward(self, tree_b, grid_b, counts_b, bestcost_b, a_pos, obstacles, is_3d):\n        last = self._extend_toward(tree_b, grid_b, counts_b, bestcost_b, a_pos, obstacles, is_3d)\n        if last is None:\n            return None, False\n        if not self._edge_blocked(last.position, a_pos, obstacles, is_3d):\n            return last, True\n        return last, False\n\n    def _path_to_root(self, node):\n        seq = []\n        cur = node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _extract_path(self, meet_a, meet_b):\n        pa = self._path_to_root(meet_a)\n        pb = []\n        cur = meet_b\n        while cur is not None:\n            pb.append(cur.position)\n            cur = cur.parent\n        return pa + pb\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        n = len(path)\n        i = 0\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts\n\n    def _sample(self, obstacles, is_3d, start, goal, best_len, attractor):\n        r = self._rand()\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        if best_len < float('inf'):\n            for _ in range(self.informed_tries):\n                p = self._uniform_point()\n                if self._dist(p, start) + self._dist(p, goal) <= best_len and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jit = 0.5 * self.step_size\n            if self.dim == 3:\n                p = (self._clamp((base[0] + self._uniform(-jit, jit), base[1] + self._uniform(-jit, jit), base[2] + self._uniform(-jit, jit))))\n            else:\n                p = (min(max(base[0] + self._uniform(-jit, jit), 0.0), self.bounds[0]),\n                     min(max(base[1] + self._uniform(-jit, jit), 0.0), self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        while True:\n            p = self._uniform_point()\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p",
          "objective": -35.01262,
          "time_improvement": 55.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1329.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016425013542175293,
                    "num_nodes_avg": 47.0,
                    "path_length_avg": 154.62508050902176,
                    "smoothness_avg": 0.04071980109549708,
                    "success_improvement": 0.0,
                    "time_improvement": 33.4245918733191,
                    "node_improvement": 88.16419038025687,
                    "length_improvement": 15.247543181809576,
                    "smoothness_improvement": 537.3533116078908,
                    "objective_score": 21.86267002912093
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04094517230987549,
                    "num_nodes_avg": 124.0,
                    "path_length_avg": 229.46535757937585,
                    "smoothness_avg": 0.08684323820145955,
                    "success_improvement": 0.0,
                    "time_improvement": 75.51881386278623,
                    "node_improvement": 91.66834643553047,
                    "length_improvement": 23.397858845899172,
                    "smoothness_improvement": 2134.539069579714,
                    "objective_score": 47.36705481427394
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022255563735961915,
                    "num_nodes_avg": 88.0,
                    "path_length_avg": 119.3089523489693,
                    "smoothness_avg": 0.11130492356865981,
                    "success_improvement": 0.0,
                    "time_improvement": 55.909249570294364,
                    "node_improvement": 88.81118881118881,
                    "length_improvement": 20.760674731610354,
                    "smoothness_improvement": 1315.790412118499,
                    "objective_score": 35.80813177064702
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "FlashLink-Connect BiRRT: a time-optimized bidirectional planner that couples greedy multi-step extensions, tight obstacle prefiltering, hashed-nearest lookup with compact anchors fallback, and a safe blocked-only LRU edge cache. It prioritizes fast connection attempts with RRT-Connect-style growth while enforcing strict node and edge collision checks, then exits early upon the first feasible bridge and lightly post-processes the path.",
          "planning_mechanism": "Mechanism: Alternate trees expand. Each iteration samples goal/corridor/uniform, finds a near node via grid hashing, and greedily extends multiple step-size hops while validating node and edge collisions at every hop. After growth, the opposite tree performs a greedy connect toward the last new node. A blocked-only memo cache accelerates repeated edge checks without risking false frees. On a successful bridge, extract, visibility-collapse, and lightly shortcut the path, returning immediately.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=12.0,\n        extend_steps=6,\n        connect_steps=64,\n        goal_bias=0.25,\n        corridor_bias=0.5,\n        informed_bias=0.6,\n        nn_cell_factor=0.9,\n        min_sep_ratio=0.3,\n        anchors_stride=20,\n        obs_cell_factor=0.5,\n        edge_cache_max=20000,\n        edge_cache_bin_factor=0.2,\n        smooth_shortcuts=8\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.extend_steps = extend_steps\n        self.connect_steps = connect_steps\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.informed_bias = informed_bias\n        self.nn_cell_factor = nn_cell_factor\n        self.min_sep_ratio = min_sep_ratio\n        self.anchors_stride = max(1, int(anchors_stride))\n        self.obs_cell_factor = obs_cell_factor\n        self.edge_cache_max = edge_cache_max\n        self.edge_cache_bin_factor = edge_cache_bin_factor\n        self.smooth_shortcuts = smooth_shortcuts\n\n        # Runtime\n        self.dim = 2\n        self.bounds = None\n        self.start = None\n        self.goal = None\n        self.obstacles = None\n        self.is_3d = False\n\n        # Spatial hashing for nodes\n        self.nn_cell = 1.0\n        self.min_sep = 1.0\n\n        # Obstacle index\n        self.obs_cell = 4.0\n        self.obs_index = None  # dict[cell_key] -> list of obstacles\n\n        # Blocked-only edge memoization (safe)\n        self.cache_bin = 1.0\n        self.edge_blocked_cache = None  # dict[key] -> True\n        self.edge_cache_order = None  # list of keys for aging\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        self.obstacles = list(map.obstacles)\n        self.is_3d = (self.dim == 3)\n\n        # Derived params\n        self.nn_cell = max(1.0, self.step_size * self.nn_cell_factor)\n        self.min_sep = max(0.5, self.step_size * self.min_sep_ratio)\n        self.obs_cell = max(2.0, self.step_size * self.obs_cell_factor)\n        self.cache_bin = max(0.25, self.step_size * self.edge_cache_bin_factor)\n        self.edge_blocked_cache = {}\n        self.edge_cache_order = []\n\n        # Validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._build_obstacle_index()\n        if self._point_in_obstacle(self.start) or self._point_in_obstacle(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if not self._edge_blocked(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Initialize trees\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        anchors_a, anchors_b = [start_root], [goal_root]\n\n        d_sg = self._dist(self.start, self.goal)\n        base_corridor_w = max(self.step_size, 0.25 * d_sg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            anchors1 = anchors_a if active_start else anchors_b\n            anchors2 = anchors_b if active_start else anchors_a\n            other_root = self.goal if active_start else self.start\n\n            # Sampling\n            r = self._rand()\n            if r < self.goal_bias:\n                x_rand = other_root\n            else:\n                r2 = self._rand()\n                if r2 < self.corridor_bias:\n                    x_rand = self._sample_corridor(base_corridor_w)\n                else:\n                    x_rand = self._sample_free()\n\n            # Greedy extend from active tree\n            new_last = self._extend_toward(tree1, grid1, anchors1, x_rand, self.extend_steps, nodes, edges)\n            if new_last is None:\n                continue\n\n            # Attempt immediate bridge to nearest in the other tree\n            other_near = self._nearest_hashed(grid2, anchors2, new_last.position)\n            if other_near is not None and not self._edge_blocked(new_last.position, other_near.position):\n                path = self._extract_path_bridge(new_last, other_near, active_start)\n                path = self._post_process_path(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Greedy connect from the other tree toward the new point\n            connected_last = self._extend_toward(tree2, grid2, anchors2, new_last.position, self.connect_steps, nodes, edges)\n            if connected_last is not None:\n                if not self._edge_blocked(new_last.position, connected_last.position):\n                    path = self._extract_path_bridge(new_last, connected_last, active_start)\n                    path = self._post_process_path(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry and basic ops\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Obstacle indexing\n    def _obs_cell_key(self, p):\n        return tuple(int(p[i] // self.obs_cell) for i in range(self.dim))\n\n    def _build_obstacle_index(self):\n        self.obs_index = {}\n        if self.is_3d:\n            for obs in self.obstacles:\n                x, y, z, w, h, d = obs\n                gx0 = int(x // self.obs_cell)\n                gy0 = int(y // self.obs_cell)\n                gz0 = int(z // self.obs_cell)\n                gx1 = int((x + w) // self.obs_cell)\n                gy1 = int((y + h) // self.obs_cell)\n                gz1 = int((z + d) // self.obs_cell)\n                for gx in range(gx0, gx1 + 1):\n                    for gy in range(gy0, gy1 + 1):\n                        for gz in range(gz0, gz1 + 1):\n                            key = (gx, gy, gz)\n                            lst = self.obs_index.get(key)\n                            if lst is None:\n                                self.obs_index[key] = [obs]\n                            else:\n                                lst.append(obs)\n        else:\n            for obs in self.obstacles:\n                x, y, w, h = obs\n                gx0 = int(x // self.obs_cell)\n                gy0 = int(y // self.obs_cell)\n                gx1 = int((x + w) // self.obs_cell)\n                gy1 = int((y + h) // self.obs_cell)\n                for gx in range(gx0, gx1 + 1):\n                    for gy in range(gy0, gy1 + 1):\n                        key = (gx, gy)\n                        lst = self.obs_index.get(key)\n                        if lst is None:\n                            self.obs_index[key] = [obs]\n                        else:\n                            lst.append(obs)\n\n    def _point_in_obstacle(self, pos):\n        key = self._obs_cell_key(pos)\n        lst = self.obs_index.get(key)\n        if lst is None:\n            return False\n        if self.is_3d:\n            px, py, pz = pos\n            for x, y, z, w, h, d in lst:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for x, y, w, h in lst:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    # Segment vs AABB (slab method), generic for 2D/3D\n    def _seg_intersects_aabb(self, a, b, mins, maxs):\n        t0 = 0.0\n        t1 = 1.0\n        eps = 1e-12\n        for i in range(self.dim):\n            p0 = a[i]\n            p1 = b[i]\n            d = p1 - p0\n            mn = mins[i]\n            mx = maxs[i]\n            if abs(d) < eps:\n                if p0 < mn or p0 > mx:\n                    return False\n                else:\n                    continue\n            inv = 1.0 / d\n            tmin = (mn - p0) * inv\n            tmax = (mx - p0) * inv\n            if tmin > tmax:\n                tmin, tmax = tmax, tmin\n            if tmax < t0 or tmin > t1:\n                return False\n            if tmin > t0:\n                t0 = tmin\n            if tmax < t1:\n                t1 = tmax\n            if t0 > t1:\n                return False\n        return True\n\n    def _edge_blocked_core(self, a, b):\n        mins = tuple(min(a[i], b[i]) for i in range(self.dim))\n        maxs = tuple(max(a[i], b[i]) for i in range(self.dim))\n        if self.is_3d:\n            gx0 = int(mins[0] // self.obs_cell)\n            gy0 = int(mins[1] // self.obs_cell)\n            gz0 = int(mins[2] // self.obs_cell)\n            gx1 = int(maxs[0] // self.obs_cell)\n            gy1 = int(maxs[1] // self.obs_cell)\n            gz1 = int(maxs[2] // self.obs_cell)\n            uniq = {}\n            for gx in range(gx0, gx1 + 1):\n                for gy in range(gy0, gy1 + 1):\n                    for gz in range(gz0, gz1 + 1):\n                        lst = self.obs_index.get((gx, gy, gz))\n                        if lst:\n                            for o in lst:\n                                uniq[id(o)] = o\n            if not uniq:\n                return False\n            for x, y, z, w, h, d in uniq.values():\n                if self._seg_intersects_aabb(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            gx0 = int(mins[0] // self.obs_cell)\n            gy0 = int(mins[1] // self.obs_cell)\n            gx1 = int(maxs[0] // self.obs_cell)\n            gy1 = int(maxs[1] // self.obs_cell)\n            uniq = {}\n            for gx in range(gx0, gx1 + 1):\n                for gy in range(gy0, gy1 + 1):\n                    lst = self.obs_index.get((gx, gy))\n                    if lst:\n                        for o in lst:\n                            uniq[id(o)] = o\n            if not uniq:\n                return False\n            for x, y, w, h in uniq.values():\n                if self._seg_intersects_aabb(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    # Safe blocked-only cache\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] / self.cache_bin + 0.5) for i in range(self.dim))\n        qb = tuple(int(b[i] / self.cache_bin + 0.5) for i in range(self.dim))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_blocked(self, a, b):\n        key = self._edge_key_q(a, b)\n        if key in self.edge_blocked_cache:\n            return True\n        blocked = self._edge_blocked_core(a, b)\n        if blocked:\n            self.edge_blocked_cache[key] = True\n            self.edge_cache_order.append(key)\n            if len(self.edge_cache_order) > self.edge_cache_max:\n                # Evict oldest 10%\n                k = max(1, self.edge_cache_max // 10)\n                for _ in range(k):\n                    old = self.edge_cache_order.pop(0)\n                    if old in self.edge_blocked_cache:\n                        del self.edge_blocked_cache[old]\n        return blocked\n\n    # Sampling\n    def _sample_free(self):\n        while True:\n            if self.is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._point_in_obstacle(p):\n                return p\n\n    def _sample_corridor(self, width):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.is_3d:\n            for _ in range(12):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp((base[0] + ox, base[1] + oy, base[2] + oz))\n                    if not self._point_in_obstacle(p):\n                        return p\n        else:\n            for _ in range(12):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp((base[0] + ox, base[1] + oy))\n                    if not self._point_in_obstacle(p):\n                        return p\n        return self._sample_free()\n\n    # Node grid hashing\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.nn_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, anchors, pos):\n        k = self._grid_key(pos)\n        best = None\n        bestd = float(\"inf\")\n        for r in range(0, 3):\n            cand = self._grid_ring_collect(grid, k, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback: anchors\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # Last resort: any node in grid\n        for bucket in grid.values():\n            if bucket:\n                return bucket[0]\n        return None\n\n    def _exists_close(self, grid, pos, radius):\n        k = self._grid_key(pos)\n        r_cells = int(radius / max(1e-9, self.nn_cell)) + 1\n        cand = self._grid_ring_collect(grid, k, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # Greedy extension toward a target with strict node+edge checks\n    def _extend_toward(self, tree, grid, anchors, target_pos, max_steps, nodes, edges):\n        nearest = self._nearest_hashed(grid, anchors, target_pos)\n        if nearest is None:\n            return None\n        cur = nearest\n        added = None\n        steps = 0\n        while steps < max_steps:\n            nxt_pos = self._steer(cur.position, target_pos, self.step_size)\n            if not self._in_bounds(nxt_pos):\n                break\n            if self._point_in_obstacle(nxt_pos):\n                break\n            if self._exists_close(grid, nxt_pos, self.min_sep):\n                break\n            if self._edge_blocked(cur.position, nxt_pos):\n                break\n            new_cost = cur.cost + self._dist(cur.position, nxt_pos)\n            new_node = Node(nxt_pos, cur, new_cost)\n            cur.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((cur, new_node))\n            self._grid_add(grid, new_node)\n            if len(tree) % self.anchors_stride == 0:\n                anchors.append(new_node)\n            added = new_node\n            cur = new_node\n            steps += 1\n            # Stop if close enough to target\n            if self._dist(cur.position, target_pos) <= self.step_size * 0.5:\n                break\n        return added\n\n    # Path utilities and smoothing\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path_bridge(self, a_leaf, b_leaf, a_from_start):\n        if a_from_start:\n            left = self._path_to_root(a_leaf)\n            right = []\n            cur = b_leaf\n            while cur is not None:\n                right.append(cur.position)\n                cur = cur.parent\n            return left + right\n        else:\n            left = self._path_to_root(b_leaf)\n            right = []\n            cur = a_leaf\n            while cur is not None:\n                right.append(cur.position)\n                cur = cur.parent\n            return left + right\n\n    def _visibility_collapse(self, path):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        anchor = path[0]\n        i = 1\n        while i < len(path) - 1:\n            if self._edge_blocked(anchor, path[i + 1]):\n                out.append(path[i])\n                anchor = path[i]\n            i += 1\n        out.append(path[-1])\n        return out\n\n    def _shortcut(self, path, attempts):\n        pts = list(path)\n        if len(pts) < 3:\n            return pts\n        tries = 0\n        while tries < attempts and len(pts) >= 3:\n            i = int(self._uniform(0, len(pts) - 2))\n            j = int(self._uniform(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b):\n                pts = pts[:i + 1] + pts[j:]\n            tries += 1\n        return pts\n\n    def _post_process_path(self, path):\n        path = self._visibility_collapse(path)\n        path = self._shortcut(path, self.smooth_shortcuts)\n        return path",
          "objective": -34.70595,
          "time_improvement": 73.0,
          "length_improvement": 4.0,
          "smoothness_improvement": 2047.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011841702461242675,
                    "num_nodes_avg": 80.4,
                    "path_length_avg": 183.39408874434636,
                    "smoothness_avg": 0.08304705292189839,
                    "success_improvement": 0.0,
                    "time_improvement": 52.00209897863236,
                    "node_improvement": 79.75321077814154,
                    "length_improvement": -0.5212061060800529,
                    "smoothness_improvement": 1199.8667177895645,
                    "objective_score": 21.2872396188895
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.015815162658691408,
                    "num_nodes_avg": 114.9,
                    "path_length_avg": 259.7967118682781,
                    "smoothness_avg": 0.12339660675530258,
                    "success_improvement": 0.0,
                    "time_improvement": 90.54408813064502,
                    "node_improvement": 92.27978230195525,
                    "length_improvement": 13.272379744637384,
                    "smoothness_improvement": 3075.0835707972656,
                    "objective_score": 50.50207213996226
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.011373257637023926,
                    "num_nodes_avg": 94.2,
                    "path_length_avg": 151.1663116243918,
                    "smoothness_avg": 0.15450600267509548,
                    "success_improvement": 0.0,
                    "time_improvement": 77.46830994730173,
                    "node_improvement": 88.02288620470438,
                    "length_improvement": -0.39746641469366556,
                    "smoothness_improvement": 1865.304949580401,
                    "objective_score": 32.328537883276326
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SGB-RRT* Connect: A simplified, robust bi-directional RRT with grid-based nearest neighbors, strict collision checks before any add, safe simulated bridge connection, shallow line-of-sight compression, and capped local rewiring. It targets fast planning, strong success rate, and improved path length/smoothness via minimal, general mechanisms.",
          "planning_mechanism": "Alternate expanding start/goal trees: sample with goal bias, steer a fixed step, validate node and edge, insert if collision-free and not a duplicate, compress to grandparent if visible, and locally rewire cheaper neighbors. Attempt a safe simulated greedy connect to the opposite tree; on success, merge the trees and finalize the path with visibility prune and lightweight shortcutting.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=6.0,\n                 goal_bias=0.25,\n                 grid_scale=1.0,\n                 dupe_radius_ratio=0.5,\n                 neighbor_radius_ratio=2.5,\n                 rewire_cap=8,\n                 connect_steps=12,\n                 shortcut_attempts=60):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_scale = float(grid_scale)\n        self.dupe_ratio = float(dupe_radius_ratio)\n        self.neigh_ratio = float(neighbor_radius_ratio)\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_steps = int(max(1, connect_steps))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self._rng = 88172645463393265  # 64-bit LCG seed\n\n    # -------------------- Main planning --------------------\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes, edges = [], []\n\n        # basic validation\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._build_obs_grid()\n\n        if self._point_in_obs(self.start) or self._point_in_obs(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # early straight-line path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        self.cell = max(1.0, self.step * self.grid_scale)\n        self.dupe_radius = max(0.5, self.step * self.dupe_ratio)\n        self.neigh_radius = max(1.2 * self.step, self.step * self.neigh_ratio)\n\n        # initialize two trees and their grids\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        tree_a, tree_b = [a_root], [b_root]\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, a_root)\n        self._grid_add(grid_b, b_root)\n        nodes.extend([a_root, b_root])\n\n        for it in range(self.max_iter):\n            expand_a = (it % 2 == 0)\n            tree = tree_a if expand_a else tree_b\n            other_tree = tree_b if expand_a else tree_a\n            grid = grid_a if expand_a else grid_b\n            other_grid = grid_b if expand_a else grid_a\n            attractor = self.goal if expand_a else self.start\n\n            q_rand = self._sample(attractor)\n            if q_rand is None:\n                continue\n\n            parent = self._nearest(grid, q_rand, tree)\n            if parent is None:\n                continue\n\n            q_new = self._steer(parent.position, q_rand, self.step)\n            if (not self._in_bounds(q_new)) or self._point_in_obs(q_new):\n                continue\n            if self._exists_close(grid, q_new, self.dupe_radius):\n                continue\n            if not self._edge_free(parent.position, q_new):\n                continue\n\n            # insert node with strict checks\n            new_node = Node(q_new, parent, parent.cost + self._dist(parent.position, q_new))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(grid, new_node)\n\n            # shallow LOS compression to grandparent if visible\n            gp = parent.parent\n            if gp is not None:\n                if (not self._point_in_obs(new_node.position)) and (not self._point_in_obs(gp.position)):\n                    if self._edge_free(gp.position, new_node.position):\n                        self._reparent(new_node, gp, edges)\n\n            # local rewiring (capped)\n            if self.rewire_cap > 0:\n                self._rewire_around(grid, new_node, edges, self.neigh_radius, self.rewire_cap)\n\n            # try direct edge to nearest in other tree\n            other_near = self._nearest(other_grid, new_node.position, other_tree)\n            if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                path = self._merge_path(new_node, other_near, expand_a)\n                path = self._finalize_path(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # safe simulated greedy connect to other tree (no partial commits)\n            if other_near is not None:\n                ok, sim_pts, last_pt = self._simulate_connect(other_near.position, new_node.position, self.connect_steps)\n                if ok:\n                    # commit simulated nodes on other tree\n                    prev = other_near\n                    commit_ok = True\n                    for p in sim_pts:\n                        # strict checks before add\n                        if (not self._in_bounds(p)) or self._point_in_obs(p):\n                            commit_ok = False\n                            break\n                        if not self._edge_free(prev.position, p):\n                            commit_ok = False\n                            break\n                        n2 = Node(p, prev, prev.cost + self._dist(prev.position, p))\n                        prev.add_child(n2)\n                        other_tree.append(n2)\n                        nodes.append(n2)\n                        edges.append((prev, n2))\n                        self._grid_add(other_grid, n2)\n                        prev = n2\n                    # final link to new_node must be collision-free\n                    if commit_ok and self._edge_free(prev.position, new_node.position):\n                        path = self._merge_path(new_node, prev, expand_a)\n                        path = self._finalize_path(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # -------------------- RNG --------------------\n    def _rand(self):\n        # 64-bit LCG\n        self._rng = (6364136223846793005 * self._rng + 1) & ((1 << 64) - 1)\n        return (self._rng >> 11) / float(1 << 53)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # -------------------- Geometry --------------------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-16:\n            return tuple(a)\n        if d2 <= step * step:\n            tgt = b\n        else:\n            d = d2 ** 0.5\n            r = step / d\n            tgt = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n        # clamp to bounds\n        return tuple(min(max(tgt[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # -------------------- Grid for nodes --------------------\n    def _grid_key(self, pos):\n        if self.is3:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        else:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos, fallback=None):\n        key = self._grid_key(pos)\n        best, bestd = None, 1e100\n        for r in range(0, 3):\n            cand = self._ring_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd, best = d2, n\n            if best is not None:\n                return best\n        if fallback:\n            for n in fallback:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd, best = d2, n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        cand = self._ring_collect(grid, key, r_cells)\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                out.append(n)\n        return out\n\n    def _exists_close(self, grid, pos, radius):\n        return len(self._neighbors_in_radius(grid, pos, radius)) > 0\n\n    # -------------------- Obstacles & collisions --------------------\n    def _build_obs_grid(self):\n        self.og_cell = max(3.0, self.step * 1.5)\n        self.ogrid = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.og_cell)\n                cy0 = int(max(0.0, y) // self.og_cell)\n                cz0 = int(max(0.0, z) // self.og_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.og_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.og_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.og_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            if k not in self.ogrid:\n                                self.ogrid[k] = [idx]\n                            else:\n                                self.ogrid[k].append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.og_cell)\n                cy0 = int(max(0.0, y) // self.og_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.og_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.og_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        if k not in self.ogrid:\n                            self.ogrid[k] = [idx]\n                        else:\n                            self.ogrid[k].append(idx)\n\n    def _bucket_candidates(self, a, b):\n        if self.is3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.og_cell)\n            cy0 = int(max(0.0, miny) // self.og_cell)\n            cz0 = int(max(0.0, minz) // self.og_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.og_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.og_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.og_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.ogrid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            return cand\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.og_cell)\n            cy0 = int(max(0.0, miny) // self.og_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.og_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.og_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.ogrid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            return cand\n\n    def _point_in_obs(self, p):\n        if self.is3:\n            cx = int(p[0] // self.og_cell)\n            cy = int(p[1] // self.og_cell)\n            cz = int(p[2] // self.og_cell)\n            bucket = self.ogrid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if (ox <= x <= ox + w) and (oy <= y <= oy + h) and (oz <= z <= oz + d):\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.og_cell)\n            cy = int(p[1] // self.og_cell)\n            bucket = self.ogrid.get((cx, cy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if (ox <= x <= ox + w) and (oy <= y <= oy + h):\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        cand = self._bucket_candidates(a, b)\n        if not cand:\n            return False\n        if self.is3:\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        # Liang-Barsky in 2D\n        t0, t1 = 0.0, 1.0\n        dx = p1[0] - p0[0]\n        dy = p1[1] - p0[1]\n        for p, q in [(-dx, p0[0] - bmin[0]),\n                     ( dx, bmax[0] - p0[0]),\n                     (-dy, p0[1] - bmin[1]),\n                     ( dy, bmax[1] - p0[1])]:\n            if abs(p) < 1e-12:\n                if q < 0.0:\n                    return False\n            else:\n                t = q / p\n                if p < 0:\n                    if t > t1: return False\n                    if t > t0: t0 = t\n                else:\n                    if t < t0: return False\n                    if t < t1: t1 = t\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        # Liang-Barsky generalized to 3D\n        t0, t1 = 0.0, 1.0\n        for i in range(3):\n            d = p1[i] - p0[i]\n            for s, bound in [(-1.0, bmin[i]), (1.0, bmax[i])]:\n                p = s * d\n                q = s * (p0[i] - bound)\n                if abs(p) < 1e-12:\n                    if q < 0.0:\n                        return False\n                else:\n                    t = q / p\n                    if p < 0:\n                        if t > t1: return False\n                        if t > t0: t0 = t\n                    else:\n                        if t < t0: return False\n                        if t < t1: t1 = t\n        return True\n\n    # -------------------- Sampling --------------------\n    def _sample(self, attractor):\n        for _ in range(16):\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attractor\n            else:\n                if self.is3:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(p) and (not self._point_in_obs(p)):\n                return p\n        return None\n\n    # -------------------- Reparent/rewire --------------------\n    def _reparent(self, child, new_parent, edges):\n        if child is new_parent or child.parent is new_parent:\n            return\n        if self._point_in_obs(child.position) or self._point_in_obs(new_parent.position):\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            try:\n                old.children.remove(child)\n            except:\n                pass\n            self._remove_edge(edges, old, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        # propagate costs down\n        stack = list(child.children)\n        while stack:\n            n = stack.pop()\n            n.cost = n.parent.cost + self._dist(n.parent.position, n.position)\n            if n.children:\n                for c in n.children:\n                    stack.append(c)\n\n    def _rewire_around(self, grid, node, edges, radius, cap):\n        neigh = self._neighbors_in_radius(grid, node.position, radius)\n        cnt = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            # avoid cycles\n            cur = node\n            cyc = False\n            while cur is not None:\n                if cur is nb:\n                    cyc = True\n                    break\n                cur = cur.parent\n            if cyc:\n                continue\n            if self._point_in_obs(nb.position) or self._point_in_obs(node.position):\n                continue\n            if not self._edge_free(node.position, nb.position):\n                continue\n            ncost = node.cost + self._dist(node.position, nb.position)\n            if ncost + 1e-12 < nb.cost:\n                self._reparent(nb, node, edges)\n                cnt += 1\n                if cnt >= cap:\n                    break\n\n    def _remove_edge(self, edges, parent, child):\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                edges.pop(i)\n                return\n\n    # -------------------- Connect & path utilities --------------------\n    def _simulate_connect(self, start_pos, target_pos, steps):\n        pts = []\n        cur = start_pos\n        for _ in range(steps):\n            nxt = self._steer(cur, target_pos, self.step)\n            if self._point_in_obs(nxt) or (not self._edge_free(cur, nxt)):\n                return False, [], cur\n            pts.append(nxt)\n            cur = nxt\n            if self._edge_free(cur, target_pos):\n                # final segment check later by caller\n                return True, pts, cur\n        # ensure last check to target helps early exit decisions\n        if self._edge_free(cur, target_pos):\n            return True, pts, cur\n        return False, pts, cur\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_path(self, a_end, b_end, a_forward):\n        pa = self._path_to_root(a_end)\n        pb = self._path_to_root(b_end)\n        if a_forward:\n            return pa + pb[::-1]\n        else:\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _vis_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-12 <= bestL:\n                    cur = cand\n                    bestL = L\n            tries += 1\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._vis_prune(path)\n        p1 = self._shortcut(p0, self.shortcut_attempts)\n        p2 = self._vis_prune(p1)\n        return p2",
          "objective": -34.6993,
          "time_improvement": 61.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1729.0,
          "node_improvement": 85.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016133785247802734,
                    "num_nodes_avg": 81.8,
                    "path_length_avg": 171.93416133127897,
                    "smoothness_avg": 0.04800154406384858,
                    "success_improvement": 0.0,
                    "time_improvement": 34.60502575887451,
                    "node_improvement": 79.40065474691514,
                    "length_improvement": 5.7601617031927885,
                    "smoothness_improvement": 651.3284016205362,
                    "objective_score": 17.094246757680708
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.026781320571899414,
                    "num_nodes_avg": 138.6,
                    "path_length_avg": 239.09045233639964,
                    "smoothness_avg": 0.11363406057020475,
                    "success_improvement": 0.0,
                    "time_improvement": 83.98740420582064,
                    "node_improvement": 90.68736141906875,
                    "length_improvement": 20.184725173013117,
                    "smoothness_improvement": 2823.8862257769038,
                    "objective_score": 51.42648749443858
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018439054489135742,
                    "num_nodes_avg": 129.9,
                    "path_length_avg": 130.56172756377174,
                    "smoothness_avg": 0.1425140883988898,
                    "success_improvement": 0.0,
                    "time_improvement": 63.470179444318234,
                    "node_improvement": 83.48378893833438,
                    "length_improvement": 13.287117233512797,
                    "smoothness_improvement": 1712.7686851381018,
                    "objective_score": 35.577167599093656
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "GLIDE-Connect: a simplified, robust BiRRT-Connect with grid-based proximity, duplicate suppression, and greedy opposite-tree connection. It prioritizes generalization by using uniform goal-biased sampling, lightweight spatial hashing, and strict node+edge validation before commitment. After a first solution, it applies fast line-of-sight collapse, randomized shortcuts, and collision-aware corner rounding for shorter, smoother paths.",
          "planning_mechanism": "Alternate growing start/goal trees. For a sampled target, extend the active tree by several validated steps toward it, inserting nodes only if the point is free and the incoming edge is collision-free. After each successful step, greedily extend the opposite tree toward the new node (multi-step connect); on reach or direct visibility, assemble and smooth the path. Uniform sampling with goal bias and a dupe-radius gate maintains coverage and avoids near-duplicates; a coarse obstacle grid accelerates collision checks.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            i = 0\n            while i < len(self.parent.children):\n                if self.parent.children[i] is self:\n                    self.parent.children.pop(i)\n                    break\n                i += 1\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=6.0,\n                 goal_bias=0.28,\n                 cell_factor=1.6,\n                 dupe_radius_ratio=0.4,\n                 connect_limit=16,\n                 smooth_shortcuts=80,\n                 smooth_rounds=6):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.cell_factor = float(cell_factor)\n        self.dupe_ratio = float(dupe_radius_ratio)\n        self.connect_limit = int(connect_limit)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self.smooth_rounds = int(max(0, smooth_rounds))\n        self._rng = 123456789\n\n    def plan(self, map):\n        # Scene\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n\n        # Basic checks\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        # Build obstacle grid early to use for point checks\n        self._build_obs_grid()\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Parameters derived\n        self.cell = max(1.0, self.step * self.cell_factor)\n        self.dupe_radius = max(0.4, self.dupe_ratio * self.step)\n\n        # Data holders\n        self._nodes = []\n        self._edges = []\n\n        # Trees and grids\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        self._nodes.extend([a_root, b_root])\n        A, B = [a_root], [b_root]\n        GA, GB = {}, {}\n        self._grid_add(GA, a_root)\n        self._grid_add(GB, b_root)\n\n        # Main loop\n        for it in range(self.max_iter):\n            growA = (it % 2 == 0)\n            T = A if growA else B\n            O = B if growA else A\n            G = GA if growA else GB\n            GO = GB if growA else GA\n            attractor = self.goal if growA else self.start\n\n            target = self._sample_target(attractor)\n            if target is None:\n                continue\n\n            qnear = self._nearest(G, target)\n            if qnear is None:\n                qnear = T[-1]\n\n            new_end = self._extend(T, G, qnear, target, self.connect_limit)\n            if new_end is None:\n                continue\n\n            # Try to greedily connect the opposite tree toward the new node\n            other_near = self._nearest(GO, new_end.position)\n            if other_near is None:\n                other_near = O[-1]\n\n            # Direct bridge\n            if self._edge_free(new_end.position, other_near.position):\n                path = self._assemble_path(new_end, other_near, growA)\n                path = self._postprocess(path)\n                return PlannerResult(True, path, self._nodes, self._edges)\n\n            # Greedy connect\n            reach_end = self._extend(O, GO, other_near, new_end.position, self.connect_limit)\n            if reach_end is not None:\n                # If reached exactly or last hop can see the new node, accept\n                if self._same_pos(reach_end.position, new_end.position) or self._edge_free(reach_end.position, new_end.position):\n                    path = self._assemble_path(new_end, reach_end, growA)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, self._nodes, self._edges)\n\n        return PlannerResult(False, [], self._nodes, self._edges)\n\n    # RNG\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry and bounds\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _same_pos(self, a, b, eps=1e-9):\n        for i in range(self.dims):\n            if abs(a[i] - b[i]) > eps:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Obstacle grid\n    def _build_obs_grid(self):\n        self.obs_cell = max(4.0, self.step * 2.0)\n        self._ogrid = {}\n        if self.is3d:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self._ogrid.get(k)\n                            if b is None:\n                                self._ogrid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self._ogrid.get(k)\n                        if b is None:\n                            self._ogrid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _cell_candidates(self, a, b):\n        # Collect obstacle indices in bounding box of the segment\n        if self.is3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        lst = self._ogrid.get((cx, cy, cz))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            return cand\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    lst = self._ogrid.get((cx, cy))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            return cand\n\n    def _point_blocked(self, p):\n        if self.is3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self._ogrid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            x0, y0, z0 = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= x0 <= x + w and y <= y0 <= y + h and z <= z0 <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self._ogrid.get((cx, cy))\n            if not bucket:\n                return False\n            x0, y0 = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= x0 <= x + w and y <= y0 <= y + h:\n                    return True\n            return False\n\n    def _seg_aabb_hit(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(self.dims):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _edge_free(self, a, b):\n        cand = self._cell_candidates(a, b)\n        if not cand:\n            return True\n        if self.is3d:\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_hit(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return False\n            return True\n        else:\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_hit(a, b, (x, y), (x + w, y + h)):\n                    return False\n            return True\n\n    # Node grid for proximity queries\n    def _cell_key(self, pos):\n        if self.is3d:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos):\n        k = self._cell_key(pos)\n        best = None\n        bd = 1e100\n        for r in range(0, 3):\n            cand = self._grid_ring(grid, k, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bd:\n                        bd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback scan\n        for b in grid.values():\n            for n in b:\n                d = self._dist(n.position, pos)\n                if d < bd:\n                    bd = d\n                    best = n\n        return best\n\n    def _has_close(self, grid, pos, radius):\n        k = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell) + 1)\n        lst = self._grid_ring(grid, k, rc)\n        r2 = radius * radius\n        for n in lst:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # Extension (RRT-Connect style, limited steps). Ensures node+edge checks before adding.\n    def _extend(self, T, G, from_node, toward_pos, max_steps):\n        cur = from_node\n        advanced = False\n        steps = 0\n        while steps < max_steps:\n            nxt = self._steer(cur.position, toward_pos, self.step)\n            if self._same_pos(nxt, cur.position):\n                break\n            if not self._in_bounds(nxt):\n                break\n            if self._point_blocked(nxt):\n                break\n            if self._has_close(G, nxt, self.dupe_radius):\n                break\n            if not self._edge_free(cur.position, nxt):\n                break\n            d = self._dist(cur.position, nxt)\n            q = Node(nxt, cur, cur.cost + d)\n            q.attach(cur)\n            T.append(q)\n            self._nodes.append(q)\n            self._edges.append((cur, q))\n            self._grid_add(G, q)\n            cur = q\n            advanced = True\n            steps += 1\n            # If we reached the target exactly, stop\n            if self._same_pos(cur.position, toward_pos):\n                break\n        return cur if advanced else None\n\n    # Sampling\n    def _sample_target(self, attractor):\n        if self._rand() < self.goal_bias:\n            return attractor\n        return self._random_free()\n\n    def _random_free(self):\n        for _ in range(64):\n            if self.is3d:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n            else:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n            if not self._point_blocked(p):\n                return p\n        # As a last resort, return center clamped\n        if self.is3d:\n            return (min(max(self.bounds[0] * 0.5, 0.0), self.bounds[0]),\n                    min(max(self.bounds[1] * 0.5, 0.0), self.bounds[1]),\n                    min(max(self.bounds[2] * 0.5, 0.0), self.bounds[2]))\n        else:\n            return (min(max(self.bounds[0] * 0.5, 0.0), self.bounds[0]),\n                    min(max(self.bounds[1] * 0.5, 0.0), self.bounds[1]))\n\n    # Path utilities\n    def _to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _assemble_path(self, a_end, b_end, a_side_grew):\n        if a_side_grew:\n            pa = self._to_root(a_end)\n            pb = self._to_root(b_end)\n            if pa and pb and pa[0] == pb[-1]:\n                pb = pb[:-1]\n            return pa + pb[::-1]\n        else:\n            pa = self._to_root(a_end)\n            pb = self._to_root(b_end)\n            if pa and pb and pb[0] == pa[-1]:\n                pa = pa[:-1]\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    # Smoothing\n    def _los_collapse(self, path, rounds=3):\n        if len(path) < 3:\n            return path[:]\n        cur = path[:]\n        for _ in range(rounds):\n            out = [cur[0]]\n            anchor_idx = 0\n            i = 1\n            while i < len(cur) - 1:\n                if self._edge_free(cur[anchor_idx], cur[i + 1]):\n                    i += 1\n                    continue\n                out.append(cur[i])\n                anchor_idx = len(out) - 1\n                i += 1\n            out.append(cur[-1])\n            if len(out) == len(cur):\n                break\n            cur = out\n        return cur\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = path[:]\n        best = self._path_len(pts)\n        tries = 0\n        n = len(pts)\n        while tries < attempts and len(pts) >= 3:\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j >= n:\n                tries += 1\n                continue\n            a, b = pts[i], pts[j]\n            if self._edge_free(a, b):\n                cand = pts[:i + 1] + pts[j:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    pts = cand\n                    best = L\n                    n = len(pts)\n            tries += 1\n        return pts\n\n    def _round_corners(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return path[:]\n        pts = list(path)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dims))\n                if not self._in_bounds(mid):\n                    continue\n                if self._point_blocked(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if pts[i] != mid:\n                        pts[i] = mid\n                        moved = True\n            if not moved:\n                break\n        return pts\n\n    def _postprocess(self, path):\n        p = self._los_collapse(path, rounds=3)\n        p = self._shortcut(p, self.smooth_shortcuts)\n        p = self._round_corners(p, self.smooth_rounds)\n        return p",
          "objective": -34.29181,
          "time_improvement": 72.0,
          "length_improvement": 5.0,
          "smoothness_improvement": 1957.0,
          "node_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008447527885437012,
                    "num_nodes_avg": 92.2,
                    "path_length_avg": 191.3731638691875,
                    "smoothness_avg": 0.048336809326901084,
                    "success_improvement": 0.0,
                    "time_improvement": 65.75968627420662,
                    "node_improvement": 76.78166708637623,
                    "length_improvement": -4.894663618541875,
                    "smoothness_improvement": 656.5760310274793,
                    "objective_score": 20.07398786627425
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.011332845687866211,
                    "num_nodes_avg": 132.2,
                    "path_length_avg": 259.23683578863955,
                    "smoothness_avg": 0.13710610795003553,
                    "success_improvement": 0.0,
                    "time_improvement": 93.22407284919258,
                    "node_improvement": 91.11738224820265,
                    "length_improvement": 13.45928249516016,
                    "smoothness_improvement": 3427.838911092322,
                    "objective_score": 53.18198590731548
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022087860107421874,
                    "num_nodes_avg": 237.8,
                    "path_length_avg": 141.0070779227184,
                    "smoothness_avg": 0.14838337221438208,
                    "success_improvement": 0.0,
                    "time_improvement": 56.24148913608739,
                    "node_improvement": 69.76478067387158,
                    "length_improvement": 6.349812879234684,
                    "smoothness_improvement": 1787.4255420456973,
                    "objective_score": 29.619462178595512
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "FLASH-IBiConnect: Fast, Lightweight, Adaptive\u2011Stride, Hashed Informed Bi\u2011Connect planner. It accelerates bidirectional exploration with early throttling before collisions, adaptive multi\u2011step steering, bounded Connect\u2011style bridging, and cached edge tests. A greedy visibility pass plus a few shortcuts refine the first solution with minimal overhead.",
          "planning_mechanism": "Alternate expanding start/goal trees using hashed-grid nearest neighbors; for each sample, pick the nearest, then adaptively stride 1\u20133 steps toward the target while skipping saturated/duplicate cells before doing any collision tests. Insert only if both node and edge are free. After each insertion, greedily Connect the opposite tree toward the new node for a few steps, stopping on the first valid bridge. Maintain exact/quantized blocked edge caches to avoid repeated tests. On success, extract, visibility-prune, then lightly shortcut the path and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=6.0,\n                 goal_bias=0.35,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=24,\n                 max_per_cell=8,\n                 search_r_max=2,\n                 max_stride_steps=3,\n                 connect_steps=6,\n                 dup_radius_factor=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n        self.max_per_cell = max_per_cell\n        self.search_r_max = search_r_max\n        self.max_stride_steps = max_stride_steps\n        self.connect_steps = connect_steps\n        self.dup_radius_factor = dup_radius_factor\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        # Caches\n        self._edge_blocked_cache = set()  # quantized blocked segments only\n        self._edge_exact_cache = {}       # (a,b) exact -> bool\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Parameters derived\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size * 1.1)\n        self.edge_res = max(0.5, self.collision_step)\n\n        # Reset caches\n        self._edge_blocked_cache = set()\n        self._edge_exact_cache = {}\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            path = [start, goal]\n            path = self._visibility_prune(path, obstacles, is_3d)\n            path = self._shortcut_smooth(path, obstacles, is_3d, max(4, self.smoothing_iters // 3))\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Initialize trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Grids and counts\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n        self._grid_add(grid_start, counts_start, start_root)\n        self._grid_add(grid_goal, counts_goal, goal_root)\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            grid_a = grid_start if active_start else grid_goal\n            counts_a = counts_start if active_start else counts_goal\n\n            tree_b = goal_tree if active_start else start_tree\n            grid_b = grid_goal if active_start else grid_start\n            counts_b = counts_goal if active_start else counts_start\n\n            root_other = goal if active_start else start\n\n            # Sample with goal/opposite-root bias\n            if self._rand() < self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest lookup\n            nearest = self._nearest_hashed(grid_a, tree_a, x_rand)\n            if nearest is None:\n                continue\n\n            # Adaptive stride toward sample with pre-throttling before collision checks\n            cand_pos = None\n            dist_to_rand = self._dist(nearest.position, x_rand)\n            if dist_to_rand < 1e-9:\n                continue\n            for stride in range(1, self.max_stride_steps + 1):\n                step = min(self.step_size * stride, dist_to_rand)\n                new_pos = self._interpolate(nearest.position, x_rand, step / dist_to_rand)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                # Per-cell throttling and near-dup suppression before edge checks\n                k_new = self._grid_key(new_pos)\n                if self._cell_count(counts_a, k_new) >= self.max_per_cell:\n                    continue\n                if self._near_duplicate(grid_a, new_pos, self.dup_radius_factor * self.step_size):\n                    continue\n                # Candidate accepted; check edge\n                if not self._edge_blocked(nearest.position, new_pos, obstacles, is_3d):\n                    cand_pos = new_pos\n                    break\n\n            if cand_pos is None:\n                continue\n\n            # Insert node and edge (both node and edge have been checked)\n            new_node = Node(cand_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, cand_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, counts_a, new_node)\n\n            # Try bounded Connect from the other tree toward new_node\n            meet = self._connect_toward(tree_b, grid_b, counts_b, new_node.position, obstacles, is_3d, edges)\n            if meet is not None:\n                # Build path\n                path = self._extract_path(new_node, meet, a_is_start_tree=active_start)\n                path = self._visibility_prune(path, obstacles, is_3d)\n                path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ------------- Random -------------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------- Geometry -------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _interpolate(self, a, b, t):\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim)))\n\n    # ------------- Collision & caches -------------\n    def _quant(self, p, q=1.5):\n        if self.dim == 3:\n            return (int(p[0] // q), int(p[1] // q), int(p[2] // q))\n        else:\n            return (int(p[0] // q), int(p[1] // q))\n\n    def _seg_key_exact(self, a, b):\n        if a <= b:\n            return (a, b)\n        else:\n            return (b, a)\n\n    def _seg_key_quant_blocked(self, a, b):\n        qa = self._quant(a)\n        qb = self._quant(b)\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k_exact = self._seg_key_exact(a, b)\n        cached = self._edge_exact_cache.get(k_exact)\n        if cached is not None:\n            return cached\n        kq = self._seg_key_quant_blocked(a, b)\n        if kq in self._edge_blocked_cache:\n            self._edge_exact_cache[k_exact] = True\n            return True\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_exact_cache[k_exact] = blocked\n        if blocked:\n            self._edge_blocked_cache.add(kq)\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ------------- Sampling -------------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ------------- Grid / NN -------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n\n    def _cell_count(self, counts, key):\n        return counts.get(key, 0)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.search_r_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback: random subset\n        if tree:\n            trials = min(64, len(tree))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(tree)))\n                n = tree[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _near_duplicate(self, grid, pos, dup_radius):\n        key = self._grid_key(pos)\n        cand = self._grid_ring_collect(grid, key, 1)\n        rr = dup_radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # ------------- Connect -------------\n    def _connect_toward(self, tree, grid, counts, target_pos, obstacles, is_3d, edges):\n        # Find a starting node in this tree nearest to target\n        nearest = self._nearest_hashed(grid, tree, target_pos)\n        if nearest is None:\n            return None\n\n        cur = nearest\n        for _ in range(self.connect_steps):\n            d = self._dist(cur.position, target_pos)\n            if d <= self.step_size:\n                # Attempt direct bridge (edge check only; target node already validated earlier)\n                if not self._edge_blocked(cur.position, target_pos, obstacles, is_3d):\n                    return cur\n                else:\n                    return None\n            # Propose next step toward target with pre-throttling\n            new_pos = self._interpolate(cur.position, target_pos, self.step_size / d)\n            if not self._in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            k_new = self._grid_key(new_pos)\n            if self._cell_count(counts, k_new) >= self.max_per_cell or self._near_duplicate(grid, new_pos, self.dup_radius_factor * self.step_size):\n                # Try skipping ahead one extra step if possible\n                if d > 2 * self.step_size:\n                    new_pos2 = self._interpolate(cur.position, target_pos, (2.0 * self.step_size) / d)\n                    if self._in_bounds(new_pos2) and (not self._is_in_obstacle(new_pos2, obstacles, is_3d)):\n                        k_new2 = self._grid_key(new_pos2)\n                        if self._cell_count(counts, k_new2) < self.max_per_cell and (not self._near_duplicate(grid, new_pos2, self.dup_radius_factor * self.step_size)):\n                            if not self._edge_blocked(cur.position, new_pos2, obstacles, is_3d):\n                                n2 = Node(new_pos2, parent=cur, cost=cur.cost + self._dist(cur.position, new_pos2))\n                                cur.add_child(n2)\n                                tree.append(n2)\n                                edges.append((cur, n2))\n                                self._grid_add(grid, counts, n2)\n                                cur = n2\n                                continue\n                return None\n            if self._edge_blocked(cur.position, new_pos, obstacles, is_3d):\n                return None\n            # Commit\n            nxt = Node(new_pos, parent=cur, cost=cur.cost + self._dist(cur.position, new_pos))\n            cur.add_child(nxt)\n            tree.append(nxt)\n            edges.append((cur, nxt))\n            self._grid_add(grid, counts, nxt)\n            cur = nxt\n        # Final attempt if close enough\n        if self._dist(cur.position, target_pos) <= self.step_size and not self._edge_blocked(cur.position, target_pos, obstacles, is_3d):\n            return cur\n        return None\n\n    # ------------- Path -------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -34.17161,
          "time_improvement": 53.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1656.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017466092109680177,
                    "num_nodes_avg": 62.6,
                    "path_length_avg": 163.87259344320734,
                    "smoothness_avg": 0.04964655781883516,
                    "success_improvement": 0.0,
                    "time_improvement": 29.204794407362268,
                    "node_improvement": 84.2357088894485,
                    "length_improvement": 10.178834806362733,
                    "smoothness_improvement": 677.0764390906203,
                    "objective_score": 18.25412140147942
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05110058784484863,
                    "num_nodes_avg": 150.2,
                    "path_length_avg": 234.1330981250513,
                    "smoothness_avg": 0.10546763418938201,
                    "success_improvement": 0.0,
                    "time_improvement": 69.44687414469483,
                    "node_improvement": 89.90794866626352,
                    "length_improvement": 21.839632698290526,
                    "smoothness_improvement": 2613.7581929591665,
                    "objective_score": 47.0066328271786
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.020591354370117186,
                    "num_nodes_avg": 111.5,
                    "path_length_avg": 122.69634602394744,
                    "smoothness_avg": 0.13971203959587924,
                    "success_improvement": 0.0,
                    "time_improvement": 59.20623367201239,
                    "node_improvement": 85.82326764144946,
                    "length_improvement": 18.510929143043064,
                    "smoothness_improvement": 1677.1268311895358,
                    "objective_score": 37.254061743377235
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "ARC-BiRRT: Adaptive Reuse-Cached, Ring-Hashed, Cost-Gated BiRRT-Connect. It accelerates bidirectional planning with exact edge-collision memoization, ring-hash nearest search, local LOS parent selection, per-cell cost-gated admission, and single-shot tree bridging; upon success it applies cache-reused visibility pruning and bounded shortcut smoothing for shorter, smoother paths.",
          "planning_mechanism": "Alternate expanding start/goal trees with small-beam guided sampling (goal/corridor bias); find a near node via ring-hash, steer one step, enforce node+edge checks and near-duplicate rejection; pick a best-cost parent among nearby ring neighbors that see the new point; admit only if per-cell capacity or cost improves; after insertion, attempt a direct LOS bridge to the opposite tree; on success, extract and cache-prune/shortcut the path and stop early.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=7.5,\n        beam_width=2,\n        goal_bias=0.3,\n        grid_cell_factor=1.6,\n        ring_max=3,\n        max_per_cell=6,\n        min_sep_factor=0.5,\n        los_neighbor_rings=1,\n        smoothing_iters=50,\n        corridor_bias=0.5\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.ring_max = ring_max\n        self.max_per_cell = max_per_cell\n        self.min_sep_factor = min_sep_factor\n        self.los_neighbor_rings = los_neighbor_rings\n        self.smoothing_iters = smoothing_iters\n        self.corridor_bias = corridor_bias\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        # RNG state\n        self._lcg_state = 2463534242\n\n        # Caches\n        self._edge_cache = {}  # exact endpoints (ordered) -> bool blocked\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Derived params\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.3, self.step_size * self.min_sep_factor)\n        self.edge_res = max(0.5, min(1.0, self.step_size * 0.5))\n\n        # Reset caches\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            path = [start, goal]\n            path = self._visibility_prune(path, obstacles, is_3d)\n            path = self._shortcut_smooth(path, obstacles, is_3d, iters=min(10, self.smoothing_iters))\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Initialize trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n        bestcost_start = {}\n        bestcost_goal = {}\n\n        self._grid_add(grid_start, counts_start, bestcost_start, start_root)\n        self._grid_add(grid_goal, counts_goal, bestcost_goal, goal_root)\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n\n            tree_a = start_tree if active_start else goal_tree\n            grid_a = grid_start if active_start else grid_goal\n            counts_a = counts_start if active_start else counts_goal\n            bestcost_a = bestcost_start if active_start else bestcost_goal\n\n            tree_b = goal_tree if active_start else start_tree\n            grid_b = grid_goal if active_start else grid_start\n            counts_b = counts_goal if active_start else counts_start\n            bestcost_b = bestcost_goal if active_start else bestcost_start\n\n            attractor = goal if active_start else start\n\n            for _ in range(self.beam_width):\n                x_rand = self._guided_sample(obstacles, is_3d, attractor)\n\n                nearest = self._nearest_hashed(grid_a, tree_a, x_rand)\n                if nearest is None:\n                    continue\n\n                new_pos = self._steer(nearest.position, x_rand)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._edge_blocked(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                if self._near_duplicate(grid_a, new_pos, self.min_sep):\n                    continue\n\n                # Choose a parent among local neighbors with LOS (limited rings) for better path cost\n                parent = self._choose_parent_local(grid_a, new_pos, nearest, obstacles, is_3d)\n                if self._edge_blocked(parent.position, new_pos, obstacles, is_3d):\n                    continue  # safety\n\n                new_cost = parent.cost + self._dist(parent.position, new_pos)\n\n                # Per-cell cost-gated admission\n                key_new = self._grid_key(new_pos)\n                ccount = counts_a.get(key_new, 0)\n                bestc = bestcost_a.get(key_new, float('inf'))\n                if ccount >= self.max_per_cell and not (new_cost + 1e-9 < bestc):\n                    continue\n\n                # Insert node\n                new_node = Node(new_pos, parent=parent, cost=new_cost)\n                parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((parent, new_node))\n                self._grid_add(grid_a, counts_a, bestcost_a, new_node)\n\n                # Try single-shot direct bridge to the other tree\n                other_near = self._nearest_hashed(grid_b, tree_b, new_node.position)\n                if other_near is not None:\n                    if not self._edge_blocked(new_node.position, other_near.position, obstacles, is_3d):\n                        path = self._extract_path(new_node, other_near, a_is_start_tree=active_start)\n                        path = self._visibility_prune(path, obstacles, is_3d)\n                        path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos):\n        d = self._dist(from_pos, to_pos)\n        if d <= 1e-9:\n            return self._clamp(from_pos)\n        if d <= self.step_size:\n            return self._clamp(to_pos)\n        r = self.step_size / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision and caching\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        if k in self._edge_cache:\n            return self._edge_cache[k]\n        blocked = self._segment_hits(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_hits(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _guided_sample(self, obstacles, is_3d, attractor):\n        # Goal-biased with optional corridor pull (activated only after success; here kept generic)\n        if self._rand() < self.goal_bias:\n            p = attractor\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # Mild blend toward attractor\n        alpha = 0.2\n        if self.dim == 3:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]),\n                   self._uniform(0.0, self.bounds[2]))\n            p = tuple(alpha * attractor[i] + (1.0 - alpha) * rnd[i] for i in range(3))\n        else:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]))\n            p = tuple(alpha * attractor[i] + (1.0 - alpha) * rnd[i] for i in range(2))\n        if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    # Grid / NN\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, bestcost, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n        bc = bestcost.get(k)\n        if bc is None or node.cost < bc:\n            bestcost[k] = node.cost\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.ring_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback to limited random subset to avoid O(N)\n        if not tree:\n            return None\n        trials = min(64, len(tree))\n        for _ in range(trials):\n            idx = int(self._uniform(0, len(tree)))\n            n = tree[idx]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r = 1\n        cand = self._grid_ring_collect(grid, key, r)\n        rr = radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # Parent selection among local neighbors with LOS\n    def _choose_parent_local(self, grid, new_pos, fallback_nearest, obstacles, is_3d):\n        key = self._grid_key(new_pos)\n        best_parent = fallback_nearest\n        best_cost = fallback_nearest.cost + self._dist(fallback_nearest.position, new_pos)\n        max_r = max(1, self.los_neighbor_rings)\n        for r in range(0, max_r + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            for n in cand:\n                if n is fallback_nearest or n is best_parent:\n                    pass\n                # Check LOS\n                if not self._edge_blocked(n.position, new_pos, obstacles, is_3d):\n                    c = n.cost + self._dist(n.position, new_pos)\n                    if c + 1e-9 < best_cost:\n                        best_cost = c\n                        best_parent = n\n        return best_parent\n\n    # Path\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -33.74569,
          "time_improvement": 58.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1051.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010497808456420898,
                    "num_nodes_avg": 34.0,
                    "path_length_avg": 154.57051194099205,
                    "smoothness_avg": 0.03958955729868922,
                    "success_improvement": 0.0,
                    "time_improvement": 58.830179046785545,
                    "node_improvement": 91.4379249559305,
                    "length_improvement": 15.277453078640955,
                    "smoothness_improvement": 519.6625418241595,
                    "objective_score": 29.41383827034103
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.049208974838256835,
                    "num_nodes_avg": 116.0,
                    "path_length_avg": 236.11546529476226,
                    "smoothness_avg": 0.06943512420354042,
                    "success_improvement": 0.0,
                    "time_improvement": 69.28227518814471,
                    "node_improvement": 92.20587247194786,
                    "length_improvement": 21.177861477765767,
                    "smoothness_improvement": 1686.6157578555544,
                    "objective_score": 41.92447823238064
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026494455337524415,
                    "num_nodes_avg": 117.0,
                    "path_length_avg": 122.03531483713664,
                    "smoothness_avg": 0.08227711903121854,
                    "success_improvement": 0.0,
                    "time_improvement": 45.98660915000911,
                    "node_improvement": 85.12396694214877,
                    "length_improvement": 18.94995458240024,
                    "smoothness_improvement": 946.5588810119002,
                    "objective_score": 29.898749899502377
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "QUICKSILVER-IBiRRT#: Quick Informed Bidirectional RRT with Low-Dispersion Sampling, Sparse Best-Parent, and Direct-Connect. It accelerates planning with Halton-guided samples and ring-hash nearest queries, reduces detours via best-parent plus short ancestor compression and light rewiring, and minimizes post-processing by immediate visibility collapse and targeted shortcuts. A strict direct-connect (no opposite-tree growth) avoids node bloat, while adaptive neighbor radii and step sizes cut search time.",
          "planning_mechanism": "Alternate expanding two trees. Each iteration: draw a bounded Halton/uniform/corridor sample (switch to an informed ellipse after any solution). From the nearest node, steer one step; pick a best parent from local neighbors (with edge checks), then attempt short ancestor compression if visible. Insert the node (only if node- and edge-safe) and lightly rewire cheaper neighbors. Try a direct connect to the opposite tree\u2019s nearest; on success, extract the path, apply visibility collapse, shortcutting, and corner rounding, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=7.5,\n                 goal_bias=0.18,\n                 corridor_bias=0.30,\n                 ellipse_bias=0.52,\n                 grid_cell_factor=1.6,\n                 k_parent=8,\n                 k_rewire=6,\n                 min_sep_ratio=0.18,\n                 smoothing_attempts=140,\n                 improve_iters=0):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.ellipse_bias = float(ellipse_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.k_parent = int(max(1, k_parent))\n        self.k_rewire = int(max(0, k_rewire))\n        self.min_sep_ratio = float(min_sep_ratio)\n        self.smoothing_attempts = int(max(0, smoothing_attempts))\n        self.improve_iters = int(max(0, improve_iters))\n        self._rng = 123456789\n        self._halton_idx = 1\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self._is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if hasattr(map, 'obstacles') and map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        # Bounds and feasibility checks\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Trivial straight line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._refine_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize spatial and dynamic parameters\n        diag = (sum((self.bounds[i]) * (self.bounds[i]) for i in range(self.dim))) ** 0.5\n        self.step = max(1.0, min(self.step, 0.08 * diag))\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.min_sep = max(0.2, self.step * self.min_sep_ratio)\n        self.connect_step = max(self.step, 1.8 * self.step)\n        self.dup_thresh = max(0.35, 0.7 * self.step)\n\n        # Trees\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        Ta = [a_root]\n        Tb = [b_root]\n        nodes.extend([a_root, b_root])\n\n        G_a = {}\n        G_b = {}\n        self._grid_add(G_a, a_root)\n        self._grid_add(G_b, b_root)\n\n        best_len = None\n        incumbent_path = None\n\n        for it in range(self.max_iter):\n            # Alternate active tree\n            if (it & 1) == 0:\n                A, B = Ta, Tb\n                GA, GB = G_a, G_b\n                target_root = self.goal\n            else:\n                A, B = Tb, Ta\n                GA, GB = G_b, G_a\n                target_root = self.start\n\n            # Adaptive neighbor radius (shrinks with growth)\n            Ra = self._adaptive_radius(len(A) + len(B))\n            # Guided sample (Halton/uniform/corridor/informed)\n            sp = self._guided_sample(target_root, best_len)\n            if sp is None:\n                continue\n\n            # Nearest in active tree\n            near = self._nearest(GA, sp)\n            if near is None:\n                continue\n\n            newp = self._steer(near.position, sp, self.step)\n            if (not self._in_bounds(newp)) or self._point_blocked(newp):\n                continue\n            if self._too_close(GA, newp, self.min_sep):\n                continue\n\n            # Best parent among neighbors including anchor\n            neigh = self._neighbors(GA, newp, Ra)\n            if not neigh:\n                neigh = [near]\n            cand_parents = self._select_k_by_dist(neigh, newp, self.k_parent)\n            parent = None\n            gbest = 1e100\n            for nb in cand_parents:\n                if not self._edge_free(nb.position, newp):\n                    continue\n                gc = nb.cost + self._dist(nb.position, newp)\n                if gc < gbest:\n                    gbest = gc\n                    parent = nb\n            if parent is None:\n                continue\n\n            # Short ancestor compression (deepen if beneficial)\n            anc = parent\n            hops = 0\n            while anc.parent is not None and hops < 6:\n                up = anc.parent\n                if self._edge_free(up.position, newp):\n                    gc = up.cost + self._dist(up.position, newp)\n                    if gc + 1e-12 < gbest:\n                        gbest = gc\n                        parent = up\n                anc = up\n                hops += 1\n\n            # Final checks before insertion (both checks)\n            if self._point_blocked(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, gbest)\n            parent.add_child(nn)\n            A.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(GA, nn)\n\n            # Light local rewiring to reduce path length\n            if self.k_rewire > 0:\n                self._rewire_local(nn, GA, edges, radius=Ra)\n\n            # Direct connect attempt to the other tree (no bloat)\n            other = self._nearest(GB, nn.position)\n            if other is not None and self._edge_free(nn.position, other.position):\n                path = self._merge_path(nn, other)\n                raw_len = self._path_len(path)\n                if best_len is None or raw_len < best_len:\n                    best_len = raw_len\n                    incumbent_path = path\n                path = self._refine_path(path)\n                return PlannerResult(True, path, Ta + Tb, edges)\n\n        # If loop ends without direct connect, optionally refine any incumbent\n        if incumbent_path is not None:\n            path = self._refine_path(incumbent_path)\n            return PlannerResult(True, path, Ta + Tb, edges)\n\n        return PlannerResult(False, [], Ta + Tb, edges)\n\n    # ---------- RNG and low-disersion sampling ----------\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            iv = int((v + 0.12345) * 2654435761) & 0xffffffff\n            s ^= (iv + 0x9E3779B97F4A7C15) & 0xffffffff\n            s = ((s << 13) ^ (s >> 17) ^ (s << 7)) & 0xffffffff\n        s ^= (len(self.obstacles) * 1103515245) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n        self._halton_idx = 1\n\n    def _randu(self):\n        x = self._rng\n        x ^= (x << 13) & 0xffffffff\n        x ^= (x >> 17) & 0xffffffff\n        x ^= (x << 5) & 0xffffffff\n        self._rng = x & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rad_inv(self, n, base):\n        inv = 0.0\n        f = 1.0 / base\n        while n > 0:\n            inv += f * (n % base)\n            n //= base\n            f /= base\n        return inv\n\n    def _halton(self, idx):\n        if self._is3:\n            return (self._rad_inv(idx, 2), self._rad_inv(idx, 3), self._rad_inv(idx, 5))\n        else:\n            return (self._rad_inv(idx, 2), self._rad_inv(idx, 3))\n\n    # ---------- Geometry ----------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # ---------- Spatial hashing ----------\n    def _cell_key(self, p):\n        if self._is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _neighbors(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        span = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self._is3:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        # Expand rings up to 3; then fallback scan\n        for r in range(0, 4):\n            cand = []\n            if self._is3:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                            if lst:\n                                cand += lst\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy))\n                        if lst:\n                            cand += lst\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback full scan\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _select_k_by_dist(self, nodes, pos, k):\n        if not nodes:\n            return []\n        # Partial selection without heavy sorts\n        buf = []\n        for nd in nodes:\n            buf.append((self._dist2(nd.position, pos), nd))\n        # Simple selection of k smallest\n        k = min(k, len(buf))\n        # Manual partial ordering\n        for i in range(k):\n            mi = i\n            mv = buf[i][0]\n            for j in range(i + 1, len(buf)):\n                if buf[j][0] < mv:\n                    mi = j\n                    mv = buf[j][0]\n            if mi != i:\n                buf[i], buf[mi] = buf[mi], buf[i]\n        return [buf[i][1] for i in range(k)]\n\n    def _too_close(self, grid, pos, radius):\n        neigh = self._neighbors(grid, pos, radius)\n        return len(neigh) > 0\n\n    # ---------- Obstacles & collision ----------\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self._is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            self._obin_add((i, j, k), idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        self._obin_add((i, j), idx)\n\n    def _obin_add(self, key, idx):\n        lst = self.obin.get(key)\n        if lst is None:\n            self.obin[key] = [idx]\n        else:\n            lst.append(idx)\n\n    def _bucket_candidates(self, a, b):\n        if self._is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self.obin.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            return cand\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self.obin.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            return cand\n\n    def _point_blocked(self, p):\n        if self._is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            lst = self.obin.get((ix, iy, iz))\n            if not lst:\n                return False\n            x, y, z = p\n            for idx in lst:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            lst = self.obin.get((ix, iy))\n            if not lst:\n                return False\n            x, y = p\n            for idx in lst:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        cand = self._bucket_candidates(a, b)\n        if not cand:\n            return True\n        if self._is3:\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            q = p1[i]\n            d = q - p\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # ---------- Rewiring ----------\n    def _rewire_local(self, new_node, grid, edges, radius):\n        neigh = self._neighbors(grid, new_node.position, radius)\n        if not neigh:\n            return\n        cands = self._select_k_by_dist(neigh, new_node.position, self.k_rewire)\n        for nb in cands:\n            if nb is new_node or nb is new_node.parent:\n                continue\n            # Prevent cycles\n            cur = new_node\n            cyc = False\n            while cur is not None:\n                if cur is nb:\n                    cyc = True\n                    break\n                cur = cur.parent\n            if cyc:\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            cand_cost = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand_cost + 1e-9 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, oldp, nb)\n                new_node.add_child(nb)\n                edges.append((new_node, nb))\n                delta = cand_cost - nb.cost\n                nb.cost = cand_cost\n                self._propagate_cost_limited(nb, delta, cap=256)\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                del edges[i]\n                break\n\n    def _propagate_cost_limited(self, node, delta, cap=256):\n        stack = [node]\n        visited = 0\n        while stack and visited < cap:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n                visited += 1\n                if visited >= cap:\n                    break\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, target_root, incumbent_len):\n        # Halton base sample mixed with biases\n        tries = 10\n        while tries > 0:\n            tries -= 1\n            r = self._randu()\n            if incumbent_len is not None and r < self.ellipse_bias:\n                p = self._sample_in_ellipse(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                r2 = self._randu()\n                if r2 < self.goal_bias:\n                    p = target_root\n                elif r2 < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_point()\n                else:\n                    h = self._halton(self._halton_idx)\n                    self._halton_idx += 1\n                    if self._is3:\n                        p = (h[0] * self.bounds[0], h[1] * self.bounds[1], h[2] * self.bounds[2])\n                    else:\n                        p = (h[0] * self.bounds[0], h[1] * self.bounds[1])\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            return p\n        return None\n\n    def _corridor_point(self):\n        t = self._randu()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step, 0.06 * sg)\n        if self._is3:\n            ox = (self._randu() * 2.0 - 1.0) * w\n            oy = (self._randu() * 2.0 - 1.0) * w\n            oz = (self._randu() * 2.0 - 1.0) * w\n            p = (base[0] + ox, base[1] + oy, base[2] + oz)\n        else:\n            ox = (self._randu() * 2.0 - 1.0) * w\n            oy = (self._randu() * 2.0 - 1.0) * w\n            p = (base[0] + ox, base[1] + oy)\n        return self._clamp(p)\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        center = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(16):\n            if self._is3:\n                p = (center[0] + self._randu() * 2 * ext[0] - ext[0],\n                     center[1] + self._randu() * 2 * ext[1] - ext[1],\n                     center[2] + self._randu() * 2 * ext[2] - ext[2])\n            else:\n                p = (center[0] + self._randu() * 2 * ext[0] - ext[0],\n                     center[1] + self._randu() * 2 * ext[1] - ext[1])\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            if self._dist(p, f1) + self._dist(p, f2) <= max_sum + 1e-9:\n                return p\n        return None\n\n    def _adaptive_radius(self, n):\n        # Shrink with growth; keep above 1.2*step\n        base = 3.5 * self.step\n        shrink = 0.5 + 0.5 / ((1.0 + n) ** 0.5)\n        return max(1.2 * self.step, base * shrink)\n\n    # ---------- Paths ----------\n    def _trace(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _merge_path(self, meet_a, meet_b):\n        pa = self._trace(meet_a)\n        pb = []\n        cur = meet_b\n        while cur is not None:\n            pb.append(cur.position)\n            cur = cur.parent\n        return pa + pb\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # ---------- Refinement ----------\n    def _prune_collinear(self, pts, cos_eps=0.997):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        for i in range(1, len(pts) - 1):\n            a = out[-1]\n            b = pts[i]\n            c = pts[i + 1]\n            v1 = tuple(b[j] - a[j] for j in range(self.dim))\n            v2 = tuple(c[j] - b[j] for j in range(self.dim))\n            n1 = (sum(v1[j] * v1[j] for j in range(self.dim))) ** 0.5\n            n2 = (sum(v2[j] * v2[j] for j in range(self.dim))) ** 0.5\n            if n1 < 1e-9 or n2 < 1e-9:\n                continue\n            cosang = sum(v1[j] * v2[j] for j in range(self.dim)) / (n1 * n2)\n            if cosang < cos_eps:\n                out.append(b)\n        out.append(pts[-1])\n        return out\n\n    def _vis_collapse(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = pts[:]\n        i = 0\n        while i < len(out) - 2:\n            j = len(out) - 1\n            collapsed = False\n            while j > i + 1:\n                if self._edge_free(out[i], out[j]):\n                    del out[i + 1:j]\n                    collapsed = True\n                    break\n                j -= 1\n            if not collapsed:\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        stall = 0\n        n = len(cur)\n        while tries < attempts and len(cur) > 2:\n            # Bias towards wide-span pairs\n            i = int(self._randu() * max(1, len(cur) - 2))\n            j = i + 2 + int(self._randu() * max(1, len(cur) - i - 2))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-9 <= bestL:\n                    cur = cand\n                    bestL = L\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            tries += 1\n            if stall > 28:\n                break\n        return cur\n\n    def _round_corners(self, pts, passes=2):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            k = 1\n            while k < len(cur) - 1:\n                a = cur[k - 1]\n                c = cur[k + 1]\n                mid = tuple(0.5 * (a[i] + c[i]) for i in range(self.dim))\n                if self._in_bounds(mid) and (not self._point_blocked(mid)):\n                    if self._edge_free(a, mid) and self._edge_free(mid, c):\n                        cur[k] = mid\n                k += 1\n        return cur\n\n    def _refine_path(self, path):\n        if not path or len(path) < 2:\n            return path[:]\n        p0 = self._prune_collinear(path)\n        p1 = self._vis_collapse(p0)\n        p2 = self._shortcut(p1, self.smoothing_attempts)\n        p3 = self._round_corners(p2, passes=2)\n        return p3",
          "objective": -33.56039,
          "time_improvement": 59.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1214.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018087029457092285,
                    "num_nodes_avg": 76.0,
                    "path_length_avg": 164.1642926287751,
                    "smoothness_avg": 0.037059814088076425,
                    "success_improvement": 0.0,
                    "time_improvement": 26.68795280970323,
                    "node_improvement": 80.86124401913875,
                    "length_improvement": 10.018949860483662,
                    "smoothness_improvement": 480.06656715276216,
                    "objective_score": 16.418088594964978
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02971317768096924,
                    "num_nodes_avg": 127.0,
                    "path_length_avg": 235.99878921874523,
                    "smoothness_avg": 0.08998990022915673,
                    "success_improvement": 0.0,
                    "time_improvement": 82.23444199890521,
                    "node_improvement": 91.46677417187395,
                    "length_improvement": 21.216811310274892,
                    "smoothness_improvement": 2215.5049500014106,
                    "objective_score": 48.47794413584356
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016322517395019533,
                    "num_nodes_avg": 90.0,
                    "path_length_avg": 123.58708796709747,
                    "smoothness_avg": 0.0823046580695243,
                    "success_improvement": 0.0,
                    "time_improvement": 67.6632751528354,
                    "node_improvement": 88.55689764780675,
                    "length_improvement": 17.919340756976133,
                    "smoothness_improvement": 946.9091755464293,
                    "objective_score": 35.78513287776844
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "IBEX-Lite: Informed Beam-Expand Bi-Tree with on-the-fly visibility compression and lazy bounded connect. It grows two sparse trees from start and goal using a small beam of candidate samples per iteration, selects the best steer via a simple cost+heuristic score, enforces strict node/edge collision checks, suppresses near-duplicates with a spatial hash, and line-of-sight compresses to ancestors to keep chains short. Upon a short-range or lazily-bridged connection, it visibility-prunes and performs bounded shortcut smoothing, enabling early termination with a short, smooth path.",
          "planning_mechanism": "Alternate expansion between start and goal trees. Each iteration: beam-sample around an attractor (goal/start) with goal/informed bias; pick a nearest-based parent and steer once; validate node and edge, insert, and compress to a visible ancestor. Try a direct or short-step lazy connect to the opposite tree. On success, extract, visibility-prune, shortcut, and return. Spatial hashing accelerates nearest checks and duplicate suppression; no rewiring keeps computations light.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=8.0,\n        goal_bias=0.2,\n        informed_bias=0.5,\n        beam_width=4,\n        dupe_radius_ratio=0.5,\n        connect_radius_factor=4.0,\n        connect_steps=4,\n        smoothing_iters=60,\n        no_improve_stop=15,\n        cell_factor=1.0\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.beam_width = int(beam_width)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.connect_radius_factor = float(connect_radius_factor)\n        self.connect_steps = int(connect_steps)\n        self.smoothing_iters = int(smoothing_iters)\n        self.no_improve_stop = int(no_improve_stop)\n        self.cell_factor = float(cell_factor)\n        self._rng = 1234567\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_from_scene()\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Parameters\n        self.cell_size = max(1.0, self.step_size * self.cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.connect_radius = max(self.step_size, self.connect_radius_factor * self.step_size)\n\n        # Trees and grids\n        nodes = []\n        edges = []\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        nodes.extend([root_a, root_b])\n        tree_a, tree_b = [root_a], [root_b]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, root_a)\n        self._grid_insert(grid_b, root_b)\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            tree = tree_a if side_a else tree_b\n            other_tree = tree_b if side_a else tree_a\n            grid = grid_a if side_a else grid_b\n            other_grid = grid_b if side_a else grid_a\n            attractor = self.goal if side_a else self.start\n\n            # Beam sampling and candidate selection\n            best_cand = None\n            best_score = 1e100\n            samples = self._beam_samples(attractor, best_len)\n            for s in samples:\n                near = self._nearest_hashed(grid, tree, s, 4)\n                if near is None:\n                    continue\n                new_pos = self._steer(near.position, s)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._point_in_obstacles(new_pos):\n                    continue\n                if self._has_nearby(grid, new_pos, self.dupe_radius):\n                    continue\n                if not self._edge_free(near.position, new_pos):\n                    continue\n                g = near.cost + self._dist(near.position, new_pos)\n                h = self._dist(new_pos, attractor)\n                score = g + h\n                if score < best_score:\n                    best_score = score\n                    best_cand = (near, new_pos)\n\n            if best_cand is None:\n                continue\n\n            parent, new_pos = best_cand\n            # Validate node and edge before adding\n            if self._point_in_obstacles(new_pos):\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, parent, parent.cost + self._dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(grid, new_node)\n\n            # On-the-fly visibility compression to up to 3 visible ancestors\n            self._compress_to_ancestors(new_node, edges, 3)\n\n            # Try to connect to the other tree\n            other_near = self._nearest_hashed(other_grid, other_tree, new_node.position, 4)\n            if other_near is not None:\n                if self._dist(other_near.position, new_node.position) <= self.connect_radius and self._edge_free(other_near.position, new_node.position):\n                    path = self._extract_path(new_node, other_near, side_a)\n                    final = self._finalize_path(path)\n                    return PlannerResult(True, final, nodes, edges)\n                ok, joined = self._lazy_connect(new_node, other_tree, other_grid, nodes, edges)\n                if ok:\n                    path = self._extract_path(new_node, joined, side_a)\n                    final = self._finalize_path(path)\n                    return PlannerResult(True, final, nodes, edges)\n\n        if best_path:\n            final = self._finalize_path(best_path)\n            return PlannerResult(True, final, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG utilities\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1103515245 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 1) * 2654435761\n        if s == 0:\n            s = 1234567\n        self._rng = s & 0x7fffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0x7fffffff\n        return self._rng / float(1 << 31)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry and bounds\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= self.step_size:\n            return tuple(b)\n        r = self.step_size / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n\n    # Obstacles and collisions\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            px, py, pz = p\n            for o in self.obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            px, py = p\n            for o in self.obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            for o in self.obstacles:\n                x, y, z, w, h, d = o\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            for o in self.obstacles:\n                x, y, w, h = o\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Spatial hashing\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, tree, pos, max_rings):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        found = False\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n                    found = True\n            if found:\n                return best\n        # fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    # Sampling\n    def _beam_samples(self, attractor, best_len):\n        out = []\n        for _ in range(self.beam_width * 2):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p and self._in_bounds(p) and not self._point_in_obstacles(p):\n                    out.append(p)\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._in_bounds(p) and not self._point_in_obstacles(p):\n                    out.append(p)\n            if len(out) >= self.beam_width:\n                break\n        if not out:\n            # fallback uniform\n            p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n            if self._in_bounds(p) and not self._point_in_obstacles(p):\n                out.append(p)\n        return out\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [half] * self.dim\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dim))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # Compression\n    def _compress_to_ancestors(self, node, edges, depth_limit):\n        depth = 0\n        cur = node\n        while depth < depth_limit and cur.parent is not None and cur.parent.parent is not None:\n            gp = cur.parent.parent\n            if self._edge_free(gp.position, cur.position):\n                self._reparent(cur, gp, edges)\n            else:\n                break\n            depth += 1\n\n    def _reparent(self, child, new_parent, edges):\n        old_parent = child.parent\n        if old_parent is new_parent:\n            return\n        if old_parent is not None:\n            old_parent.remove_child(child)\n            self._edges_remove(edges, old_parent, child)\n        new_parent.add_child(child)\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        edges.append((new_parent, child))\n        self._propagate_costs(child)\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                old = ch.cost\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                if abs(ch.cost - old) > 1e-12:\n                    stack.append(ch)\n\n    # Lazy connect\n    def _lazy_connect(self, new_node, other_tree, other_grid, nodes, edges):\n        near = self._nearest_hashed(other_grid, other_tree, new_node.position, 4)\n        if near is None:\n            return False, None\n        if self._edge_free(near.position, new_node.position):\n            return True, near\n        p = near\n        steps = 0\n        while steps < self.connect_steps:\n            step_pos = self._steer(p.position, new_node.position)\n            if not self._in_bounds(step_pos):\n                break\n            if self._point_in_obstacles(step_pos):\n                break\n            if not self._edge_free(p.position, step_pos):\n                break\n            if self._has_nearby(other_grid, step_pos, self.dupe_radius):\n                break\n            q = Node(step_pos, p, p.cost + self._dist(p.position, step_pos))\n            p.add_child(q)\n            other_tree.append(q)\n            nodes.append(q)\n            edges.append((p, q))\n            self._grid_insert(other_grid, q)\n            if self._edge_free(q.position, new_node.position):\n                return True, q\n            p = q\n            steps += 1\n        return False, None\n\n    # Paths\n    def _path_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        return out[::-1]\n\n    def _extract_path(self, a_node, b_node, a_forward=True):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return (pa + pb[::-1]) if a_forward else (pb + pa[::-1])\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # Finalization: prune + shortcut\n    def _finalize_path(self, path):\n        if not path:\n            return []\n        pruned = self._visibility_prune(path)\n        sm = self._shortcut(pruned)\n        return sm\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        pts = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(pts[-1], path[j]):\n                    pts.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pts.append(path[i + 1])\n                i += 1\n        return pts\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best_len = self._path_len(pts)\n        attempts = 0\n        no_imp = 0\n        while attempts < self.smoothing_iters:\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                attempts += 1\n                continue\n            a, b = pts[i], pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= best_len + 1e-12:\n                    pts = new_pts\n                    best_len = L\n                    no_imp = 0\n                else:\n                    no_imp += 1\n            else:\n                no_imp += 1\n            attempts += 1\n            if no_imp >= self.no_improve_stop:\n                break\n        return pts",
          "objective": -33.37732,
          "time_improvement": 62.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1447.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020781850814819335,
                    "num_nodes_avg": 68.0,
                    "path_length_avg": 170.9976979112377,
                    "smoothness_avg": 0.05181632978932453,
                    "success_improvement": 0.0,
                    "time_improvement": 15.765049686457818,
                    "node_improvement": 82.87584991186098,
                    "length_improvement": 6.2734521429299,
                    "smoothness_improvement": 711.0380821640268,
                    "objective_score": 12.04877660251542
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02635343074798584,
                    "num_nodes_avg": 100.0,
                    "path_length_avg": 249.8743230654094,
                    "smoothness_avg": 0.09393033531173191,
                    "success_improvement": 0.0,
                    "time_improvement": 84.24324023811695,
                    "node_improvement": 93.28092454478264,
                    "length_improvement": 16.58475872716112,
                    "smoothness_improvement": 2316.8951828567397,
                    "objective_score": 46.808303222015454
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.007054257392883301,
                    "num_nodes_avg": 52.0,
                    "path_length_avg": 128.22672229799147,
                    "smoothness_avg": 0.11108113551878454,
                    "success_improvement": 0.0,
                    "time_improvement": 86.02473045093231,
                    "node_improvement": 93.38842975206612,
                    "length_improvement": 14.837916550041735,
                    "smoothness_improvement": 1312.943844642401,
                    "objective_score": 41.274888288516735
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "Bi-Hash RRT*-Gate: a bidirectional, hash-accelerated RRT* with cost-gated cells, angle-aware parentging, bounded rewiring, and best-of-many short bridging. It balances exploration and smoothness using per-cell admission with dynamic best-cost updates, ring-limited neighbor scans computed from true radii, cached edge checks, and informed sampling after first solution. Post-bridge, it performs visibility pruning and non-length-increasing shortcuts for compact, smooth paths.",
          "planning_mechanism": "Alternate expanding start/goal trees. Each step: sample (goal-biased; then informed ellipse after first path), find hashed-nearest, steer, validate node and edge, then select the lowest (cost + lambda\u00b7turn) parent among line-of-sight neighbors within a bounded radius, admit via a per-cell cost gate, insert, and perform bounded rewiring with ancestor guard and incremental cost propagation. Attempt a best-of-many short bridge to the other tree; on success, extract the bi-tree path, prune by visibility, shortcut without increasing length, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=6.0,\n        goal_bias=0.22,\n        cell_factor=1.2,\n        max_per_cell=6,\n        parent_radius_factor=2.6,\n        rewire_radius_factor=1.8,\n        connect_radius_factor=3.2,\n        ring_cap=4,\n        smoothing_iters=100\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.cell_factor = float(cell_factor)\n        self.max_per_cell = int(max_per_cell)\n        self.parent_radius_factor = float(parent_radius_factor)\n        self.rewire_radius_factor = float(rewire_radius_factor)\n        self.connect_radius_factor = float(connect_radius_factor)\n        self.ring_cap = int(ring_cap)\n        self.smoothing_iters = int(smoothing_iters)\n\n        self._rng = 123456789\n        self.edge_res = 0.8\n        self._edge_cache = {}\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        # Validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._in_obs(self.start) or self._in_obs(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        self._edge_cache = {}\n        self._seed_from_scene()\n\n        # Early straight line\n        if not self._edge_blocked(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Parameters derived\n        self.cell_size = max(1.0, self.step_size * self.cell_factor)\n        parent_radius = max(self.step_size * self.parent_radius_factor, self.step_size + 1e-9)\n        rewire_radius = max(self.step_size * self.rewire_radius_factor, self.step_size + 1e-9)\n        connect_radius = max(self.step_size, self.connect_radius_factor * self.step_size)\n        self.edge_res = max(0.4, min(1.0, self.step_size * 0.5))\n        dupe_radius = max(0.4, 0.55 * self.step_size)\n\n        # Trees, grids, and per-cell gates\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes = [start_root, goal_root]\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n\n        grid_start, grid_goal = {}, {}\n        counts_start, counts_goal = {}, {}\n        bestcost_start, bestcost_goal = {}, {}\n\n        self._grid_add(grid_start, counts_start, bestcost_start, start_root)\n        self._grid_add(grid_goal, counts_goal, bestcost_goal, goal_root)\n\n        # Informed sampling bookkeeping\n        have_solution = False\n        best_path = []\n        best_len = float('inf')\n        c_min = self._dist(self.start, self.goal)\n\n        for it in range(self.max_iter):\n            a_is_start = (it % 2 == 0)\n            tree_a = start_tree if a_is_start else goal_tree\n            tree_b = goal_tree if a_is_start else start_tree\n            grid_a = grid_start if a_is_start else grid_goal\n            grid_b = grid_goal if a_is_start else grid_start\n            counts_a = counts_start if a_is_start else counts_goal\n            bestcost_a = bestcost_start if a_is_start else bestcost_goal\n            bestcost_b = bestcost_goal if a_is_start else bestcost_start\n            attractor = self.goal if a_is_start else self.start\n\n            # Sample\n            x_rand = self._sample(attractor, have_solution, best_len, c_min)\n            if x_rand is None:\n                continue\n\n            # Nearest and steer\n            nearest = self._nearest_hashed(grid_a, tree_a, x_rand)\n            if nearest is None:\n                continue\n            new_pos = self._steer(nearest.position, x_rand)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._in_obs(new_pos):\n                continue\n            if self._edge_blocked(nearest.position, new_pos):\n                continue\n            if self._has_nearby(grid_a, new_pos, dupe_radius):\n                continue\n\n            # Choose parent among local LOS neighbors with turn smoothing bias\n            parent = self._choose_parent(new_pos, nearest, grid_a, tree_a, parent_radius)\n            # Ensure edge is valid\n            if self._edge_blocked(parent.position, new_pos):\n                continue\n\n            # Per-cell admission: allow if space remains or if it improves local best cost\n            key_new = self._cell_of(new_pos)\n            new_cost = parent.cost + self._dist(parent.position, new_pos)\n            ccount = counts_a.get(key_new, 0)\n            bestc = bestcost_a.get(key_new, float('inf'))\n            if ccount >= self.max_per_cell and not (new_cost + 1e-9 < bestc * 0.98):\n                continue\n\n            # Insert node (node collision and parent edge collision already checked)\n            a_new = Node(new_pos, parent, new_cost)\n            parent.add_child(a_new)\n            tree_a.append(a_new)\n            nodes.append(a_new)\n            self._grid_add(grid_a, counts_a, bestcost_a, a_new)\n\n            # Local rewiring (bounded, ancestor guard)\n            self._rewire_local(a_new, grid_a, rewire_radius, bestcost_a)\n\n            # Try a best-of-many short bridge to the opposite tree\n            cand_b = self._neighbors_within(grid_b, a_new.position, connect_radius)\n            best_bridge = None\n            best_total = float('inf')\n            for bnode in cand_b:\n                if bnode is None:\n                    continue\n                if self._edge_blocked(bnode.position, a_new.position):\n                    continue\n                total = a_new.cost + self._dist(a_new.position, bnode.position) + bnode.cost\n                if total < best_total:\n                    best_total = total\n                    best_bridge = bnode\n            if best_bridge is not None:\n                path = self._extract_path_with_bridge(a_new, best_bridge, a_is_start)\n                path = self._visibility_prune(path)\n                path = self._shortcut_smooth(path, self.smoothing_iters)\n                plen = self._path_length(path)\n                if plen + 1e-9 < best_len:\n                    best_len = plen\n                    have_solution = True\n                    best_path = path\n                    # Early return on first valid bridge to reduce time\n                    edges = self._collect_edges(nodes)\n                    return PlannerResult(True, best_path, nodes, edges)\n\n        # Finalize\n        if have_solution:\n            edges = self._collect_edges(nodes)\n            return PlannerResult(True, best_path, nodes, edges)\n        edges = self._collect_edges(nodes)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1103515245 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 33) * 2654435761\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _sub(self, a, b):\n        return tuple(a[i] - b[i] for i in range(self.dim))\n\n    def _dot(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            s += a[i] * b[i]\n        return s\n\n    def _norm(self, v):\n        return self._dist((0.0,) * self.dim, v)\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= self.step_size:\n            return tuple(b)\n        r = self.step_size / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n\n    # Obstacles and edges\n    def _in_obs(self, p):\n        if self.is_3d:\n            px, py, pz = p\n            for o in self.obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            px, py = p\n            for o in self.obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked(self, a, b):\n        k = self._edge_key(a, b)\n        val = self._edge_cache.get(k)\n        if val is not None:\n            return val\n        blocked = self._segment_hits(a, b)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _segment_hits(self, a, b):\n        d = self._dist(a, b)\n        steps = max(1, int(d / max(1e-9, self.edge_res)))\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._in_obs(p):\n                return True\n        return False\n\n    # Spatial hashing\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_add(self, grid, counts, bestcost, node):\n        k = self._cell_of(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n        counts[k] = counts.get(k, 0) + 1\n        bc = bestcost.get(k)\n        if bc is None or node.cost < bc:\n            bestcost[k] = node.cost\n\n    def _neighbors_within(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        out = []\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            for n in b:\n                                if self._dist(n.position, pos) <= radius:\n                                    out.append(n)\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        for n in b:\n                            if self._dist(n.position, pos) <= radius:\n                                out.append(n)\n        return out\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._cell_of(pos)\n        best = None\n        bestd2 = float('inf')\n        found_any = False\n        for r in range(0, self.ring_cap + 1):\n            # Collect ring up to r\n            cand = []\n            if self.is_3d:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                            if b:\n                                cand.extend(b)\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy))\n                        if b:\n                            cand.extend(b)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n                    found_any = True\n            if found_any:\n                return best\n        # Fallback random subset if very sparse\n        if not tree:\n            return None\n        tries = min(64, len(tree))\n        for i in range(tries):\n            n = tree[int(self._rand_range(0, len(tree)))]\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd2:\n                bestd2 = d2\n                best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    # Parent selection with turn penalty\n    def _choose_parent(self, new_pos, fallback_nearest, grid, tree, radius_bound):\n        best_parent = fallback_nearest\n        best_score = fallback_nearest.cost + self._dist(fallback_nearest.position, new_pos)\n        # Simple angle penalty encourages smoothness\n        lam = 0.15\n        prev_dir = None\n        if fallback_nearest.parent is not None:\n            prev_dir = self._sub(fallback_nearest.position, fallback_nearest.parent.position)\n        if prev_dir is not None:\n            cur_dir = self._sub(new_pos, fallback_nearest.position)\n            dp = self._dot(prev_dir, cur_dir)\n            np = max(1e-12, self._norm(prev_dir) * self._norm(cur_dir))\n            turn_pen = 1.0 - max(-1.0, min(1.0, dp / np))\n            best_score += lam * turn_pen\n\n        cand = self._neighbors_within(grid, new_pos, radius_bound)\n        for n in cand:\n            if n is fallback_nearest:\n                continue\n            if self._edge_blocked(n.position, new_pos):\n                continue\n            c = n.cost + self._dist(n.position, new_pos)\n            # angle penalty\n            pd = None\n            if n.parent is not None:\n                pd = self._sub(n.position, n.parent.position)\n            if pd is not None:\n                cd = self._sub(new_pos, n.position)\n                dp = self._dot(pd, cd)\n                np = max(1e-12, self._norm(pd) * self._norm(cd))\n                turn_pen = 1.0 - max(-1.0, min(1.0, dp / np))\n                c += lam * turn_pen\n            if c + 1e-12 < best_score:\n                best_score = c\n                best_parent = n\n        return best_parent\n\n    # Rewiring\n    def _rewire_local(self, pivot, grid, radius, bestcost_map):\n        cand = self._neighbors_within(grid, pivot.position, radius)\n        for nb in cand:\n            if nb is pivot or nb.parent is pivot:\n                continue\n            # Ancestor guard\n            if self._is_ancestor(nb, pivot):\n                continue\n            # Check edge\n            if self._edge_blocked(pivot.position, nb.position):\n                continue\n            new_cost = pivot.cost + self._dist(pivot.position, nb.position)\n            if new_cost + 1e-12 < nb.cost:\n                # Reconnect nb under pivot\n                old_parent = nb.parent\n                if old_parent is not None:\n                    try:\n                        old_parent.children.remove(nb)\n                    except:\n                        pass\n                pivot.add_child(nb)\n                nb.cost = new_cost\n                # Propagate decreased costs locally\n                self._propagate_cost_decrease(nb, bestcost_map)\n\n    def _is_ancestor(self, node, potential_child):\n        cur = potential_child\n        while cur is not None:\n            if cur is node:\n                return True\n            cur = cur.parent\n        return False\n\n    def _propagate_cost_decrease(self, node, bestcost_map):\n        queue = [node]\n        qi = 0\n        while qi < len(queue):\n            cur = queue[qi]\n            qi += 1\n            # Update per-cell best cost\n            cell = self._cell_of(cur.position)\n            bc = bestcost_map.get(cell)\n            if bc is None or cur.cost < bc:\n                bestcost_map[cell] = cur.cost\n            # Update children costs\n            for ch in cur.children:\n                new_c = cur.cost + self._dist(cur.position, ch.position)\n                if new_c + 1e-12 < ch.cost:\n                    ch.cost = new_c\n                    queue.append(ch)\n\n    # Sampling\n    def _sample(self, attractor, informed, best_len, c_min):\n        r = self._rand()\n        if informed and best_len < float('inf') and r < 0.6:\n            p = self._informed_sample(self.start, self.goal, best_len * 1.01, c_min)\n            if p is not None and self._in_bounds(p) and not self._in_obs(p):\n                return p\n        if r < self.goal_bias:\n            p = attractor\n        else:\n            p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n        if self._in_bounds(p) and not self._in_obs(p):\n            return p\n        return None\n\n    def _informed_sample(self, f1, f2, c_best, c_min):\n        if not (c_best > c_min + 1e-9):\n            return None\n        center = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        a_vec = self._sub(f2, f1)\n        a_norm = self._norm(a_vec)\n        if a_norm <= 1e-12:\n            return None\n        a_hat = tuple(a_vec[i] / a_norm for i in range(self.dim))\n        r1 = 0.5 * c_best\n        r2 = 0.5 * ((c_best * c_best - c_min * c_min) ** 0.5) if c_best > c_min else 0.0\n        for _ in range(32):\n            if self.is_3d:\n                # build orthonormal basis [a_hat, v, w]\n                u = (1.0, 0.0, 0.0) if abs(a_hat[0]) < 0.9 else (0.0, 1.0, 0.0)\n                v = self._orth(self._cross(a_hat, u))\n                w = self._cross(a_hat, v)\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                z = self._rand_range(-1.0, 1.0)\n                if x * x + y * y + z * z > 1.0:\n                    continue\n                px = r1 * x\n                py = r2 * y\n                pz = r2 * z\n                ex = center[0] + px * a_hat[0] + py * v[0] + pz * w[0]\n                ey = center[1] + px * a_hat[1] + py * v[1] + pz * w[1]\n                ez = center[2] + px * a_hat[2] + py * v[2] + pz * w[2]\n                p = (ex, ey, ez)\n            else:\n                perp = (-a_hat[1], a_hat[0])\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                if x * x + y * y > 1.0:\n                    continue\n                px = r1 * x\n                py = r2 * y\n                ex = center[0] + px * a_hat[0] + py * perp[0]\n                ey = center[1] + px * a_hat[1] + py * perp[1]\n                p = (ex, ey)\n            if self._in_bounds(p) and not self._in_obs(p):\n                return p\n        return None\n\n    def _cross(self, a, b):\n        return (a[1] * b[2] - a[2] * b[1],\n                a[2] * b[0] - a[0] * b[2],\n                a[0] * b[1] - a[1] * b[0])\n\n    def _orth(self, v):\n        n = self._norm(v)\n        if n <= 1e-12:\n            return (1.0, 0.0, 0.0) if self.dim == 3 else (1.0, 0.0)\n        return tuple(v[i] / n for i in range(len(v)))\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path_with_bridge(self, a_node, b_node, a_is_start_tree):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if a_is_start_tree:\n            return pa + list(reversed(pb))\n        else:\n            return pb + list(reversed(pa))\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(pruned[-1], path[j]):\n                    # Only accept if not longer than original subpath\n                    seg = self._dist(pruned[-1], path[j])\n                    mid = 0.0\n                    for t in range(i + 1, j + 1):\n                        mid += self._dist(path[t - 1], path[t])\n                    if seg + 1e-9 <= mid:\n                        pruned.append(path[j])\n                        i = j\n                        advanced = True\n                        break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _shortcut_smooth(self, path, iters):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        best_L = self._path_length(pts)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_length(new_pts)\n                if L <= best_L + 1e-12:\n                    pts = new_pts\n                    best_L = L\n        return pts\n\n    def _collect_edges(self, nodes):\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        return edges",
          "objective": -33.07941,
          "time_improvement": 56.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1266.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01999363899230957,
                    "num_nodes_avg": 65.0,
                    "path_length_avg": 168.19610907842977,
                    "smoothness_avg": 0.05993023295813018,
                    "success_improvement": 0.0,
                    "time_improvement": 18.95990390311455,
                    "node_improvement": 83.63132712163183,
                    "length_improvement": 7.809047376207891,
                    "smoothness_improvement": 838.0382863785782,
                    "objective_score": 14.56359102855199
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03245158195495605,
                    "num_nodes_avg": 126.0,
                    "path_length_avg": 231.15171948335015,
                    "smoothness_avg": 0.06895159120076712,
                    "success_improvement": 0.0,
                    "time_improvement": 80.59714556153635,
                    "node_improvement": 91.53396492642612,
                    "length_improvement": 22.834902703116473,
                    "smoothness_improvement": 1674.174105419453,
                    "objective_score": 46.25095581742806
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01587519645690918,
                    "num_nodes_avg": 87.0,
                    "path_length_avg": 121.87513711670701,
                    "smoothness_avg": 0.10888485954924418,
                    "success_improvement": 0.0,
                    "time_improvement": 68.54946775070414,
                    "node_improvement": 88.93833439287985,
                    "length_improvement": 19.0563369974662,
                    "smoothness_improvement": 1285.0073764220767,
                    "objective_score": 38.423679405801344
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "IBI-Connect-Lite: Informed Batched BiRRT with LOS compression and elastic shortcutting. The planner alternates growth of two trees, evaluates a small batch of guided samples per side using a hashed nearest-neighbor, inserts only the best feasible candidate that passes node and edge checks, and compresses to a visible ancestor to reduce turns and cost. It tries a minimal bridge to the opposite tree without forcing target insertions. Upon success, it performs bounded shortcutting and a light elastic smoothing with continuous collision checks. Spatial hashing accelerates lookup and duplicate suppression, while an ellipse-informed sampler focuses search after the first solution.",
          "planning_mechanism": "At each iteration, pick an active tree and generate a batch of candidates biased toward the opposite root (and within an informed ellipse when an incumbent exists). For each candidate, find a hashed-nearest node, steer by a fixed step, and score by g+dist+h; keep several best that are in-bounds and not duplicates. Try to insert candidates in score order, enforcing both node and edge collision checks; on insertion, attempt line-of-sight compression to an ancestor. Then attempt a limited, stepwise bridge from the other tree; if a direct edge becomes free, merge trees and extract a path. Post-process with greedy shortcuts and a few elastic adjustments that preserve feasibility and do not increase length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3500,\n        step_size=8.0,\n        batch_size=4,\n        goal_bias=0.2,\n        cell_factor=1.2,\n        dupe_radius_ratio=0.5,\n        los_lookback=6,\n        connect_steps_limit=16,\n        collision_res=0.75,\n        shortcut_attempts=60,\n        elastic_iters=20\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.batch_size = batch_size\n        self.goal_bias = goal_bias\n        self.cell_factor = cell_factor\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.los_lookback = los_lookback\n        self.connect_steps_limit = connect_steps_limit\n        self.collision_res = collision_res\n        self.shortcut_attempts = shortcut_attempts\n        self.elastic_iters = elastic_iters\n        self._rng = 2463534242\n\n    # ----------------- Public API -----------------\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obstacle(self.start) or self._point_in_obstacle(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        self._seed_rng()\n        self.cell_size = max(1.0, self.step_size * self.cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n\n        # Straight-line early exit\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        nodes = []\n        edges = []\n\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        A, B = [a_root], [b_root]\n        GA, GB = {}, {}\n        self._grid_add(GA, a_root)\n        self._grid_add(GB, b_root)\n\n        best_len = float('inf')\n        best_path = None\n\n        for it in range(self.max_iter):\n            # Alternate sides\n            sideA = (it % 2 == 0)\n            T = A if sideA else B\n            TO = B if sideA else A\n            G = GA if sideA else GB\n            GO = GB if sideA else GA\n            attractor = self.goal if sideA else self.start\n\n            candidates = []\n            for _ in range(self.batch_size):\n                qrand = self._sample(attractor, best_len)\n                if qrand is None:\n                    continue\n                qnear = self._nearest(G, qrand)\n                if qnear is None:\n                    continue\n                qnew = self._steer(qnear.position, qrand, self.step_size)\n                if not self._in_bounds(qnew):\n                    continue\n                if self._point_in_obstacle(qnew):\n                    continue\n                if self._has_near(G, qnew, self.dupe_radius):\n                    continue\n                # score without edge check to limit expensive calls\n                f = qnear.cost + self._dist(qnear.position, qnew) + 0.9 * self._dist(qnew, attractor)\n                candidates.append((f, qnear, qnew))\n\n            if not candidates:\n                continue\n\n            # Try best-first\n            candidates.sort(key=lambda t: t[0])\n            inserted = None\n            for _, qnear, qnew in candidates:\n                # Both checks before insertion\n                if self._point_in_obstacle(qnew):\n                    continue\n                if not self._edge_free(qnear.position, qnew):\n                    continue\n                qnode = Node(qnew, qnear, qnear.cost + self._dist(qnear.position, qnew))\n                qnode.attach(qnear)\n                T.append(qnode)\n                nodes.append(qnode)\n                edges.append((qnear, qnode))\n                self._grid_add(G, qnode)\n\n                # LOS compression to ancestor\n                self._compress_los(qnode, edges)\n\n                inserted = qnode\n                break\n\n            if inserted is None:\n                continue\n\n            # Attempt to bridge\n            meet = self._attempt_bridge(TO, GO, inserted.position, nodes, edges)\n            if meet is not None:\n                # Path extraction\n                path_a = self._path_to_root(inserted)\n                path_b = self._path_to_root(meet)\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                raw = path_a + path_b[::-1]\n                # Post-process\n                sm = self._shortcut(raw, self.shortcut_attempts)\n                sm = self._elastic_smooth(sm, self.elastic_iters)\n                bl = self._path_len(sm)\n                best_len = bl\n                best_path = sm\n                return PlannerResult(True, best_path, nodes, edges)\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # ----------------- Geometry and Utils -----------------\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            s ^= int(v * 997 + 0.5) + 0x9E3779B97F4A7C15 + (s << 6) + (s >> 2)\n            s &= 0xffffffff\n        s ^= len(self.obstacles) * 2654435761\n        self._rng = s if s != 0 else 2463534242\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(max(0.0, min(a[i], self.bounds[i])) for i in range(self.dims))\n        if d <= step:\n            tgt = b\n        else:\n            r = step / d\n            tgt = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n        # clamp\n        return tuple(max(0.0, min(tgt[i], self.bounds[i])) for i in range(self.dims))\n\n    # ----------------- Spatial Hash -----------------\n    def _cell_key(self, p):\n        if self.is3d:\n            return (int(p[0] // self.cell_size), int(p[1] // self.cell_size), int(p[2] // self.cell_size))\n        return (int(p[0] // self.cell_size), int(p[1] // self.cell_size))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos):\n        k = self._cell_key(pos)\n        best = None\n        bd = float('inf')\n        for r in range(0, 4):\n            cand = self._grid_ring(grid, k, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bd:\n                        bd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback linear (rare)\n        nearest = None\n        nd = float('inf')\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._dist(n.position, pos)\n                if d < nd:\n                    nd = d\n                    nearest = n\n        return nearest\n\n    def _has_near(self, grid, pos, radius):\n        k = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell_size) + 1)\n        if self.is3d:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        b = grid.get((k[0] + dx, k[1] + dy, k[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    b = grid.get((k[0] + dx, k[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    # ----------------- Collision -----------------\n    def _point_in_obstacle(self, p):\n        if self.is3d:\n            px, py, pz = p\n            for x, y, z, w, h, d in self.obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            px, py = p\n            for x, y, w, h in self.obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        # Sample along the segment with adaptive resolution\n        dist = self._dist(a, b)\n        if dist <= 1e-12:\n            return not self._point_in_obstacle(a)\n        res = max(0.25, min(self.collision_res, self.step_size * 0.5))\n        steps = max(1, int(dist / res))\n        for i in range(steps + 1):\n            t = i / steps\n            p = tuple(a[d] + (b[d] - a[d]) * t for d in range(self.dims))\n            if self._point_in_obstacle(p):\n                return False\n        return True\n\n    # ----------------- LOS compression -----------------\n    def _compress_los(self, node, edges):\n        p = node.parent\n        if p is None:\n            return\n        best_parent = p\n        best_cost = node.cost\n        steps = 0\n        cur = p\n        while cur is not None and steps < self.los_lookback:\n            if self._edge_free(cur.position, node.position):\n                cand_cost = cur.cost + self._dist(cur.position, node.position)\n                if cand_cost + 1e-12 < best_cost:\n                    best_cost = cand_cost\n                    best_parent = cur\n            cur = cur.parent\n            steps += 1\n        if best_parent is not node.parent:\n            oldp = node.parent\n            node.attach(best_parent)\n            node.cost = best_cost\n            self._remove_edge(edges, oldp, node)\n            edges.append((best_parent, node))\n\n    def _remove_edge(self, edges, p, c):\n        if p is None:\n            return\n        rm = -1\n        for i in range(len(edges)):\n            if edges[i][0] is p and edges[i][1] is c:\n                rm = i\n                break\n        if rm >= 0:\n            edges.pop(rm)\n\n    # ----------------- Bridge attempt -----------------\n    def _attempt_bridge(self, tree_other, grid_other, target_pos, nodes, edges):\n        if not tree_other:\n            return None\n        qnear = self._nearest(grid_other, target_pos)\n        if qnear is None:\n            return None\n        # Direct edge first\n        if self._edge_free(qnear.position, target_pos):\n            return qnear\n\n        # Minimal progressive connection: grow the other tree slightly toward target\n        current = qnear\n        for _ in range(self.connect_steps_limit):\n            step = self._steer(current.position, target_pos, self.step_size)\n            if not self._in_bounds(step):\n                return None\n            if self._point_in_obstacle(step):\n                return None\n            if not self._edge_free(current.position, step):\n                return None\n            # avoid duplicates near existing nodes in other grid\n            if self._has_near(grid_other, step, self.dupe_radius):\n                return None\n            new_node = Node(step, current, current.cost + self._dist(current.position, step))\n            new_node.attach(current)\n            tree_other.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_add(grid_other, new_node)\n            current = new_node\n            # Check if we can now directly connect\n            if self._edge_free(current.position, target_pos):\n                return current\n        return None\n\n    # ----------------- Sampling -----------------\n    def _sample(self, attractor, best_len):\n        # Informed ellipse if we have an incumbent\n        for _ in range(24):\n            if best_len < float('inf') and self._rand() < 0.65:\n                p = self._ellipse_pick(self.start, self.goal, best_len * 1.02)\n                if p is not None:\n                    return p\n            else:\n                r = self._rand()\n                if r < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n                if self._in_bounds(p) and not self._point_in_obstacle(p):\n                    return p\n        return None\n\n    def _ellipse_pick(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(18):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._in_bounds(p) and not self._point_in_obstacle(p):\n                return p\n        return None\n\n    # ----------------- Path ops -----------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best_L = self._path_len(pts)\n        tries = 0\n        no_imp = 0\n        while tries < attempts and len(pts) > 2:\n            i = int(self._rand_range(0, len(pts) - 2))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                cand = pts[:i + 1] + pts[j:]\n                L = self._path_len(cand)\n                if L <= best_L + 1e-12:\n                    pts = cand\n                    best_L = L\n                    no_imp = 0\n                else:\n                    no_imp += 1\n            else:\n                no_imp += 1\n            tries += 1\n            if no_imp >= 12:\n                break\n        return pts\n\n    def _elastic_smooth(self, path, iters):\n        if len(path) < 3:\n            return path[:]\n        pts = [tuple(p) for p in path]\n        base_len = self._path_len(pts)\n        for _ in range(iters):\n            changed = False\n            for k in range(1, len(pts) - 1):\n                a = pts[k - 1]\n                b = pts[k]\n                c = pts[k + 1]\n                # proposed move toward midpoint of neighbors\n                mid = tuple(0.5 * (a[d] + c[d]) for d in range(self.dims))\n                prop = tuple(0.6 * mid[d] + 0.4 * b[d] for d in range(self.dims))\n                # bounds and collision\n                prop = tuple(max(0.0, min(prop[d], self.bounds[d])) for d in range(self.dims))\n                if self._point_in_obstacle(prop):\n                    continue\n                if self._edge_free(a, prop) and self._edge_free(prop, c):\n                    old_len = self._dist(a, b) + self._dist(b, c)\n                    new_len = self._dist(a, prop) + self._dist(prop, c)\n                    if new_len <= old_len + 1e-9:\n                        pts[k] = prop\n                        changed = True\n            if not changed:\n                break\n        # final feasibility check\n        ok = True\n        for i in range(1, len(pts)):\n            if not self._edge_free(pts[i - 1], pts[i]):\n                ok = False\n                break\n        if not ok:\n            return path[:]\n        return pts",
          "objective": -33.03942,
          "time_improvement": 57.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1596.0,
          "node_improvement": 92.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02291398048400879,
                    "num_nodes_avg": 48.0,
                    "path_length_avg": 162.3715024736225,
                    "smoothness_avg": 0.045283030818523244,
                    "success_improvement": 0.0,
                    "time_improvement": 7.122901383760357,
                    "node_improvement": 87.91236464366659,
                    "length_improvement": 11.001606553100745,
                    "smoothness_improvement": 608.7777659851962,
                    "objective_score": 11.781723176914534
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028193902969360352,
                    "num_nodes_avg": 106.0,
                    "path_length_avg": 226.46753860051695,
                    "smoothness_avg": 0.08639360422955294,
                    "success_improvement": 0.0,
                    "time_improvement": 83.14281885776845,
                    "node_improvement": 92.87778001746959,
                    "length_improvement": 24.398617108477243,
                    "smoothness_improvement": 2122.969663624298,
                    "objective_score": 50.19686424053837
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.008996152877807617,
                    "num_nodes_avg": 48.0,
                    "path_length_avg": 145.04275395386156,
                    "smoothness_avg": 0.16957145057025852,
                    "success_improvement": 0.0,
                    "time_improvement": 82.17761922058317,
                    "node_improvement": 93.89701207883026,
                    "length_improvement": 3.6695090175910625,
                    "smoothness_improvement": 2056.936334791184,
                    "objective_score": 37.13967285068551
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Adaptive Goal-Biased Grid BiRRT (AG-GBiRRT): a simplified, robust bidirectional RRT with commit-only connection, grid-accelerated nearest search, and light post-connection shortcut smoothing. It alternates growing two trees, uses uniform-with-goal-bias sampling, single-step steering with strict node/edge collision checks, and an early straight-line test. Upon any successful bridge between trees, it extracts the path and performs a few inexpensive shortcuts for smoothness, returning quickly without extra rewiring or bloat.",
          "planning_mechanism": "Mechanism: alternate start/goal tree expansion; sample (goal-biased), find nearest via grid, steer one step, validate node and edge, add node and edge, attempt a direct, collision-free bridge to the opposite tree (commit-only); on success, extract [start\u2192\u2026\u2192meetA, meetB\u2192\u2026\u2192goal] and run brief shortcut smoothing; terminate on success or iteration budget.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size * 2.0)\n        self.edge_res = max(0.5, self.collision_step)\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_res):\n            path = [start, goal]\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Trees and grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = goal if active_start else start\n\n            # Sample with goal/opposite-root bias\n            if self._rand() < self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest and steer\n            nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                continue\n\n            # Insert node (both node and edge validated)\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, new_node)\n\n            # Try commit-only direct connection to the other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None:\n                if not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                    path = self._extract_path(new_node, other_near)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- Random ----------\n    def _rand(self):\n        try:\n            return self._lcg_next()\n        except:\n            return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Sampling ----------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ---------- Grid nearest ----------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    # ---------- Path ----------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # path_a ends at meet_a; we then go straight to meet_b and up to other root\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            # pick two indices i < j with at least one point between\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -32.96764,
          "time_improvement": 69.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1142.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01299290657043457,
                    "num_nodes_avg": 78.8,
                    "path_length_avg": 167.86786188508313,
                    "smoothness_avg": 0.03825680999831742,
                    "success_improvement": 0.0,
                    "time_improvement": 49.04501835909778,
                    "node_improvement": 80.15613195668597,
                    "length_improvement": 7.988964864290817,
                    "smoothness_improvement": 498.8021524662562,
                    "objective_score": 22.000895188635106
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02625594139099121,
                    "num_nodes_avg": 208.9,
                    "path_length_avg": 244.3021244779086,
                    "smoothness_avg": 0.07331771296729457,
                    "success_improvement": 0.0,
                    "time_improvement": 83.61025026480232,
                    "node_improvement": 85.96385137405093,
                    "length_improvement": 18.444919002512343,
                    "smoothness_improvement": 1786.5175632625994,
                    "objective_score": 45.082614297261095
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01305999755859375,
                    "num_nodes_avg": 163.0,
                    "path_length_avg": 140.27860161008172,
                    "smoothness_avg": 0.09759083301298958,
                    "success_improvement": 0.0,
                    "time_improvement": 73.37500455677744,
                    "node_improvement": 79.27527018436109,
                    "length_improvement": 6.833632159773637,
                    "smoothness_improvement": 1141.348192519241,
                    "objective_score": 31.819421625493614
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "FALCON-IBiRRT*: Fast Adaptive Lazy-Connect Optimal BiRRT with Cone-Guided Sampling and Lite Rewiring. It blends bidirectional growth, informed/corridor/goal-biased sampling with directional cone gating, spatial hash for near/nearest, obstacle binning for fast segment tests, best-parent with short ancestor compression, and bounded local rewiring. A lazy, capped-node connect avoids opposite-tree bloat. On first meet, a two-pass visibility+shortcut+rounding refiner outputs a short, smooth path quickly.",
          "planning_mechanism": "Alternate expand start/goal trees. For each iteration: draw a guided sample (goal/corridor/uniform; switch to informed ellipse once an incumbent exists) filtered by a cone toward the opposite root. Steer one step, pick a best parent from k-near via grid, optionally compress to a visible ancestor, validate node and edge, insert, then lightly rewire k neighbors. Try a lazy connect from the other tree: direct line-of-sight or at most two validated steps with duplicate suppression. On connection, extract, refine (visibility collapse, randomized shortcutting, corner rounding), and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=7.0,\n                 goal_bias=0.20,\n                 corridor_bias=0.30,\n                 ellipse_bias=0.55,\n                 grid_cell_factor=1.8,\n                 neighbor_radius_factor=2.5,\n                 k_parent=6,\n                 k_rewire=6,\n                 connect_mult=1.8,\n                 min_sep_ratio=0.25,\n                 smoothing_attempts=100):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.ellipse_bias = float(ellipse_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neigh_factor = float(neighbor_radius_factor)\n        self.k_parent = int(max(1, k_parent))\n        self.k_rewire = int(max(0, k_rewire))\n        self.connect_mult = float(connect_mult)\n        self.min_sep_ratio = float(min_sep_ratio)\n        self.smoothing_attempts = int(max(0, smoothing_attempts))\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self._is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if hasattr(map, 'obstacles') and map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        # Bounds/start-goal validation\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.neigh_radius = max(self.step * 1.2, self.step * self.neigh_factor)\n        self.min_sep = max(0.25, self.step * self.min_sep_ratio)\n        self.cstep = max(self.step, self.step * self.connect_mult)\n        self.dup_thresh = max(0.4, 0.8 * self.step)\n\n        # Build obstacle bins\n        self._build_obs_bins()\n\n        # Node validity\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Trivial solution\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._refine_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize trees and grids\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        Ta = [a_root]\n        Tb = [b_root]\n        nodes.extend([a_root, b_root])\n\n        G_a = {}\n        G_b = {}\n        self._grid_add(G_a, a_root)\n        self._grid_add(G_b, b_root)\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            # Alternate active tree\n            if (it & 1) == 0:\n                A, B = Ta, Tb\n                GA, GB = G_a, G_b\n                root_other = self.goal\n            else:\n                A, B = Tb, Ta\n                GA, GB = G_b, G_a\n                root_other = self.start\n\n            # Guided sample with cone gating\n            sample = self._guided_sample(root_other, best_len)\n            if sample is None:\n                continue\n\n            # Nearest and steer\n            anchor = self._nearest(GA, sample)\n            newp = self._steer(anchor.position, sample, self.step)\n\n            # Pre-insertion checks: bounds, node collision, proximity, edge collision\n            if (not self._in_bounds(newp)) or self._point_blocked(newp):\n                continue\n            if self._too_close(GA, newp, self.min_sep):\n                continue\n\n            # Best-parent selection among k nearest neighbors\n            neigh = self._neighbors(GA, newp, self.neigh_radius)\n            cands = self._k_nearest(neigh if neigh else [anchor], newp, self.k_parent)\n            parent, gbest = None, 1e100\n            for nb in cands:\n                if not self._edge_free(nb.position, newp):\n                    continue\n                gc = nb.cost + self._dist(nb.position, newp)\n                if gc < gbest:\n                    parent = nb\n                    gbest = gc\n\n            if parent is None:\n                continue\n\n            # Short ancestor compression (up to 3 hops) for flatter chains\n            anc = parent\n            hops = 0\n            while anc is not None and anc.parent is not None and hops < 3:\n                up = anc.parent\n                if self._edge_free(up.position, newp):\n                    gc = up.cost + self._dist(up.position, newp)\n                    if gc + 1e-12 < gbest:\n                        parent = up\n                        gbest = gc\n                anc = up\n                hops += 1\n\n            # Final insertion checks (both checks before adding)\n            if self._point_blocked(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, gbest)\n            parent.add_child(nn)\n            A.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(GA, nn)\n\n            # Local bounded rewiring\n            if self.k_rewire > 0:\n                self._rewire_lite(nn, GA, edges)\n\n            # Lazy connect attempt from the other tree\n            meet_b = None\n            other_near = self._nearest(GB, nn.position)\n            # Direct connect\n            if self._edge_free(other_near.position, nn.position):\n                meet_b = other_near\n            else:\n                # At most two validated steps to avoid bloat\n                cur = other_near\n                steps = 0\n                added_nodes = 0\n                while steps < 2:\n                    nxtp = self._steer(cur.position, nn.position, self.cstep)\n                    if (not self._in_bounds(nxtp)) or self._point_blocked(nxtp):\n                        break\n                    if not self._edge_free(cur.position, nxtp):\n                        break\n                    # Duplicate suppression\n                    if self._too_close(GB, nxtp, self.dup_thresh):\n                        break\n                    # Add step node (both checks already OK)\n                    cn = Node(nxtp, cur, cur.cost + self._dist(cur.position, nxtp))\n                    cur.add_child(cn)\n                    B.append(cn)\n                    nodes.append(cn)\n                    edges.append((cur, cn))\n                    self._grid_add(GB, cn)\n                    added_nodes += 1\n                    cur = cn\n                    # Try final snap\n                    if self._edge_free(cur.position, nn.position):\n                        meet_b = cur\n                        break\n                    steps += 1\n\n            if meet_b is not None:\n                # Extract path without adding cross-edge\n                path = self._merge_path(nn, meet_b)\n                rawL = self._path_len(path)\n                if best_len is None or rawL < best_len:\n                    best_len = rawL\n                path = self._refine_path(path)\n                return PlannerResult(True, path, Ta + Tb, edges)\n\n        return PlannerResult(False, [], Ta + Tb, edges)\n\n    # ---------- RNG ----------\n    def _seed_rng(self):\n        s = 0\n        for v in self.start + self.goal:\n            iv = int((v + 1.2345) * 2654435761) & 0xffffffff\n            s ^= iv\n            s = (s << 13) ^ (s >> 17) ^ (s << 7)\n            s &= 0xffffffff\n        s ^= len(self.obstacles) * 1103515245 & 0xffffffff\n        if s == 0:\n            s = 2463534242\n        self._rng = s & 0xffffffff\n\n    def _randu(self):\n        # xorshift32\n        x = self._rng\n        x ^= (x << 13) & 0xffffffff\n        x ^= (x >> 17) & 0xffffffff\n        x ^= (x << 5) & 0xffffffff\n        self._rng = x & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._randu()\n\n    # ---------- Geometry ----------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # ---------- Spatial hashing for nodes ----------\n    def _cell_key(self, p):\n        if self._is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _neighbors(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        span = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self._is3:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        # Expanding rings up to 3\n        for r in range(0, 4):\n            cand = []\n            if self._is3:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                            if lst:\n                                cand += lst\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy))\n                        if lst:\n                            cand += lst\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback full scan\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _k_nearest(self, nodes, pos, k):\n        # Keep k best by squared distance without full sort\n        buf_d = [1e200] * k\n        buf_n = [None] * k\n        for nd in nodes:\n            d2 = self._dist2(nd.position, pos)\n            # find slot\n            mx = -1\n            mxd = -1.0\n            for i in range(k):\n                if buf_n[i] is None:\n                    mx = i\n                    mxd = -1.0\n                    break\n                if buf_d[i] > mxd:\n                    mxd = buf_d[i]\n                    mx = i\n            if mx >= 0 and (buf_n[mx] is None or d2 < buf_d[mx]):\n                # Replace worst if buffer full\n                worst_i = 0\n                worst_d = -1.0\n                for j in range(k):\n                    if buf_n[j] is None:\n                        worst_i = j\n                        worst_d = -1.0\n                        break\n                    if buf_d[j] > worst_d:\n                        worst_d = buf_d[j]\n                        worst_i = j\n                if buf_n[worst_i] is None or d2 < buf_d[worst_i]:\n                    buf_d[worst_i] = d2\n                    buf_n[worst_i] = nd\n        # Compact\n        out = []\n        for i in range(k):\n            if buf_n[i] is not None:\n                out.append(buf_n[i])\n        # Order roughly by distance\n        out.sort(key=lambda n: self._dist2(n.position, pos))\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        neigh = self._neighbors(grid, pos, radius)\n        return len(neigh) > 0\n\n    # ---------- Obstacles & collision ----------\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.6)\n        self.obin = {}\n        if self._is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            self._obin_add((i, j, k), idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        self._obin_add((i, j), idx)\n\n    def _obin_add(self, key, idx):\n        lst = self.obin.get(key)\n        if lst is None:\n            self.obin[key] = [idx]\n        else:\n            lst.append(idx)\n\n    def _bucket_candidates(self, a, b):\n        if self._is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self.obin.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            return cand\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self.obin.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            return cand\n\n    def _point_blocked(self, p):\n        if self._is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            lst = self.obin.get((ix, iy, iz))\n            if not lst:\n                return False\n            x, y, z = p\n            for idx in lst:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            lst = self.obin.get((ix, iy))\n            if not lst:\n                return False\n            x, y = p\n            for idx in lst:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        # Segment vs candidate obstacles\n        cand = self._bucket_candidates(a, b)\n        if not cand:\n            return True\n        if self._is3:\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        # Slab intersection (Liang-Barsky style)\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            q = p1[i]\n            d = q - p\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # ---------- Rewiring ----------\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                del edges[i]\n                break\n\n    def _propagate_cost_limited(self, node, delta, cap=128):\n        stack = [node]\n        visited = 0\n        while stack and visited < cap:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n                visited += 1\n                if visited >= cap:\n                    break\n\n    def _rewire_lite(self, new_node, grid, edges):\n        neigh = self._neighbors(grid, new_node.position, self.neigh_radius)\n        if not neigh:\n            return\n        cands = self._k_nearest(neigh, new_node.position, self.k_rewire)\n        for nb in cands:\n            if nb is new_node or nb is new_node.parent:\n                continue\n            # Avoid cycles\n            cur = new_node\n            cyc = False\n            while cur is not None:\n                if cur is nb:\n                    cyc = True\n                    break\n                cur = cur.parent\n            if cyc:\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            cand_cost = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand_cost + 1e-9 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, oldp, nb)\n                new_node.add_child(nb)\n                edges.append((new_node, nb))\n                delta = cand_cost - nb.cost\n                nb.cost = cand_cost\n                self._propagate_cost_limited(nb, delta, cap=256)\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, target_root, incumbent_len):\n        tries = 18\n        while tries > 0:\n            tries -= 1\n            r = self._randu()\n            if incumbent_len is not None and r < self.ellipse_bias:\n                p = self._sample_in_ellipse(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                r2 = self._randu()\n                if r2 < self.goal_bias:\n                    p = target_root\n                elif r2 < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_point()\n                else:\n                    if self._is3:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]),\n                             self._rand_range(0.0, self.bounds[2]))\n                    else:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]))\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            # Cone gating: encourage samples pointing toward the opposite root\n            v1 = tuple(p[i] - self.start[i] for i in range(self.dim))\n            v2 = tuple(target_root[i] - self.start[i] for i in range(self.dim))\n            if self._cos_align(v1, v2) < -0.2 and self._randu() < 0.5:\n                continue\n            return p\n        return None\n\n    def _cos_align(self, a, b):\n        na = 0.0\n        nb = 0.0\n        dp = 0.0\n        for i in range(self.dim):\n            na += a[i] * a[i]\n            nb += b[i] * b[i]\n            dp += a[i] * b[i]\n        if na <= 1e-18 or nb <= 1e-18:\n            return 1.0\n        return dp / ((na ** 0.5) * (nb ** 0.5))\n\n    def _corridor_point(self):\n        t = self._randu()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step, 0.06 * sg)\n        if self._is3:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            oz = self._rand_range(-w, w)\n            return self._clamp((base[0] + ox, base[1] + oy, base[2] + oz))\n        else:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            return self._clamp((base[0] + ox, base[1] + oy))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        center = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(20):\n            if self._is3:\n                p = (center[0] + self._rand_range(-ext[0], ext[0]),\n                     center[1] + self._rand_range(-ext[1], ext[1]),\n                     center[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (center[0] + self._rand_range(-ext[0], ext[0]),\n                     center[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            if self._dist(p, f1) + self._dist(p, f2) <= max_sum + 1e-9:\n                return p\n        return None\n\n    # ---------- Paths and smoothing ----------\n    def _trace(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _merge_path(self, meet_a, meet_b):\n        pa = self._trace(meet_a)\n        # meet_b is in the other tree towards its root\n        pb = []\n        cur = meet_b\n        while cur is not None:\n            pb.append(cur.position)\n            cur = cur.parent\n        return pa + pb\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _prune_collinear(self, pts, cos_eps=0.9975):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        for i in range(1, len(pts) - 1):\n            a = out[-1]\n            b = pts[i]\n            c = pts[i + 1]\n            v1 = tuple(b[j] - a[j] for j in range(self.dim))\n            v2 = tuple(c[j] - b[j] for j in range(self.dim))\n            n1 = (sum(v1[j] * v1[j] for j in range(self.dim))) ** 0.5\n            n2 = (sum(v2[j] * v2[j] for j in range(self.dim))) ** 0.5\n            if n1 < 1e-9 or n2 < 1e-9:\n                continue\n            cosang = sum(v1[j] * v2[j] for j in range(self.dim)) / (n1 * n2)\n            if cosang < cos_eps:\n                out.append(b)\n        out.append(pts[-1])\n        return out\n\n    def _vis_collapse(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = pts[:]\n        i = 0\n        while i < len(out) - 2:\n            j = len(out) - 1\n            collapsed = False\n            while j > i + 1:\n                if self._edge_free(out[i], out[j]):\n                    del out[i + 1:j]\n                    collapsed = True\n                    break\n                j -= 1\n            if not collapsed:\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        stall = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-9 <= bestL:\n                    cur = cand\n                    bestL = L\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            tries += 1\n            if stall > 28:\n                break\n        return cur\n\n    def _round_corners(self, pts, passes=2):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            k = 1\n            while k < len(cur) - 1:\n                a = cur[k - 1]\n                c = cur[k + 1]\n                mid = tuple(0.5 * (a[i] + c[i]) for i in range(self.dim))\n                if self._in_bounds(mid) and (not self._point_blocked(mid)):\n                    if self._edge_free(a, mid) and self._edge_free(mid, c):\n                        cur[k] = mid\n                k += 1\n        return cur\n\n    def _refine_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._prune_collinear(path)\n        p1 = self._vis_collapse(p0)\n        p2 = self._shortcut(p1, self.smoothing_attempts)\n        p3 = self._round_corners(p2, passes=2)\n        return p3",
          "objective": -32.87452,
          "time_improvement": 65.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1389.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012348318099975586,
                    "num_nodes_avg": 55.0,
                    "path_length_avg": 174.85272669498227,
                    "smoothness_avg": 0.04900620000433415,
                    "success_improvement": 0.0,
                    "time_improvement": 49.9486368718647,
                    "node_improvement": 86.14958448753463,
                    "length_improvement": 4.160449779719303,
                    "smoothness_improvement": 667.0534487344287,
                    "objective_score": 20.816128173063134
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04547526836395264,
                    "num_nodes_avg": 139.0,
                    "path_length_avg": 237.675280217124,
                    "smoothness_avg": 0.0895281065411136,
                    "success_improvement": 0.0,
                    "time_improvement": 72.81026195146428,
                    "node_improvement": 90.66048511724787,
                    "length_improvement": 20.65715035989825,
                    "smoothness_improvement": 2203.6226657915117,
                    "objective_score": 45.25548213033579
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014064836502075195,
                    "num_nodes_avg": 75.0,
                    "path_length_avg": 139.45225702777378,
                    "smoothness_avg": 0.10977562995077768,
                    "success_improvement": 0.0,
                    "time_improvement": 72.13599244643852,
                    "node_improvement": 90.46408137317228,
                    "length_improvement": 7.382450885042043,
                    "smoothness_improvement": 1296.337910179751,
                    "objective_score": 32.55195781585554
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "AIL-Connect: Adaptive Informed Lazy BiRRT-Connect with grid-kNN, direct bridging, and on-the-fly corner-cut smoothing. It accelerates planning via analytic segment\u2013AABB collision tests (broad-phase + slab), informed corridor-biased sampling after a candidate path, k-nearest grid lookup with cost-aware parent choice, greedy connect with immediate direct-bridge checks, and local grandparent rewiring to cut corners during growth. A short bounded-time shortcut pass finalizes the path.",
          "planning_mechanism": "Alternate growing two trees. Each iteration: sample (uniform early, corridor-biased later), pick a parent via grid-based kNN minimizing cost+heuristic, extend-connect until blocked while validating node and edge. After each insertion, attempt grandparent bypass and then a direct bridge to the opposite tree; if blocked, greedily connect the opposite tree toward the new node. On success, assemble and briefly shortcut the path; stop at first feasible solution or time cap.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=5.0,\n        time_limit_sec=10.0,\n        grid_cell_factor=1.6,\n        k_candidates=12,\n        goal_bias=0.08,\n        corridor_bias=0.35,\n        smooth_attempts=50,\n        smooth_time_frac=0.08\n    ):\n        self.max_iter = max_iter\n        self.step_size = float(step_size)\n        self.time_limit_sec = float(time_limit_sec)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.k_candidates = int(k_candidates)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.smooth_attempts = int(smooth_attempts)\n        self.smooth_time_frac = float(smooth_time_frac)\n\n    # -------- Public API --------\n    def plan(self, map):\n        bounds = map.size\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        obstacles = list(map.obstacles)\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Validate start/goal\n        if not self._within_bounds(start, bounds) or not self._within_bounds(goal, bounds):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line check\n        if not self._edge_hits_any_obstacle(start, goal, obstacles, is_3d):\n            start_node = Node(start, parent=None, cost=0.0)\n            goal_node = Node(goal, parent=start_node, cost=self._dist(start, goal))\n            start_node.add_child(goal_node)\n            nodes = [start_node, goal_node]\n            edges = [(start_node, goal_node)]\n            return PlannerResult(True, [start, goal], nodes, edges)\n\n        # Initialize trees and grids\n        start_root = Node(start, parent=None, cost=0.0)\n        goal_root = Node(goal, parent=None, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n        nodes = [start_root, goal_root]\n\n        cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        grid_start = {}\n        grid_goal = {}\n        self._grid_insert(grid_start, start_root.position, start_root, cell_size, dim)\n        self._grid_insert(grid_goal, goal_root.position, goal_root, cell_size, dim)\n\n        # Corridor sampler parameters\n        have_candidate = False  # becomes True once any connection is attempted successfully\n        best_path_cost = float(\"inf\")\n\n        import time  # environment commonly provides, guarded import to avoid top-level\n        t0 = time.time()\n\n        for it in range(self.max_iter):\n            if (time.time() - t0) >= self.time_limit_sec:\n                return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n            # Alternate sides\n            grow_from_start = (it % 2 == 0)\n            if grow_from_start:\n                grow_tree, grow_grid = start_tree, grid_start\n                other_tree, other_grid = goal_tree, grid_goal\n                other_root = goal_root\n            else:\n                grow_tree, grow_grid = goal_tree, grid_goal\n                other_tree, other_grid = start_tree, grid_start\n                other_root = start_root\n\n            # Sample\n            sample = self._sample(bounds, is_3d, start, goal, have_candidate)\n\n            # Choose parent via grid-kNN (cost-aware)\n            parent_node = self._best_parent(grow_tree, grow_grid, sample, cell_size, dim)\n\n            # Extend toward sample\n            last_new = self._extend_connect(grow_tree, grow_grid, parent_node, sample, nodes, edges, obstacles, is_3d, bounds, cell_size, dim)\n            if last_new is None:\n                continue\n\n            # Try direct bridge to opposite tree's nearest\n            near_other = self._nearest_from_grid(other_tree, other_grid, last_new.position, cell_size, dim, want_k=1, max_rings=4)\n            bridge_ok = False\n            if not self._edge_hits_any_obstacle(last_new.position, near_other.position, obstacles, is_3d):\n                edges.append((last_new, near_other))\n                have_candidate = True\n                bridge_ok = True\n                a_node = last_new\n                b_node = near_other\n            else:\n                # Greedy connect other tree toward last_new\n                b_last = self._extend_connect(other_tree, other_grid, near_other, last_new.position, nodes, edges, obstacles, is_3d, bounds, cell_size, dim)\n                if b_last is not None and not self._edge_hits_any_obstacle(b_last.position, last_new.position, obstacles, is_3d):\n                    edges.append((b_last, last_new))\n                    have_candidate = True\n                    bridge_ok = True\n                    a_node = last_new\n                    b_node = b_last\n\n            if bridge_ok:\n                # Assemble path\n                if grow_from_start:\n                    pa = a_node.path_from_root()\n                    pb = b_node.path_from_root()\n                    path = pa + pb[::-1]\n                else:\n                    pa = a_node.path_from_root()\n                    pb = b_node.path_from_root()\n                    path = pb + pa[::-1]\n\n                # Quick bounded-time shortcutting\n                remaining = self.time_limit_sec - (time.time() - t0)\n                budget = max(0.0, min(remaining, self.time_limit_sec * self.smooth_time_frac))\n                path = self._shortcut_path(path, obstacles, is_3d, bounds, budget, self.smooth_attempts)\n\n                # Update best and return immediately (time-optimized)\n                best_path_cost = self._path_length(path)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # -------- Core utilities --------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(len(a)):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        if len(path) < 2:\n            return 0.0\n        c = 0.0\n        for i in range(1, len(path)):\n            c += self._dist(path[i - 1], path[i])\n        return c\n\n    def _within_bounds(self, p, bounds):\n        for i in range(len(bounds)):\n            if p[i] < 0.0 or p[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return tuple(to_pos)\n        r = step / d if d > 0.0 else 0.0\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    def _sample(self, bounds, is_3d, start, goal, focused):\n        # Bias toward corridor after first candidate\n        try:\n            import random\n        except:\n            random = None\n        dim = len(bounds)\n        if focused:\n            if random is not None and self._rand01(random) < self.corridor_bias:\n                t = self._rand01(random)\n                base = tuple(start[i] + (goal[i] - start[i]) * t for i in range(dim))\n                # Jitter per-dimension within a small corridor (proportional to step_size)\n                jitter = []\n                for i in range(dim):\n                    width = max(1.0, self.step_size * 2.5)\n                    u = (self._rand01(random) * 2.0 - 1.0) * width\n                    jitter.append(u)\n                pt = tuple(base[i] + jitter[i] for i in range(dim))\n                if self._within_bounds(pt, bounds):\n                    return pt\n        # Occasional direct goal bias\n        if random is not None and self._rand01(random) < self.goal_bias:\n            return tuple(goal)\n        # Uniform sampling with limited rejection\n        for _ in range(8):\n            if random is not None:\n                pt = tuple(self._rand01(random) * bounds[i] for i in range(dim))\n            else:\n                # Fallback deterministic mid-bounds (rare path)\n                pt = tuple(bounds[i] * 0.5 for i in range(dim))\n            if self._within_bounds(pt, bounds):\n                return pt\n        return tuple(min(max(0.0, pt[i]), bounds[i]) for i in range(dim))\n\n    def _rand01(self, random_mod):\n        return random_mod.random()\n\n    # -------- Tree growth --------\n    def _best_parent(self, tree, grid, sample, cell_size, dim):\n        # For small trees, linear scan\n        if len(tree) < 32:\n            best = tree[0]\n            best_val = best.cost + self._dist(best.position, sample)\n            for n in tree[1:]:\n                v = n.cost + self._dist(n.position, sample)\n                if v < best_val:\n                    best = n\n                    best_val = v\n            return best\n        # Gather k candidates from expanding rings\n        candidates = self._nearest_from_grid(tree, grid, sample, cell_size, dim, want_k=self.k_candidates, max_rings=5, break_on_k=True, return_all=True)\n        if not candidates:\n            # Fallback to nearest by distance\n            return self._nearest_from_grid(tree, grid, sample, cell_size, dim, want_k=1, max_rings=5)\n        best = candidates[0]\n        best_val = best.cost + self._dist(best.position, sample)\n        for n in candidates[1:]:\n            v = n.cost + self._dist(n.position, sample)\n            if v < best_val:\n                best = n\n                best_val = v\n        return best\n\n    def _extend_connect(self, tree, grid, from_node, target_pos, nodes, edges, obstacles, is_3d, bounds, cell_size, dim):\n        current = from_node\n        last_new = None\n        while True:\n            step_pos = self._steer(current.position, target_pos, self.step_size)\n            if not self._within_bounds(step_pos, bounds):\n                break\n            # Node and edge collision checks\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                break\n            if self._edge_hits_any_obstacle(current.position, step_pos, obstacles, is_3d):\n                break\n            # Commit node\n            new_node = Node(step_pos, parent=current, cost=current.cost + self._dist(current.position, step_pos))\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node.position, new_node, cell_size, dim)\n\n            # Local on-the-fly corner cut (grandparent bypass)\n            gp = current.parent\n            if gp is not None:\n                if not self._edge_hits_any_obstacle(gp.position, new_node.position, obstacles, is_3d):\n                    # Rewire new_node to grandparent\n                    current.remove_child(new_node)\n                    new_node.parent = gp\n                    gp.add_child(new_node)\n                    # Update edge list: replace (current, new_node) with (gp, new_node)\n                    self._replace_edge(edges, current, new_node, gp, new_node)\n                    # Update cost from gp\n                    new_node.cost = gp.cost + self._dist(gp.position, new_node.position)\n\n            last_new = new_node\n            current = new_node\n            if self._dist(current.position, target_pos) <= self.step_size:\n                break\n        return last_new\n\n    # -------- Grid NN --------\n    def _cell_index(self, pos, cell_size, dim):\n        if dim == 2:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size))\n        else:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size), int(pos[2] // cell_size))\n\n    def _grid_insert(self, grid, pos, node, cell_size, dim):\n        key = self._cell_index(pos, cell_size, dim)\n        if key in grid:\n            grid[key].append(node)\n        else:\n            grid[key] = [node]\n\n    def _nearest_from_grid(self, tree, grid, point, cell_size, dim, want_k=1, max_rings=4, break_on_k=False, return_all=False):\n        # Linear scan for small trees\n        if len(tree) < 32:\n            if want_k <= 1 and not return_all:\n                best = tree[0]\n                best_d = self._dist(best.position, point)\n                for n in tree[1:]:\n                    d = self._dist(n.position, point)\n                    if d < best_d:\n                        best = n\n                        best_d = d\n                return best\n            else:\n                arr = list(tree)\n                arr.sort(key=lambda n: self._dist(n.position, point))\n                return arr[:want_k]\n\n        center = self._cell_index(point, cell_size, dim)\n        candidates = []\n        for r in range(0, max_rings + 1):\n            if dim == 2:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        idx = (center[0] + dx, center[1] + dy)\n                        if idx in grid:\n                            candidates.extend(grid[idx])\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            idx = (center[0] + dx, center[1] + dy, center[2] + dz)\n                            if idx in grid:\n                                candidates.extend(grid[idx])\n            if break_on_k and len(candidates) >= want_k:\n                break\n        if not candidates:\n            candidates = tree\n\n        # Return nearest or top-k\n        if want_k <= 1 and not return_all:\n            best = candidates[0]\n            best_d = self._dist(best.position, point)\n            for n in candidates[1:]:\n                d = self._dist(n.position, point)\n                if d < best_d:\n                    best = n\n                    best_d = d\n            return best\n        else:\n            # Partial selection by distance\n            cand = list(candidates)\n            cand.sort(key=lambda n: self._dist(n.position, point))\n            return cand[:want_k]\n\n    # -------- Collision checks --------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for x, y, z, w, h, d in obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for x, y, w, h in obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_hits_any_obstacle(self, p0, p1, obstacles, is_3d):\n        # Broad-phase: segment AABB vs box AABB\n        if is_3d:\n            minx = p0[0] if p0[0] < p1[0] else p1[0]\n            maxx = p0[0] if p0[0] > p1[0] else p1[0]\n            miny = p0[1] if p0[1] < p1[1] else p1[1]\n            maxy = p0[1] if p0[1] > p1[1] else p1[1]\n            minz = p0[2] if p0[2] < p1[2] else p1[2]\n            maxz = p0[2] if p0[2] > p1[2] else p1[2]\n            for x, y, z, w, h, d in obstacles:\n                if (maxx < x) or (minx > x + w) or (maxy < y) or (miny > y + h) or (maxz < z) or (minz > z + d):\n                    continue\n                if self._segment_intersects_box(p0, p1, (x, y, z, w, h, d), True):\n                    return True\n            return False\n        else:\n            minx = p0[0] if p0[0] < p1[0] else p1[0]\n            maxx = p0[0] if p0[0] > p1[0] else p1[0]\n            miny = p0[1] if p0[1] < p1[1] else p1[1]\n            maxy = p0[1] if p0[1] > p1[1] else p1[1]\n            for x, y, w, h in obstacles:\n                if (maxx < x) or (minx > x + w) or (maxy < y) or (miny > y + h):\n                    continue\n                if self._segment_intersects_box(p0, p1, (x, y, w, h), False):\n                    return True\n            return False\n\n    def _segment_intersects_box(self, p0, p1, box, is_3d):\n        # Slab method for segment-box intersection; includes endpoints.\n        if is_3d:\n            x, y, z, w, h, d = box\n            bmin = (x, y, z)\n            bmax = (x + w, y + h, z + d)\n            tmin = 0.0\n            tmax = 1.0\n            for i in range(3):\n                a = p0[i]\n                b = p1[i]\n                dlt = b - a\n                if dlt == 0.0:\n                    if a < bmin[i] or a > bmax[i]:\n                        return False\n                    else:\n                        continue\n                inv = 1.0 / dlt\n                t1 = (bmin[i] - a) * inv\n                t2 = (bmax[i] - a) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n            return True\n        else:\n            x, y, w, h = box\n            bmin = (x, y)\n            bmax = (x + w, y + h)\n            tmin = 0.0\n            tmax = 1.0\n            for i in range(2):\n                a = p0[i]\n                b = p1[i]\n                dlt = b - a\n                if dlt == 0.0:\n                    if a < bmin[i] or a > bmax[i]:\n                        return False\n                    else:\n                        continue\n                inv = 1.0 / dlt\n                t1 = (bmin[i] - a) * inv\n                t2 = (bmax[i] - a) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n            return True\n\n    # -------- Edges / smoothing --------\n    def _replace_edge(self, edges, old_u, old_v, new_u, new_v):\n        # Remove first occurrence of (old_u, old_v), then append (new_u, new_v)\n        idx = -1\n        for i in range(len(edges)):\n            u, v = edges[i]\n            if u is old_u and v is old_v:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n        edges.append((new_u, new_v))\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds, time_budget, attempts):\n        if len(path) < 3:\n            return path\n        import time\n        start_t = time.time()\n        pts = list(path)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and (time.time() - start_t) <= time_budget:\n            # Prefer larger gaps\n            i = self._bounded_rand_int(0, n - 3)\n            j = self._bounded_rand_int(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            # Endpoints are in bounds -> segment stays in bounds (box is convex)\n            if not self._edge_hits_any_obstacle(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n            tries += 1\n        return pts\n\n    def _bounded_rand_int(self, lo, hi):\n        try:\n            import random\n            return random.randint(lo, hi)\n        except:\n            # Fallback deterministic midpoint\n            return (lo + hi) // 2",
          "objective": -32.81411,
          "time_improvement": 53.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 2252.0,
          "node_improvement": 60.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0225860595703125,
                    "num_nodes_avg": 251.7,
                    "path_length_avg": 171.85198364917562,
                    "smoothness_avg": 0.06040808331984212,
                    "success_improvement": 0.0,
                    "time_improvement": 8.452061241470474,
                    "node_improvement": 36.61546210022665,
                    "length_improvement": 5.805204592942339,
                    "smoothness_improvement": 845.5176822080389,
                    "objective_score": 10.24632953924674
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02895486354827881,
                    "num_nodes_avg": 340.9,
                    "path_length_avg": 245.2869996289932,
                    "smoothness_avg": 0.1574856214355659,
                    "success_improvement": 0.0,
                    "time_improvement": 82.68783927105191,
                    "node_improvement": 77.09467177316402,
                    "length_improvement": 18.116139329020882,
                    "smoothness_improvement": 3952.2184718452627,
                    "objective_score": 55.43712773795441
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.015923190116882324,
                    "num_nodes_avg": 261.0,
                    "path_length_avg": 144.47625851074147,
                    "smoothness_avg": 0.16187356345760986,
                    "success_improvement": 0.0,
                    "time_improvement": 68.45438696509973,
                    "node_improvement": 66.81500317863954,
                    "length_improvement": 4.045748317297235,
                    "smoothness_improvement": 1959.0197789172153,
                    "objective_score": 32.75886397449433
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "FIBCO: Fast Indexed BiRRT-Connect with Obstacle Binning. A time-focused bidirectional planner that combines single-step tree growth, spatial hashing for fast nearest queries, and an obstacle binning index for cheap, exact line-of-sight tests. It uses corridor- and goal-biased sampling, throttles near-duplicate nodes, performs on-the-fly grandparent compression, attempts an immediate bridge to the opposite tree, and only applies a lightweight visibility-first smoothing once a connection is found. By filtering collision checks to only nearby obstacles and minimizing per-iteration work, it yields faster plans with coherent edges and improved path quality.",
          "planning_mechanism": "Mechanism: Build an obstacle bin grid and two node grids, seed start/goal roots. Each iteration select a target (goal/corridor/uniform), pick the nearest node in the active tree, steer one step, and validate node and edge against only obstacles retrieved from the bins. If valid and not a near-duplicate, insert the node, try grandparent line-of-sight compression, then attempt a direct bridge to the nearest node in the other tree; if that fails, run a very short greedy connect with per-step validation. On success, extract the path, run a fast visibility compression followed by a few shortcuts, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=8.0,\n                 goal_bias=0.20,\n                 corridor_bias=0.55,\n                 connect_steps=6,\n                 min_sep_ratio=0.3,\n                 dupe_radius_ratio=0.5,\n                 smoothing_shortcuts=14):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.connect_steps = connect_steps\n        self.min_sep_ratio = min_sep_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.smoothing_shortcuts = smoothing_shortcuts\n\n        self.dim = 2\n        self.bounds = None\n        self.start = None\n        self.goal = None\n\n        # Node grid (for nearest and duplicate suppression)\n        self.grid_cell = None\n\n        # RNG state\n        self._lcg_state = 2463534242\n\n        # Obstacle bins\n        self._bins_cell = None\n        self._bins_n = None\n        self._bins = None\n        self._obstacles = None\n\n    # ---------------- Planning ----------------\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self._obstacles = list(map.obstacles)\n        is_3d = (self.dim == 3)\n\n        # Grid cell for nodes tuned to step size\n        self.grid_cell = max(1.0, 0.85 * self.step_size)\n\n        # Build obstacle bins for fast filtering\n        self._build_obstacle_bins(is_3d)\n\n        # Validate start/goal inside bounds and free\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obstacle(self.start, is_3d) or self._point_in_obstacle(self.goal, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._edge_blocked(self.start, self.goal, is_3d):\n            nodes = [Node(self.start), Node(self.goal)]\n            return PlannerResult(True, [self.start, self.goal], nodes, [])\n\n        # Initialize trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Corridor parameters\n        dsg = self._dist(self.start, self.goal)\n        base_corridor = max(self.step_size, 0.15 * dsg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = self.goal if active_start else self.start\n\n            # Target selection\n            r = self._rand()\n            if r < self.goal_bias:\n                x_rand = root_other\n            elif r < self.goal_bias + self.corridor_bias:\n                x_rand = self._sample_corridor(base_corridor, is_3d)\n            else:\n                x_rand = self._sample_free(is_3d)\n\n            # Nearest and one-step steer\n            nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n            if nearest is None:\n                continue\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n\n            # Bounds, node collision, separation, duplicate throttle\n            if not self._in_bounds(new_pos):\n                continue\n            if self._point_in_obstacle(new_pos, is_3d):\n                continue\n            if self._dist(nearest.position, new_pos) < self.step_size * self.min_sep_ratio:\n                continue\n            if self._exists_close(grid_a, new_pos, self.step_size * self.dupe_radius_ratio):\n                continue\n\n            # Edge collision check (must be clear)\n            if self._edge_blocked(nearest.position, new_pos, is_3d):\n                continue\n\n            # Insert node and edge\n            new_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, new_node)\n\n            # On-the-fly grandparent compression\n            gp = nearest.parent\n            if gp is not None and not self._edge_blocked(gp.position, new_node.position, is_3d):\n                nearest.remove_child(new_node)\n                try:\n                    edges.remove((nearest, new_node))\n                except:\n                    pass\n                gp.add_child(new_node)\n                edges.append((gp, new_node))\n                new_node.cost = gp.cost + self._dist(gp.position, new_node.position)\n\n            # Try direct bridge to the nearest in the other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None and not self._edge_blocked(new_node.position, other_near.position, is_3d):\n                path = self._extract_path(new_node, other_near)\n                path = self._smooth_path(path, is_3d)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Short greedy connect from other tree\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, new_node.position, self.step_size)\n                if not self._in_bounds(to_pos):\n                    break\n                if self._point_in_obstacle(to_pos, is_3d):\n                    break\n                if self._dist(p.position, to_pos) < self.step_size * self.min_sep_ratio:\n                    break\n                if self._edge_blocked(p.position, to_pos, is_3d):\n                    break\n\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                edges.append((p, q))\n                self._grid_add(grid_b, q)\n                p = q\n                steps += 1\n\n                # Bridge now?\n                if not self._edge_blocked(new_node.position, p.position, is_3d):\n                    path = self._extract_path(new_node, p)\n                    path = self._smooth_path(path, is_3d)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------------- RNG ----------------\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------------- Geometry ----------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------------- Obstacle bins ----------------\n    def _build_obstacle_bins(self, is_3d):\n        nobs = len(self._obstacles)\n        if nobs <= 0:\n            # Single bin fallback\n            self._bins_cell = (max(self.bounds[0], 1.0), max(self.bounds[1], 1.0)) if not is_3d else (max(self.bounds[0], 1.0), max(self.bounds[1], 1.0), max(self.bounds[2], 1.0))\n            self._bins_n = (1, 1) if not is_3d else (1, 1, 1)\n            self._bins = { (0, 0) if not is_3d else (0, 0, 0): [] }\n            return\n\n        # Choose grid resolution based on obstacle count\n        base = int((nobs ** 0.5) * 2.0) + 4\n        g = max(8, min(48, base))\n        if not is_3d:\n            cx = max(self.bounds[0] / g, 1.0)\n            cy = max(self.bounds[1] / g, 1.0)\n            nx = max(int(self.bounds[0] / cx), 1)\n            ny = max(int(self.bounds[1] / cy), 1)\n            self._bins_cell = (cx, cy)\n            self._bins_n = (nx, ny)\n            self._bins = {}\n            for obs in self._obstacles:\n                x, y, w, h = obs\n                i0 = int(x / cx)\n                j0 = int(y / cy)\n                i1 = int((x + w) / cx)\n                j1 = int((y + h) / cy)\n                if i0 < 0: i0 = 0\n                if j0 < 0: j0 = 0\n                if i1 >= nx: i1 = nx - 1\n                if j1 >= ny: j1 = ny - 1\n                for i in range(i0, i1 + 1):\n                    for j in range(j0, j1 + 1):\n                        k = (i, j)\n                        bucket = self._bins.get(k)\n                        if bucket is None:\n                            self._bins[k] = [obs]\n                        else:\n                            bucket.append(obs)\n        else:\n            cx = max(self.bounds[0] / g, 1.0)\n            cy = max(self.bounds[1] / g, 1.0)\n            cz = max(self.bounds[2] / max(int(g * 0.75), 1), 1.0)\n            nx = max(int(self.bounds[0] / cx), 1)\n            ny = max(int(self.bounds[1] / cy), 1)\n            nz = max(int(self.bounds[2] / cz), 1)\n            self._bins_cell = (cx, cy, cz)\n            self._bins_n = (nx, ny, nz)\n            self._bins = {}\n            for obs in self._obstacles:\n                x, y, z, w, h, d = obs\n                i0 = int(x / cx)\n                j0 = int(y / cy)\n                k0 = int(z / cz)\n                i1 = int((x + w) / cx)\n                j1 = int((y + h) / cy)\n                k1 = int((z + d) / cz)\n                if i0 < 0: i0 = 0\n                if j0 < 0: j0 = 0\n                if k0 < 0: k0 = 0\n                if i1 >= nx: i1 = nx - 1\n                if j1 >= ny: j1 = ny - 1\n                if k1 >= nz: k1 = nz - 1\n                for i in range(i0, i1 + 1):\n                    for j in range(j0, j1 + 1):\n                        for k in range(k0, k1 + 1):\n                            key = (i, j, k)\n                            bucket = self._bins.get(key)\n                            if bucket is None:\n                                self._bins[key] = [obs]\n                            else:\n                                bucket.append(obs)\n\n    def _bin_key(self, pos):\n        if self.dim == 2:\n            cx, cy = self._bins_cell\n            i = int(pos[0] / cx)\n            j = int(pos[1] / cy)\n            nx, ny = self._bins_n\n            if i < 0: i = 0\n            if j < 0: j = 0\n            if i >= nx: i = nx - 1\n            if j >= ny: j = ny - 1\n            return (i, j)\n        else:\n            cx, cy, cz = self._bins_cell\n            i = int(pos[0] / cx)\n            j = int(pos[1] / cy)\n            k = int(pos[2] / cz)\n            nx, ny, nz = self._bins_n\n            if i < 0: i = 0\n            if j < 0: j = 0\n            if k < 0: k = 0\n            if i >= nx: i = nx - 1\n            if j >= ny: j = ny - 1\n            if k >= nz: k = nz - 1\n            return (i, j, k)\n\n    def _bin_range_for_bbox(self, bmin, bmax):\n        # Returns iterator over bin keys intersecting an AABB\n        if self.dim == 2:\n            cx, cy = self._bins_cell\n            nx, ny = self._bins_n\n            i0 = int(bmin[0] / cx)\n            j0 = int(bmin[1] / cy)\n            i1 = int(bmax[0] / cx)\n            j1 = int(bmax[1] / cy)\n            if i0 < 0: i0 = 0\n            if j0 < 0: j0 = 0\n            if i1 >= nx: i1 = nx - 1\n            if j1 >= ny: j1 = ny - 1\n            return ((i, j) for i in range(i0, i1 + 1) for j in range(j0, j1 + 1))\n        else:\n            cx, cy, cz = self._bins_cell\n            nx, ny, nz = self._bins_n\n            i0 = int(bmin[0] / cx)\n            j0 = int(bmin[1] / cy)\n            k0 = int(bmin[2] / cz)\n            i1 = int(bmax[0] / cx)\n            j1 = int(bmax[1] / cy)\n            k1 = int(bmax[2] / cz)\n            if i0 < 0: i0 = 0\n            if j0 < 0: j0 = 0\n            if k0 < 0: k0 = 0\n            if i1 >= nx: i1 = nx - 1\n            if j1 >= ny: j1 = ny - 1\n            if k1 >= nz: k1 = nz - 1\n            return ((i, j, k) for i in range(i0, i1 + 1) for j in range(j0, j1 + 1) for k in range(k0, k1 + 1))\n\n    def _point_in_obstacle(self, pos, is_3d):\n        key = self._bin_key(pos)\n        bucket = self._bins.get(key)\n        if not bucket:\n            return False\n        if not is_3d:\n            px, py = pos\n            for obs in bucket:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        else:\n            px, py, pz = pos\n            for obs in bucket:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        return False\n\n    def _edge_blocked(self, a, b, is_3d):\n        # Fetch candidate obstacles using segment bbox and test with slab method\n        if self.dim == 2:\n            bmin = (min(a[0], b[0]), min(a[1], b[1]))\n            bmax = (max(a[0], b[0]), max(a[1], b[1]))\n        else:\n            bmin = (min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2]))\n            bmax = (max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2]))\n        seen = {}\n        for key in self._bin_range_for_bbox(bmin, bmax):\n            bucket = self._bins.get(key)\n            if not bucket:\n                continue\n            for obs in bucket:\n                oid = id(obs)\n                if seen.get(oid) is not None:\n                    continue\n                seen[oid] = True\n                if self._segment_intersects_box(a, b, obs, is_3d):\n                    return True\n        return False\n\n    def _segment_intersects_box(self, a, b, obs, is_3d):\n        # Liang-Barsky style slab intersection for a segment [a,b] against axis-aligned box\n        tmin = 0.0\n        tmax = 1.0\n        eps = 1e-12\n        if not is_3d:\n            x, y, w, h = obs\n            bmin = (x, y)\n            bmax = (x + w, y + h)\n            for i in range(2):\n                p0 = a[i]\n                p1 = b[i]\n                d = p1 - p0\n                lo = bmin[i]\n                hi = bmax[i]\n                if abs(d) < eps:\n                    if p0 < lo or p0 > hi:\n                        return False\n                else:\n                    inv = 1.0 / d\n                    t1 = (lo - p0) * inv\n                    t2 = (hi - p0) * inv\n                    if t1 > t2:\n                        t1, t2 = t2, t1\n                    if t1 > tmin:\n                        tmin = t1\n                    if t2 < tmax:\n                        tmax = t2\n                    if tmin > tmax:\n                        return False\n            return True\n        else:\n            x, y, z, w, h, dlen = obs\n            bmin = (x, y, z)\n            bmax = (x + w, y + h, z + dlen)\n            for i in range(3):\n                p0 = a[i]\n                p1 = b[i]\n                d = p1 - p0\n                lo = bmin[i]\n                hi = bmax[i]\n                if abs(d) < eps:\n                    if p0 < lo or p0 > hi:\n                        return False\n                else:\n                    inv = 1.0 / d\n                    t1 = (lo - p0) * inv\n                    t2 = (hi - p0) * inv\n                    if t1 > t2:\n                        t1, t2 = t2, t1\n                    if t1 > tmin:\n                        tmin = t1\n                    if t2 < tmax:\n                        tmax = t2\n                    if tmin > tmax:\n                        return False\n            return True\n\n    # ---------------- Sampling ----------------\n    def _sample_free(self, is_3d):\n        # Rejection sampling with bin-based point test\n        for _ in range(64):\n            if not is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            if not self._point_in_obstacle(p, is_3d):\n                return p\n        # Fallback deterministic center\n        return tuple(min(max((self.start[i] + self.goal[i]) * 0.5, 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _sample_corridor(self, width, is_3d):\n        # Sample near the start-goal line with bounded jitter\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 2:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        if not self._point_in_obstacle(p, is_3d):\n            return p\n        return self._sample_free(is_3d)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # ---------------- Node grid ----------------\n    def _grid_key(self, pos):\n        if self.dim == 2:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell))\n        else:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell), int(pos[2] // self.grid_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, 3):\n            cand = self._grid_collect_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_collect_ring(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # ---------------- Path utilities ----------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)  # root_A -> meet_a\n        # meet_b -> root_B\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _smooth_path(self, path, is_3d):\n        if not path or len(path) < 3:\n            return path\n        # Visibility compression\n        pts = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            found = False\n            while j > i + 1:\n                if not self._edge_blocked(path[i], path[j], is_3d):\n                    pts.append(path[j])\n                    i = j\n                    found = True\n                    break\n                j -= 1\n            if not found:\n                pts.append(path[i + 1])\n                i += 1\n        # Shortcutting (bounded)\n        for _ in range(self.smoothing_shortcuts):\n            m = len(pts)\n            if m < 3:\n                break\n            i = int(self._uniform(0, m - 2))\n            j = int(self._uniform(i + 1, m - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j], is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -32.67315,
          "time_improvement": 61.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 1710.0,
          "node_improvement": 86.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01368570327758789,
                    "num_nodes_avg": 72.6,
                    "path_length_avg": 180.7567919414105,
                    "smoothness_avg": 0.05117958870062285,
                    "success_improvement": 0.0,
                    "time_improvement": 44.5278216138749,
                    "node_improvement": 81.7174515235457,
                    "length_improvement": 0.9243380622512352,
                    "smoothness_improvement": 701.0717014204404,
                    "objective_score": 17.41830782861541
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025516176223754884,
                    "num_nodes_avg": 128.9,
                    "path_length_avg": 245.53658465189,
                    "smoothness_avg": 0.1119686843118635,
                    "success_improvement": 0.0,
                    "time_improvement": 84.74383610072074,
                    "node_improvement": 91.33911173822482,
                    "length_improvement": 18.032820664471366,
                    "smoothness_improvement": 2781.03489512775,
                    "objective_score": 50.14801770453779
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022872543334960936,
                    "num_nodes_avg": 112.6,
                    "path_length_avg": 135.98428209550633,
                    "smoothness_avg": 0.13735319148358044,
                    "success_improvement": 0.0,
                    "time_improvement": 54.686944269812166,
                    "node_improvement": 85.68340750158931,
                    "length_improvement": 9.685714707833764,
                    "smoothness_improvement": 1647.1224573131515,
                    "objective_score": 30.453124392209663
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "FALCON-IBiRRT*: Fast LRU-cached, AABB-indexed, Corridor-Optimized BiRRT* with micro-rewiring and informed bridging. It accelerates collision checks via an obstacle spatial grid and slab-based segment-vs-AABB tests, boosts cache reuse with coarse edge quantization and gentle LRU pruning, focuses growth using goal/ellipse-guided sampling once a provisional bound exists, and keeps NN queries light with a coarse node grid and per-cell caps. Shortcuts and collinearity pruning finalize smooth, short paths quickly.",
          "planning_mechanism": "Mechanism: Build an obstacle grid for fast point/segment queries, then grow two trees from start/goal. Each step samples (goal-biased; ellipse-focused after a bound), steers once, validates node+edge, picks the cheapest parent from nearby nodes, inserts, and micro-rewires. After each insertion, try a cost-aware direct bridge to nearby nodes of the opposite tree. Edge checks use slab-AABB tests with an LRU edge cache. On bridge, extract, shortcut with cached checks, and prune collinear points; otherwise iterate until the budget.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=2800,\n        step_size=5.5,\n        beam_width=2,\n        goal_bias=0.35,\n        grid_cell_factor=1.8,\n        neighbor_radius_factor=2.2,\n        rewire_ratio=0.6,\n        per_cell_cap=8,\n        min_separation_factor=0.5,\n        edge_cache_capacity=48000,\n        cache_quant_factor=0.9,\n        shortcut_attempts=70,\n        no_improve_stop=16,\n        connect_radius_factor=2.2\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.neighbor_radius_factor = neighbor_radius_factor\n        self.rewire_ratio = rewire_ratio\n        self.per_cell_cap = per_cell_cap\n        self.min_separation_factor = min_separation_factor\n        self.edge_cache_capacity = edge_cache_capacity\n        self.cache_quant_factor = cache_quant_factor\n        self.shortcut_attempts = shortcut_attempts\n        self.no_improve_stop = no_improve_stop\n        self.connect_radius_factor = connect_radius_factor\n\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = map.start\n        self.goal = map.goal\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        # Parameterized helpers\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n        self.neighbor_radius = max(self.step_size * self.neighbor_radius_factor, self.cell_size * 1.4)\n        self.connect_radius = max(self.neighbor_radius, self.step_size * self.connect_radius_factor)\n\n        # Edge cache (LRU-ish)\n        self._ecache = {}\n        self._tick = 0\n        self._q = max(1.0, self.step_size * self.cache_quant_factor)\n\n        # Seed RNG from scene\n        seedmix = 1469598103934665603\n        seedmix ^= int(sum(self.start) * 1315423911) & 0xFFFFFFFF\n        seedmix ^= int(sum(self.goal) * 2654435761) & 0xFFFFFFFF\n        seedmix ^= int(self.bounds[0]) & 0xFFFFFFFF\n        self._rng = (seedmix | 1) & 0xFFFFFFFF\n\n        # Validate start/goal\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._build_obstacle_grid()\n        if self._in_obstacle(self.start) or self._in_obstacle(self.goal):\n            return PlannerResult(False, [], [], [])\n        # Early LOS\n        if self._edge_free(self.start, self.goal):\n            nodes = [Node(self.start), Node(self.goal)]\n            return PlannerResult(True, [self.start, self.goal], nodes, [])\n\n        # Trees and spatial hashing\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        best_path = None\n        incumbent_len = None\n        dsg = self._distance(self.start, self.goal)\n\n        for _ in range(self.max_iter):\n            for active_tree, active_grid, other_tree, other_grid, attractor in [\n                (tree_a, grid_a, tree_b, grid_b, self.goal),\n                (tree_b, grid_b, tree_a, grid_a, self.start),\n            ]:\n                progressed = False\n                for _b in range(self.beam_width):\n                    sp = self._guided_sample(attractor, incumbent_len, dsg)\n                    if sp is None:\n                        continue\n                    nearest = self._nearest_in_grid(active_grid, sp)\n                    if nearest is None:\n                        continue\n                    new_pos = self._steer(nearest.position, sp)\n                    if not self._within_bounds(new_pos):\n                        continue\n                    if self._in_obstacle(new_pos):\n                        continue\n                    if not self._edge_free(nearest.position, new_pos):\n                        continue\n                    if self._has_nearby(active_grid, new_pos, self.min_separation):\n                        continue\n\n                    parent, new_cost = self._choose_parent(active_grid, nearest, new_pos)\n                    cell_key = self._cell_of(new_pos)\n                    bucket = active_grid.get(cell_key)\n                    if bucket and len(bucket) >= self.per_cell_cap:\n                        best_bucket_cost = min(n.cost for n in bucket)\n                        if new_cost >= best_bucket_cost - 1e-9:\n                            continue\n\n                    # Insert node (both checks already done)\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node)\n                    progressed = True\n\n                    # Micro-rewiring with both checks\n                    self._rewire_neighbors(active_grid, new_node, nodes, edges)\n\n                    # Attempt cost-aware bridge\n                    partner = self._best_bridge(new_node, other_grid)\n                    if partner is not None:\n                        raw = self._path_from_root(new_node) + self._path_from_root(partner)[::-1]\n                        raw = self._dedup_consecutive(raw)\n                        sm = self._shortcut_and_prune(raw)\n                        final_path = sm if sm else raw\n                        best_path = final_path\n                        incumbent_len = self._path_length(final_path)\n                        return PlannerResult(True, final_path, nodes, edges)\n                if not progressed:\n                    continue\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xFFFFFFFF\n        return self._rng / 4294967296.0\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _distance(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._distance(path[i - 1], path[i])\n        return total\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    def _steer(self, a, b):\n        d = self._distance(a, b)\n        if d <= 1e-12:\n            return a\n        if d <= self.step_size:\n            p = b\n        else:\n            r = self.step_size / d\n            p = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n        if self.is_3d:\n            return (self._clamp(p[0], 0.0, self.bounds[0]),\n                    self._clamp(p[1], 0.0, self.bounds[1]),\n                    self._clamp(p[2], 0.0, self.bounds[2]))\n        else:\n            return (self._clamp(p[0], 0.0, self.bounds[0]),\n                    self._clamp(p[1], 0.0, self.bounds[1]))\n\n    # Sampling\n    def _guided_sample(self, attractor, incumbent_len, dsg):\n        for _ in range(14):\n            if incumbent_len is not None and dsg > 1e-9:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.02)\n                if p is not None:\n                    return p\n            if self._rand() < self.goal_bias:\n                jit = self.step_size * 0.6\n                if self.is_3d:\n                    p = (self._clamp(attractor[0] + self._rand_range(-jit, jit), 0.0, self.bounds[0]),\n                         self._clamp(attractor[1] + self._rand_range(-jit, jit), 0.0, self.bounds[1]),\n                         self._clamp(attractor[2] + self._rand_range(-jit, jit), 0.0, self.bounds[2]))\n                else:\n                    p = (self._clamp(attractor[0] + self._rand_range(-jit, jit), 0.0, self.bounds[0]),\n                         self._clamp(attractor[1] + self._rand_range(-jit, jit), 0.0, self.bounds[1]))\n            else:\n                if self.is_3d:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n            if self._within_bounds(p) and not self._in_obstacle(p):\n                return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        c = tuple((f1[i] + f2[i]) * 0.5 for i in range(self.dims))\n        half = max_sum_dist * 0.5\n        for _ in range(12):\n            if self.is_3d:\n                p = (self._clamp(c[0] + self._rand_range(-half, half), 0.0, self.bounds[0]),\n                     self._clamp(c[1] + self._rand_range(-half, half), 0.0, self.bounds[1]),\n                     self._clamp(c[2] + self._rand_range(-half, half), 0.0, self.bounds[2]))\n            else:\n                p = (self._clamp(c[0] + self._rand_range(-half, half), 0.0, self.bounds[0]),\n                     self._clamp(c[1] + self._rand_range(-half, half), 0.0, self.bounds[1]))\n            if self._distance(p, f1) + self._distance(p, f2) <= max_sum_dist and not self._in_obstacle(p):\n                return p\n        return None\n\n    # Node grid\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        k = self._cell_of(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _nearest_in_grid(self, grid, pos, max_ring=4):\n        cell = self._cell_of(pos)\n        best = None\n        best_d = 1e100\n        if self.is_3d:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            b = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if b:\n                                found = True\n                                for n in b:\n                                    d = self._distance(n.position, pos)\n                                    if d < best_d:\n                                        best_d = d\n                                        best = n\n                if found and best is not None:\n                    return best\n        else:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        b = grid.get((cell[0] + dx, cell[1] + dy))\n                        if b:\n                            found = True\n                            for n in b:\n                                d = self._distance(n.position, pos)\n                                if d < best_d:\n                                    best_d = d\n                                    best = n\n                if found and best is not None:\n                    return best\n        # fallback scan if grid sparse\n        for b in grid.values():\n            for n in b:\n                d = self._distance(n.position, pos)\n                if d < best_d:\n                    best_d = d\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        res = []\n        cell = self._cell_of(pos)\n        rc = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        b = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if b:\n                            for n in b:\n                                if self._distance(n.position, pos) <= radius:\n                                    res.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    b = grid.get((cell[0] + dx, cell[1] + dy))\n                    if b:\n                        for n in b:\n                            if self._distance(n.position, pos) <= radius:\n                                res.append(n)\n        return res\n\n    def _has_nearby(self, grid, pos, radius):\n        cell = self._cell_of(pos)\n        rc = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        b = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if b:\n                            for n in b:\n                                if self._distance(n.position, pos) <= radius:\n                                    return True\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    b = grid.get((cell[0] + dx, cell[1] + dy))\n                    if b:\n                        for n in b:\n                            if self._distance(n.position, pos) <= radius:\n                                return True\n        return False\n\n    # Parent selection and rewiring\n    def _choose_parent(self, grid, nearest, new_pos):\n        best_parent = nearest\n        best_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        neigh = self._neighbors_in_radius(grid, new_pos, self.neighbor_radius)\n        for n in neigh:\n            if self._in_obstacle(n.position):\n                continue\n            if not self._edge_free(n.position, new_pos):\n                continue\n            cand = n.cost + self._distance(n.position, new_pos)\n            if cand + 1e-9 < best_cost:\n                best_cost = cand\n                best_parent = n\n        return best_parent, best_cost\n\n    def _rewire_neighbors(self, grid, new_node, nodes, edges):\n        radius = self.neighbor_radius * self.rewire_ratio\n        neigh = self._neighbors_in_radius(grid, new_node.position, radius)\n        rewired = 0\n        for nb in neigh:\n            if nb is new_node or nb.parent is None:\n                continue\n            if self._in_obstacle(nb.position):\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            new_cost = new_node.cost + self._distance(new_node.position, nb.position)\n            if new_cost + 1e-9 < nb.cost:\n                old_parent = nb.parent\n                if old_parent is not None and nb in old_parent.children:\n                    old_parent.children.remove(nb)\n                new_node.add_child(nb)\n                self._replace_edge(edges, old_parent, nb, new_node, nb)\n                delta = new_cost - nb.cost\n                self._update_subtree_cost(nb, delta)\n                rewired += 1\n                if rewired >= 8:\n                    break\n\n    def _replace_edge(self, edges, old_u, old_v, new_u, new_v):\n        idx = -1\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is old_u and e[1] is old_v:\n                idx = i\n                break\n        if idx >= 0:\n            del edges[idx]\n        present = False\n        for e in edges:\n            if e[0] is new_u and e[1] is new_v:\n                present = True\n                break\n        if not present:\n            edges.append((new_u, new_v))\n\n    def _update_subtree_cost(self, node, delta):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            cur.cost += delta\n            for ch in cur.children:\n                stack.append(ch)\n\n    # Bridging and path extraction\n    def _best_bridge(self, new_node, other_grid):\n        candidates = self._neighbors_in_radius(other_grid, new_node.position, self.connect_radius)\n        if not candidates:\n            near = self._nearest_in_grid(other_grid, new_node.position)\n            if near is not None:\n                candidates = [near]\n        best = None\n        best_total = 1e100\n        for n in candidates:\n            if not self._edge_free(new_node.position, n.position):\n                continue\n            total = new_node.cost + self._distance(new_node.position, n.position) + n.cost\n            if total < best_total:\n                best_total = total\n                best = n\n        return best\n\n    def _path_from_root(self, node):\n        seq = []\n        cur = node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        return seq[::-1]\n\n    def _dedup_consecutive(self, path):\n        if not path:\n            return path\n        out = [path[0]]\n        last = path[0]\n        for p in path[1:]:\n            same = True\n            for i in range(self.dims):\n                if abs(p[i] - last[i]) > 1e-12:\n                    same = False\n                    break\n            if not same:\n                out.append(p)\n                last = p\n        return out\n\n    def _shortcut_and_prune(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        attempts = 0\n        no_imp = 0\n        i = 0\n        while attempts < self.shortcut_attempts and i < len(pts) - 2:\n            improved = False\n            j = len(pts) - 1\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    del pts[i + 1:j]\n                    improved = True\n                    no_imp = 0\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n                no_imp += 1\n            attempts += 1\n            if no_imp >= self.no_improve_stop:\n                break\n        return self._prune_collinear(pts)\n\n    def _prune_collinear(self, pts, tol=1e-3):\n        if len(pts) < 3:\n            return pts[:]\n        res = [pts[0]]\n        for k in range(1, len(pts) - 1):\n            a = res[-1]\n            b = pts[k]\n            c = pts[k + 1]\n            if self._point_line_distance(b, a, c) <= tol:\n                continue\n            res.append(b)\n        res.append(pts[-1])\n        return res\n\n    def _point_line_distance(self, p, a, b):\n        ap = tuple(p[i] - a[i] for i in range(self.dims))\n        ab = tuple(b[i] - a[i] for i in range(self.dims))\n        ab2 = 0.0\n        for i in range(self.dims):\n            ab2 += ab[i] * ab[i]\n        if ab2 <= 1e-12:\n            return self._distance(p, a)\n        t = 0.0\n        num = 0.0\n        for i in range(self.dims):\n            num += ap[i] * ab[i]\n        t = num / ab2\n        if t < 0.0:\n            t = 0.0\n        elif t > 1.0:\n            t = 1.0\n        proj = tuple(a[i] + ab[i] * t for i in range(self.dims))\n        return self._distance(p, proj)\n\n    # Obstacles and collision (spatial grid + slab tests)\n    def _build_obstacle_grid(self):\n        # Choose obstacle grid cell size from scene stats\n        if not self.obstacles:\n            self.og_cell = max(4.0, self.step_size * 2.5)\n            self.og = {}\n            return\n        avg_span = 0.0\n        for obs in self.obstacles:\n            if self.is_3d:\n                avg_span += (obs[3] + obs[4] + obs[5]) / 3.0\n            else:\n                avg_span += (obs[2] + obs[3]) / 2.0\n        avg_span /= max(1, len(self.obstacles))\n        self.og_cell = max(self.step_size * 2.0, avg_span)\n        self.og = {}\n        for obs in self.obstacles:\n            if self.is_3d:\n                x, y, z, w, h, d = obs\n                i0 = int(x // self.og_cell); i1 = int((x + w) // self.og_cell)\n                j0 = int(y // self.og_cell); j1 = int((y + h) // self.og_cell)\n                k0 = int(z // self.og_cell); k1 = int((z + d) // self.og_cell)\n                for i in range(i0, i1 + 1):\n                    for j in range(j0, j1 + 1):\n                        for k in range(k0, k1 + 1):\n                            key = (i, j, k)\n                            b = self.og.get(key)\n                            if b is None:\n                                self.og[key] = [obs]\n                            else:\n                                b.append(obs)\n            else:\n                x, y, w, h = obs\n                i0 = int(x // self.og_cell); i1 = int((x + w) // self.og_cell)\n                j0 = int(y // self.og_cell); j1 = int((y + h) // self.og_cell)\n                for i in range(i0, i1 + 1):\n                    for j in range(j0, j1 + 1):\n                        key = (i, j)\n                        b = self.og.get(key)\n                        if b is None:\n                            self.og[key] = [obs]\n                        else:\n                            b.append(obs)\n\n    def _og_key(self, p):\n        if self.is_3d:\n            return (int(p[0] // self.og_cell), int(p[1] // self.og_cell), int(p[2] // self.og_cell))\n        return (int(p[0] // self.og_cell), int(p[1] // self.og_cell))\n\n    def _candidates_in_box(self, mn, mx):\n        if self.is_3d:\n            i0 = int(mn[0] // self.og_cell); i1 = int(mx[0] // self.og_cell)\n            j0 = int(mn[1] // self.og_cell); j1 = int(mx[1] // self.og_cell)\n            k0 = int(mn[2] // self.og_cell); k1 = int(mx[2] // self.og_cell)\n            seen = set()\n            res = []\n            for i in range(i0, i1 + 1):\n                for j in range(j0, j1 + 1):\n                    for k in range(k0, k1 + 1):\n                        b = self.og.get((i, j, k))\n                        if b:\n                            for o in b:\n                                if o not in seen:\n                                    seen.add(o)\n                                    res.append(o)\n            return res\n        else:\n            i0 = int(mn[0] // self.og_cell); i1 = int(mx[0] // self.og_cell)\n            j0 = int(mn[1] // self.og_cell); j1 = int(mx[1] // self.og_cell)\n            seen = set()\n            res = []\n            for i in range(i0, i1 + 1):\n                for j in range(j0, j1 + 1):\n                    b = self.og.get((i, j))\n                    if b:\n                        for o in b:\n                            if o not in seen:\n                                seen.add(o)\n                                res.append(o)\n            return res\n\n    def _in_obstacle(self, pos):\n        if not self.obstacles:\n            return False\n        key = self._og_key(pos)\n        bucket = self.og.get(key)\n        if not bucket:\n            return False\n        if self.is_3d:\n            px, py, pz = pos\n            for o in bucket:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in bucket:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] // self._q) for i in range(self.dims))\n        qb = tuple(int(b[i] // self._q) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        k = self._edge_key(a, b)\n        hit = self._ecache.get(k)\n        if hit is not None:\n            self._tick += 1\n            self._ecache[k] = (hit[0], self._tick)\n            return hit[0]\n        # Query candidate obstacles via bounding box\n        mn = tuple(min(a[i], b[i]) for i in range(self.dims))\n        mx = tuple(max(a[i], b[i]) for i in range(self.dims))\n        cands = self._candidates_in_box(mn, mx)\n        free = True\n        if cands:\n            if self.is_3d:\n                for o in cands:\n                    if self._seg_box_intersect_3d(a, b, o):\n                        free = False\n                        break\n            else:\n                for o in cands:\n                    if self._seg_box_intersect_2d(a, b, o):\n                        free = False\n                        break\n        self._tick += 1\n        self._ecache[k] = (free, self._tick)\n        if len(self._ecache) > self.edge_cache_capacity:\n            self._prune_cache()\n        return free\n\n    def _prune_cache(self):\n        # Remove oldest ~35%\n        if not self._ecache:\n            return\n        # Collect items with timestamps\n        items = list(self._ecache.items())\n        # Simple selection by threshold\n        thresh = self._tick - 3000\n        removed = 0\n        for key, (val, ts) in items:\n            if ts < thresh:\n                if key in self._ecache:\n                    del self._ecache[key]\n                    removed += 1\n        if removed == 0:\n            # Fallback: drop every 4th\n            i = 0\n            for key in list(self._ecache.keys()):\n                if i % 4 == 0:\n                    del self._ecache[key]\n                i += 1\n\n    # Segment vs AABB slab tests\n    def _seg_box_intersect_2d(self, a, b, box):\n        x, y, w, h = box\n        bminx, bminy = x, y\n        bmaxx, bmaxy = x + w, y + h\n        ox, oy = a[0], a[1]\n        dx, dy = b[0] - a[0], b[1] - a[1]\n        t0, t1 = 0.0, 1.0\n        # X slab\n        if abs(dx) < 1e-12:\n            if ox < bminx or ox > bmaxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            tmin = (bminx - ox) * inv\n            tmax = (bmaxx - ox) * inv\n            if tmin > tmax:\n                tmin, tmax = tmax, tmin\n            t0 = max(t0, tmin); t1 = min(t1, tmax)\n            if t0 > t1:\n                return False\n        # Y slab\n        if abs(dy) < 1e-12:\n            if oy < bminy or oy > bmaxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            tmin = (bminy - oy) * inv\n            tmax = (bmaxy - oy) * inv\n            if tmin > tmax:\n                tmin, tmax = tmax, tmin\n            t0 = max(t0, tmin); t1 = min(t1, tmax)\n            if t0 > t1:\n                return False\n        return True\n\n    def _seg_box_intersect_3d(self, a, b, box):\n        x, y, z, w, h, d = box\n        bminx, bminy, bminz = x, y, z\n        bmaxx, bmaxy, bmaxz = x + w, y + h, z + d\n        ox, oy, oz = a[0], a[1], a[2]\n        dx, dy, dz = b[0] - a[0], b[1] - a[1], b[2] - a[2]\n        t0, t1 = 0.0, 1.0\n        # X\n        if abs(dx) < 1e-12:\n            if ox < bminx or ox > bmaxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            tmin = (bminx - ox) * inv\n            tmax = (bmaxx - ox) * inv\n            if tmin > tmax:\n                tmin, tmax = tmax, tmin\n            t0 = max(t0, tmin); t1 = min(t1, tmax)\n            if t0 > t1:\n                return False\n        # Y\n        if abs(dy) < 1e-12:\n            if oy < bminy or oy > bmaxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            tmin = (bminy - oy) * inv\n            tmax = (bmaxy - oy) * inv\n            if tmin > tmax:\n                tmin, tmax = tmax, tmin\n            t0 = max(t0, tmin); t1 = min(t1, tmax)\n            if t0 > t1:\n                return False\n        # Z\n        if abs(dz) < 1e-12:\n            if oz < bminz or oz > bmaxz:\n                return False\n        else:\n            inv = 1.0 / dz\n            tmin = (bminz - oz) * inv\n            tmax = (bmaxz - oz) * inv\n            if tmin > tmax:\n                tmin, tmax = tmax, tmin\n            t0 = max(t0, tmin); t1 = min(t1, tmax)\n            if t0 > t1:\n                return False\n        return True",
          "objective": -32.58157,
          "time_improvement": 42.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 2603.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027050352096557616,
                    "num_nodes_avg": 98.0,
                    "path_length_avg": 171.85513554228032,
                    "smoothness_avg": 0.04724224515093277,
                    "success_improvement": 0.0,
                    "time_improvement": -9.643028675411124,
                    "node_improvement": 75.3210778141526,
                    "length_improvement": 5.803476990386709,
                    "smoothness_improvement": 639.4437247894238,
                    "objective_score": 3.7863962155558073
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.040798068046569824,
                    "num_nodes_avg": 162.0,
                    "path_length_avg": 248.73422617933517,
                    "smoothness_avg": 0.19760167426978067,
                    "success_improvement": 0.0,
                    "time_improvement": 75.60676774473131,
                    "node_improvement": 89.11509776254786,
                    "length_improvement": 16.965355883602044,
                    "smoothness_improvement": 4984.433405694544,
                    "objective_score": 57.78341088205333
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02036159038543701,
                    "num_nodes_avg": 137.0,
                    "path_length_avg": 132.12841630096472,
                    "smoothness_avg": 0.17969480341941338,
                    "success_improvement": 0.0,
                    "time_improvement": 59.66142171516668,
                    "node_improvement": 82.58105530832803,
                    "length_improvement": 12.246597171969995,
                    "smoothness_improvement": 2185.7046358042544,
                    "objective_score": 36.17490799675328
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "Flash-IBiRRT-DC: A fast Bidirectional RRT with Informed Biasing, Direct-Connect, and sparse grids. It minimizes planning time by (1) aggressive informed sampling once an incumbent appears, (2) single-step expansion with min-separation to cap node count, (3) direct cross-tree connection without growing the opposite tree, (4) lightweight neighbor search via sparse spatial hash, and (5) minimal, collision-aware smoothing.",
          "planning_mechanism": "Mechanism: Alternate expanding start/goal trees. Each iteration: draw an informed/corridor/goal-biased sample, find k-nearest anchors from a few grid rings, steer one step, validate node+edge, choose the cheapest feasible parent, and insert. Then try a direct edge to the nearest node of the opposite tree within a connect radius; on success, extract and lightly smooth the path and return. No multi-step connect and no heavy rewiring to reduce time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=7.5,\n                 goal_bias=0.35,\n                 corridor_bias=0.30,\n                 ellipse_bias=0.70,\n                 grid_cell_factor=2.2,\n                 min_sep_ratio=0.6,\n                 k_parent=4,\n                 k_anchor=6,\n                 connect_radius_mult=2.6,\n                 smoothing_attempts=60):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.ellipse_bias = float(ellipse_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.min_sep_ratio = float(min_sep_ratio)\n        self.k_parent = int(max(1, k_parent))\n        self.k_anchor = int(max(1, k_anchor))\n        self.connect_radius_mult = float(connect_radius_mult)\n        self.smoothing_attempts = int(max(0, smoothing_attempts))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self._is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Spatial params\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step * self.min_sep_ratio)\n        self.connect_radius = max(self.step * 1.2, self.step * self.connect_radius_mult)\n\n        # RNG seed\n        self._seed()\n\n        # Build obstacle bins\n        self._build_obs_bins()\n\n        # Validate start/goal occupancy\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Trivial straight-line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._smooth_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        incumbent_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            target_root = self.goal if active_start else self.start\n\n            # Guided sample\n            sp = self._guided_sample(target_root, incumbent_len)\n            if sp is None:\n                continue\n\n            # k-nearest anchors in active tree\n            anchors = self._grid_k_nearest(grid_a, sp, self.k_anchor)\n            if not anchors:\n                anchors = [tree_a[-1]]\n\n            # Try steering from the best anchor\n            parent = None\n            newp = None\n            bestc = None\n            # Evaluate a few anchors, pick cheapest feasible\n            for anc in anchors:\n                cand = self._steer(anc.position, sp, self.step)\n                if not self._in_bounds(cand):\n                    continue\n                # Both checks required before adding node/edge\n                if self._point_in_obstacles(cand):\n                    continue\n                if self._too_close(grid_a, cand, self.min_sep):\n                    continue\n                if not self._edge_free(anc.position, cand):\n                    continue\n                gc = anc.cost + self._dist(anc.position, cand)\n                if (parent is None) or (gc + 1e-12 < bestc):\n                    parent = anc\n                    newp = cand\n                    bestc = gc\n\n            if parent is None or newp is None:\n                continue\n\n            nn = Node(newp, parent, bestc)\n            parent.add_child(nn)\n            tree_a.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(grid_a, nn)\n\n            # Direct-Connect: try connecting to nearest in the opposite tree\n            nb = self._grid_k_nearest(grid_b, nn.position, 1)\n            meet_b = nb[0] if nb else None\n            if meet_b is not None:\n                if self._dist(nn.position, meet_b.position) <= self.connect_radius:\n                    if self._edge_free(nn.position, meet_b.position):\n                        path = self._extract_path(nn, meet_b)\n                        L = self._path_len(path)\n                        if incumbent_len is None or L + 1e-9 < incumbent_len:\n                            incumbent_len = L\n                        path = self._smooth_path(path)\n                        return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- RNG ----------\n    def _seed(self):\n        s = 0xA5A5A5A5\n        for v in self.start + self.goal:\n            s ^= (int(v * 2654435761) & 0xffffffff)\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 374761393) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # ---------- Spatial hash ----------\n    def _cell_key(self, p):\n        if self._is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self._is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            cand.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        cand.extend(lst)\n        return cand\n\n    def _grid_k_nearest(self, grid, pos, k, max_rings=4):\n        key = self._cell_key(pos)\n        best = []\n        bestd = []\n        found_any = False\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                found_any = True\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if len(best) < k:\n                        best.append(n)\n                        bestd.append(d2)\n                    else:\n                        # replace worst if better\n                        wi = 0\n                        wd = -1.0\n                        for i in range(len(best)):\n                            if bestd[i] > wd:\n                                wd = bestd[i]\n                                wi = i\n                        if d2 < bestd[wi]:\n                            best[wi] = n\n                            bestd[wi] = d2\n                # Early exit if we have k candidates from small rings\n                if len(best) >= k and r >= 1:\n                    break\n        if not found_any:\n            # Fallback: return last node if grid empty (shouldn't happen)\n            return []\n        # Sort by distance\n        idx = list(range(len(best)))\n        for i in range(len(idx)):\n            for j in range(i + 1, len(idx)):\n                if bestd[idx[j]] < bestd[idx[i]]:\n                    idx[i], idx[j] = idx[j], idx[i]\n        return [best[i] for i in idx]\n\n    def _neighbors_within(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self._is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors_within(grid, pos, radius)) > 0\n\n    # ---------- Obstacles & collision ----------\n    def _build_obs_bins(self):\n        # cell slightly larger than step keeps buckets small and focused\n        self.obs_cell = max(3.0, self.step * 1.1)\n        self.obin = {}\n        if self._is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obin.get(key)\n                            if b is None:\n                                self.obin[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obin.get(key)\n                        if b is None:\n                            self.obin[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self._is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self._is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, target_root, incumbent_len):\n        tries = 12\n        while tries > 0:\n            tries -= 1\n            r = self._rand()\n            if incumbent_len is not None and r < self.ellipse_bias:\n                p = self._sample_in_ellipse(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                r2 = self._rand()\n                if r2 < self.goal_bias:\n                    p = target_root\n                elif r2 < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_point()\n                else:\n                    if self._is3:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]),\n                             self._rand_range(0.0, self.bounds[2]))\n                    else:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _corridor_point(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step * 0.8, 0.05 * sg)\n        if self._is3:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            oz = self._rand_range(-w, w)\n            return self._clamp((base[0] + ox, base[1] + oy, base[2] + oz))\n        else:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            return self._clamp((base[0] + ox, base[1] + oy))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(10):\n            if self._is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if not self._in_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # ---------- Paths and smoothing ----------\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._trace_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _prune_collinear(self, pts, cos_eps=0.995):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        for i in range(1, len(pts) - 1):\n            a = out[-1]\n            b = pts[i]\n            c = pts[i + 1]\n            v1 = tuple(b[j] - a[j] for j in range(self.dim))\n            v2 = tuple(c[j] - b[j] for j in range(self.dim))\n            n1 = sum(v1[j] * v1[j] for j in range(self.dim)) ** 0.5\n            n2 = sum(v2[j] * v2[j] for j in range(self.dim)) ** 0.5\n            if n1 < 1e-9 or n2 < 1e-9:\n                continue\n            cosang = sum(v1[j] * v2[j] for j in range(self.dim)) / (n1 * n2)\n            if cosang < cos_eps:\n                out.append(b)\n        out.append(pts[-1])\n        return out\n\n    def _vis_collapse(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = pts[:]\n        i = 0\n        while i < len(out) - 2:\n            j = len(out) - 1\n            collapsed = False\n            while j > i + 1:\n                if self._edge_free(out[i], out[j]):\n                    del out[i + 1:j]\n                    collapsed = True\n                    break\n                j -= 1\n            if not collapsed:\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        stall = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 1, len(cur) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-9 <= bestL:\n                    cur = cand\n                    bestL = L\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            tries += 1\n            if stall > 20:\n                break\n        return cur\n\n    def _smooth_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._prune_collinear(path)\n        p1 = self._vis_collapse(p0)\n        p2 = self._shortcut(p1, self.smoothing_attempts)\n        return p2",
          "objective": -32.29794,
          "time_improvement": 42.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1657.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011611437797546387,
                    "num_nodes_avg": 45.0,
                    "path_length_avg": 147.65257627327262,
                    "smoothness_avg": 0.04617885414768348,
                    "success_improvement": 0.0,
                    "time_improvement": 52.93542934839856,
                    "node_improvement": 88.66784185343742,
                    "length_improvement": 19.069283239823644,
                    "smoothness_improvement": 622.7993463980489,
                    "objective_score": 30.436195480404
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05334858894348145,
                    "num_nodes_avg": 129.0,
                    "path_length_avg": 238.3184995191058,
                    "smoothness_avg": 0.08995418290254918,
                    "success_improvement": 0.0,
                    "time_improvement": 68.1027905756774,
                    "node_improvement": 91.3323926627696,
                    "length_improvement": 20.44242524285565,
                    "smoothness_improvement": 2214.585917461648,
                    "objective_score": 43.76922190572485
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.047772574424743655,
                    "num_nodes_avg": 100.0,
                    "path_length_avg": 124.42974925219728,
                    "smoothness_avg": 0.1755580483910071,
                    "success_improvement": 0.0,
                    "time_improvement": 5.357209489940944,
                    "node_improvement": 87.28544183089637,
                    "length_improvement": 17.359685254631263,
                    "smoothness_improvement": 2133.0854171864203,
                    "objective_score": 22.68840108569314
               }
          ],
          "success_rate": 1.0
     }
]