[
     {
          "operator": "m3",
          "algorithm_description": "SAGE-Connect*: Simple Adaptive Grid Explorer with Informed Bidirectional Growth, Gentle Rewiring, and Fast Smoothing. It builds two trees from start and goal using a compact spatial hash, adaptive neighbor radius, LOS-aware stepping, lightweight k-best parenting, capped local rewiring, and a restrained greedy connect. Once a valid bridge is found, the path is shortcut-pruned and elastically smoothed with collision-aware line search for robust, short, and smooth trajectories.",
          "planning_mechanism": "Alternate expanding start/goal trees. Each iteration: draw a target (goal/segment/uniform; switch to informed-ellipse once a path exists), pick nearest via grid, steer with LOS-adaptive step, enforce node and edge collision checks, suppress duplicates, select a low-cost parent from nearby nodes, add the node, and locally rewire a few neighbors if the new route is cheaper (cycle-safe, edge-checked). Attempt a short greedy connect from the other tree; on success, assemble the bidirectional path, then apply shortcutting and visibility pruning followed by elastic midpoint smoothing before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        pts.reverse()\n        return pts\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step=6.0,\n        connect_factor=1.9,\n        goal_bias=0.16,\n        line_bias=0.22,\n        informed_bias=0.45,\n        grid_cell_factor=1.6,\n        neighbor_radius_scale=3.0,\n        dupe_ratio=0.4,\n        rewire_cap=12,\n        connect_steps=12,\n        shortcut_attempts=90,\n        smooth_passes=6\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step)\n        self.connect_step = float(step * connect_factor)\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neighbor_radius_scale = float(neighbor_radius_scale)\n        self.dupe_ratio = float(dupe_ratio)\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_steps = int(max(1, connect_steps))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.smooth_passes = int(max(0, smooth_passes))\n        self._rng = 123456789\n        self._eindex = {}\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n        self._eindex = {}\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step * self.dupe_ratio)\n\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            self._edges_add(edges, n0, n1)\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Trees and grids\n        Ta, Tb = [], []\n        Ga, Gb = {}, {}\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        Ta.append(start_root)\n        Tb.append(goal_root)\n        nodes.extend([start_root, goal_root])\n        self._grid_add(Ga, start_root)\n        self._grid_add(Gb, goal_root)\n\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            # Sample a common target for both directions for coherence\n            sample = self._sample_target(best_len)\n            if sample is None:\n                continue\n\n            # Expand from start side\n            res = self._expand_and_maybe_connect(Ta, Ga, Tb, Gb, sample, nodes, edges)\n            if res is not None:\n                path, L = res\n                best_len = L\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n            # Expand from goal side\n            res = self._expand_and_maybe_connect(Tb, Gb, Ta, Ga, sample, nodes, edges)\n            if res is not None:\n                path, L = res\n                best_len = L\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # Core expansion and connection\n    def _expand_and_maybe_connect(self, Ta, Ga, Tb, Gb, target, nodes, edges):\n        na = self._nearest(Ga, target)\n        if na is None:\n            return None\n        q_new = self._steer_dynamic(na.position, target)\n        if (not self._in_bounds(q_new)) or self._point_blocked(q_new):\n            return None\n        if self._too_close(Ga, q_new, self.dupe_radius):\n            return None\n\n        parent = self._select_parent(Ga, q_new, na)\n        if parent is None:\n            return None\n        # Both checks before adding node/edge\n        if self._point_blocked(q_new) or (not self._edge_free(parent.position, q_new)):\n            return None\n\n        cost = parent.cost + self._dist(parent.position, q_new)\n        nn = Node(q_new, parent, cost)\n        parent.add_child(nn)\n        Ta.append(nn)\n        nodes.append(nn)\n        self._grid_add(Ga, nn)\n        self._edges_add(edges, parent, nn)\n\n        # Gentle local rewiring\n        if self.rewire_cap > 0:\n            self._rewire_neighbors(Ga, nn, edges, self.rewire_cap)\n\n        # Try greedy connect from the opposite tree\n        meet, ok = self._greedy_connect(Tb, Gb, nn.position, nodes, edges)\n        if ok:\n            pa = nn.path_to_root()\n            pb = meet.path_to_root()\n            # Determine which root belongs to which\n            if Ta[0].position == self.start:\n                # pa: start->..., pb: goal->...\n                path = pa + pb[-2::-1]\n            else:\n                # pa: goal->..., pb: start->...\n                path = pb + pa[-2::-1]\n            L = self._path_len(path)\n            return (self._dedup(path), L)\n        return None\n\n    # RNG\n    def _seed_rng(self):\n        s = 2166136261\n        for v in self.start + self.goal:\n            s ^= int(v * 10007 + 0.5) & 0xffffffff\n            s = (s * 16777619) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Sampling\n    def _sample_target(self, best_len):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._sample_informed_ellipse(self.start, self.goal, best_len * 1.01)\n            if p is not None and self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        r2 = self._rand()\n        if r2 < self.goal_bias:\n            return self.goal\n        if r2 < self.goal_bias + self.line_bias:\n            t = self._rand()\n            if self.is3:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t,\n                     self.start[2] + (self.goal[2] - self.start[2]) * t)\n            else:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t)\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        # Uniform\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_informed_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if self._in_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and (not self._point_blocked(p)):\n                return p\n        return None\n\n    # Geometry helpers\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(self._lerp(a, b, r))\n\n    def _steer_dynamic(self, a, b):\n        if self._edge_free(a, b):\n            d = self._dist(a, b)\n            step = self.connect_step if d > self.connect_step else d\n            return self._steer(a, b, step)\n        return self._steer(a, b, self.step)\n\n    # Node grid\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 3):\n            cand = self._grid_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n            if best is not None:\n                return best\n        # fallback\n        for lst in grid.values():\n            for n in lst:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n        return best\n\n    def _neighbors_within(self, grid, pos, radius, cap):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        seen = {}\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            i2 = id(n)\n                            if i2 in seen:\n                                continue\n                            seen[i2] = True\n                            d2 = 0.0\n                            p = n.position\n                            for i in range(self.dim):\n                                di = p[i] - pos[i]\n                                d2 += di * di\n                            if d2 <= r2:\n                                out.append(n)\n                                if len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        i2 = id(n)\n                        if i2 in seen:\n                            continue\n                        seen[i2] = True\n                        d2 = 0.0\n                        p = n.position\n                        for i in range(self.dim):\n                            di = p[i] - pos[i]\n                            d2 += di * di\n                        if d2 <= r2:\n                            out.append(n)\n                            if len(out) >= cap:\n                                return out\n        return out\n\n    def _adaptive_radius(self, n_nodes):\n        t = float(max(1, n_nodes))\n        base = 1.2 * self.step\n        extra = self.neighbor_radius_scale * self.step / ((1.0 + t) ** (1.0 / 3.0))\n        r = base + extra\n        if r < 1.05 * self.step:\n            r = 1.05 * self.step\n        return r\n\n    def _too_close(self, grid, pos, radius):\n        nb = self._neighbors_within(grid, pos, radius, 1)\n        return len(nb) > 0\n\n    # Parent selection\n    def _select_parent(self, grid, newp, fallback_near):\n        r = self._adaptive_radius(len(grid))\n        neigh = self._neighbors_within(grid, newp, r, 96)\n        best = fallback_near\n        best_cost = fallback_near.cost + self._dist(fallback_near.position, newp)\n        for n in neigh:\n            if n is fallback_near:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                best = n\n                best_cost = c\n        return best\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _rewire_neighbors(self, grid, node, edges, cap):\n        r = self._adaptive_radius(len(grid))\n        neigh = self._neighbors_within(grid, node.position, r, 128)\n        cnt = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            if self._point_blocked(nb.position) or self._point_blocked(node.position):\n                continue\n            if not self._edge_free(node.position, nb.position):\n                continue\n            newc = node.cost + self._dist(node.position, nb.position)\n            if newc + 1e-12 < nb.cost:\n                self._reparent(nb, node, edges)\n                cnt += 1\n                if cnt >= cap:\n                    break\n\n    def _reparent(self, child, new_parent, edges):\n        if child is new_parent or child.parent is new_parent:\n            return\n        if self._point_blocked(child.position) or self._point_blocked(new_parent.position):\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._edges_remove(edges, old, child)\n        new_parent.add_child(child)\n        self._edges_add(edges, new_parent, child)\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        stack = list(child.children)\n        while stack:\n            n = stack.pop()\n            n.cost = n.parent.cost + self._dist(n.parent.position, n.position)\n            for c in n.children:\n                stack.append(c)\n\n    # Greedy connect\n    def _greedy_connect(self, T, G, target_pos, nodes, edges):\n        cur = self._nearest(G, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < self.connect_steps:\n            # Visible? insert exact meeting point\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                    if not self._too_close(G, target_pos, 0.75 * self.dupe_radius):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                            return cur, True\n                        cur.add_child(nn)\n                        T.append(nn)\n                        nodes.append(nn)\n                        self._grid_add(G, nn)\n                        self._edges_add(edges, cur, nn)\n                        return nn, True\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            if self._too_close(G, nxt, 0.75 * self.dupe_radius):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                return cur, False\n            cur.add_child(nn)\n            T.append(nn)\n            nodes.append(nn)\n            self._grid_add(G, nn)\n            self._edges_add(edges, cur, nn)\n            cur = nn\n            steps += 1\n        # Final visibility check\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                if not self._too_close(G, target_pos, 0.75 * self.dupe_radius):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                        return cur, True\n                    cur.add_child(nn)\n                    T.append(nn)\n                    nodes.append(nn)\n                    self._grid_add(G, nn)\n                    self._edges_add(edges, cur, nn)\n                    return nn, True\n            return cur, True\n        return cur, False\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(3.5, self.step * 1.6)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Edge bookkeeping\n    def _edges_add(self, edges, parent, child):\n        key = (id(parent), id(child))\n        if key in self._eindex:\n            return\n        edges.append((parent, child))\n        self._eindex[key] = len(edges) - 1\n\n    def _edges_remove(self, edges, parent, child):\n        key = (id(parent), id(child))\n        idx = self._eindex.get(key)\n        if idx is None:\n            return\n        last = len(edges) - 1\n        if idx != last:\n            edges[idx] = edges[last]\n            pk, ck = id(edges[idx][0]), id(edges[idx][1])\n            self._eindex[(pk, ck)] = idx\n        edges.pop()\n        self._eindex.pop(key, None)\n\n    # Path utilities and smoothing\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _elastic_smooth(self, pts, passes):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = list(pts)\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                b = cur[i]\n                c = cur[i + 1]\n                target = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                t = 1.0\n                best = b\n                while t > 1e-3:\n                    cand = tuple(b[k] + (target[k] - b[k]) * t for k in range(self.dim))\n                    cand = self._clamp(cand)\n                    if (not self._point_blocked(cand)) and self._edge_free(a, cand) and self._edge_free(cand, c):\n                        best = cand\n                        break\n                    t *= 0.5\n                if best != b:\n                    cur[i] = best\n                    moved = True\n            if not moved:\n                break\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._shortcut(path, self.shortcut_attempts)\n        p2 = self._visibility_prune(p1)\n        p3 = self._elastic_smooth(p2, self.smooth_passes)\n        return self._dedup(p3)",
          "objective": -47.53913,
          "time_improvement": 86.0,
          "length_improvement": 21.0,
          "smoothness_improvement": 1812.0,
          "node_improvement": 93.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.004579019546508789,
                    "num_nodes_avg": 30.0,
                    "path_length_avg": 146.96078572191126,
                    "smoothness_avg": 0.03859037591406768,
                    "success_improvement": 0.0,
                    "time_improvement": 81.43988774523116,
                    "node_improvement": 92.44522790229162,
                    "length_improvement": 19.448464603147585,
                    "smoothness_improvement": 504.0231833977275,
                    "objective_score": 38.621161002446534
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023305273056030272,
                    "num_nodes_avg": 122.0,
                    "path_length_avg": 229.66193713526982,
                    "smoothness_avg": 0.11885248032537557,
                    "success_improvement": 0.0,
                    "time_improvement": 86.065738755588,
                    "node_improvement": 91.80272794463482,
                    "length_improvement": 23.332234931912975,
                    "smoothness_improvement": 2958.1599247532718,
                    "objective_score": 54.609862209590545
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.004154682159423828,
                    "num_nodes_avg": 32.0,
                    "path_length_avg": 120.49632735979439,
                    "smoothness_avg": 0.1630888303105967,
                    "success_improvement": 0.0,
                    "time_improvement": 91.76911192279043,
                    "node_improvement": 95.93134138588684,
                    "length_improvement": 19.972076786142434,
                    "smoothness_improvement": 1974.4778835855395,
                    "objective_score": 49.38636906645029
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "Swift-BiRRT*: Informed Sparse Bidirectional RRT-Connect with k-Rewire and Elastic Smoothing \u2014 a fast planner that prioritizes low collision checks, compact trees, and early solutions. It alternates growth of two trees with goal-biased, informed (elliptical) low-discrepancy sampling, performs single-step greedy extension with k-limited, shrinking-radius rewiring, and uses a tight spatial hash for near/nearest queries. After a first solution, it finalizes quickly via LOS pruning, randomized shortcuts, and a light collision-safe Laplacian smoothing, delivering short, smooth paths with markedly reduced planning time.",
          "planning_mechanism": "Each iteration picks the sparser tree, samples a feasible point (goal-biased, filtered by the current best-cost ellipse), finds a near node via a small-ring grid search, and takes one bounded step. The first step selects the cheapest visible parent among up to k nearby nodes; a localized, k-limited rewire improves costs. The opposite tree attempts a short connect toward the new node. If the trees meet or a direct bridge is visible, the path is stitched and smoothed. Tight spacing, capped connect steps, and shrinking rewire radii keep the tree sparse and collision checks low for faster planning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=2000,\n        step_size=10.0,\n        goal_bias=0.25,\n        grid_cell_factor=1.6,\n        min_separation_mult=0.6,\n        connect_steps=20,\n        k_rewire=8,\n        base_rewire_radius_mult=2.5,\n        smooth_shortcuts=24,\n        laplacian_iters=6\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.sep_mult = float(min_separation_mult)\n        self.connect_steps = int(connect_steps)\n        self.k_rewire = int(k_rewire)\n        self.base_rewire_mult = float(base_rewire_radius_mult)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self.laplacian_iters = int(max(0, laplacian_iters))\n        self._rng = 1\n        self._h = 1\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if (not self._inside(self.start)) or (not self._inside(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.sep = max(0.25, self.step * self.sep_mult)\n        self.rewire_base = max(self.step * 1.5, self.step * self.base_rewire_mult)\n\n        self._build_obstacle_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Quick direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Init trees and grids\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        Ta, Tb = [root_a], [root_b]\n        Ga, Gb = {}, {}\n        self._grid_put(Ga, root_a)\n        self._grid_put(Gb, root_b)\n        nodes.extend([root_a, root_b])\n\n        best_cost = float('inf')\n        best_path = None\n\n        for it in range(self.max_iter):\n            # Grow the smaller tree to balance exploration cheaply\n            from_start_side = (len(Ta) <= len(Tb))\n            T_src, T_dst = (Ta, Tb) if from_start_side else (Tb, Ta)\n            G_src, G_dst = (Ga, Gb) if from_start_side else (Gb, Ga)\n            attractor = self.goal if from_start_side else self.start\n\n            q = self._sample(attractor, best_cost)\n            if q is None:\n                continue\n\n            new_node = self._extend_once(T_src, G_src, q, nodes, edges, choose_parent=True, do_rewire=True)\n            if new_node is None:\n                continue\n\n            # Opportunistic short connect from the other tree\n            meet = self._connect_toward(T_dst, G_dst, new_node.position, nodes, edges)\n            if meet is not None:\n                if from_start_side:\n                    path_a = self._path_to_root(new_node)\n                    path_b = self._path_to_root(meet)\n                    path = path_a + path_b[-2::-1]\n                else:\n                    path_a = self._path_to_root(meet)\n                    path_b = self._path_to_root(new_node)\n                    path = path_a + path_b[-2::-1]\n                path = self._finalize(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Try a direct bridge to the opposite root when close\n            if self._dist(new_node.position, attractor) <= self.connect_steps * self.step:\n                if self._edge_free(new_node.position, attractor):\n                    meet_node = self._attach_node(T_src, G_src, new_node, attractor, nodes, edges, ignore_spacing=True)\n                    if meet_node is not None:\n                        path = self._path_to_root(meet_node)\n                        path = self._finalize(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n            # Maintain an incremental best path cheaply via nearest opposite if visible\n            near_dst = self._nearest(G_dst, new_node.position, T_dst)\n            if near_dst and self._edge_free(new_node.position, near_dst.position):\n                tentative = self._path_to_root(new_node) + self._path_to_root(near_dst)[-2::-1]\n                cost = self._polyline_len(tentative)\n                if cost < best_cost:\n                    best_cost = cost\n                    best_path = tentative\n\n        if best_path is not None:\n            best_path = self._finalize(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG, low-discrepancy sampler\n    def _seed(self):\n        s = 0x9E3779B1\n        for v in self.start + self.goal:\n            s ^= (int(v * 2654435761) & 0xffffffff)\n            s = (s * 1664525 + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 1\n        self._rng = s\n        self._h = 1\n\n    def _rand(self):\n        self._rng = (self._rng * 1103515245 + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _halton(self, i, base):\n        f = 1.0 / base\n        r = 0.0\n        while i > 0:\n            r += (i % base) * f\n            i //= base\n            f /= base\n        return r\n\n    def _halton_point(self, idx):\n        if self.is3:\n            return (\n                self._halton(idx, 2) * self.bounds[0],\n                self._halton(idx, 3) * self.bounds[1],\n                self._halton(idx, 5) * self.bounds[2],\n            )\n        else:\n            return (\n                self._halton(idx, 2) * self.bounds[0],\n                self._halton(idx, 3) * self.bounds[1],\n            )\n\n    def _sample(self, attractor, c_best):\n        # goal-biased informed sampling\n        if self._rand() < self.goal_bias:\n            return attractor\n        tries = 0\n        idx = self._h\n        while tries < 6:\n            p = self._halton_point(idx)\n            idx += 1\n            tries += 1\n            if (not self._inside(p)) or self._point_blocked(p):\n                continue\n            if c_best < float('inf'):\n                if (self._dist(self.start, p) + self._dist(p, self.goal)) > (c_best + 1e-9):\n                    continue\n            self._h = idx\n            return p\n        # fallback uniform attempts\n        for _ in range(12):\n            if self.is3:\n                p = (\n                    self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]),\n                )\n            else:\n                p = (\n                    self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                )\n            if (not self._inside(p)) or self._point_blocked(p):\n                continue\n            if c_best < float('inf'):\n                if (self._dist(self.start, p) + self._dist(p, self.goal)) > (c_best + 1e-9):\n                    continue\n            return p\n        return None\n\n    # Geometry\n    def _inside(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        out = []\n        for i in range(self.dim):\n            out.append(a[i] + (b[i] - a[i]) * r)\n        return tuple(out)\n\n    # Spatial hash\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        else:\n            return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_put(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos, T_list):\n        key = self._cell_key(pos)\n        for r in (0, 1):\n            cand = self._collect_ring(grid, key, r)\n            if cand:\n                best = None\n                bestd = float('inf')\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                return best\n        # Fallback small scan\n        if not T_list:\n            return None\n        m = min(len(T_list), 32)\n        best = None\n        bestd = float('inf')\n        step = max(1, len(T_list) // m)\n        for i in range(0, len(T_list), step):\n            n = T_list[i]\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        return best\n\n    def _neighbors_k(self, grid, pos, radius, k):\n        key = self._cell_key(pos)\n        rc = int(radius / self.cell) + 1  # ceil(radius/cell)\n        r2 = radius * radius\n        cand = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            d2 = self._dist2(n.position, pos)\n                            if d2 <= r2:\n                                cand.append((d2, n))\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        d2 = self._dist2(n.position, pos)\n                        if d2 <= r2:\n                            cand.append((d2, n))\n        if not cand:\n            return []\n        # Partial selection of k nearest\n        cand.sort(key=lambda t: t[0])\n        out = []\n        for i in range(min(k, len(cand))):\n            out.append(cand[i][1])\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        nbrs = self._neighbors_k(grid, pos, radius, 1)\n        return len(nbrs) > 0\n\n    # Obstacles and collision\n    def _build_obstacle_bins(self):\n        self.ob_cell = max(6.0, self.step * 2.5)\n        self.ob_grid = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.ob_cell)\n                iy0 = int(max(0.0, y) // self.ob_cell)\n                iz0 = int(max(0.0, z) // self.ob_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.ob_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.ob_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.ob_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            bucket = self.ob_grid.get(key)\n                            if bucket is None:\n                                self.ob_grid[key] = [idx]\n                            else:\n                                bucket.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.ob_cell)\n                iy0 = int(max(0.0, y) // self.ob_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.ob_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.ob_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        bucket = self.ob_grid.get(key)\n                        if bucket is None:\n                            self.ob_grid[key] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            ix = int(p[0] // self.ob_cell)\n            iy = int(p[1] // self.ob_cell)\n            iz = int(p[2] // self.ob_cell)\n            bucket = self.ob_grid.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.ob_cell)\n            iy = int(p[1] // self.ob_cell)\n            bucket = self.ob_grid.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits(a, b)\n\n    def _segment_hits(self, a, b):\n        if self.is3:\n            mn = (a[0] if a[0] < b[0] else b[0],\n                  a[1] if a[1] < b[1] else b[1],\n                  a[2] if a[2] < b[2] else b[2])\n            mx = (a[0] if a[0] > b[0] else b[0],\n                  a[1] if a[1] > b[1] else b[1],\n                  a[2] if a[2] > b[2] else b[2])\n            ix0 = int(max(0.0, mn[0]) // self.ob_cell)\n            iy0 = int(max(0.0, mn[1]) // self.ob_cell)\n            iz0 = int(max(0.0, mn[2]) // self.ob_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.ob_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.ob_cell)\n            iz1 = int(min(self.bounds[2], mx[2]) // self.ob_cell)\n            cand = []\n            seen = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self.ob_grid.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                if idx not in seen:\n                                    seen.add(idx)\n                                    cand.append(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mn = (a[0] if a[0] < b[0] else b[0],\n                  a[1] if a[1] < b[1] else b[1])\n            mx = (a[0] if a[0] > b[0] else b[0],\n                  a[1] if a[1] > b[1] else b[1])\n            ix0 = int(max(0.0, mn[0]) // self.ob_cell)\n            iy0 = int(max(0.0, mn[1]) // self.ob_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.ob_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.ob_cell)\n            cand = []\n            seen = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self.ob_grid.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            if idx not in seen:\n                                seen.add(idx)\n                                cand.append(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Tree ops\n    def _attach_node(self, tree, grid, parent, pos, nodes, edges, ignore_spacing=False):\n        if (not self._inside(pos)) or self._point_blocked(pos):\n            return None\n        if (not ignore_spacing) and self._too_close(grid, pos, self.sep):\n            return None\n        if not self._edge_free(parent.position, pos):\n            return None\n        ncost = parent.cost + self._dist(parent.position, pos)\n        nd = Node(pos, parent, ncost)\n        parent.add_child(nd)\n        tree.append(nd)\n        nodes.append(nd)\n        edges.append((parent, nd))\n        self._grid_put(grid, nd)\n        return nd\n\n    def _dynamic_rewire_radius(self, ncount):\n        # Shrinking radius to cut neighbor scans over time\n        scale = (ncount + 1.0) ** (1.0 / max(2, self.dim))\n        r = self.rewire_base / scale\n        if r < self.step * 1.25:\n            r = self.step * 1.25\n        return r\n\n    def _choose_parent_and_attach(self, tree, grid, near, pos, nodes, edges):\n        best_parent = near\n        best_cost = near.cost + self._dist(near.position, pos)\n        radius = self._dynamic_rewire_radius(len(tree))\n        nbrs = self._neighbors_k(grid, pos, radius, self.k_rewire)\n        for n in nbrs:\n            if self._edge_free(n.position, pos):\n                c = n.cost + self._dist(n.position, pos)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best_parent = n\n        return self._attach_node(tree, grid, best_parent, pos, nodes, edges)\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _rewire_neighbors(self, tree, grid, new_node, edges):\n        radius = self._dynamic_rewire_radius(len(tree))\n        nbrs = self._neighbors_k(grid, new_node.position, radius, self.k_rewire)\n        for nb in nbrs:\n            if nb is new_node or nb.parent is None:\n                continue\n            alt = new_node.cost + self._dist(new_node.position, nb.position)\n            if alt + 1e-9 < nb.cost and self._edge_free(new_node.position, nb.position):\n                oldp = nb.parent\n                # remove old edge\n                for i in range(len(edges) - 1, -1, -1):\n                    if edges[i][0] is oldp and edges[i][1] is nb:\n                        edges.pop(i)\n                        break\n                if nb in oldp.children:\n                    oldp.children.remove(nb)\n                new_node.add_child(nb)\n                edges.append((new_node, nb))\n                self._propagate_cost(nb)\n\n    def _extend_once(self, tree, grid, target, nodes, edges, choose_parent=True, do_rewire=True):\n        near = self._nearest(grid, target, tree)\n        if near is None:\n            return None\n        nxt = self._steer(near.position, target, self.step)\n        if (not self._inside(nxt)) or self._point_blocked(nxt):\n            return None\n        if self._too_close(grid, nxt, self.sep):\n            return None\n        if not self._edge_free(near.position, nxt):\n            return None\n        if choose_parent:\n            ins = self._choose_parent_and_attach(tree, grid, near, nxt, nodes, edges)\n        else:\n            ins = self._attach_node(tree, grid, near, nxt, nodes, edges)\n        if ins is None:\n            return None\n        if do_rewire:\n            self._rewire_neighbors(tree, grid, ins, edges)\n        return ins\n\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        near = self._nearest(grid, target_pos, tree)\n        if near is None:\n            return None\n        cur = near\n        last_new = None\n        steps = 0\n        while steps < self.connect_steps:\n            nxt = self._steer(cur.position, target_pos, self.step)\n            if (not self._inside(nxt)) or self._point_blocked(nxt):\n                break\n            if not self._edge_free(cur.position, nxt):\n                break\n            ins = self._attach_node(tree, grid, cur, nxt, nodes, edges)\n            if ins is None:\n                break\n            last_new = ins\n            cur = ins\n            steps += 1\n            if self._dist2(nxt, target_pos) <= (self.step * self.step * 0.25):\n                break\n        if last_new is not None:\n            if self._edge_free(last_new.position, target_pos) and (not self._point_blocked(target_pos)) and self._inside(target_pos):\n                meet = self._attach_node(tree, grid, last_new, target_pos, nodes, edges, ignore_spacing=True)\n                if meet is not None:\n                    return meet\n        return None\n\n    # Path utilities\n    def _path_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        return out[::-1]\n\n    def _polyline_len(self, pts):\n        if len(pts) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(pts)):\n            s += self._dist(pts[i - 1], pts[i])\n        return s\n\n    def _prune_los(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3 or attempts <= 0:\n            return pts[:]\n        cur = pts[:]\n        t = 0\n        while t < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                t += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cur = cur[:i + 1] + cur[j:]\n            t += 1\n        # dedup\n        out = []\n        last = None\n        for p in cur:\n            if (last is None) or (p != last):\n                out.append(p)\n                last = p\n        return out\n\n    def _laplacian_smooth(self, pts, iters):\n        if len(pts) < 3 or iters <= 0:\n            return pts[:]\n        cur = [tuple(p) for p in pts]\n        alpha = 0.5\n        for _ in range(iters):\n            changed = False\n            for i in range(1, len(cur) - 1):\n                p_prev = cur[i - 1]\n                p = cur[i]\n                p_next = cur[i + 1]\n                # candidate: midpoint blend\n                cand = []\n                for d in range(self.dim):\n                    cand.append((p_prev[d] + p_next[d]) * 0.5 * alpha + p[d] * (1.0 - alpha))\n                cand = tuple(cand)\n                if (not self._inside(cand)) or self._point_blocked(cand):\n                    continue\n                if self._edge_free(p_prev, cand) and self._edge_free(cand, p_next):\n                    cur[i] = cand\n                    changed = True\n            if not changed:\n                break\n        return cur\n\n    def _finalize(self, pts):\n        if not pts or len(pts) < 2:\n            return pts\n        p1 = self._prune_los(pts)\n        p2 = self._shortcut(p1, self.smooth_shortcuts)\n        p3 = self._laplacian_smooth(p2, self.laplacian_iters)\n        return p3",
          "objective": -46.3131,
          "time_improvement": 90.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1866.0,
          "node_improvement": 95.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0031968116760253905,
                    "num_nodes_avg": 19.0,
                    "path_length_avg": 151.3156555185092,
                    "smoothness_avg": 0.04250503411011958,
                    "success_improvement": 0.0,
                    "time_improvement": 87.08473080827832,
                    "node_improvement": 95.21531100478468,
                    "length_improvement": 17.06149146030435,
                    "smoothness_improvement": 565.2960849822728,
                    "objective_score": 39.18879454357747
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01100008487701416,
                    "num_nodes_avg": 68.0,
                    "path_length_avg": 238.7363522100142,
                    "smoothness_avg": 0.12047369196284599,
                    "success_improvement": 0.0,
                    "time_improvement": 93.31004540811918,
                    "node_improvement": 95.4310286904522,
                    "length_improvement": 20.30293398740759,
                    "smoothness_improvement": 2999.874867896929,
                    "objective_score": 55.17414835436495
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.00599064826965332,
                    "num_nodes_avg": 46.0,
                    "path_length_avg": 130.63225469658005,
                    "smoothness_avg": 0.1675633775014901,
                    "success_improvement": 0.0,
                    "time_improvement": 88.25074150050804,
                    "node_improvement": 94.15130324221234,
                    "length_improvement": 13.240276470042689,
                    "smoothness_improvement": 2031.3937935769857,
                    "objective_score": 44.57635730006295
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "ZIP-Connect BiRRT: A time-minimal bidirectional RRT-Connect with grid-ANN and two-stage direct shots. It avoids global scans and rewiring, expands via greedy micro-extensions, and attempts immediate cross-tree connection each step. It performs early straight-line tests, maintains compact hash grids per tree, and applies ultra-light post-processing (visibility prune, few shortcuts, light relax) for fast, short, smooth paths.",
          "planning_mechanism": "Mechanism: Build two trees from start and goal. At each iteration, pick the smaller tree to grow; sample using goal/anchor-biased or informed uniform sampling. Find an approximate nearest via grid-ring lookup (fallback to the last node), then greedily extend toward the sample in fixed steps, inserting nodes only after passing point and edge collision checks. After each successful step, immediately try to connect to the opposite tree by extending toward its nearest node; if a collision-free link is found, stitch the two traced paths and finish with quick pruning/shortcutting/relaxation, then return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=6.0,\n                 goal_bias=0.25,\n                 shot_bias=0.35,\n                 connect_limit=12,\n                 shortcut_attempts=24,\n                 relax_passes=2):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.shot_bias = float(shot_bias)\n        self.connect_limit = int(max(1, connect_limit))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.relax_passes = int(max(0, relax_passes))\n        self._rng = 1\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", [])) if getattr(map, \"obstacles\", None) is not None else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        self.grid_h = max(1.0, 0.9 * (self.step if self.step > 0.0 else 5.0))\n        GA, GB = {}, {}\n        Ta, Tb = [], []\n\n        ra = Node(self.start, None, 0.0)\n        rb = Node(self.goal, None, 0.0)\n        Ta.append(ra)\n        Tb.append(rb)\n        nodes.extend([ra, rb])\n        self._grid_add(GA, ra)\n        self._grid_add(GB, rb)\n        lastA, lastB = ra, rb\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            growA = (len(Ta) <= len(Tb))\n            T = Ta if growA else Tb\n            O = Tb if growA else Ta\n            G = GA if growA else GB\n            GO = GB if growA else GA\n            anchor = self.goal if growA else self.start\n            fallback = lastA if growA else lastB\n\n            qrand = self._pick_sample(anchor, best_len)\n            if qrand is None:\n                continue\n\n            qnear = self._grid_nearest(G, qrand)\n            if qnear is None:\n                qnear = fallback\n\n            new_node, extended = self._greedy_extend(qnear, qrand, T, G, nodes, edges)\n            if extended:\n                if growA:\n                    lastA = new_node\n                else:\n                    lastB = new_node\n\n                meet, connected = self._try_connect(new_node, O, GO, nodes, edges)\n                if connected:\n                    if growA:\n                        pa = self._trace(new_node)\n                        pb = self._trace(meet)\n                    else:\n                        pa = self._trace(meet)\n                        pb = self._trace(new_node)\n                    full = pa + pb[::-1][1:]\n                    L = self._path_len(full)\n                    if best_len is None or L < best_len:\n                        best_len = L\n                    path = self._finalize(full)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # --- Core expansion ---\n\n    def _greedy_extend(self, start_node, target, tree, grid, nodes, edges):\n        cur = start_node\n        limit = self.connect_limit\n        k = 0\n        while k < limit:\n            nxt_pos = self._steer(cur.position, target, self.step)\n            if self._same_point(nxt_pos, cur.position):\n                break\n            if (not self._in_bounds(nxt_pos)) or self._point_blocked(nxt_pos):\n                break\n            if not self._edge_free(cur.position, nxt_pos):\n                break\n            new_cost = cur.cost + self._dist(cur.position, nxt_pos)\n            nn = Node(nxt_pos, cur, new_cost)\n            # Both checks already performed above; still satisfy contract explicitly\n            if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                break\n            nodes.append(nn)\n            tree.append(nn)\n            self._grid_add(grid, nn)\n            edges.append((cur, nn))\n            cur = nn\n            k += 1\n            if self._dist2(nxt_pos, target) <= (self.step * self.step * 0.25):\n                break\n        return cur, (cur is not start_node)\n\n    def _try_connect(self, from_node, other_tree, other_grid, nodes, edges):\n        near = self._grid_nearest(other_grid, from_node.position)\n        if near is None:\n            near = other_tree[-1]\n        # Quick direct attempt\n        if self._edge_free(from_node.position, near.position):\n            edges.append((from_node, near))\n            return near, True\n        # Micro-bridge from the nearest in the other tree\n        cur = near\n        steps = 0\n        while steps < self.connect_limit:\n            nxt = self._steer(cur.position, from_node.position, self.step)\n            if self._same_point(nxt, cur.position):\n                break\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                break\n            if not self._edge_free(cur.position, nxt):\n                break\n            nn = Node(nxt, cur, cur.cost + self._dist(cur.position, nxt))\n            if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                break\n            nodes.append(nn)\n            other_tree.append(nn)\n            self._grid_add(other_grid, nn)\n            edges.append((cur, nn))\n            cur = nn\n            if self._edge_free(cur.position, from_node.position):\n                edges.append((cur, from_node))\n                return cur, True\n            steps += 1\n        return near, False\n\n    # --- Sampling ---\n\n    def _pick_sample(self, anchor, c_best):\n        r = self._rand()\n        if r < self.goal_bias:\n            if self._in_bounds(anchor) and (not self._point_blocked(anchor)):\n                return anchor\n        if c_best is not None and r < self.goal_bias + self.shot_bias:\n            p = self._informed_sample(c_best * 1.01)\n            if p is not None:\n                return p\n        tries = 12\n        while tries > 0:\n            tries -= 1\n            if self.is3:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n            else:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        return None\n\n    def _informed_sample(self, max_sum):\n        c = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half) for _ in range(self.dim)]\n        tries = 20\n        while tries > 0:\n            tries -= 1\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= max_sum + 1e-9:\n                return p\n        return None\n\n    # --- Geometry and grids ---\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            t = tuple(b[i] for i in range(self.dim))\n        else:\n            d = d2 ** 0.5\n            r = step / d\n            t = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n        # clamp\n        return tuple(min(max(t[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _same_point(self, a, b):\n        if self.dim == 2:\n            return abs(a[0] - b[0]) < 1e-9 and abs(a[1] - b[1]) < 1e-9\n        else:\n            return abs(a[0] - b[0]) < 1e-9 and abs(a[1] - b[1]) < 1e-9 and abs(a[2] - b[2]) < 1e-9\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _gkey(self, p):\n        if self.is3:\n            return (int(p[0] // self.grid_h), int(p[1] // self.grid_h), int(p[2] // self.grid_h))\n        else:\n            return (int(p[0] // self.grid_h), int(p[1] // self.grid_h))\n\n    def _grid_add(self, grid, node):\n        k = self._gkey(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _grid_nearest(self, grid, pos):\n        kk = self._gkey(pos)\n        best = None\n        bd = 1e100\n        for r in (0, 1, 2):\n            cand = self._grid_collect(grid, kk, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bd:\n                    bd = d2\n                    best = n\n            if best is not None:\n                return best\n        return None\n\n    # --- Collision ---\n\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self._obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self._obin.get(key)\n                            if lst is None:\n                                self._obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self._obin.get(key)\n                        if lst is None:\n                            self._obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_bucket(self, p):\n        if self.is3:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell),\n                                   int(p[2] // self.obs_cell)))\n        else:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell)))\n\n    def _point_blocked(self, p):\n        bucket = self._point_bucket(p)\n        if not bucket:\n            return False\n        if self.is3:\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        if self.is3:\n            mn = (a[0] if a[0] < b[0] else b[0],\n                  a[1] if a[1] < b[1] else b[1],\n                  a[2] if a[2] < b[2] else b[2])\n            mx = (a[0] if a[0] > b[0] else b[0],\n                  a[1] if a[1] > b[1] else b[1],\n                  a[2] if a[2] > b[2] else b[2])\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            iz0 = int(max(0.0, mn[2]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mx[2]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self._obin.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            if not cand:\n                return True\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            mn = (a[0] if a[0] < b[0] else b[0],\n                  a[1] if a[1] < b[1] else b[1])\n            mx = (a[0] if a[0] > b[0] else b[0],\n                  a[1] if a[1] > b[1] else b[1])\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self._obin.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            if not cand:\n                return True\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # --- Path utilities ---\n\n    def _trace(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        out.reverse()\n        return out\n\n    def _path_len(self, pts):\n        if len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _prune_visible(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        res = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            chosen = i + 1\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    chosen = j\n                    break\n                j -= 1\n            res.append(pts[chosen])\n            i = chosen\n        return res\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        best = self._path_len(cur)\n        tries = 0\n        n = len(cur)\n        while tries < attempts and n > 2:\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            a, b = cur[i], cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    cur = cand\n                    n = len(cur)\n                    best = L\n            tries += 1\n        return cur\n\n    def _relax(self, pts, passes):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        alpha = 0.45\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                c = cur[i + 1]\n                t = tuple((1.0 - alpha) * cur[i][k] + alpha * 0.5 * (a[k] + c[k]) for k in range(self.dim))\n                if (not self._in_bounds(t)) or self._point_blocked(t):\n                    continue\n                if self._edge_free(a, t) and self._edge_free(t, c):\n                    if t != cur[i]:\n                        cur[i] = t\n                        moved = True\n            if not moved:\n                break\n        return cur\n\n    def _finalize(self, path):\n        p = self._prune_visible(path)\n        p = self._shortcut(p, self.shortcut_attempts)\n        p = self._relax(p, self.relax_passes)\n        p = self._prune_visible(p)\n        # dedup\n        out = []\n        last = None\n        for q in p:\n            if (last is None) or (q != last):\n                out.append(q)\n                last = q\n        return out\n\n    # --- RNG ---\n\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        vals = list(self.start) + list(self.goal) + [len(self.obstacles)]\n        for v in vals:\n            s ^= (int(v * 1000003) + (s << 6) + (s >> 2)) & 0xffffffff\n        self._rng = s & 0xffffffff or 1\n\n    def _rand(self):\n        # xorshift32\n        x = self._rng & 0xffffffff\n        x ^= (x << 13) & 0xffffffff\n        x ^= (x >> 17) & 0xffffffff\n        x ^= (x << 5) & 0xffffffff\n        self._rng = x & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()",
          "objective": -46.01884,
          "time_improvement": 85.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 2490.0,
          "node_improvement": 73.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0067004203796386715,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 155.2882442089263,
                    "smoothness_avg": 0.08485101195577995,
                    "success_improvement": 0.0,
                    "time_improvement": 72.929987227673,
                    "node_improvement": 66.50717703349282,
                    "length_improvement": 14.8840526493906,
                    "smoothness_improvement": 1228.1025940295524,
                    "objective_score": 36.94994072808402
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.00830092430114746,
                    "num_nodes_avg": 224.0,
                    "path_length_avg": 259.24792604615595,
                    "smoothness_avg": 0.19619608299383323,
                    "success_improvement": 0.0,
                    "time_improvement": 94.95160198614848,
                    "node_improvement": 84.9492709803131,
                    "length_improvement": 13.455580247985823,
                    "smoothness_improvement": 4948.2665297579415,
                    "objective_score": 61.300161393425746
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.006450390815734864,
                    "num_nodes_avg": 244.0,
                    "path_length_avg": 132.66575585273932,
                    "smoothness_avg": 0.10955817419808564,
                    "success_improvement": 0.0,
                    "time_improvement": 87.349063789852,
                    "node_improvement": 68.97647806738716,
                    "length_improvement": 11.88972182704114,
                    "smoothness_improvement": 1293.5718890564224,
                    "objective_score": 39.806411678462396
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "MINI-Connect BiRRT+: A compact bidirectional RRT-Connect with informed bias, duplicate suppression, obstacle binning, and safe corner smoothing. It emphasizes fast, robust planning with competitive path length and high smoothness through a simple expansion core and lightweight post-processing.",
          "planning_mechanism": "Planning mechanism: Alternate single-step growth from start/goal trees toward a biased target; validate both node and edge before insertion. After each accepted step, greedily connect the opposite tree with repeated steps toward the new point. On meeting, assemble and refine the path via visibility pruning, randomized shortcuts, and collision-aware corner smoothing. An incumbent path, updated opportunistically by cross-tree visibility, enables informed sampling.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=8.0,\n        goal_bias=0.25,\n        corridor_bias=0.25,\n        informed_bias=0.50,\n        grid_cell_factor=2.0,\n        dup_factor=0.5,\n        shortcut_trials=120,\n        smooth_passes=3\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dup_factor = float(dup_factor)\n        self.shortcut_trials = int(max(0, shortcut_trials))\n        self.smooth_passes = int(max(0, smooth_passes))\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if getattr(map, \"obstacles\", None) else []\n\n        nodes = []\n        edges = []\n        self._nodes = nodes\n        self._edges = edges\n\n        # Validate endpoints\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight-line solution\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Derived params\n        self.node_cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_radius = max(0.4, self.step * self.dup_factor)\n        self.corridor_w = max(self.step, 0.15 * self._dist(self.start, self.goal))\n\n        # Trees and node grids\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, a_root)\n        self._grid_add(Gb, b_root)\n        nodes.extend([a_root, b_root])\n\n        best_path = None\n        best_len = None\n\n        for it in range(self.max_iter):\n            grow_a = (it & 1) == 0\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            attractor = self.goal if grow_a else self.start\n\n            target = self._sample_target(attractor, best_len)\n            if target is None:\n                continue\n\n            # Extend one step from nearest towards target\n            base = self._nearest(G, target, T)\n            if base is None:\n                continue\n            new_node = self._extend_from(base, target, T, G)\n            if new_node is None:\n                continue\n\n            # Opportunistic incumbent update via direct cross-tree visibility\n            other = self._nearest(Gopp, new_node.position, Topp)\n            if other is not None and self._edge_free(new_node.position, other.position):\n                cand = self._assemble(new_node, other, grow_a)\n                L = self._path_len(cand)\n                if best_len is None or L < best_len:\n                    best_len = L\n                    best_path = cand\n\n            # Try greedy connect from opposite tree towards the new node\n            meet = self._connect_towards(Topp, Gopp, new_node.position)\n            if meet is not None and meet.position == new_node.position:\n                raw = self._assemble(new_node, meet, grow_a)\n                path = self._postprocess(raw)\n                return PlannerResult(True, path, Ta + Tb, edges)\n\n        # Fallback to best found\n        if best_path is not None:\n            path = self._postprocess(best_path)\n            return PlannerResult(True, path, Ta + Tb, edges)\n\n        return PlannerResult(False, [], Ta + Tb, edges)\n\n    # ---------- RNG ----------\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            s ^= (int((v + 0.5) * 977) + 41) & 0xffffffff\n            s = (s * 1664525 + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) + 17) * 1103515245 & 0xffffffff\n        self._rng = s if s != 0 else 2463534242\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # ---------- Node spatial hashing ----------\n    def _cell_key(self, p):\n        return tuple(int(p[i] // self.node_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_query(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        span = int(radius // self.node_cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.dim == 3:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _nearest(self, grid, pos, tree):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        # expand ring up to radius 3\n        for r in range(0, 4):\n            cand = []\n            if self.dim == 3:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                            if lst:\n                                cand.extend(lst)\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy))\n                        if lst:\n                            cand.extend(lst)\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                if best is not None:\n                    return best\n        # fallback light scan\n        if not tree:\n            return None\n        step = max(1, len(tree) // 64)\n        for i in range(0, len(tree), step):\n            n = tree[i]\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        return best\n\n    def _has_duplicate(self, grid, pos, radius):\n        return len(self._grid_query(grid, pos, radius)) > 0\n\n    # ---------- Obstacles & collision ----------\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self.dim == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            self._obin_add((i, j, k), idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        self._obin_add((i, j), idx)\n\n    def _obin_add(self, key, idx):\n        lst = self.obin.get(key)\n        if lst is None:\n            self.obin[key] = [idx]\n        else:\n            lst.append(idx)\n\n    def _bucket_candidates(self, a, b):\n        if self.dim == 3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self.obin.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            return cand\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self.obin.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            return cand\n\n    def _point_blocked(self, p):\n        if self.dim == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            lst = self.obin.get((ix, iy, iz))\n            if not lst:\n                return False\n            x, y, z = p\n            for idx in lst:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            lst = self.obin.get((ix, iy))\n            if not lst:\n                return False\n            x, y = p\n            for idx in lst:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            q = p1[i]\n            d = q - p\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _edge_free(self, a, b):\n        cand = self._bucket_candidates(a, b)\n        if not cand:\n            return True\n        if self.dim == 3:\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    # ---------- Expansion ----------\n    def _extend_from(self, base, target, tree, grid):\n        newp = self._steer(base.position, target, self.step)\n        if newp == base.position:\n            return None\n        if (not self._in_bounds(newp)) or self._point_blocked(newp):\n            return None\n        if not self._edge_free(base.position, newp):\n            return None\n        if self._has_duplicate(grid, newp, self.dup_radius):\n            return None\n        nn = Node(newp, base, base.cost + self._dist(base.position, newp))\n        base.add_child(nn)\n        tree.append(nn)\n        self._nodes.append(nn)\n        self._edges.append((base, nn))\n        self._grid_add(grid, nn)\n        return nn\n\n    def _connect_towards(self, tree, grid, target_point):\n        # Greedy multiple steps toward target; returns last added node, or None if blocked immediately.\n        base = self._nearest(grid, target_point, tree)\n        if base is None:\n            return None\n        last = None\n        cap = 64\n        while cap > 0:\n            cap -= 1\n            nxt = self._extend_from(base, target_point, tree, grid)\n            if nxt is None:\n                break\n            last = nxt\n            base = nxt\n            if nxt.position == target_point:\n                return nxt\n            # If we are very close and can snap exactly\n            if self._dist(nxt.position, target_point) <= self.step and self._edge_free(nxt.position, target_point):\n                # Snap: ensure point-valid and no duplicate\n                tp = target_point\n                if (not self._point_blocked(tp)) and (not self._has_duplicate(grid, tp, self.dup_radius)):\n                    snap = Node(tp, nxt, nxt.cost + self._dist(nxt.position, tp))\n                    nxt.add_child(snap)\n                    tree.append(snap)\n                    self._nodes.append(snap)\n                    self._edges.append((nxt, snap))\n                    self._grid_add(grid, snap)\n                    return snap\n                else:\n                    # cannot snap; stop\n                    break\n        return last\n\n    # ---------- Sampling ----------\n    def _sample_target(self, attractor, best_len):\n        tries = 18\n        while tries > 0:\n            tries -= 1\n            r = self._rand()\n            p = None\n            if best_len is not None and r < self.informed_bias:\n                p = self._sample_informed(best_len * 1.02)\n            if p is None:\n                r2 = self._rand()\n                if r2 < self.goal_bias:\n                    p = attractor\n                elif r2 < self.goal_bias + self.corridor_bias:\n                    t = self._rand()\n                    base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n                    if self.dim == 3:\n                        p = (self._rand_range(base[0] - self.corridor_w, base[0] + self.corridor_w),\n                             self._rand_range(base[1] - self.corridor_w, base[1] + self.corridor_w),\n                             self._rand_range(base[2] - self.corridor_w, base[2] + self.corridor_w))\n                    else:\n                        p = (self._rand_range(base[0] - self.corridor_w, base[0] + self.corridor_w),\n                             self._rand_range(base[1] - self.corridor_w, base[1] + self.corridor_w))\n                else:\n                    if self.dim == 3:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]),\n                             self._rand_range(0.0, self.bounds[2]))\n                    else:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]))\n            if p is None:\n                continue\n            p = self._clamp(p)\n            if not self._point_blocked(p):\n                return p\n        return None\n\n    def _sample_informed(self, max_sum):\n        c = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        for _ in range(24):\n            if self.dim == 3:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half),\n                     self._rand_range(c[2] - half, c[2] + half))\n            else:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half))\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= max_sum + 1e-9:\n                return p\n        return None\n\n    # ---------- Path assembly and postprocess ----------\n    def _trace(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _assemble(self, u, v, a_side):\n        pu = self._trace(u)\n        pv = self._trace(v)\n        if a_side:\n            # start->u + v->goal reversed\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        out[0] = pts[0]\n        out[-1] = pts[-1]\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3 or attempts <= 0:\n            return pts[:]\n        cur = list(pts)\n        best = self._path_len(cur)\n        stall = 0\n        for _ in range(attempts):\n            if len(cur) < 3:\n                break\n            i = int(self._rand_range(0, len(cur) - 2))\n            j = int(self._rand_range(i + 2, len(cur)))\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    cur = cand\n                    best = L\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            if stall > 64:\n                break\n        return cur\n\n    def _smooth_corners(self, pts, passes):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = list(pts)\n        for _ in range(passes):\n            k = 1\n            while k < len(cur) - 1:\n                a = cur[k - 1]\n                b = cur[k]\n                c = cur[k + 1]\n                # Weighted corner pull\n                newp = tuple(0.25 * a[i] + 0.5 * b[i] + 0.25 * c[i] for i in range(self.dim))\n                if (not self._point_blocked(newp)) and self._edge_free(a, newp) and self._edge_free(newp, c):\n                    cur[k] = newp\n                k += 1\n        cur[0] = pts[0]\n        cur[-1] = pts[-1]\n        return cur\n\n    def _postprocess(self, path):\n        p0 = self._visibility_prune(path)\n        p1 = self._shortcut(p0, self.shortcut_trials)\n        p2 = self._smooth_corners(p1, self.smooth_passes)\n        return p2",
          "objective": -42.99999,
          "time_improvement": 72.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 2430.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014277505874633788,
                    "num_nodes_avg": 76.0,
                    "path_length_avg": 167.21355485066445,
                    "smoothness_avg": 0.04013469633201503,
                    "success_improvement": 0.0,
                    "time_improvement": 42.1290717238007,
                    "node_improvement": 80.86124401913875,
                    "length_improvement": 8.347600918014143,
                    "smoothness_improvement": 528.1951514840665,
                    "objective_score": 20.288257825369026
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022111225128173827,
                    "num_nodes_avg": 121.0,
                    "path_length_avg": 242.3049263601756,
                    "smoothness_avg": 0.1876430362390729,
                    "success_improvement": 0.0,
                    "time_improvement": 86.77966198339568,
                    "node_improvement": 91.869918699187,
                    "length_improvement": 19.111641220372025,
                    "smoothness_improvement": 4728.1904762473905,
                    "objective_score": 61.14183570847888
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.007026815414428711,
                    "num_nodes_avg": 81.0,
                    "path_length_avg": 121.51158192729731,
                    "smoothness_avg": 0.167728285331934,
                    "success_improvement": 0.0,
                    "time_improvement": 86.07909606654616,
                    "node_improvement": 89.70120788302607,
                    "length_improvement": 19.297793043634346,
                    "smoothness_improvement": 2033.4914090080024,
                    "objective_score": 47.569861691184464
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "BiCon-Lite*: Simplified Bi-directional RRT-Connect with local best-parent and light rewiring. It grows two trees from start and goal using uniform sampling with small goal bias and informed sampling once a path bound is known. Each added node is chosen from a few nearest candidates by lowest path cost if the edge is collision-free; after insertion, nearby nodes can be rewired if cheaper. Trees greedily connect toward each other; upon connection, the path is visibility-pruned and shortcut for length and smoothness.",
          "planning_mechanism": "Alternate expanding start/goal trees. For each iteration: sample a target (uniform, goal-biased, or informed ellipse), steer one step from the nearest node, reject if outside/duplicate/colliding, then pick a best feasible parent among k-nearest to insert. Lightly rewire nearby neighbors if the new route is cheaper (cycle-safe). Attempt a greedy connect from the opposite tree toward the new node by incremental steps; if it reaches within one step and the final edge is free, extract the full path (start-to-A, cross-edge, B-to-goal), then prune and shortcut. Always check node and edge collisions before adding any node or edge.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n\n    def attach(self, new_parent):\n        if new_parent is self.parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            if self not in new_parent.children:\n                new_parent.children.append(self)\n\n    def is_ancestor_of(self, other):\n        cur = other\n        while cur is not None:\n            if cur is self:\n                return True\n            cur = cur.parent\n        return False\n\n    def propagate_cost(self, delta):\n        if delta == 0.0:\n            return\n        self.cost += delta\n        for c in self.children:\n            c.propagate_cost(delta)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=10.0,\n        goal_bias=0.1,\n        informed_bias=0.5,\n        dupe_radius_ratio=0.5,\n        neighbor_radius_factor=2.5,\n        k_near=5,\n        shortcut_attempts=80\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.neighbor_radius_factor = float(neighbor_radius_factor)\n        self.k_near = int(k_near)\n        self.shortcut_attempts = int(shortcut_attempts)\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obstacle(self.start) or self._point_in_obstacle(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        self._seed_rng()\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.neighbor_radius = max(self.step_size * 1.5, self.step_size * self.neighbor_radius_factor)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            edges = [(n0, n1)]\n            return PlannerResult(True, self._finalize_path([self.start, self.goal]), [n0, n1], edges)\n\n        nodes = []\n        edges = []\n\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        A = [a_root]\n        B = [b_root]\n\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            grow_A = (it % 2 == 0)\n            T = A if grow_A else B\n            O = B if grow_A else A\n            attractor = self.goal if grow_A else self.start\n\n            qrand = self._sample(attractor, best_len)\n            if qrand is None:\n                continue\n\n            qnear = self._nearest_in(T, qrand)\n            if qnear is None:\n                continue\n\n            qnew_pos = self._steer(qnear.position, qrand)\n            if not self._in_bounds(qnew_pos):\n                continue\n            if self._point_in_obstacle(qnew_pos):\n                continue\n            if self._has_near_in(T, qnew_pos, self.dupe_radius):\n                continue\n\n            parent = self._best_parent(T, qnew_pos, qnear)\n            if parent is None:\n                continue\n            if not self._edge_free(parent.position, qnew_pos):\n                continue\n\n            qnew_cost = parent.cost + self._dist(parent.position, qnew_pos)\n            qnew = Node(qnew_pos, parent, qnew_cost)\n            T.append(qnew)\n            nodes.append(qnew)\n            edges.append((parent, qnew))\n\n            self._light_rewire(T, qnew, edges)\n\n            ok, last_other, added = self._connect_toward(O, qnew.position, nodes, edges)\n            if ok and last_other is not None:\n                edges.append((last_other, qnew))\n                path = self._extract_path(qnew, last_other)\n                best_len = self._path_len(path)\n                return PlannerResult(True, self._finalize_path(path), nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0xA5A5A5A5\n        for v in self.start + self.goal:\n            s ^= (int(v * 1315423911) + (s << 7) + (s >> 3)) & 0xffffffff\n            s &= 0xffffffff\n        s ^= (len(self.obstacles) * 0x9E3779B9) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            tgt = a\n        elif d <= self.step_size:\n            tgt = b\n        else:\n            r = self.step_size / d\n            tgt = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n        out = tuple(max(0.0, min(tgt[i], self.bounds[i])) for i in range(self.dims))\n        return out\n\n    # Nearest and neighbors\n    def _nearest_in(self, nodes_list, pos):\n        best = None\n        bd = 1e100\n        for n in nodes_list:\n            d = self._dist(n.position, pos)\n            if d < bd:\n                bd = d\n                best = n\n        return best\n\n    def _k_nearest_in(self, nodes_list, pos, k):\n        if not nodes_list:\n            return []\n        pairs = []\n        for n in nodes_list:\n            pairs.append((self._dist(n.position, pos), n))\n        pairs.sort(key=lambda x: x[0])\n        out = [n for _, n in pairs[:max(1, k)]]\n        return out\n\n    def _neighbors_radius(self, nodes_list, pos, radius):\n        out = []\n        r = float(radius)\n        for n in nodes_list:\n            if self._dist(n.position, pos) <= r:\n                out.append(n)\n        return out\n\n    def _has_near_in(self, nodes_list, pos, radius):\n        r = float(radius)\n        for n in nodes_list:\n            if self._dist(n.position, pos) <= r:\n                return True\n        return False\n\n    # Parent selection\n    def _best_parent(self, nodes_list, qpos, fallback):\n        cands = self._k_nearest_in(nodes_list, qpos, self.k_near)\n        if fallback not in cands:\n            cands.append(fallback)\n        best = None\n        best_cost = 1e100\n        for p in cands:\n            if not self._edge_free(p.position, qpos):\n                continue\n            c = p.cost + self._dist(p.position, qpos)\n            if c < best_cost:\n                best_cost = c\n                best = p\n        return best\n\n    # Light rewiring\n    def _light_rewire(self, nodes_list, qnew, edges):\n        nbrs = self._neighbors_radius(nodes_list, qnew.position, self.neighbor_radius)\n        rewired = 0\n        for w in nbrs:\n            if w is qnew or w is qnew.parent:\n                continue\n            if w.is_ancestor_of(qnew):\n                continue\n            d = self._dist(qnew.position, w.position)\n            cand_cost = qnew.cost + d\n            if cand_cost + 1e-12 < w.cost and self._edge_free(qnew.position, w.position):\n                oldp = w.parent\n                self._replace_edge(edges, oldp, w, qnew)\n                w.attach(qnew)\n                delta = cand_cost - w.cost\n                w.propagate_cost(delta)\n                rewired += 1\n                if rewired >= 10:\n                    break\n\n    # Connect toward a target (other tree growth)\n    def _connect_toward(self, tree_nodes, target_pos, all_nodes, edges):\n        if not tree_nodes:\n            return False, None, []\n        cur = self._nearest_in(tree_nodes, target_pos)\n        added = []\n        for _ in range(1000):\n            nxt = self._steer(cur.position, target_pos)\n            if self._dist(cur.position, nxt) <= 1e-9:\n                break\n            if not self._in_bounds(nxt):\n                break\n            if self._point_in_obstacle(nxt):\n                break\n            if self._has_near_in(tree_nodes, nxt, self.dupe_radius):\n                # If very close to some node, snap to the nearest and continue\n                cur = self._nearest_in(tree_nodes, nxt)\n                if self._dist(cur.position, target_pos) <= self.step_size and self._edge_free(cur.position, target_pos):\n                    return True, cur, added\n                continue\n            if not self._edge_free(cur.position, nxt):\n                break\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            q = Node(nxt, cur, new_cost)\n            tree_nodes.append(q)\n            all_nodes.append(q)\n            edges.append((cur, q))\n            added.append(q)\n            cur = q\n            if self._dist(cur.position, target_pos) <= self.step_size and self._edge_free(cur.position, target_pos):\n                return True, cur, added\n        return False, cur, added\n\n    # Collision\n    def _point_in_obstacle(self, p):\n        if self.is3d:\n            px, py, pz = p\n            for x, y, z, w, h, d in self.obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            px, py = p\n            for x, y, w, h in self.obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        if self.is3d:\n            for x, y, z, w, h, d in self.obstacles:\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return False\n            return True\n        else:\n            for x, y, w, h in self.obstacles:\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return False\n            return True\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Edges\n    def _replace_edge(self, edges, old_parent, child, new_parent):\n        if old_parent is not None:\n            rm = -1\n            for i, (u, v) in enumerate(edges):\n                if u is old_parent and v is child:\n                    rm = i\n                    break\n            if rm >= 0:\n                edges.pop(rm)\n        if new_parent is not None:\n            exists = False\n            for u, v in edges:\n                if u is new_parent and v is child:\n                    exists = True\n                    break\n            if not exists:\n                edges.append((new_parent, child))\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        for _ in range(24):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p is not None and not self._point_in_obstacle(p):\n                    return p\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n                if self._in_bounds(p) and not self._point_in_obstacle(p):\n                    return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(16):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._in_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Path ops\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        return pa + pb[::-1]\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(pruned[-1], path[j]):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best_L = self._path_len(pts)\n        tries = 0\n        while tries < attempts and len(pts) > 2:\n            n = len(pts)\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                cand = pts[:i + 1] + pts[j:]\n                L = self._path_len(cand)\n                if L <= best_L + 1e-12:\n                    pts = cand\n                    best_L = L\n            tries += 1\n        return pts\n\n    def _finalize_path(self, path):\n        if not path:\n            return []\n        p = self._visibility_prune(path)\n        p = self._shortcut(p, self.shortcut_attempts)\n        return p",
          "objective": -42.61971,
          "time_improvement": 88.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1715.0,
          "node_improvement": 94.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.005434727668762207,
                    "num_nodes_avg": 33.0,
                    "path_length_avg": 172.03461483544805,
                    "smoothness_avg": 0.051447969062332066,
                    "success_improvement": 0.0,
                    "time_improvement": 77.97145118473429,
                    "node_improvement": 91.68975069252078,
                    "length_improvement": 5.705101545770078,
                    "smoothness_improvement": 705.2724368784732,
                    "objective_score": 30.3408584672747
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.012911844253540038,
                    "num_nodes_avg": 78.0,
                    "path_length_avg": 254.30361579440722,
                    "smoothness_avg": 0.12651907716440625,
                    "success_improvement": 0.0,
                    "time_improvement": 92.27998699936137,
                    "node_improvement": 94.75912114493046,
                    "length_improvement": 15.106133324099327,
                    "smoothness_improvement": 3155.4269834480324,
                    "objective_score": 52.52481101150817
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0025941610336303713,
                    "num_nodes_avg": 30.0,
                    "path_length_avg": 125.19016890049133,
                    "smoothness_avg": 0.10884440067125287,
                    "success_improvement": 0.0,
                    "time_improvement": 94.86067807289716,
                    "node_improvement": 96.18563254926892,
                    "length_improvement": 16.854650731526867,
                    "smoothness_improvement": 1284.492742480391,
                    "objective_score": 44.99345757318722
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "ZIP-Connect: a zero-idle, proximity-gated bi-directional RRT-Connect that accelerates planning by accept-on-Halton sampling, micro-grid nearest queries, and intermittent meeting attempts. It reduces collision checks by only trying goal/opposite-tree connections when geometrically near, avoids greedy multi-step linking, enforces duplicate spacing, and performs a single-pass visibility prune with a tiny shortcut budget.",
          "planning_mechanism": "Alternate expanding start/goal trees. Per iteration: draw a free sample via goal bias then Halton scanning; find the nearest via a 0\u20131 ring micro-grid; steer one step; if node and edge are free and not too-close, insert. Attempt an exact meeting to the attractor or the opposite tree only when within a small distance window, then stitch through the meeting node. Finalize with a greedy line-of-sight prune and a couple of shortcuts.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=2500,\n        step_size=8.0,\n        goal_bias=0.07,\n        grid_cell_factor=1.0,\n        min_separation_mult=0.5,\n        connect_window_mult=2.5,\n        smooth_shortcuts=2\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.min_sep_mult = float(min_separation_mult)\n        self.conn_mult = float(connect_window_mult)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self._rng = 1\n        self._hidx = 1\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step * self.min_sep_mult)\n        self.conn_win = max(self.step * 1.5, self.step * self.conn_mult)\n\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Quick straight-line test\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize trees and grids\n        root_s = Node(self.start, None, 0.0)\n        root_g = Node(self.goal, None, 0.0)\n        Ta = [root_s]\n        Tb = [root_g]\n        Ga = {}\n        Gb = {}\n        self._grid_add(Ga, root_s)\n        self._grid_add(Gb, root_g)\n        nodes.extend([root_s, root_g])\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            T_src = Ta if active_start else Tb\n            T_dst = Tb if active_start else Ta\n            G_src = Ga if active_start else Gb\n            G_dst = Gb if active_start else Ga\n            attractor = self.goal if active_start else self.start\n            other_root = root_g if active_start else root_s\n\n            q_rand = self._sample_free(attractor)\n            if q_rand is None:\n                continue\n\n            n_near = self._nearest(G_src, q_rand, T_src)\n            if n_near is None:\n                continue\n\n            q_new = self._steer(n_near.position, q_rand, self.step)\n            if (not self._in_bounds(q_new)) or self._point_in_obstacles(q_new):\n                continue\n            if self._too_close(G_src, q_new, self.min_sep):\n                continue\n            if not self._edge_free(n_near.position, q_new):\n                continue\n\n            nn = self._insert_node(T_src, G_src, n_near, q_new, nodes, edges)\n            if nn is None:\n                continue\n\n            # Opportunistic direct connect to attractor (goal/start) only when near\n            d_att = self._dist(nn.position, attractor)\n            if d_att <= self.conn_win and self._edge_free(nn.position, attractor):\n                meet = self._insert_node(T_src, G_src, nn, attractor, nodes, edges)\n                if meet is not None:\n                    if active_start:\n                        pa = self._trace_to_root(meet)\n                        pb = self._trace_to_root(root_g)\n                    else:\n                        pa = self._trace_to_root(root_s)\n                        pb = self._trace_to_root(meet)\n                    # Stitch via exact meeting at attractor\n                    path = pa if active_start else pb\n                    path = self._finalize_path(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n            # Intermittent opposite-tree meeting when close\n            n_other = self._nearest(G_dst, nn.position, T_dst)\n            if n_other is not None:\n                d_opp = self._dist(nn.position, n_other.position)\n                if d_opp <= self.conn_win and self._edge_free(n_other.position, nn.position):\n                    # Prefer inserting an exact meeting into the opposite tree if allowable\n                    if (not self._too_close(G_dst, nn.position, self.min_sep)) and (not self._point_in_obstacles(nn.position)):\n                        meetB = self._insert_node(T_dst, G_dst, n_other, nn.position, nodes, edges)\n                    else:\n                        meetB = n_other\n                    if meetB is not None:\n                        if active_start:\n                            pa = self._trace_to_root(nn)\n                            pb = self._trace_to_root(meetB)\n                            path = pa + pb[-2::-1]\n                        else:\n                            pa = self._trace_to_root(meetB)\n                            pb = self._trace_to_root(nn)\n                            path = pa + pb[-2::-1]\n                        path = self._finalize_path(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG and Halton\n    def _seed_rng(self):\n        s = 0xA17E5EED\n        for v in self.start + self.goal:\n            iv = int(v * 1315423911) & 0xffffffff\n            s ^= (iv * 1103515245 + 12345) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 1\n        self._rng = s & 0xffffffff\n        self._hidx = 1\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _radical_inverse(self, base, i):\n        inv = 1.0 / base\n        f = inv\n        x = 0.0\n        n = i\n        while n > 0:\n            x += (n % base) * f\n            n //= base\n            f *= inv\n        return x\n\n    def _halton_point(self, idx):\n        if self.is3:\n            return (\n                self._radical_inverse(2, idx) * self.bounds[0],\n                self._radical_inverse(3, idx) * self.bounds[1],\n                self._radical_inverse(5, idx) * self.bounds[2],\n            )\n        else:\n            return (\n                self._radical_inverse(2, idx) * self.bounds[0],\n                self._radical_inverse(3, idx) * self.bounds[1],\n            )\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        out = []\n        for i in range(self.dim):\n            out.append(a[i] + (b[i] - a[i]) * r)\n        return self._clamp(tuple(out))\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # Spatial hash\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        else:\n            return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos, T_list):\n        key = self._cell_key(pos)\n        # Micro-ring search for speed; small random fallback\n        for r in (0, 1):\n            cand = self._collect_ring(grid, key, r)\n            if cand:\n                best = None\n                bestd = 1e100\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                return best\n        if not T_list:\n            return None\n        m = min(16, len(T_list))\n        best = None\n        bestd = 1e100\n        for _ in range(m):\n            j = int(self._rand_range(0, len(T_list)))\n            if j >= len(T_list):\n                j = len(T_list) - 1\n            n = T_list[j]\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius, limit=None):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n                                if limit is not None and len(out) >= limit:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n                            if limit is not None and len(out) >= limit:\n                                return out\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors_in_radius(grid, pos, radius, limit=1)) > 0\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            bucket = self.obin.get(key)\n                            if bucket is None:\n                                self.obin[key] = [idx]\n                            else:\n                                bucket.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        bucket = self.obin.get(key)\n                        if bucket is None:\n                            self.obin[key] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Sampling\n    def _sample_free(self, attractor):\n        r = self._rand()\n        if r < self.goal_bias:\n            return attractor\n        # Try a short Halton scan to find a free sample\n        trials = 0\n        idx = self._hidx\n        while trials < 6:\n            p = self._halton_point(idx)\n            idx += 1\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                self._hidx = idx\n                return p\n            trials += 1\n        # Fallback to uniform random attempts\n        tries = 0\n        while tries < 6:\n            if self.is3:\n                p = (\n                    self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]),\n                )\n            else:\n                p = (\n                    self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                )\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n            tries += 1\n        return None\n\n    # Insert node (assumes checks done)\n    def _insert_node(self, tree, grid, parent, pos, nodes, edges):\n        if (not self._in_bounds(pos)) or self._point_in_obstacles(pos):\n            return None\n        if self._too_close(grid, pos, self.min_sep):\n            return None\n        if not self._edge_free(parent.position, pos):\n            return None\n        new_cost = parent.cost + self._dist(parent.position, pos)\n        nn = Node(pos, parent, new_cost)\n        parent.add_child(nn)\n        tree.append(nn)\n        nodes.append(nn)\n        edges.append((parent, nn))\n        self._grid_add(grid, nn)\n        return nn\n\n    # Path utilities\n    def _trace_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        return out[::-1]\n\n    def _prune_visibility(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3 or attempts <= 0:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._prune_visibility(path)\n        p2 = self._shortcut(p1, self.smooth_shortcuts)\n        out = []\n        last = None\n        for p in p2:\n            if (last is None) or (p != last):\n                out.append(p)\n                last = p\n        return out",
          "objective": -42.25413,
          "time_improvement": 82.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1949.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.006530570983886719,
                    "num_nodes_avg": 51.0,
                    "path_length_avg": 165.30934267335007,
                    "smoothness_avg": 0.06354030894209622,
                    "success_improvement": 0.0,
                    "time_improvement": 73.52967609821906,
                    "node_improvement": 87.15688743389575,
                    "length_improvement": 9.391329786573037,
                    "smoothness_improvement": 894.54381493312,
                    "objective_score": 32.16641977607514
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.012840461730957032,
                    "num_nodes_avg": 115.0,
                    "path_length_avg": 229.6388777300784,
                    "smoothness_avg": 0.11761146977996584,
                    "success_improvement": 0.0,
                    "time_improvement": 92.32266672748835,
                    "node_improvement": 92.27306322650003,
                    "length_improvement": 23.33993282509405,
                    "smoothness_improvement": 2926.2278295561136,
                    "objective_score": 56.3318988610835
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010579800605773926,
                    "num_nodes_avg": 124.0,
                    "path_length_avg": 139.48550177732233,
                    "smoothness_avg": 0.1672303632461557,
                    "success_improvement": 0.0,
                    "time_improvement": 79.0402366958931,
                    "node_improvement": 84.23394787031151,
                    "length_improvement": 7.360371305336757,
                    "smoothness_improvement": 2027.1578768296877,
                    "objective_score": 38.26408317611842
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SWIFT-Connect: a lean bidirectional RRT-Connect with spatial hashing and duplicate suppression. It alternates tree growth, validates nodes and edges before commitment, greedily connects to the opposite tree, and exits on the first feasible bridge. Lightweight LOS collapse and shortcutting polish the path. The design trades heavy optimization for fast, robust, generalizable solves.",
          "planning_mechanism": "Alternate expanding start and goal trees. For each goal-biased sample, extend the active tree one validated step, then greedily advance the opposite tree toward it with multi-step connect; on a collision-free join, assemble the path and smooth via LOS and random shortcuts. Nearest lookups use a coarse grid; all samples stay within bounds and all nodes/edges are collision-checked before insertion.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            i = 0\n            while i < len(self.parent.children):\n                if self.parent.children[i] is self:\n                    self.parent.children.pop(i)\n                    break\n                i += 1\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=5.0,\n                 goal_bias=0.3,\n                 cell_factor=1.6,\n                 dupe_radius_ratio=0.4,\n                 smooth_shortcuts=80):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.cell_factor = float(cell_factor)\n        self.dupe_ratio = float(dupe_radius_ratio)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._build_obs_grid()\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        self.cell = max(1.0, self.step * self.cell_factor)\n        self.dupe_radius = max(0.5, self.dupe_ratio * self.step)\n\n        self._nodes = []\n        self._edges = []\n        rootA = Node(self.start, None, 0.0)\n        rootB = Node(self.goal, None, 0.0)\n        self._nodes.append(rootA)\n        self._nodes.append(rootB)\n\n        self._gridA = {}\n        self._gridB = {}\n        self._grid_add(self._gridA, rootA)\n        self._grid_add(self._gridB, rootB)\n\n        for it in range(self.max_iter):\n            use_A = (it % 2 == 0)\n            active_grid = self._gridA if use_A else self._gridB\n            other_grid = self._gridB if use_A else self._gridA\n            attractor = self.goal if use_A else self.start\n\n            target = self._sample_target(attractor)\n            if target is None:\n                continue\n\n            new_node = self._extend_one(active_grid, target)\n            if new_node is None:\n                continue\n\n            q_reached, ok = self._connect_greedy(other_grid, new_node.position)\n            if ok and self._edge_free(q_reached.position, new_node.position):\n                join = Node(new_node.position, q_reached, q_reached.cost + self._dist(q_reached.position, new_node.position))\n                join.attach(q_reached)\n                self._nodes.append(join)\n                self._edges.append((q_reached, join))\n                self._grid_add(other_grid, join)\n\n                if use_A:\n                    path1 = self._trace_to_root(new_node)\n                    path2 = self._trace_to_root(q_reached)\n                    path = path1 + list(reversed(path2))\n                else:\n                    path1 = self._trace_to_root(q_reached)\n                    path2 = self._trace_to_root(new_node)\n                    path = path1 + list(reversed(path2))\n\n                path = self._postprocess(path)\n                return PlannerResult(True, path, self._nodes, self._edges)\n\n        return PlannerResult(False, [], self._nodes, self._edges)\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _same_pos(self, a, b, eps=1e-9):\n        for i in range(self.dims):\n            if abs(a[i] - b[i]) > eps:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    def _build_obs_grid(self):\n        self.obs_cell = max(4.0, self.step * 2.0)\n        self._ogrid = {}\n        if self.is3d:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self._ogrid.get(k)\n                            if b is None:\n                                self._ogrid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self._ogrid.get(k)\n                        if b is None:\n                            self._ogrid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _cell_candidates(self, a, b):\n        if self.is3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            out = []\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        lst = self._ogrid.get((cx, cy, cz))\n                        if lst:\n                            out.extend(lst)\n            return out\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            out = []\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    lst = self._ogrid.get((cx, cy))\n                    if lst:\n                        out.extend(lst)\n            return out\n\n    def _point_blocked(self, p):\n        if self.is3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self._ogrid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            x0, y0, z0 = p\n            i = 0\n            while i < len(bucket):\n                x, y, z, w, h, d = self.obstacles[bucket[i]]\n                if x <= x0 <= x + w and y <= y0 <= y + h and z <= z0 <= z + d:\n                    return True\n                i += 1\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self._ogrid.get((cx, cy))\n            if not bucket:\n                return False\n            x0, y0 = p\n            i = 0\n            while i < len(bucket):\n                x, y, w, h = self.obstacles[bucket[i]]\n                if x <= x0 <= x + w and y <= y0 <= y + h:\n                    return True\n                i += 1\n            return False\n\n    def _seg_aabb_hit(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(self.dims):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _edge_free(self, a, b):\n        cand = self._cell_candidates(a, b)\n        if not cand:\n            return True\n        if self.is3d:\n            i = 0\n            while i < len(cand):\n                x, y, z, w, h, d = self.obstacles[cand[i]]\n                if self._seg_aabb_hit(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return False\n                i += 1\n            return True\n        else:\n            i = 0\n            while i < len(cand):\n                x, y, w, h = self.obstacles[cand[i]]\n                if self._seg_aabb_hit(a, b, (x, y), (x + w, y + h)):\n                    return False\n                i += 1\n            return True\n\n    def _cell_key(self, pos):\n        if self.is3d:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is3d:\n            dx = -r\n            while dx <= r:\n                dy = -r\n                while dy <= r:\n                    dz = -r\n                    while dz <= r:\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n                        dz += 1\n                    dy += 1\n                dx += 1\n        else:\n            dx = -r\n            while dx <= r:\n                dy = -r\n                while dy <= r:\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n                    dy += 1\n                dx += 1\n        return out\n\n    def _nearest(self, grid, pos):\n        k = self._cell_key(pos)\n        best = None\n        bd = 1e100\n        max_r = 2\n        r = 0\n        while r <= max_r:\n            cand = self._grid_ring(grid, k, r)\n            if cand:\n                i = 0\n                while i < len(cand):\n                    n = cand[i]\n                    d = self._dist(n.position, pos)\n                    if d < bd:\n                        bd = d\n                        best = n\n                    i += 1\n                if best is not None:\n                    return best\n            r += 1\n        for b in grid.values():\n            i = 0\n            while i < len(b):\n                n = b[i]\n                d = self._dist(n.position, pos)\n                if d < bd:\n                    bd = d\n                    best = n\n                i += 1\n        return best\n\n    def _has_close(self, grid, pos, radius):\n        k = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell) + 1)\n        lst = self._grid_ring(grid, k, rc)\n        r2 = radius * radius\n        i = 0\n        while i < len(lst):\n            n = lst[i]\n            s = 0.0\n            p = n.position\n            j = 0\n            while j < self.dims:\n                d = p[j] - pos[j]\n                s += d * d\n                j += 1\n            if s <= r2:\n                return True\n            i += 1\n        return False\n\n    def _extend_one(self, grid, target):\n        qnear = self._nearest(grid, target)\n        if qnear is None:\n            return None\n        qpos = self._steer(qnear.position, target, self.step)\n        if self._same_pos(qpos, qnear.position):\n            return None\n        if not self._in_bounds(qpos):\n            return None\n        if self._point_blocked(qpos):\n            return None\n        if not self._edge_free(qnear.position, qpos):\n            return None\n        if self._has_close(grid, qpos, self.dupe_radius):\n            return None\n        new_node = Node(qpos, qnear, qnear.cost + self._dist(qnear.position, qpos))\n        new_node.attach(qnear)\n        self._nodes.append(new_node)\n        self._edges.append((qnear, new_node))\n        self._grid_add(grid, new_node)\n        return new_node\n\n    def _connect_greedy(self, grid, target_pos):\n        qnear = self._nearest(grid, target_pos)\n        if qnear is None:\n            return None, False\n        cur = qnear\n        max_steps = max(1, int(self._dist(qnear.position, target_pos) / max(1e-9, self.step)) + 2)\n        if max_steps > 64:\n            max_steps = 64\n        steps = 0\n        while steps < max_steps:\n            if self._dist(cur.position, target_pos) <= self.step and self._edge_free(cur.position, target_pos):\n                return cur, True\n            qpos = self._steer(cur.position, target_pos, self.step)\n            if self._same_pos(qpos, cur.position):\n                break\n            if not self._in_bounds(qpos):\n                break\n            if self._point_blocked(qpos):\n                break\n            if not self._edge_free(cur.position, qpos):\n                break\n            if self._has_close(grid, qpos, self.dupe_radius):\n                break\n            nxt = Node(qpos, cur, cur.cost + self._dist(cur.position, qpos))\n            nxt.attach(cur)\n            self._nodes.append(nxt)\n            self._edges.append((cur, nxt))\n            self._grid_add(grid, nxt)\n            cur = nxt\n            steps += 1\n        return cur, False\n\n    def _sample_target(self, attractor):\n        if self._rand() < self.goal_bias:\n            return attractor\n        return self._random_free()\n\n    def _random_free(self):\n        tries = 64\n        while tries > 0:\n            tries -= 1\n            if self.is3d:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n            else:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n            if not self._point_blocked(p):\n                return p\n        return None\n\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        s = 0.0\n        i = 1\n        while i < len(path):\n            s += self._dist(path[i - 1], path[i])\n            i += 1\n        return s\n\n    def _los_collapse(self, path, rounds=3):\n        if len(path) < 3:\n            return path[:]\n        cur = path[:]\n        r = 0\n        while r < rounds:\n            out = [cur[0]]\n            anchor = cur[0]\n            i = 1\n            while i < len(cur) - 1:\n                if self._edge_free(anchor, cur[i + 1]):\n                    i += 1\n                    continue\n                out.append(cur[i])\n                anchor = cur[i]\n                i += 1\n            out.append(cur[-1])\n            if len(out) == len(cur):\n                break\n            cur = out\n            r += 1\n        return cur\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = path[:]\n        best = self._path_len(pts)\n        t = 0\n        while t < attempts and len(pts) >= 3:\n            n = len(pts)\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j > n - 1:\n                t += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                cand = pts[:i + 1] + pts[j:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    pts = cand\n                    best = L\n            t += 1\n        return pts\n\n    def _postprocess(self, path):\n        p = path[:]\n        p = self._los_collapse(p, rounds=3)\n        p = self._shortcut(p, self.smooth_shortcuts)\n        p = self._los_collapse(p, rounds=2)\n        return p",
          "objective": -41.85803,
          "time_improvement": 74.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1880.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007715272903442383,
                    "num_nodes_avg": 73.0,
                    "path_length_avg": 160.85834898192107,
                    "smoothness_avg": 0.04902467731266237,
                    "success_improvement": 0.0,
                    "time_improvement": 68.72773096737596,
                    "node_improvement": 81.6167212289096,
                    "length_improvement": 11.83098995935377,
                    "smoothness_improvement": 667.3426587338824,
                    "objective_score": 31.05362655949446
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025490784645080568,
                    "num_nodes_avg": 183.3,
                    "path_length_avg": 234.9419709193859,
                    "smoothness_avg": 0.12316192274741442,
                    "success_improvement": 0.0,
                    "time_improvement": 84.75901776753946,
                    "node_improvement": 87.68393469058657,
                    "length_improvement": 21.56960767742916,
                    "smoothness_improvement": 3069.0449822382448,
                    "objective_score": 53.71469484791056
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.015743160247802736,
                    "num_nodes_avg": 173.6,
                    "path_length_avg": 123.84164743815386,
                    "smoothness_avg": 0.15742682886839948,
                    "success_improvement": 0.0,
                    "time_improvement": 68.81104618621191,
                    "node_improvement": 77.92752701843611,
                    "length_improvement": 17.75027447711989,
                    "smoothness_improvement": 1902.4576431662642,
                    "objective_score": 40.80576675796682
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "FLASH-BiConnect: a fast heuristic-aware BiRRT-Connect with informed ellipse sampling, micro-bridge connection, collision-caching, grid-accelerated nearest search, and light post-smoothing. It emphasizes early feasible paths and minimal per-iteration work to cut planning time while delivering short, smooth trajectories.",
          "planning_mechanism": "Mechanism: Grow two trees from start and goal. Each iteration samples toward the goal/corridor or an informed ellipse once an incumbent exists, extends one step from the nearest node (grid lookup), validates node and edge, inserts, and immediately micro-bridges the opposite tree with bounded steps using cached collision checks. On a bridge, assemble and lightly smooth via visibility pruning, few shortcuts, and brief elastic relaxation. Maintain an incumbent to focus informed sampling and terminate early.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        return pts[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=7.5,\n                 connect_multiplier=2.4,\n                 connect_steps=12,\n                 goal_bias=0.22,\n                 corridor_bias=0.28,\n                 informed_bias=0.62,\n                 dupe_ratio=0.18,\n                 shortcut_attempts=80,\n                 relax_passes=6):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_mult = float(connect_multiplier)\n        self.connect_steps = int(connect_steps)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.dupe_ratio = float(dupe_ratio)\n        self.shortcut_attempts = int(shortcut_attempts)\n        self.relax_passes = int(relax_passes)\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if getattr(map, \"obstacles\", None) else []\n\n        nodes = []\n        edges = []\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Build obstacle bins and seed RNG\n        self._build_obs_bins()\n        self._seed_from_scene()\n\n        # Endpoint collision checks\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early direct path\n        self._edge_free_cache = {}\n        self._edge_block_cache = {}\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Spatial grid and duplicate control\n        self.grid_cell = max(1.0, 0.95 * self.step)\n        self.dupe_radius = max(0.25, self.dupe_ratio * self.step)\n        self.connect_step = max(self.step, self.connect_mult * self.step)\n\n        # Trees and grids\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        Ta, Tb = [root_a], [root_b]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, root_a)\n        self._grid_add(Gb, root_b)\n        nodes.extend([root_a, root_b])\n\n        best_path = None\n        best_len = None\n        corridor_w = max(self.step, 0.15 * self._dist(self.start, self.goal))\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            T = Ta if side_a else Tb\n            G = Ga if side_a else Gb\n            T_opp = Tb if side_a else Ta\n            G_opp = Gb if side_a else Ga\n            attractor = self.goal if side_a else self.start\n\n            tgt = self._sample_target(attractor, best_len, corridor_w)\n            if tgt is None:\n                continue\n\n            near = self._nearest(G, tgt)\n            if near is None:\n                continue\n\n            q_new = self._steer(near.position, tgt, self.step)\n            if (not self._in_bounds(q_new)) or self._point_in_obstacles(q_new):\n                continue\n            if self._exists_close(G, q_new, self.dupe_radius):\n                continue\n            if not self._edge_free(near.position, q_new):\n                continue\n\n            # BOTH checks before adding node/edge\n            if self._point_in_obstacles(q_new):\n                continue\n            if not self._edge_free(near.position, q_new):\n                continue\n\n            nn = Node(q_new, near, near.cost + self._dist(near.position, q_new))\n            near.add_child(nn)\n            T.append(nn)\n            nodes.append(nn)\n            edges.append((near, nn))\n            self._grid_add(G, nn)\n\n            # Greedy micro-bridge to the opposite tree\n            meet, bridged = self._micro_bridge(T_opp, G_opp, nn.position, nodes, edges)\n            if bridged:\n                path = self._assemble_full_path(nn, meet, side_a)\n                path = self._finalize_path(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Maintain incumbent to guide informed sampling\n            other = self._nearest(G_opp, nn.position)\n            if other is not None and self._edge_free(nn.position, other.position):\n                tmp = self._assemble_full_path(nn, other, side_a)\n                L = self._path_len(tmp)\n                if (best_len is None) or (L + 1e-12 < best_len):\n                    best_len = L\n                    best_path = tmp\n\n        if best_path is not None:\n            best_path = self._finalize_path(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0x9E3779B97F4A7C15 & 0xffffffffffffffff\n        for v in self.start + self.goal:\n            q = int(abs(v) * 1000003) & 0xffffffff\n            s ^= (q + 0x9E3779B97F4A7C15 + ((s << 6) & 0xffffffffffffffff) + (s >> 2)) & 0xffffffffffffffff\n        s ^= ((len(self.obstacles) + 3) * 0xBF58476D1CE4E5B9) & 0xffffffffffffffff\n        self._rng = s & 0xffffffff or 123456789\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial grid\n    def _grid_key(self, pos):\n        if self.is3:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell), int(pos[2] // self.grid_cell))\n        else:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 3):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n            if best is not None:\n                return best\n        # Fallback scan\n        for b in grid.values():\n            for n in b:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        rc = max(1, int(radius // self.grid_cell) + 1)\n        cand = self._grid_collect_ring(grid, key, rc)\n        r2 = radius * radius\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                return True\n        return False\n\n    # Obstacles and collisions\n    def _build_obs_bins(self):\n        self.obs_cell = max(3.0, self.step * 1.3)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obin.get(key)\n                            if b is None:\n                                self.obin[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obin.get(key)\n                        if b is None:\n                            self.obin[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _canon_seg(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_free(self, a, b):\n        key = self._canon_seg(a, b)\n        v = self._edge_free_cache.get(key)\n        if v is not None:\n            return v\n        hit = self._edge_hits_any(a, b)\n        res = not hit\n        self._edge_free_cache[key] = res\n        self._edge_block_cache[key] = hit\n        return res\n\n    def _edge_hits_any(self, a, b):\n        key = self._canon_seg(a, b)\n        v = self._edge_block_cache.get(key)\n        if v is not None:\n            return v\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obin.get((i, j, k))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                self._edge_block_cache[key] = False\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    self._edge_block_cache[key] = True\n                    return True\n            self._edge_block_cache[key] = False\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obin.get((i, j))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                self._edge_block_cache[key] = False\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    self._edge_block_cache[key] = True\n                    return True\n            self._edge_block_cache[key] = False\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0 = 0.0\n        t1 = 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Micro-bridge connect\n    def _micro_bridge(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n        # Direct attempt\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                if not self._exists_close(grid, target_pos, 0.75 * self.dupe_radius):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    if (not self._point_in_obstacles(nn.position)) and self._edge_free(cur.position, nn.position):\n                        cur.add_child(nn)\n                        tree.append(nn)\n                        nodes.append(nn)\n                        edges.append((cur, nn))\n                        self._grid_add(grid, nn)\n                        return nn, True\n            return cur, True\n        # Short progressive bridge\n        steps = self.connect_steps\n        for _ in range(steps):\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if self._exists_close(grid, nxt, 0.75 * self.dupe_radius):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            if self._point_in_obstacles(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                return cur, False\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                    if not self._exists_close(grid, target_pos, 0.75 * self.dupe_radius):\n                        final_cost = cur.cost + self._dist(cur.position, target_pos)\n                        meet = Node(target_pos, cur, final_cost)\n                        if (not self._point_in_obstacles(meet.position)) and self._edge_free(cur.position, meet.position):\n                            cur.add_child(meet)\n                            tree.append(meet)\n                            nodes.append(meet)\n                            edges.append((cur, meet))\n                            self._grid_add(grid, meet)\n                            return meet, True\n                return cur, True\n        return cur, False\n\n    # Sampling\n    def _sample_target(self, attractor, best_len, corridor_w):\n        r = self._rand()\n        if best_len is not None and r < self.informed_bias:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        r = self._rand()\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n        elif r < self.goal_bias + self.corridor_bias:\n            t = self._rand()\n            base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n            if self.is3:\n                p = (self._rand_range(base[0] - corridor_w, base[0] + corridor_w),\n                     self._rand_range(base[1] - corridor_w, base[1] + corridor_w),\n                     self._rand_range(base[2] - corridor_w, base[2] + corridor_w))\n            else:\n                p = (self._rand_range(base[0] - corridor_w, base[0] + corridor_w),\n                     self._rand_range(base[1] - corridor_w, base[1] + corridor_w))\n            p = self._clamp(p)\n            if not self._point_in_obstacles(p):\n                return p\n        # Uniform fallback limited retries\n        if self.is3:\n            for _ in range(12):\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n                if not self._point_in_obstacles(p):\n                    return p\n        else:\n            for _ in range(12):\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n                if not self._point_in_obstacles(p):\n                    return p\n        return None\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(20):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                if self._dist(p, f1) + self._dist(p, f2) <= max_sum:\n                    return p\n        return None\n\n    # Path utilities\n    def _assemble_full_path(self, u, v, side_a):\n        pu = u.path_from_root()\n        pv = v.path_from_root()\n        if side_a:\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        best = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            n = len(cur)\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            a = cur[i]; b = cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    cur = cand\n                    best = L\n            tries += 1\n        return cur\n\n    def _elastic_relax(self, pts, passes):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        alpha = 0.6\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                c = cur[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                tgt = tuple((1.0 - alpha) * cur[i][k] + alpha * mid[k] for k in range(self.dim))\n                if (not self._in_bounds(tgt)) or self._point_in_obstacles(tgt):\n                    continue\n                if self._edge_free(a, tgt) and self._edge_free(tgt, c):\n                    if tgt != cur[i]:\n                        cur[i] = tgt\n                        moved = True\n            if not moved:\n                break\n        return cur\n\n    def _finalize_path(self, path):\n        p = self._visibility_prune(path)\n        p = self._shortcut(p, self.shortcut_attempts)\n        p = self._elastic_relax(p, self.relax_passes)\n        p = self._visibility_prune(p)\n        return p",
          "objective": -41.5137,
          "time_improvement": 76.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 2280.0,
          "node_improvement": 86.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011682534217834472,
                    "num_nodes_avg": 90.0,
                    "path_length_avg": 174.69654519251782,
                    "smoothness_avg": 0.05500932206075824,
                    "success_improvement": 0.0,
                    "time_improvement": 52.80201351978747,
                    "node_improvement": 77.33568370687485,
                    "length_improvement": 4.246055336074347,
                    "smoothness_improvement": 761.0153449056593,
                    "objective_score": 22.193313982109146
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0223921537399292,
                    "num_nodes_avg": 151.0,
                    "path_length_avg": 243.39260845590448,
                    "smoothness_avg": 0.18946894378939338,
                    "success_improvement": 0.0,
                    "time_improvement": 86.3816967405798,
                    "node_improvement": 89.85419606262178,
                    "length_improvement": 18.74854162962448,
                    "smoothness_improvement": 4775.172392665187,
                    "objective_score": 61.03949596327456
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.006050515174865723,
                    "num_nodes_avg": 64.0,
                    "path_length_avg": 129.6031745448857,
                    "smoothness_avg": 0.11028457328976785,
                    "success_improvement": 0.0,
                    "time_improvement": 88.13332653751176,
                    "node_improvement": 91.86268277177369,
                    "length_improvement": 13.923742507267159,
                    "smoothness_improvement": 1302.8116318854163,
                    "objective_score": 41.308301625040905
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "AURORA-Simple: A compact BiRRT*-Connect with informed sampling and elastic smoothing. It alternates bidirectional growth with light RRT* parent selection and capped local rewiring, uses an ellipse-informed sampler after the first solution, and applies visibility pruning, shortcutting, and collision-aware Laplacian relaxation for smooth, short paths. A simple spatial hash accelerates nearest/neighbor queries and obstacle binning speeds collision checks.",
          "planning_mechanism": "Alternate expansions from start and goal trees. Each iteration samples a target (uniform with goal bias; ellipse-informed once a solution exists), steers a step, picks the cheapest feasible parent within a shrinking radius, inserts the node after node and edge checks, and rewires nearby neighbors if cost improves. The opposite tree greedily connects toward the new node with safe increments; upon meeting, paths are merged and post-processed (visibility prune, shortcuts, relaxation), then returned.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = parent\n        if parent is not None:\n            if self not in parent.children:\n                parent.children.append(self)\n\n    def path_from_root(self):\n        out = []\n        cur = self\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        return out[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=5.0,\n        connect_step=10.0,\n        goal_bias=0.2,\n        grid_factor=1.25,\n        obs_grid_factor=1.8,\n        rewire_factor=1.6,\n        neighbor_cap=20,\n        min_separation_ratio=0.35,\n        shortcut_attempts=80,\n        relax_iters=12\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_step = float(connect_step)\n        self.goal_bias = float(goal_bias)\n        self.grid_factor = float(grid_factor)\n        self.obs_grid_factor = float(obs_grid_factor)\n        self.rewire_factor = float(rewire_factor)\n        self.neighbor_cap = int(neighbor_cap)\n        self.min_sep_ratio = float(min_separation_ratio)\n        self.shortcut_attempts = int(shortcut_attempts)\n        self.relax_iters = int(relax_iters)\n        self._rng = 1234567\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        # Bounds checks\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Seed RNG\n        self._seed()\n\n        # Grid parameters\n        self.cell = max(1.0, self.step * self.grid_factor)\n        self.obs_cell = max(3.0, self.step * self.obs_grid_factor)\n        self.min_sep = max(0.2, self.step * self.min_sep_ratio)\n\n        # Build obstacle bins\n        self._build_obs_bins()\n\n        # Start/goal collision\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Trivial straight-line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Initialize trees, grids\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, a_root)\n        self._grid_add(Gb, b_root)\n        nodes.extend([a_root, b_root])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            grow_a = (it % 2 == 0)\n            T1, T2 = (Ta, Tb) if grow_a else (Tb, Ta)\n            G1, G2 = (Ga, Gb) if grow_a else (Gb, Ga)\n            attractor = self.goal if grow_a else self.start\n\n            # Sample target\n            qrand = self._sample_target(attractor, best_len)\n            if qrand is None:\n                continue\n\n            # Nearest and steer\n            near = self._nearest(G1, T1, qrand)\n            if near is None:\n                continue\n            newp = self._steer(near.position, qrand, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._has_nearby(G1, newp, self.min_sep):\n                continue\n\n            # Select parent (light RRT*)\n            parent, new_cost = self._select_parent(G1, T1, near, newp)\n            if parent is None:\n                continue\n\n            # Both checks before add\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, new_cost)\n            nn.attach(parent)\n            T1.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(G1, nn)\n\n            # Local rewiring\n            self._rewire(G1, nn, edges)\n\n            # Attempt to connect from the other tree\n            meet, connected = self._connect_toward(T2, G2, nn.position, nodes, edges)\n            if connected and meet is not None:\n                # Build full path\n                if grow_a:\n                    pa = nn.path_from_root()\n                    pb = meet.path_from_root()\n                    path = pa + pb[-2::-1]\n                else:\n                    pa = meet.path_from_root()\n                    pb = nn.path_from_root()\n                    path = pa + pb[-2::-1]\n                path = self._dedup(path)\n                best_len = self._path_len(path)\n                final = self._finalize(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed(self):\n        h = 2166136261\n        vals = list(self.start) + list(self.goal) + [float(len(self.obstacles))]\n        for v in vals:\n            x = int(v * 2654435761) & 0xffffffff\n            h ^= x\n            h = (h * 16777619) & 0xffffffff\n        if h == 0:\n            h = 1234567\n        self._rng = h & 0x7fffffff\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0x7fffffff\n        return (self._rng % 1000000) / 1000000.0\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial hash for nodes\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, rings):\n        out = []\n        if self.is3:\n            for dx in range(-rings, rings + 1):\n                for dy in range(-rings, rings + 1):\n                    for dz in range(-rings, rings + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-rings, rings + 1):\n                for dy in range(-rings, rings + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, nodes, pos):\n        key = self._cell_key(pos)\n        best, bestd = None, 1e100\n        for r in range(0, 3):\n            cand = self._grid_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n            if best is not None:\n                return best\n        # fallback full scan\n        for n in nodes:\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, cap=None):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        cand = self._grid_collect(grid, key, rc)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                out.append(n)\n        if cap is not None and len(out) > cap:\n            k = cap\n            res = []\n            for i, n in enumerate(out):\n                if len(res) < k:\n                    res.append(n)\n                else:\n                    j = int(self._rand_range(0, i + 1))\n                    if j < k:\n                        res[j] = n\n            return res\n        return out\n\n    def _has_nearby(self, grid, pos, radius):\n        neigh = self._neighbors(grid, pos, radius, cap=8)\n        return len(neigh) > 0\n\n    # Obstacles and collision\n    def _obs_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.obs_cell), int(p[1] // self.obs_cell), int(p[2] // self.obs_cell))\n        return (int(p[0] // self.obs_cell), int(p[1] // self.obs_cell))\n\n    def _build_obs_bins(self):\n        self.ogrid = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                gx0 = int(max(0.0, x) // self.obs_cell)\n                gy0 = int(max(0.0, y) // self.obs_cell)\n                gz0 = int(max(0.0, z) // self.obs_cell)\n                gx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                gy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                gz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(gx0, gx1 + 1):\n                    for j in range(gy0, gy1 + 1):\n                        for k in range(gz0, gz1 + 1):\n                            key = (i, j, k)\n                            lst = self.ogrid.get(key)\n                            if lst is None:\n                                self.ogrid[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                gx0 = int(max(0.0, x) // self.obs_cell)\n                gy0 = int(max(0.0, y) // self.obs_cell)\n                gx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                gy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(gx0, gx1 + 1):\n                    for j in range(gy0, gy1 + 1):\n                        key = (i, j)\n                        lst = self.ogrid.get(key)\n                        if lst is None:\n                            self.ogrid[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_in_obstacles(self, p):\n        key = self._obs_key(p)\n        lst = self.ogrid.get(key)\n        if not lst:\n            return False\n        if self.is3:\n            x, y, z = p\n            for idx in lst:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            x, y = p\n            for idx in lst:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        mins = tuple(min(a[i], b[i]) for i in range(self.dim))\n        maxs = tuple(max(a[i], b[i]) for i in range(self.dim))\n        if self.is3:\n            gx0 = int(max(0.0, mins[0]) // self.obs_cell)\n            gy0 = int(max(0.0, mins[1]) // self.obs_cell)\n            gz0 = int(max(0.0, mins[2]) // self.obs_cell)\n            gx1 = int(min(self.bounds[0], maxs[0]) // self.obs_cell)\n            gy1 = int(min(self.bounds[1], maxs[1]) // self.obs_cell)\n            gz1 = int(min(self.bounds[2], maxs[2]) // self.obs_cell)\n            uniq = {}\n            for i in range(gx0, gx1 + 1):\n                for j in range(gy0, gy1 + 1):\n                    for k in range(gz0, gz1 + 1):\n                        lst = self.ogrid.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                uniq[idx] = True\n            if not uniq:\n                return False\n            for idx in uniq.keys():\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            gx0 = int(max(0.0, mins[0]) // self.obs_cell)\n            gy0 = int(max(0.0, mins[1]) // self.obs_cell)\n            gx1 = int(min(self.bounds[0], maxs[0]) // self.obs_cell)\n            gy1 = int(min(self.bounds[1], maxs[1]) // self.obs_cell)\n            uniq = {}\n            for i in range(gx0, gx1 + 1):\n                for j in range(gy0, gy1 + 1):\n                    lst = self.ogrid.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            uniq[idx] = True\n            if not uniq:\n                return False\n            for idx in uniq.keys():\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Parent selection and rewiring\n    def _rr_radius(self, n_nodes):\n        n = max(2, n_nodes)\n        return max(1.05 * self.step, self.rewire_factor * self.step / (n ** (1.0 / max(1.0, float(self.dim)))))\n\n    def _select_parent(self, grid, tree, fallback, newp):\n        radius = self._rr_radius(len(tree) + 1)\n        neigh = self._neighbors(grid, newp, radius, cap=self.neighbor_cap)\n        best_p = None\n        best_c = 1e100\n        if neigh:\n            for p in neigh:\n                d = self._dist(p.position, newp)\n                if d > 1.75 * self.step + 1e-9:\n                    continue\n                if not self._edge_free(p.position, newp):\n                    continue\n                cand = p.cost + d\n                if cand + 1e-12 < best_c:\n                    best_c = cand\n                    best_p = p\n        if best_p is None:\n            if self._edge_free(fallback.position, newp):\n                return fallback, fallback.cost + self._dist(fallback.position, newp)\n            return None, None\n        return best_p, best_c\n\n    def _rewire(self, grid, node, edges):\n        radius = self._rr_radius(len(edges) + 32)\n        neigh = self._neighbors(grid, node.position, radius, cap=self.neighbor_cap)\n        count = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if d > 1.75 * self.step + 1e-9:\n                continue\n            newc = node.cost + d\n            if newc + 1e-9 < nb.cost:\n                # Checks before reparenting\n                if (not self._point_in_obstacles(nb.position)) and (not self._point_in_obstacles(node.position)) and self._edge_free(node.position, nb.position):\n                    oldp = nb.parent\n                    nb.attach(node)\n                    nb.cost = newc\n                    if oldp is not None:\n                        self._remove_edge(edges, (oldp, nb))\n                    edges.append((node, nb))\n                    self._propagate_costs(nb)\n                    count += 1\n                    if count >= max(3, self.neighbor_cap // 2):\n                        break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            base = 0.0 if cur.parent is None else cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            if abs(base - cur.cost) > 1e-12:\n                cur.cost = base\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _remove_edge(self, edges, e):\n        for i in range(len(edges)):\n            if edges[i][0] is e[0] and edges[i][1] is e[1]:\n                edges.pop(i)\n                return\n\n    # Connect other tree toward target position\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        head = self._nearest(grid, tree, target_pos)\n        if head is None:\n            return None, False\n\n        # Direct connect attempt\n        if self._edge_free(head.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)) and (not self._has_nearby(grid, target_pos, self.min_sep * 0.8)):\n                meet = Node(target_pos, head, head.cost + self._dist(head.position, target_pos))\n                # Both checks\n                if (not self._point_in_obstacles(meet.position)) and self._edge_free(head.position, meet.position):\n                    meet.attach(head)\n                    tree.append(meet)\n                    nodes.append(meet)\n                    edges.append((head, meet))\n                    self._grid_add(grid, meet)\n                    return meet, True\n            return None, False\n\n        # Greedy incremental connect\n        cur = head\n        max_steps = 4\n        steps = 0\n        while steps < max_steps:\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return None, False\n            if self._has_nearby(grid, nxt, self.min_sep * 0.8):\n                return None, False\n            if not self._edge_free(cur.position, nxt):\n                return None, False\n            nn = Node(nxt, cur, cur.cost + self._dist(cur.position, nxt))\n            # Both checks\n            if self._point_in_obstacles(nn.position) or not self._edge_free(cur.position, nn.position):\n                return None, False\n            nn.attach(cur)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n            # Final link if possible\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)) and (not self._has_nearby(grid, target_pos, self.min_sep * 0.8)):\n                    meet = Node(target_pos, cur, cur.cost + self._dist(cur.position, target_pos))\n                    if (not self._point_in_obstacles(meet.position)) and self._edge_free(cur.position, meet.position):\n                        meet.attach(cur)\n                        tree.append(meet)\n                        nodes.append(meet)\n                        edges.append((cur, meet))\n                        self._grid_add(grid, meet)\n                        return meet, True\n                return None, False\n        return None, False\n\n    # Sampling\n    def _sample_target(self, attractor, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.6:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias and (not self._point_in_obstacles(attractor)):\n            return attractor\n        # Uniform random in free\n        for _ in range(16):\n            if self.is3:\n                q = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n            else:\n                q = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(q) and (not self._point_in_obstacles(q)):\n                return q\n        return None\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                    return p\n        return None\n\n    # Path utilities\n    def _path_len(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _vis_prune(self, pts):\n        if len(pts) < 3:\n            return list(pts)\n        out = [pts[0]]\n        anchor = pts[0]\n        i = 1\n        while i < len(pts):\n            far = i\n            j = i\n            while j < len(pts):\n                if self._edge_free(anchor, pts[j]):\n                    far = j\n                    j += 1\n                else:\n                    break\n            out.append(pts[far])\n            anchor = pts[far]\n            i = far + 1\n        out[0] = pts[0]\n        out[-1] = pts[-1]\n        return out\n\n    def _shortcut(self, pts, attempts):\n        cur = list(pts)\n        if len(cur) < 3:\n            return cur\n        best = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) >= 3:\n            i = int(self._rand_range(0, len(cur) - 2))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j > len(cur):\n                j = len(cur)\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = cur[i]\n            b = cur[j - 1]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j - 1:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    cur = cand\n                    best = L\n            tries += 1\n        return cur\n\n    def _relax(self, pts, iters):\n        if len(pts) < 3 or iters <= 0:\n            return list(pts)\n        cur = list(pts)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                c = cur[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                if self._in_bounds(mid) and (not self._point_in_obstacles(mid)):\n                    if self._edge_free(a, mid) and self._edge_free(mid, c):\n                        if mid != cur[i]:\n                            cur[i] = mid\n                            moved = True\n            if not moved:\n                break\n        return cur\n\n    def _finalize(self, path):\n        p = self._vis_prune(path)\n        p = self._shortcut(p, self.shortcut_attempts)\n        p = self._relax(p, self.relax_iters)\n        return self._dedup(p)",
          "objective": -41.08777,
          "time_improvement": 77.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1963.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0053506135940551754,
                    "num_nodes_avg": 49.0,
                    "path_length_avg": 164.16540194185723,
                    "smoothness_avg": 0.0604680221490293,
                    "success_improvement": 0.0,
                    "time_improvement": 78.38326998541683,
                    "node_improvement": 87.6605389070763,
                    "length_improvement": 10.018341828405152,
                    "smoothness_improvement": 846.455855044069,
                    "objective_score": 33.758265367888484
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0371267557144165,
                    "num_nodes_avg": 205.0,
                    "path_length_avg": 244.75937964787263,
                    "smoothness_avg": 0.12042929944393894,
                    "success_improvement": 0.0,
                    "time_improvement": 77.42050969149274,
                    "node_improvement": 86.2258953168044,
                    "length_improvement": 18.29227406541803,
                    "smoothness_improvement": 2998.7326164108117,
                    "objective_score": 49.19518042875269
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.012696647644042968,
                    "num_nodes_avg": 108.0,
                    "path_length_avg": 131.57971906355084,
                    "smoothness_avg": 0.1684555037540335,
                    "success_improvement": 0.0,
                    "time_improvement": 75.09848875579885,
                    "node_improvement": 86.26827717736809,
                    "length_improvement": 12.61101575090558,
                    "smoothness_improvement": 2042.7415736594278,
                    "objective_score": 40.30986394558014
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "NOVA-BRRT*: A bidirectional RRT*-Connect variant with dual spatial hashes, exact-bridge meeting, density-aware duplicate control, and lazy local rewiring. It uses obstacle binning and slab-segment tests for fast collision checks, selects best-cost parents within an adaptive radius, rewires cheaper neighbors, and connects greedily from the opposite tree with insertion of the exact meeting node for kink-free junctions. After a connection, a compact visibility prune + guided shortcut + midpoint relaxation yields smooth, short paths with minimal overhead.",
          "planning_mechanism": "Alternate growing start/goal trees. Each iteration: biased/informed sample (goal/corridor/ellipse), find a near node via grid, steer one step, choose the best parent among neighbors and verify node+edge, add and locally rewire. Greedily extend the other tree toward the new node; if visibility holds, insert the exact meeting node. On connection, assemble a continuous path (no duplicate junction), visibility-prune, shortcut, midpoint-smooth, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        pts = []\n        cur = self\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5500,\n        step_size=6.0,\n        connect_mult=2.0,\n        grid_cell_factor=1.4,\n        goal_bias=0.10,\n        corridor_bias=0.25,\n        rewire_factor=2.4,\n        smooth_shortcuts=90\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_step = float(connect_mult) * self.step\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.rewire_factor = float(rewire_factor)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self._rng = 123456789\n\n    def plan(self, map):\n        # Scene\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n        self._edges_set = {}\n\n        # Basic validation\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Seed RNG and structures\n        self._seed_from_scene()\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_radius = max(0.5, 0.35 * self.step)\n        self.rewire_base = max(1.2 * self.step, self.rewire_factor * self.step)\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        # Corridor width for biased sampling\n        sg = self._dist(self.start, self.goal)\n        corridor_w = max(self.step, 0.18 * sg)\n        best_len = None  # enable informed sampling after first solution\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            Ta = tree_a if active_start else tree_b\n            Tb = tree_b if active_start else tree_a\n            Ga = grid_a if active_start else grid_b\n            Gb = grid_b if active_start else grid_a\n            attract = self.goal if active_start else self.start\n\n            # Sample target\n            target = self._sample_target(attract, best_len, corridor_w)\n            if target is None:\n                continue\n\n            na = self._nearest(Ga, target)\n            if na is None:\n                continue\n\n            newp = self._steer(na.position, target, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            # Density-aware duplicate suppression\n            if self._too_close(Ga, newp, self._adaptive_dup_radius(Ga, newp)):\n                continue\n\n            # Choose best parent within adaptive radius\n            rew_rad = self._adaptive_rewire_radius(len(Ta))\n            parent, new_cost = self._choose_parent(Ga, newp, na, rew_rad)\n            # Strict checks before commit\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, new_cost)\n            parent.add_child(nn)\n            Ta.append(nn)\n            nodes.append(nn)\n            self._add_edge(edges, parent, nn)\n            self._grid_add(Ga, nn)\n\n            # Local rewiring\n            self._local_rewire(Ga, nn, rew_rad, edges)\n\n            # Try to connect from the other tree\n            meet_node, reached = self._connect_toward(Tb, Gb, nn.position, nodes, edges)\n            if not reached:\n                continue\n\n            # Build final path without duplicate junction\n            if active_start:\n                pa = self._trace_to_root(nn)         # start -> ... -> nn\n                pb = self._trace_to_root(meet_node)  # goal  -> ... -> nn\n                path = pa + pb[-2::-1]\n            else:\n                pa = self._trace_to_root(meet_node)  # start -> ... -> nn\n                pb = self._trace_to_root(nn)         # goal  -> ... -> nn\n                path = pa + pb[-2::-1]\n\n            # Smoothing\n            path = self._visibility_prune(path)\n            path = self._shortcut(path, self.smooth_shortcuts)\n            path = self._midpoint_relax(path, iters=6)\n\n            return PlannerResult(True, self._dedup(path), nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG utilities\n    def _seed_from_scene(self):\n        s = 0x9E3779B9 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= (q ^ (q >> 13) ^ ((q << 7) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 29) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_pt(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp_pt(a)\n        if d2 <= step * step:\n            return self._clamp_pt(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp_pt(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial hash for nodes\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found_any = False\n        for r in range(0, 4):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found_any = True\n            if found_any:\n                return best\n        # fallback\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors_in_radius(grid, pos, radius)) > 0\n\n    # Obstacles: binning and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.2)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        # Slab method\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Sampling\n    def _sample_target(self, attract, best_len, corridor_w):\n        r = self._rand()\n        # Informed ellipse after first solution\n        if best_len is not None and r < 0.60:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        # Goal bias\n        if r < self.goal_bias:\n            if self._in_bounds(attract) and (not self._point_in_obstacles(attract)):\n                return attract\n        # Corridor-biased\n        if r < self.goal_bias + self.corridor_bias:\n            t = self._rand()\n            base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n            if self.is3:\n                p = (\n                    self._clamp(base[0] + self._rand_range(-corridor_w, corridor_w), 0.0, self.bounds[0]),\n                    self._clamp(base[1] + self._rand_range(-corridor_w, corridor_w), 0.0, self.bounds[1]),\n                    self._clamp(base[2] + self._rand_range(-corridor_w, corridor_w), 0.0, self.bounds[2]),\n                )\n            else:\n                p = (\n                    self._clamp(base[0] + self._rand_range(-corridor_w, corridor_w), 0.0, self.bounds[0]),\n                    self._clamp(base[1] + self._rand_range(-corridor_w, corridor_w), 0.0, self.bounds[1]),\n                )\n            if (not self._point_in_obstacles(p)) and self._in_bounds(p):\n                return p\n        # Uniform\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _clamp(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(28):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Parenting and rewiring\n    def _choose_parent(self, grid, newp, fallback, radius):\n        parent = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        neigh = self._neighbors_in_radius(grid, newp, radius)\n        for n in neigh:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                parent = n\n                best_cost = c\n        return parent, best_cost\n\n    def _local_rewire(self, grid, nn, radius, edges):\n        neigh = self._neighbors_in_radius(grid, nn.position, radius)\n        for nb in neigh:\n            if nb is nn or nb is nn.parent:\n                continue\n            cand = nn.cost + self._dist(nn.position, nb.position)\n            if cand + 1e-12 < nb.cost and self._edge_free(nn.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, oldp, nb)\n                nn.add_child(nb)\n                nb.cost = cand\n                self._add_edge(edges, nn, nb)\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    # Connect from other tree toward target, optionally inserting exact meeting node\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        # First, try direct visibility to exact meeting\n        if self._edge_free(cur.position, target_pos):\n            if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    # Strict checks already done above\n                    cur.add_child(nn)\n                    tree.append(nn)\n                    nodes.append(nn)\n                    self._add_edge(edges, cur, nn)\n                    self._grid_add(grid, nn)\n                    return nn, True\n            return cur, True  # meet at current if too close to insert node\n\n        # Greedy stepwise connect\n        while steps < 48:\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if self._too_close(grid, nxt, self.dup_radius * 0.75):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            self._add_edge(edges, cur, nn)\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n            if self._edge_free(cur.position, target_pos):\n                if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                    if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        mn = Node(target_pos, cur, new_cost)\n                        cur.add_child(mn)\n                        tree.append(mn)\n                        nodes.append(mn)\n                        self._add_edge(edges, cur, mn)\n                        self._grid_add(grid, mn)\n                        return mn, True\n                return cur, True\n        return cur, False\n\n    # Path helpers\n    def _trace_to_root(self, node):\n        return node.path_from_root()\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _midpoint_relax(self, pts, iters=6):\n        if len(pts) < 3 or iters <= 0:\n            return pts[:]\n        out = pts[:]\n        for _ in range(iters):\n            changed = False\n            for i in range(1, len(out) - 1):\n                a = out[i - 1]\n                c = out[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                if self._point_in_obstacles(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if mid != out[i]:\n                        out[i] = mid\n                        changed = True\n            if not changed:\n                break\n        return out\n\n    # Adaptive radii\n    def _adaptive_rewire_radius(self, n_nodes):\n        decay = pow(0.5, n_nodes / 3000.0)\n        return max(1.2 * self.step, self.rewire_base * decay)\n\n    def _adaptive_dup_radius(self, grid, pos):\n        # Slightly reduce duplicate radius in dense areas to allow refinement\n        base = self.dup_radius\n        neigh = self._neighbors_in_radius(grid, pos, 2.5 * self.dup_radius)\n        if len(neigh) > 12:\n            return 0.6 * base\n        if len(neigh) > 6:\n            return 0.8 * base\n        return base\n\n    # Edge bookkeeping\n    def _add_edge(self, edges, a, b):\n        key = (a, b)\n        if key in self._edges_set:\n            return\n        edges.append((a, b))\n        self._edges_set[key] = 1\n\n    def _remove_edge(self, edges, a, b):\n        key = (a, b)\n        if key in self._edges_set:\n            # remove from list\n            for i in range(len(edges) - 1, -1, -1):\n                ea, eb = edges[i]\n                if ea is a and eb is b:\n                    edges.pop(i)\n                    break\n            del self._edges_set[key]",
          "objective": -40.90484,
          "time_improvement": 74.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1621.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009995555877685547,
                    "num_nodes_avg": 55.0,
                    "path_length_avg": 160.51471104652452,
                    "smoothness_avg": 0.04571645372029039,
                    "success_improvement": 0.0,
                    "time_improvement": 59.48507376866201,
                    "node_improvement": 86.14958448753463,
                    "length_improvement": 12.019343357036162,
                    "smoothness_improvement": 615.5617755907475,
                    "objective_score": 28.13493702277404
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.030689311027526856,
                    "num_nodes_avg": 142.0,
                    "path_length_avg": 228.58360131426812,
                    "smoothness_avg": 0.11916107389456083,
                    "success_improvement": 0.0,
                    "time_improvement": 81.65081025910044,
                    "node_improvement": 90.45891285359134,
                    "length_improvement": 23.692214467138992,
                    "smoothness_improvement": 2966.1002595593727,
                    "objective_score": 53.541073055810394
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009439635276794433,
                    "num_nodes_avg": 83.0,
                    "path_length_avg": 124.8569736985716,
                    "smoothness_avg": 0.10854185440910273,
                    "success_improvement": 0.0,
                    "time_improvement": 81.29903119622774,
                    "node_improvement": 89.446916719644,
                    "length_improvement": 17.075943119591432,
                    "smoothness_improvement": 1280.6443763574832,
                    "objective_score": 41.038497112410596
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "ZIDC*: Informed Dual-Connect with Local Rewire \u2014 a bi-directional RRT*-Connect variant that grows greedily toward low-discrepancy samples, selects parents by local cost, performs radius-limited rewiring, and switches to informed (start\u2013goal ellipse) sampling after the first solution. A compact spatial hash accelerates near/nearest queries; obstacle-binned collision checks reduce segment tests; spacing is permissive to densify corridors; and a two-stage LOS+shortcut smoother improves curvature with minimal overhead.",
          "planning_mechanism": "Alternate expansions of start/goal trees. Each iteration: draw a goal-biased Halton sample; if a best cost exists, reject samples outside the start\u2013goal ellipse. From the nearest node, extend multiple steps toward the sample; at the first step, choose the best-cost visible parent among nearby nodes, insert, then locally rewire neighbors that benefit. After each insertion, greedily connect the opposite tree toward the new node; if it reaches (or can insert an exact meeting), stitch the trees and finalize with visibility pruning and shortcut smoothing.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=8.0,\n        goal_bias=0.1,\n        grid_cell_factor=1.0,\n        min_separation_mult=0.25,\n        connect_greedy_steps=64,\n        rewire_radius_mult=3.0,\n        smooth_shortcuts=32\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.sep_mult = float(min_separation_mult)\n        self.conn_steps = int(connect_greedy_steps)\n        self.rewire_mult = float(rewire_radius_mult)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self._rng = 1\n        self._h = 1\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if (not self._inside(self.start)) or (not self._inside(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.sep = max(0.25, self.step * self.sep_mult)\n        self.rewire_radius = max(self.step * 1.5, self.step * self.rewire_mult)\n\n        self._build_obstacle_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Direct path quick check\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize trees and spatial hashes\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        Ta, Tb = [root_a], [root_b]\n        Ga, Gb = {}, {}\n        self._grid_put(Ga, root_a)\n        self._grid_put(Gb, root_b)\n        nodes.extend([root_a, root_b])\n\n        best_cost = float('inf')\n        best_path = None\n\n        for it in range(self.max_iter):\n            from_start_side = (it % 2 == 0)\n            T_src, T_dst = (Ta, Tb) if from_start_side else (Tb, Ta)\n            G_src, G_dst = (Ga, Gb) if from_start_side else (Gb, Ga)\n            attractor = self.goal if from_start_side else self.start\n\n            q = self._sample(attractor, best_cost)\n            if q is None:\n                continue\n\n            new_node = self._extend_greedy(T_src, G_src, q, nodes, edges, choose_parent=True, do_rewire=True)\n            if new_node is None:\n                continue\n\n            meet = self._connect_toward(T_dst, G_dst, new_node.position, nodes, edges)\n            if meet is not None:\n                # Stitch and finalize\n                if from_start_side:\n                    path_a = self._path_to_root(new_node)\n                    path_b = self._path_to_root(meet)\n                    path = path_a + path_b[-2::-1]\n                else:\n                    path_a = self._path_to_root(meet)\n                    path_b = self._path_to_root(new_node)\n                    path = path_a + path_b[-2::-1]\n                path = self._finalize(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Opportunistic goal/start direct bridging when close and visible\n            tgt = attractor\n            if self._dist(new_node.position, tgt) <= self.conn_steps * self.step:\n                if self._edge_free(new_node.position, tgt):\n                    # Insert exact meeting into the same tree (ignoring spacing for solution stitching)\n                    meet_node = self._attach_node(T_src, G_src, new_node, tgt, nodes, edges, ignore_spacing=True)\n                    if meet_node is not None:\n                        if from_start_side:\n                            path = self._path_to_root(meet_node)\n                        else:\n                            path = self._path_to_root(meet_node)\n                        path = self._finalize(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n            # Maintain an incremental best path via nearest opposite if visible\n            near_dst = self._nearest(G_dst, new_node.position, T_dst)\n            if near_dst and self._edge_free(new_node.position, near_dst.position):\n                tentative = self._path_to_root(new_node) + self._path_to_root(near_dst)[-2::-1]\n                cost = self._polyline_len(tentative)\n                if cost < best_cost:\n                    best_cost = cost\n                    best_path = tentative\n\n        if best_path is not None:\n            best_path = self._finalize(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG and sampling\n    def _seed(self):\n        s = 0x9E3779B1\n        for v in self.start + self.goal:\n            s ^= (int(v * 2654435761) & 0xffffffff)\n            s = (s * 1664525 + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 1\n        self._rng = s\n        self._h = 1\n\n    def _rand(self):\n        self._rng = (self._rng * 1103515245 + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _halton(self, i, base):\n        f = 1.0 / base\n        r = 0.0\n        while i > 0:\n            r += (i % base) * f\n            i //= base\n            f /= base\n        return r\n\n    def _halton_point(self, idx):\n        if self.is3:\n            return (\n                self._halton(idx, 2) * self.bounds[0],\n                self._halton(idx, 3) * self.bounds[1],\n                self._halton(idx, 5) * self.bounds[2],\n            )\n        else:\n            return (\n                self._halton(idx, 2) * self.bounds[0],\n                self._halton(idx, 3) * self.bounds[1],\n            )\n\n    def _sample(self, attractor, c_best):\n        r = self._rand()\n        if r < self.goal_bias:\n            return attractor\n\n        # Try a few Halton candidates (filtered by informed set if available)\n        tries = 0\n        idx = self._h\n        while tries < 8:\n            p = self._halton_point(idx)\n            idx += 1\n            tries += 1\n            if (not self._inside(p)) or self._point_blocked(p):\n                continue\n            if c_best < float('inf'):\n                if (self._dist(self.start, p) + self._dist(p, self.goal)) > (c_best + 1e-9):\n                    continue\n            self._h = idx\n            return p\n\n        # Fallback uniform attempts\n        for _ in range(16):\n            if self.is3:\n                p = (\n                    self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]),\n                )\n            else:\n                p = (\n                    self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                )\n            if (not self._inside(p)) or self._point_blocked(p):\n                continue\n            if c_best < float('inf'):\n                if (self._dist(self.start, p) + self._dist(p, self.goal)) > (c_best + 1e-9):\n                    continue\n            return p\n        return None\n\n    # Geometry\n    def _inside(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        out = []\n        for i in range(self.dim):\n            out.append(a[i] + (b[i] - a[i]) * r)\n        return tuple(out)\n\n    # Spatial hash for nodes\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        else:\n            return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_put(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos, T_list):\n        key = self._cell_key(pos)\n        # Expand search rings up to 2 then fallback\n        for r in (0, 1, 2):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                best = None\n                bestd = float('inf')\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                return best\n        # Fallback to partial linear scan (sample up to 64)\n        if not T_list:\n            return None\n        m = min(len(T_list), 64)\n        best = None\n        bestd = float('inf')\n        step = max(1, len(T_list) // m)\n        for i in range(0, len(T_list), step):\n            n = T_list[i]\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, limit=None):\n        key = self._cell_key(pos)\n        rc = int(max(1, radius // self.cell)) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n                                if limit is not None and len(out) >= limit:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n                            if limit is not None and len(out) >= limit:\n                                return out\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        nbr = self._neighbors(grid, pos, radius, limit=1)\n        return len(nbr) > 0\n\n    # Obstacles and collision\n    def _build_obstacle_bins(self):\n        self.ob_cell = max(4.0, self.step * 2.0)\n        self.ob_grid = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.ob_cell)\n                iy0 = int(max(0.0, y) // self.ob_cell)\n                iz0 = int(max(0.0, z) // self.ob_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.ob_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.ob_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.ob_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            bucket = self.ob_grid.get(key)\n                            if bucket is None:\n                                self.ob_grid[key] = [idx]\n                            else:\n                                bucket.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.ob_cell)\n                iy0 = int(max(0.0, y) // self.ob_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.ob_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.ob_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        bucket = self.ob_grid.get(key)\n                        if bucket is None:\n                            self.ob_grid[key] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            ix = int(p[0] // self.ob_cell)\n            iy = int(p[1] // self.ob_cell)\n            iz = int(p[2] // self.ob_cell)\n            bucket = self.ob_grid.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.ob_cell)\n            iy = int(p[1] // self.ob_cell)\n            bucket = self.ob_grid.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits(a, b)\n\n    def _segment_hits(self, a, b):\n        # Collect candidate bins intersecting bounding box of segment\n        if self.is3:\n            mn = (a[0] if a[0] < b[0] else b[0],\n                  a[1] if a[1] < b[1] else b[1],\n                  a[2] if a[2] < b[2] else b[2])\n            mx = (a[0] if a[0] > b[0] else b[0],\n                  a[1] if a[1] > b[1] else b[1],\n                  a[2] if a[2] > b[2] else b[2])\n            ix0 = int(max(0.0, mn[0]) // self.ob_cell)\n            iy0 = int(max(0.0, mn[1]) // self.ob_cell)\n            iz0 = int(max(0.0, mn[2]) // self.ob_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.ob_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.ob_cell)\n            iz1 = int(min(self.bounds[2], mx[2]) // self.ob_cell)\n            cand = []\n            seen = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self.ob_grid.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                if idx not in seen:\n                                    seen.add(idx)\n                                    cand.append(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mn = (a[0] if a[0] < b[0] else b[0],\n                  a[1] if a[1] < b[1] else b[1])\n            mx = (a[0] if a[0] > b[0] else b[0],\n                  a[1] if a[1] > b[1] else b[1])\n            ix0 = int(max(0.0, mn[0]) // self.ob_cell)\n            iy0 = int(max(0.0, mn[1]) // self.ob_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.ob_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.ob_cell)\n            cand = []\n            seen = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self.ob_grid.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            if idx not in seen:\n                                seen.add(idx)\n                                cand.append(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box(self, p0, p1, bmin, bmax):\n        # Slab intersection test\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Tree operations\n    def _attach_node(self, tree, grid, parent, pos, nodes, edges, ignore_spacing=False):\n        if (not self._inside(pos)) or self._point_blocked(pos):\n            return None\n        if (not ignore_spacing) and self._too_close(grid, pos, self.sep):\n            return None\n        if not self._edge_free(parent.position, pos):\n            return None\n        ncost = parent.cost + self._dist(parent.position, pos)\n        nd = Node(pos, parent, ncost)\n        parent.add_child(nd)\n        tree.append(nd)\n        nodes.append(nd)\n        edges.append((parent, nd))\n        self._grid_put(grid, nd)\n        return nd\n\n    def _choose_parent_and_attach(self, tree, grid, near, pos, nodes, edges):\n        # Evaluate possible parents among neighbors for minimal cost\n        best_parent = near\n        best_cost = near.cost + self._dist(near.position, pos)\n        nbrs = self._neighbors(grid, pos, self.rewire_radius)\n        for n in nbrs:\n            if self._edge_free(n.position, pos):\n                c = n.cost + self._dist(n.position, pos)\n                if c < best_cost:\n                    best_cost = c\n                    best_parent = n\n        return self._attach_node(tree, grid, best_parent, pos, nodes, edges)\n\n    def _propagate_cost(self, node):\n        # Update costs down the subtree from this node\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                base = 0.0\n            else:\n                base = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            cur.cost = base\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _rewire_neighbors(self, tree, grid, new_node, edges):\n        nbrs = self._neighbors(grid, new_node.position, self.rewire_radius)\n        for nb in nbrs:\n            if nb is new_node or nb.parent is None:\n                continue\n            alt = new_node.cost + self._dist(new_node.position, nb.position)\n            if alt + 1e-9 < nb.cost and self._edge_free(new_node.position, nb.position):\n                # Rewire nb to new_node\n                oldp = nb.parent\n                # Remove edge (oldp, nb)\n                for i in range(len(edges) - 1, -1, -1):\n                    if edges[i][0] is oldp and edges[i][1] is nb:\n                        edges.pop(i)\n                        break\n                # Update parent-child lists\n                if nb in oldp.children:\n                    oldp.children.remove(nb)\n                new_node.add_child(nb)\n                # Add new edge\n                edges.append((new_node, nb))\n                # Propagate new costs\n                self._propagate_cost(nb)\n\n    def _extend_greedy(self, tree, grid, target, nodes, edges, choose_parent=True, do_rewire=True):\n        near = self._nearest(grid, target, tree)\n        if near is None:\n            return None\n        cur = near\n        created_any = None\n        steps = 0\n        first = True\n        while steps < max(2, int(self.conn_steps // 4)):\n            nxt = self._steer(cur.position, target, self.step)\n            if (not self._inside(nxt)) or self._point_blocked(nxt):\n                break\n            if self._too_close(grid, nxt, self.sep):\n                # If too dense around, stop this branch\n                break\n            if not self._edge_free(cur.position, nxt):\n                break\n            if first and choose_parent:\n                ins = self._choose_parent_and_attach(tree, grid, cur, nxt, nodes, edges)\n            else:\n                ins = self._attach_node(tree, grid, cur, nxt, nodes, edges)\n            if ins is None:\n                break\n            created_any = ins\n            if do_rewire:\n                self._rewire_neighbors(tree, grid, ins, edges)\n            cur = ins\n            steps += 1\n            if self._dist2(nxt, target) <= (self.step * self.step * 0.25):\n                break\n        return created_any\n\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        near = self._nearest(grid, target_pos, tree)\n        if near is None:\n            return None\n        cur = near\n        steps = 0\n        last_new = None\n        while steps < self.conn_steps:\n            nxt = self._steer(cur.position, target_pos, self.step)\n            if (not self._inside(nxt)) or self._point_blocked(nxt):\n                break\n            if not self._edge_free(cur.position, nxt):\n                break\n            ins = self._attach_node(tree, grid, cur, nxt, nodes, edges)\n            if ins is None:\n                break\n            last_new = ins\n            cur = ins\n            steps += 1\n            if self._dist2(nxt, target_pos) <= (self.step * self.step * 0.25):\n                break\n        # Try to insert exact meeting node at target (ignore spacing but respect collisions)\n        if last_new is not None:\n            if self._edge_free(last_new.position, target_pos) and (not self._point_blocked(target_pos)) and self._inside(target_pos):\n                meet = self._attach_node(tree, grid, last_new, target_pos, nodes, edges, ignore_spacing=True)\n                if meet is not None:\n                    return meet\n        return None\n\n    # Path utilities\n    def _path_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        return out[::-1]\n\n    def _polyline_len(self, pts):\n        if len(pts) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(pts)):\n            s += self._dist(pts[i - 1], pts[i])\n        return s\n\n    def _prune_los(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3 or attempts <= 0:\n            return pts[:]\n        cur = pts[:]\n        t = 0\n        while t < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                t += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cur = cur[:i + 1] + cur[j:]\n            t += 1\n        # remove consecutive duplicates\n        out = []\n        last = None\n        for p in cur:\n            if (last is None) or (p != last):\n                out.append(p)\n                last = p\n        return out\n\n    def _finalize(self, pts):\n        if not pts or len(pts) < 2:\n            return pts\n        p1 = self._prune_los(pts)\n        p2 = self._shortcut(p1, self.smooth_shortcuts)\n        return p2",
          "objective": -40.853,
          "time_improvement": 81.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1732.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009050464630126953,
                    "num_nodes_avg": 62.0,
                    "path_length_avg": 167.25184196372624,
                    "smoothness_avg": 0.05773376057210564,
                    "success_improvement": 0.0,
                    "time_improvement": 63.4356981723821,
                    "node_improvement": 84.38680433140266,
                    "length_improvement": 8.326615144646848,
                    "smoothness_improvement": 803.658723821166,
                    "objective_score": 28.044972157608566
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.007950639724731446,
                    "num_nodes_avg": 70.0,
                    "path_length_avg": 251.14175674494882,
                    "smoothness_avg": 0.12433013000291153,
                    "success_improvement": 0.0,
                    "time_improvement": 95.16463560694861,
                    "node_improvement": 95.29664718134785,
                    "length_improvement": 16.161652883875146,
                    "smoothness_improvement": 3099.103796347861,
                    "objective_score": 53.74190139414897
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.007700490951538086,
                    "num_nodes_avg": 72.0,
                    "path_length_avg": 128.38035355103494,
                    "smoothness_avg": 0.1094566942751672,
                    "success_improvement": 0.0,
                    "time_improvement": 84.89728411849231,
                    "node_improvement": 90.8455181182454,
                    "length_improvement": 14.735881986904387,
                    "smoothness_improvement": 1292.2810719273684,
                    "objective_score": 40.77211978732716
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SIMPLE-BiRRT-i: a simplified informed bi-directional RRT with spatial hashing and ghost-connect. It grows two trees from start and goal with small-step steering, hashed nearest search, light duplicate suppression, and early termination upon a valid bridge. It maintains coherence (node/edge checks before add), avoids heavy rewiring/compression, and performs greedy visibility pruning followed by bounded shortcut smoothing for shorter, smoother paths.",
          "planning_mechanism": "Alternate expanding start and goal trees. Each iteration: sample uniformly with goal-bias and optionally inside the informed ellipse if a path bound exists; choose a hashed-nearest parent; steer one step; validate node and edge; insert into the active tree. Try to connect to the opposite tree by direct line or a ghost (non-committal) short-step chain; if feasible, commit the chain, extract the bi-tree path, prune by visibility, shortcut, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        goal_bias=0.15,\n        informed_bias=0.5,\n        dupe_radius_ratio=0.35,\n        connect_radius_factor=3.0,\n        connect_steps=6,\n        smoothing_iters=60,\n        cell_factor=1.0\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.connect_radius_factor = float(connect_radius_factor)\n        self.connect_steps = int(connect_steps)\n        self.smoothing_iters = int(smoothing_iters)\n        self.cell_factor = float(cell_factor)\n        self._rng = 1234567\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_from_scene()\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Direct path early exit\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        self.cell_size = max(1.0, self.step_size * self.cell_factor)\n        self.dupe_radius = max(0.25, self.step_size * self.dupe_radius_ratio)\n        self.connect_radius = max(self.step_size, self.connect_radius_factor * self.step_size)\n\n        # Trees\n        nodes = []\n        edges = []\n\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        nodes.extend([root_a, root_b])\n        edges.extend([])\n\n        tree_a, tree_b = [root_a], [root_b]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, root_a)\n        self._grid_insert(grid_b, root_b)\n\n        best_len = float('inf')  # enables informed sampling when a bound appears\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            tree = tree_a if side_a else tree_b\n            other_tree = tree_b if side_a else tree_a\n            grid = grid_a if side_a else grid_b\n            other_grid = grid_b if side_a else grid_a\n            attractor = self.goal if side_a else self.start\n\n            s = self._sample(attractor, best_len)\n            if s is None:\n                continue\n\n            parent = self._nearest_hashed(grid, tree, s, 2)\n            if parent is None:\n                continue\n\n            new_pos = self._steer(parent.position, s)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n            if self._has_nearby(grid, new_pos, self.dupe_radius):\n                continue\n\n            new_node = Node(new_pos, parent, parent.cost + self._dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(grid, new_node)\n\n            # Try to connect directly to nearest in the opposite tree\n            near_other = self._nearest_hashed(other_grid, other_tree, new_node.position, 2)\n            if near_other is not None:\n                if self._dist(near_other.position, new_node.position) <= self.connect_radius and self._edge_free(near_other.position, new_node.position):\n                    path = self._extract_path(new_node, near_other, side_a)\n                    path = self._finalize_path(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n                # Ghost-connect: plan a short chain without committing, commit only if bridging succeeds\n                ok, chain_positions, last_pos = self._ghost_connect_positions(near_other.position, new_node.position, other_grid)\n                if ok and self._edge_free(last_pos, new_node.position):\n                    # Commit chain into the opposite tree\n                    prev = near_other\n                    for p in chain_positions:\n                        if self._has_nearby(other_grid, p, self.dupe_radius):\n                            prev = self._nearest_hashed(other_grid, other_tree, p, 1)\n                            if prev is None:\n                                prev = near_other\n                            continue\n                        if self._point_in_obstacles(p):\n                            ok = False\n                            break\n                        if not self._edge_free(prev.position, p):\n                            ok = False\n                            break\n                        q = Node(p, prev, prev.cost + self._dist(prev.position, p))\n                        prev.add_child(q)\n                        other_tree.append(q)\n                        nodes.append(q)\n                        edges.append((prev, q))\n                        self._grid_insert(other_grid, q)\n                        prev = q\n                    if ok and self._edge_free(prev.position, new_node.position):\n                        # We do not add a cross-tree edge; extract bi-tree path\n                        path = self._extract_path(new_node, prev, side_a)\n                        L = self._path_len(path)\n                        if L < best_len:\n                            best_len = L\n                        path = self._finalize_path(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1103515245 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 1) * 2654435761\n        if s == 0:\n            s = 1234567\n        self._rng = s & 0x7fffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0x7fffffff\n        return self._rng / float(1 << 31)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= self.step_size:\n            return tuple(b)\n        r = self.step_size / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n\n    # Obstacles\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            px, py, pz = p\n            for o in self.obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            px, py = p\n            for o in self.obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            for o in self.obstacles:\n                x, y, z, w, h, d = o\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            for o in self.obstacles:\n                x, y, w, h = o\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Spatial hashing\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, tree, pos, max_rings):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        any_found = False\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n                    any_found = True\n        if any_found:\n            return best\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n            if p and self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        if r < self.goal_bias:\n            p = attractor\n        else:\n            p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n        if self._in_bounds(p) and not self._point_in_obstacles(p):\n            return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [half] * self.dim\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dim))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # Ghost connect (non-committal)\n    def _ghost_connect_positions(self, from_pos, to_pos, other_grid):\n        chain = []\n        cur = from_pos\n        steps = 0\n        while steps < self.connect_steps:\n            nxt = self._steer(cur, to_pos)\n            if not self._in_bounds(nxt):\n                return False, None, None\n            if self._point_in_obstacles(nxt):\n                return False, None, None\n            if not self._edge_free(cur, nxt):\n                return False, None, None\n            if self._has_nearby(other_grid, nxt, self.dupe_radius):\n                return False, None, None\n            chain.append(nxt)\n            cur = nxt\n            if self._dist(cur, to_pos) <= self.step_size or self._edge_free(cur, to_pos):\n                return True, chain, cur\n            steps += 1\n        return False, None, None\n\n    # Paths and smoothing\n    def _path_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        return out[::-1]\n\n    def _extract_path(self, a_node, b_node, a_forward=True):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return (pa + pb[::-1]) if a_forward else (pb + pa[::-1])\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(pruned[-1], path[j]):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best_L = self._path_len(pts)\n        for _ in range(self.smoothing_iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                continue\n            a, b = pts[i], pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= best_L + 1e-12:\n                    pts = new_pts\n                    best_L = L\n        return pts\n\n    def _finalize_path(self, path):\n        if not path:\n            return []\n        p = self._visibility_prune(path)\n        p = self._shortcut(p)\n        return p",
          "objective": -40.79252,
          "time_improvement": 68.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 2580.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007870960235595702,
                    "num_nodes_avg": 48.0,
                    "path_length_avg": 179.5861954290845,
                    "smoothness_avg": 0.06548709066523807,
                    "success_improvement": 0.0,
                    "time_improvement": 68.09668444484818,
                    "node_improvement": 87.91236464366659,
                    "length_improvement": 1.565960559945877,
                    "smoothness_improvement": 925.0151764044653,
                    "objective_score": 25.993657551444304
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0211273193359375,
                    "num_nodes_avg": 158.0,
                    "path_length_avg": 237.3530114017347,
                    "smoothness_avg": 0.18862965381071545,
                    "success_improvement": 0.0,
                    "time_improvement": 87.36794088130645,
                    "node_improvement": 89.38386078075656,
                    "length_improvement": 20.764732966468724,
                    "smoothness_improvement": 4753.576856997666,
                    "objective_score": 62.437106329261496
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026227736473083497,
                    "num_nodes_avg": 250.0,
                    "path_length_avg": 127.39626037258856,
                    "smoothness_avg": 0.16982997215257256,
                    "success_improvement": 0.0,
                    "time_improvement": 48.039932985286335,
                    "node_improvement": 68.21360457724094,
                    "length_improvement": 15.389469818547017,
                    "smoothness_improvement": 2060.2247102361403,
                    "objective_score": 33.94678533789481
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "FIBER-Connect*: Fast Informed Bi-directional Edge-Refining RRT* with priority-balanced growth, adaptive neighbor/rewire radii, short validated bridges, and online visibility-prune/shortcutting for smooth, compact paths with low search cost.",
          "planning_mechanism": "Per iteration, expand the smaller tree: sample (uniform/goal; informed ellipse after first path), steer one step, validate node and parent edge, pick the lowest-cost parent among nearby neighbors, insert, then locally rewire to reduce cost. Attempt a short, validated bridge to the opposite tree; if blocked, allow at most one assisted hop on the passive tree before retrying. On a bridge, extract the bi-tree path, apply visibility pruning and length-nonincreasing shortcuts, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=5.5,\n        goal_bias=0.25,\n        informed_bias=0.6,\n        grid_cell_factor=1.0,\n        neighbor_base=3.2,\n        rewire_base=2.6,\n        connect_factor=3.0,\n        dupe_ratio=0.45,\n        ring_cap=4,\n        bridge_hops=1,\n        smooth_iters=80\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neighbor_base = float(neighbor_base)\n        self.rewire_base = float(rewire_base)\n        self.connect_factor = float(connect_factor)\n        self.dupe_ratio = float(dupe_ratio)\n        self.ring_cap = int(ring_cap)\n        self.bridge_hops = int(bridge_hops)\n        self.smooth_iters = int(smooth_iters)\n        self._rng = 123456789\n\n    def plan(self, map):\n        # Scene\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        # Validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_rng()\n        # Build obstacle index and ensure start/goal free\n        self._build_obs_index()\n        if self._in_obs(self.start) or self._in_obs(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Straight line early exit\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            edges = [(n0, n1)]\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], edges)\n\n        # Parameters\n        self.space_extent = max(1.0, max(self.bounds))\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius_base = max(0.3, self.dupe_ratio * self.step_size)\n        self.connect_radius = max(self.step_size, self.connect_factor * self.step_size)\n\n        # Trees and spatial hashes\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes = [start_root, goal_root]\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        # Informed sampling bookkeeping\n        have_solution = False\n        best_path = []\n        best_len = 1e100\n        c_min = self._dist(self.start, self.goal)\n\n        for it in range(self.max_iter):\n            # Choose the tree with fewer nodes to keep balance\n            expand_a = (len(tree_a) <= len(tree_b))\n            active_tree = tree_a if expand_a else tree_b\n            passive_tree = tree_b if expand_a else tree_a\n            active_grid = grid_a if expand_a else grid_b\n            passive_grid = grid_b if expand_a else grid_a\n            attractor = self.goal if expand_a else self.start\n\n            # Radii adapt to tree size\n            n_active = max(2, len(active_tree))\n            parent_radius = self._adaptive_radius(n_active, self.neighbor_base)\n            rewire_radius = self._adaptive_radius(n_active, self.rewire_base)\n            dupe_radius = self.dupe_radius_base * (0.35 if have_solution else 1.0)\n\n            # Sample\n            x_rand = self._sample(attractor, have_solution, best_len, c_min)\n            if x_rand is None:\n                continue\n\n            # Nearest and steer\n            nearest = self._nearest(active_grid, x_rand)\n            if nearest is None:\n                continue\n            x_new = self._steer(nearest.position, x_rand, self.step_size)\n            if self._dist2(nearest.position, x_new) < 1e-10:\n                continue\n            if not self._in_bounds(x_new):\n                continue\n            if self._in_obs(x_new):\n                continue\n            if self._has_nearby(active_grid, x_new, dupe_radius):\n                continue\n\n            # Choose lowest-cost parent among neighbors (ties broken by smoother turn)\n            parent, new_cost = self._choose_parent(active_grid, x_new, nearest, parent_radius)\n            if parent is None:\n                continue\n\n            # Validate both checks before adding\n            if self._in_obs(x_new):\n                continue\n            if not self._edge_free(parent.position, x_new):\n                continue\n\n            # Insert node\n            new_node = Node(x_new, parent, new_cost)\n            parent.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            self._grid_insert(active_grid, new_node)\n\n            # Local rewiring\n            self._rewire(new_node, active_grid, rewire_radius)\n\n            # Try a short, validated bridge\n            bnode = self._best_bridge_candidate(passive_grid, new_node.position, self.connect_radius)\n            bridged = None\n            if bnode is not None and self._edge_free(bnode.position, new_node.position):\n                bridged = bnode\n            else:\n                # One assisted hop on passive tree if allowed\n                hops = 0\n                while bridged is None and hops < self.bridge_hops:\n                    hops += 1\n                    near_p = self._nearest(passive_grid, new_node.position)\n                    if near_p is None:\n                        break\n                    x_step = self._steer(near_p.position, new_node.position, self.step_size)\n                    if not self._in_bounds(x_step) or self._in_obs(x_step):\n                        break\n                    if self._has_nearby(passive_grid, x_step, dupe_radius):\n                        break\n                    # Select parent for the hop\n                    hop_parent, hop_cost = self._choose_parent(passive_grid, x_step, near_p, parent_radius)\n                    if hop_parent is None:\n                        break\n                    if not self._edge_free(hop_parent.position, x_step):\n                        break\n                    # Insert hop node in passive tree\n                    hop_node = Node(x_step, hop_parent, hop_cost)\n                    hop_parent.add_child(hop_node)\n                    passive_tree.append(hop_node)\n                    nodes.append(hop_node)\n                    self._grid_insert(passive_grid, hop_node)\n                    # Light rewiring on passive tree\n                    self._rewire(hop_node, passive_grid, rewire_radius)\n                    # Retry direct bridge\n                    if self._edge_free(hop_node.position, new_node.position):\n                        bridged = hop_node\n                        break\n\n            if bridged is not None:\n                path = self._extract_path(new_node, bridged, expand_a)\n                # Visibility prune then length-nonincreasing shortcuts\n                path = self._visibility_prune(path)\n                path = self._shortcut_nonincreasing(path, self.smooth_iters)\n                best_path = path\n                best_len = self._path_len(path)\n                edges = self._collect_edges(nodes)\n                return PlannerResult(True, best_path, nodes, edges)\n\n            # Optional online smoothing of incumbent (if already found, keep improving lightly)\n            if have_solution and best_path:\n                best_path = self._shortcut_nonincreasing(best_path, 4)\n                best_len = self._path_len(best_path)\n\n        # Finalize\n        edges = self._collect_edges(nodes)\n        if best_path:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # -------------------- RNG --------------------\n    def _seed_rng(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 17) * 2654435761\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # -------------------- Geometry --------------------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        d = d2 ** 0.5\n        if d <= step:\n            q = []\n            for i in range(self.dim):\n                v = b[i]\n                if v < 0.0:\n                    v = 0.0\n                if v > self.bounds[i]:\n                    v = self.bounds[i]\n                q.append(v)\n            return tuple(q)\n        r = step / d\n        q = []\n        for i in range(self.dim):\n            v = a[i] + (b[i] - a[i]) * r\n            if v < 0.0:\n                v = 0.0\n            if v > self.bounds[i]:\n                v = self.bounds[i]\n            q.append(v)\n        return tuple(q)\n\n    # -------------------- Obstacles --------------------\n    def _build_obs_index(self):\n        self.obs_cell = max(3.0, self.step_size * 1.3)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, ob in enumerate(self.obstacles):\n                x, y, z, w, h, d = ob\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, ob in enumerate(self.obstacles):\n                x, y, w, h = ob\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _in_obs(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            b = self.obs_grid.get((cx, cy, cz))\n            if not b:\n                return False\n            px, py, pz = p\n            for idx in b:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            b = self.obs_grid.get((cx, cy))\n            if not b:\n                return False\n            px, py = p\n            for idx in b:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        arr = self.obs_grid.get((cx, cy, cz))\n                        if arr:\n                            for idx in arr:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    arr = self.obs_grid.get((cx, cy))\n                    if arr:\n                        for idx in arr:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # -------------------- Spatial hashing --------------------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _neighbors_within(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        out = []\n        r2 = radius * radius\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_of(pos)\n        best = None\n        bestd2 = 1e100\n        got = False\n        for r in range(0, self.ring_cap + 1):\n            cand = []\n            if self.is_3d:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                            if b:\n                                cand.extend(b)\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy))\n                        if b:\n                            cand.extend(b)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n                    got = True\n            if got:\n                return best\n        # Fallback random probe\n        buckets = list(grid.values())\n        tries = 0\n        while tries < 32 and buckets:\n            b = buckets[int(self._rand_range(0, len(buckets)))]\n            if b:\n                n = b[int(self._rand_range(0, len(b)))]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            tries += 1\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        ns = self._neighbors_within(grid, pos, radius)\n        return len(ns) > 0\n\n    # -------------------- Parent selection and rewiring --------------------\n    def _choose_parent(self, grid, new_pos, fallback, radius):\n        cand = self._neighbors_within(grid, new_pos, radius)\n        if fallback not in cand:\n            cand.append(fallback)\n        best = None\n        best_cost = 1e100\n        best_smooth = -1.0\n        for n in cand:\n            if not self._edge_free(n.position, new_pos):\n                continue\n            c = n.cost + self._dist(n.position, new_pos)\n            if c + 1e-12 < best_cost:\n                best_cost = c\n                best = n\n                best_smooth = self._smooth_score(n, new_pos)\n            elif abs(c - best_cost) <= 1e-12:\n                sc = self._smooth_score(n, new_pos)\n                if sc > best_smooth:\n                    best_smooth = sc\n                    best = n\n        if best is None:\n            return None, None\n        return best, best_cost\n\n    def _smooth_score(self, parent, new_pos):\n        # Cosine of turn angle; higher is smoother. If no grandparent, neutral.\n        if parent.parent is None:\n            return 0.0\n        a = parent.parent.position\n        b = parent.position\n        c = new_pos\n        ab = tuple(b[i] - a[i] for i in range(self.dim))\n        bc = tuple(c[i] - b[i] for i in range(self.dim))\n        nab = self._dist(a, b)\n        nbc = self._dist(b, c)\n        if nab <= 1e-12 or nbc <= 1e-12:\n            return 0.0\n        dot = 0.0\n        for i in range(self.dim):\n            dot += ab[i] * bc[i]\n        cosang = dot / (nab * nbc)\n        if cosang < -1.0:\n            cosang = -1.0\n        if cosang > 1.0:\n            cosang = 1.0\n        return cosang\n\n    def _rewire(self, pivot, grid, radius):\n        neighbors = self._neighbors_within(grid, pivot.position, radius)\n        for nb in neighbors:\n            if nb is pivot or nb.parent is pivot:\n                continue\n            # prevent cycles: if nb is ancestor of pivot, skip\n            if self._is_ancestor(nb, pivot):\n                continue\n            if not self._edge_free(pivot.position, nb.position):\n                continue\n            new_c = pivot.cost + self._dist(pivot.position, nb.position)\n            if new_c + 1e-12 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    try:\n                        oldp.children.remove(nb)\n                    except:\n                        pass\n                pivot.add_child(nb)\n                nb.cost = new_c\n                self._propagate_cost(nb)\n\n    def _is_ancestor(self, node, potential_child):\n        cur = potential_child\n        while cur is not None:\n            if cur is node:\n                return True\n            cur = cur.parent\n        return False\n\n    def _propagate_cost(self, node):\n        # Update subtree costs after rewiring\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if newc + 1e-12 < ch.cost:\n                    ch.cost = newc\n                stack.append(ch)\n\n    # -------------------- Bridging and paths --------------------\n    def _best_bridge_candidate(self, grid_other, pos, radius):\n        cand = self._neighbors_within(grid_other, pos, radius)\n        if not cand:\n            return None\n        best = None\n        bestd2 = 1e100\n        for n in cand:\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd2:\n                bestd2 = d2\n                best = n\n        return best\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node, a_from_start):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if a_from_start:\n            return pa + list(reversed(pb))\n        else:\n            return pb + list(reversed(pa))\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(pruned[-1], path[j]):\n                    # Accept only if not longer than original subpath\n                    seg = self._dist(pruned[-1], path[j])\n                    walk = 0.0\n                    for k in range(i + 1, j + 1):\n                        walk += self._dist(path[k - 1], path[k])\n                    if seg + 1e-9 <= walk:\n                        pruned.append(path[j])\n                        i = j\n                        advanced = True\n                        break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _shortcut_nonincreasing(self, path, iters):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        bestL = self._path_len(pts)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                newL = self._path_len(new_pts)\n                if newL <= bestL + 1e-12:\n                    pts = new_pts\n                    bestL = newL\n        return pts\n\n    def _collect_edges(self, nodes):\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        return edges\n\n    # -------------------- Sampling --------------------\n    def _sample(self, attractor, informed, best_len, c_min):\n        r = self._rand()\n        if informed and best_len < 1e99 and r < self.informed_bias:\n            p = self._informed_sample(self.start, self.goal, best_len * 1.01, c_min)\n            if p is not None and self._in_bounds(p) and not self._in_obs(p):\n                return p\n        if r < self.goal_bias:\n            p = attractor\n            return p if self._in_bounds(p) and not self._in_obs(p) else None\n        # Uniform\n        p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n        if self._in_bounds(p) and not self._in_obs(p):\n            return p\n        return None\n\n    def _informed_sample(self, f1, f2, c_best, c_min):\n        if not (c_best > c_min + 1e-9):\n            return None\n        center = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        a_vec = tuple(f2[i] - f1[i] for i in range(self.dim))\n        a_len = self._dist((0.0,) * self.dim, a_vec)\n        if a_len <= 1e-12:\n            return None\n        a_hat = tuple(a_vec[i] / a_len for i in range(self.dim))\n        r1 = 0.5 * c_best\n        r2_sq = max(0.0, 0.25 * (c_best * c_best - c_min * c_min))\n        if self.is_3d:\n            # Build orthonormal basis [a_hat, v, w]\n            # Simple fixed aux and cross to form basis\n            u = (1.0, 0.0, 0.0) if abs(a_hat[0]) < 0.9 else (0.0, 1.0, 0.0)\n            v = self._normalize(self._cross(a_hat, u))\n            w = self._cross(a_hat, v)\n            for _ in range(32):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                z = self._rand_range(-1.0, 1.0)\n                if x * x + y * y + z * z > 1.0:\n                    continue\n                px = r1 * x\n                r2 = (r2_sq ** 0.5)\n                py = r2 * y\n                pz = r2 * z\n                ex = center[0] + px * a_hat[0] + py * v[0] + pz * w[0]\n                ey = center[1] + px * a_hat[1] + py * v[1] + pz * w[1]\n                ez = center[2] + px * a_hat[2] + py * v[2] + pz * w[2]\n                p = (ex, ey, ez)\n                if self._in_bounds(p) and not self._in_obs(p):\n                    return p\n            return None\n        else:\n            # 2D ellipse with axes r1, r2\n            perp = (-a_hat[1], a_hat[0])\n            for _ in range(32):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                if x * x + y * y > 1.0:\n                    continue\n                r2 = (r2_sq ** 0.5)\n                px = r1 * x\n                py = r2 * y\n                ex = center[0] + px * a_hat[0] + py * perp[0]\n                ey = center[1] + px * a_hat[1] + py * perp[1]\n                p = (ex, ey)\n                if self._in_bounds(p) and not self._in_obs(p):\n                    return p\n            return None\n\n    def _normalize(self, v):\n        n = self._dist((0.0,) * len(v), v)\n        if n <= 1e-12:\n            return v\n        return tuple(v[i] / n for i in range(len(v)))\n\n    def _cross(self, a, b):\n        return (a[1] * b[2] - a[2] * b[1],\n                a[2] * b[0] - a[0] * b[2],\n                a[0] * b[1] - a[1] * b[0])\n\n    # -------------------- Radii --------------------\n    def _adaptive_radius(self, n, base_mult):\n        # Decays with n; lower-bounded by 1.5*step_size\n        decay = (1.0 / (n ** (1.0 / max(2, self.dim))))\n        r = base_mult * self.step_size * 0.5 + self.space_extent * 0.05 * decay\n        return max(1.5 * self.step_size, r)",
          "objective": -40.1344,
          "time_improvement": 63.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1814.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012674951553344726,
                    "num_nodes_avg": 45.0,
                    "path_length_avg": 153.35894992834636,
                    "smoothness_avg": 0.03846541732582647,
                    "success_improvement": 0.0,
                    "time_improvement": 48.6246954693179,
                    "node_improvement": 88.66784185343742,
                    "length_improvement": 15.941529416200709,
                    "smoothness_improvement": 502.0673101398352,
                    "objective_score": 26.66266284121497
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05657989978790283,
                    "num_nodes_avg": 140.0,
                    "path_length_avg": 233.83827885399037,
                    "smoothness_avg": 0.11832797178444796,
                    "success_improvement": 0.0,
                    "time_improvement": 66.17078448590458,
                    "node_improvement": 90.5932943626957,
                    "length_improvement": 21.93805185687287,
                    "smoothness_improvement": 2944.6639422069725,
                    "objective_score": 47.73738617092995
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013706851005554199,
                    "num_nodes_avg": 79.0,
                    "path_length_avg": 115.01768024557694,
                    "smoothness_avg": 0.16483033391240323,
                    "success_improvement": 0.0,
                    "time_improvement": 72.84520158496316,
                    "node_improvement": 89.95549904640814,
                    "length_improvement": 23.61073333426484,
                    "smoothness_improvement": 1996.6296808560942,
                    "objective_score": 46.003148880328325
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "FENRIR-Connect: A fast, cost-aware BiRRT*-Connect variant with spatial hashing for nodes and obstacles, adaptive neighbor radius, duplicate suppression, and exact seam insertion. It prioritizes early direct-visibility connections, chooses lowest-cost parents, incrementally rewires local neighbors, and finishes with light visibility pruning plus a few randomized shortcuts for short, smooth paths at low planning time.",
          "planning_mechanism": "Alternate expansion from start and goal: sample (goal-biased; informed ellipse after first path), steer one step, pick the best-cost parent within an adaptive radius, add only if node and edge are collision-free, locally rewire cheaper neighbors, then greedily connect the opposite tree and insert the exact meeting point if visible; upon connection, extract and finalize the path via visibility pruning and brief shortcut smoothing, then return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=5.5,\n        connect_mult=2.2,\n        goal_bias=0.14,\n        grid_cell_factor=1.8,\n        rewire_base=2.6,\n        dup_radius_factor=0.35,\n        smooth_attempts=120\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_step = float(step_size * connect_mult)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.rewire_base = float(rewire_base)\n        self.dup_factor = float(dup_radius_factor)\n        self.smooth_attempts = int(max(0, smooth_attempts))\n        self._rng = 88172645463393265 % (1 << 32)\n\n    # ------------------ Public API ------------------\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n\n        # Spatial params\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_radius = max(0.5, self.dup_factor * self.step)\n\n        # Build obstacle bins\n        self._build_obs_bins()\n\n        # Start/goal validity\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Direct visibility\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            final = self._finalize_path(path)\n            return PlannerResult(True, final, nodes, edges)\n\n        # Initialize trees and node grids\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        Ta, Tb = [root_a], [root_b]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, root_a)\n        self._grid_add(Gb, root_b)\n        nodes.extend([root_a, root_b])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            # Alternate expansion\n            active_from_start = (it % 2 == 0)\n            tree = Ta if active_from_start else Tb\n            other_tree = Tb if active_from_start else Ta\n            grid = Ga if active_from_start else Gb\n            other_grid = Gb if active_from_start else Ga\n            attractor = self.goal if active_from_start else self.start\n\n            s = self._sample(attractor, best_len)\n            if s is None:\n                continue\n\n            near = self._nearest(grid, s)\n            if near is None:\n                continue\n\n            newp = self._steer(near.position, s, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(grid, newp, self.dup_radius):\n                continue\n\n            # Parent selection within adaptive radius\n            radius = self._rewire_radius(len(tree))\n            parent, new_cost = self._best_parent(grid, near, newp, radius)\n            if parent is None:\n                continue\n\n            # Strict checks before adding node/edge\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, new_cost)\n            parent.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(grid, nn)\n\n            # Local rewiring\n            self._rewire_neighbors(grid, nn, radius, edges)\n\n            # Greedy connect other tree toward nn; insert exact meeting if visible\n            meet, reached = self._connect_toward(other_tree, other_grid, nn.position, nodes, edges)\n            if reached:\n                if active_from_start:\n                    pa = self._trace_to_root(nn)        # start -> ... -> meet\n                    pb = self._trace_to_root(meet)      # goal  -> ... -> meet\n                    path = pa + pb[-2::-1]\n                else:\n                    pa = self._trace_to_root(meet)      # start -> ... -> meet\n                    pb = self._trace_to_root(nn)        # goal  -> ... -> meet\n                    path = pa + pb[-2::-1]\n\n                path = self._dedup(path)\n                best_len = self._path_len(path)\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # ------------------ RNG ------------------\n    def _seed_from_scene(self):\n        s = 2166136261 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= q\n            s = (s * 16777619) & 0xffffffff\n        s ^= ((len(self.obstacles) + 97) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        # 32-bit LCG\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------------ Geometry ------------------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a[i] for i in range(self.dim))\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # ------------------ Spatial hash (nodes) ------------------\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, ring):\n        out = []\n        if self.is3:\n            for dx in range(-ring, ring + 1):\n                for dy in range(-ring, ring + 1):\n                    for dz in range(-ring, ring + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-ring, ring + 1):\n                for dy in range(-ring, ring + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        k = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        for r in range(0, 4):\n            cand = self._grid_collect(grid, k, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found = True\n            if found:\n                return best\n        # fallback scan\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_radius(self, grid, pos, radius):\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        k = self._cell_key(pos)\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((k[0] + dx, k[1] + dy, k[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((k[0] + dx, k[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        neigh = self._neighbors_radius(grid, pos, radius)\n        return len(neigh) > 0\n\n    # ------------------ Obstacles and collision ------------------\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.25)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        # Collect candidate obstacles via bin bounds\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_overlap(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_overlap(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_overlap(self, p0, p1, bmin, bmax):\n        # Slab method\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            q = p1[i]\n            d = q - p\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t0 = (mn - p) * inv\n                t1 = (mx - p) * inv\n                if t0 > t1:\n                    tt = t0\n                    t0 = t1\n                    t1 = tt\n                if t0 > tmin:\n                    tmin = t0\n                if t1 < tmax:\n                    tmax = t1\n                if tmin > tmax:\n                    return False\n        return True\n\n    # ------------------ Parenting and rewiring ------------------\n    def _rewire_radius(self, n_nodes):\n        # Smooth decay with tree size; keep generous early radius\n        base = max(self.step * 1.5, self.step * self.rewire_base)\n        scale = 1.0 / (1.0 + 0.002 * n_nodes)\n        # dimension-aware shrink\n        exp = 1.0 / float(self.dim if self.dim > 0 else 1)\n        r = base * (scale ** exp)\n        return max(self.step * 1.25, r)\n\n    def _best_parent(self, grid, near, newp, radius):\n        parent = None\n        best = 1e100\n        neigh = self._neighbors_radius(grid, newp, radius)\n        if not neigh:\n            neigh = [near]\n        for n in neigh:\n            if not self._edge_free(n.position, newp):\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c < best:\n                best = c\n                parent = n\n        return parent, best if parent is not None else (None, None)\n\n    def _rewire_neighbors(self, grid, pivot, radius, edges):\n        neigh = self._neighbors_radius(grid, pivot.position, radius)\n        for nb in neigh:\n            if nb is pivot or nb.parent is None:\n                continue\n            cand = pivot.cost + self._dist(pivot.position, nb.position)\n            if cand + 1e-12 < nb.cost and self._edge_free(pivot.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, (oldp, nb))\n                pivot.add_child(nb)\n                nb.cost = cand\n                edges.append((pivot, nb))\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _remove_edge(self, edges, e):\n        # remove first match\n        for i in range(len(edges)):\n            if edges[i][0] is e[0] and edges[i][1] is e[1]:\n                edges.pop(i)\n                return\n\n    # ------------------ Connect other tree ------------------\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n\n        # Direct connect if visible\n        if self._edge_free(cur.position, target_pos):\n            # Insert exact meeting if not too close\n            if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    nc = Node(target_pos, cur, cur.cost + self._dist(cur.position, target_pos))\n                    cur.add_child(nc)\n                    tree.append(nc)\n                    nodes.append(nc)\n                    edges.append((cur, nc))\n                    self._grid_add(grid, nc)\n                    return nc, True\n            return cur, True\n\n        # Greedy bounded stepping\n        steps = 0\n        limit = 64\n        here = cur\n        while steps < limit:\n            nxt = self._steer(here.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                break\n            if not self._edge_free(here.position, nxt):\n                break\n            if self._too_close(grid, nxt, self.dup_radius * 0.75):\n                break\n            nn = Node(nxt, here, here.cost + self._dist(here.position, nxt))\n            here.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((here, nn))\n            self._grid_add(grid, nn)\n            here = nn\n            steps += 1\n            if self._edge_free(here.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                    if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                        meet = Node(target_pos, here, here.cost + self._dist(here.position, target_pos))\n                        here.add_child(meet)\n                        tree.append(meet)\n                        nodes.append(meet)\n                        edges.append((here, meet))\n                        self._grid_add(grid, meet)\n                        return meet, True\n                return here, True\n\n        # Final direct try\n        if self._edge_free(here.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    meet = Node(target_pos, here, here.cost + self._dist(here.position, target_pos))\n                    here.add_child(meet)\n                    tree.append(meet)\n                    nodes.append(meet)\n                    edges.append((here, meet))\n                    self._grid_add(grid, meet)\n                    return meet, True\n            return here, True\n\n        return here, False\n\n    # ------------------ Sampling ------------------\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.6:\n            p = self._sample_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            if self._in_bounds(attractor) and (not self._point_in_obstacles(attractor)):\n                return attractor\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(32):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum + 1e-9:\n                return p\n        return None\n\n    # ------------------ Path utilities ------------------\n    def _trace_to_root(self, node):\n        cur = node\n        pts = []\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        n = len(cur)\n        tries = 0\n        while tries < attempts and n > 2:\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cur = cur[:i + 1] + cur[j:]\n                n = len(cur)\n            tries += 1\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._visibility_prune(path)\n        p1 = self._shortcut(p0, max(20, self.smooth_attempts))\n        p2 = self._visibility_prune(p1)\n        return self._dedup(p2)",
          "objective": -40.03655,
          "time_improvement": 75.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1190.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.00911562442779541,
                    "num_nodes_avg": 42.0,
                    "path_length_avg": 160.0835385997664,
                    "smoothness_avg": 0.0506179669795133,
                    "success_improvement": 0.0,
                    "time_improvement": 63.051694596676235,
                    "node_improvement": 89.42331906320827,
                    "length_improvement": 12.255675807468933,
                    "smoothness_improvement": 692.2811019039884,
                    "objective_score": 29.73031937300417
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02603757381439209,
                    "num_nodes_avg": 162.0,
                    "path_length_avg": 231.3416199523067,
                    "smoothness_avg": 0.08683134390642434,
                    "success_improvement": 0.0,
                    "time_improvement": 84.43209162029012,
                    "node_improvement": 89.11509776254786,
                    "length_improvement": 22.77150846059685,
                    "smoothness_improvement": 2134.233020801344,
                    "objective_score": 49.66369766645187
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010724067687988281,
                    "num_nodes_avg": 75.0,
                    "path_length_avg": 117.01222962601585,
                    "smoothness_avg": 0.06631602341986054,
                    "success_improvement": 0.0,
                    "time_improvement": 78.75442753856959,
                    "node_improvement": 90.46408137317228,
                    "length_improvement": 22.286048606012514,
                    "smoothness_improvement": 743.5349229609544,
                    "objective_score": 40.715632039983156
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SAGE-Connect: A simplified adaptive BiRRT-Connect with local cost-aware parenting and light rewiring. It uses a uniform spatial hash for nearest/neighbor queries, coarse obstacle binning for fast collision checks, adaptive rewire radius, and minimal biased/informed sampling. It inserts only strictly node- and edge-free states, creates the exact meeting node to reduce kinks, and applies a compact densify+shortcut+visibility smoother for short, smooth paths.",
          "planning_mechanism": "Alternate growth from start/goal trees: sample (uniform with small goal bias; ellipse after first solution), steer one step, choose the best-cost parent among nearby nodes, add after node+edge checks, locally rewire cheaper neighbors, then greedily extend the opposite tree toward the new node and insert the exact meeting point; upon connection, extract, densify, shortcut, visibility-prune, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=6.0,\n        connect_mult=2.0,\n        goal_bias=0.12,\n        grid_cell_factor=1.6,\n        rewire_base=2.2,\n        smooth_iters=120\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_mult = float(connect_mult)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.rewire_base = float(rewire_base)\n        self.smooth_iters = int(max(0, smooth_iters))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.connect_step = max(self.step, self.step * self.connect_mult)\n        self.dup_radius = max(0.5, 0.4 * self.step)\n\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            Ta = tree_a if active_start else tree_b\n            Tb = tree_b if active_start else tree_a\n            Ga = grid_a if active_start else grid_b\n            Gb = grid_b if active_start else grid_a\n            attractor = self.goal if active_start else self.start\n\n            sample = self._sample(attractor, best_len)\n            if sample is None:\n                continue\n\n            na = self._nearest(Ga, sample)\n            if na is None:\n                continue\n\n            newp = self._steer(na.position, sample, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(Ga, newp, self.dup_radius):\n                continue\n            if not self._edge_free(na.position, newp):\n                continue\n\n            rew_rad = self._adaptive_rewire_radius(len(Ta))\n            parent, new_cost = self._choose_parent(Ga, newp, na, rew_rad)\n\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, new_cost)\n            parent.add_child(nn)\n            Ta.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(Ga, nn)\n\n            self._local_rewire(Ga, nn, rew_rad, edges)\n\n            meet_node, reached = self._connect_toward(Tb, Gb, nn.position, nodes, edges)\n            if reached:\n                if active_start:\n                    pa = self._trace_to_root(nn)        # start -> ... -> nn\n                    pb = self._trace_to_root(meet_node) # goal  -> ... -> nn\n                    path = pa + pb[-2::-1]              # avoid duplicate nn\n                else:\n                    pa = self._trace_to_root(meet_node) # start -> ... -> nn\n                    pb = self._trace_to_root(nn)        # goal  -> ... -> nn\n                    path = pa + pb[-2::-1]\n\n                path = self._dedup(path)\n                best_len = self._path_len(path)\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0x9E3779B9 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= (q ^ (q >> 13) ^ ((q << 7) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 13) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial hash\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found_any = False\n        for r in range(0, 4):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found_any = True\n            if found_any:\n                return best\n        # fallback\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors_in_radius(grid, pos, radius)) > 0\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.2)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Parenting and rewiring\n    def _choose_parent(self, grid, newp, fallback, radius):\n        parent = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        neigh = self._neighbors_in_radius(grid, newp, radius)\n        for n in neigh:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                parent = n\n                best_cost = c\n        return parent, best_cost\n\n    def _local_rewire(self, grid, nn, radius, edges):\n        neigh = self._neighbors_in_radius(grid, nn.position, radius)\n        for nb in neigh:\n            if nb is nn or nb is nn.parent:\n                continue\n            cand = nn.cost + self._dist(nn.position, nb.position)\n            if cand + 1e-12 < nb.cost and self._edge_free(nn.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, (oldp, nb))\n                nn.add_child(nb)\n                nb.cost = cand\n                edges.append((nn, nb))\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _remove_edge(self, edges, e):\n        try:\n            idx = edges.index(e)\n            edges.pop(idx)\n        except:\n            pass\n\n    def _adaptive_rewire_radius(self, n_nodes):\n        # Shrink with tree size without log; simple exponential decay\n        base = max(self.step * 1.2, self.step * self.rewire_base)\n        decay = pow(0.5, n_nodes / 2500.0)\n        return max(self.step * 1.2, base * decay)\n\n    # BiRRT-Connect growth from other tree toward target; insert exact meeting node if visible\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < 64:\n            if self._edge_free(cur.position, target_pos):\n                # Insert the exact meeting point for a clean junction\n                if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                    if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        cur.add_child(nn)\n                        tree.append(nn)\n                        nodes.append(nn)\n                        edges.append((cur, nn))\n                        self._grid_add(grid, nn)\n                        return nn, True\n                # If too close, treat current as meeting node\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            if self._too_close(grid, nxt, self.dup_radius * 0.75):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n        # Final try after capped steps\n        if self._edge_free(cur.position, target_pos):\n            if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    cur.add_child(nn)\n                    tree.append(nn)\n                    nodes.append(nn)\n                    edges.append((cur, nn))\n                    self._grid_add(grid, nn)\n                    return nn, True\n            return cur, True\n        return cur, False\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.55:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Path utilities\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _densify(self, pts, seg_len):\n        if len(pts) < 2:\n            return pts[:]\n        out = [pts[0]]\n        for i in range(1, len(pts)):\n            a = out[-1]\n            b = pts[i]\n            d = self._dist(a, b)\n            if d <= seg_len * 1.05:\n                out.append(b)\n                continue\n            nseg = int(d / seg_len)\n            if nseg < 1:\n                out.append(b)\n                continue\n            for k in range(1, nseg + 1):\n                t = k / float(nseg + 1)\n                inter = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n                if self._edge_free(out[-1], inter):\n                    out.append(inter)\n                else:\n                    break\n            if self._edge_free(out[-1], b):\n                out.append(b)\n            else:\n                out.append(b)\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._densify(path, seg_len=max(1.0, 0.5 * self.step))\n        p1 = self._shortcut(p0, self.smooth_iters)\n        p2 = self._visibility_prune(p1)\n        p3 = self._shortcut(p2, max(20, self.smooth_iters // 2))\n        return self._dedup(p3)",
          "objective": -39.95809,
          "time_improvement": 69.0,
          "length_improvement": 21.0,
          "smoothness_improvement": 1361.0,
          "node_improvement": 85.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008446240425109863,
                    "num_nodes_avg": 40.0,
                    "path_length_avg": 154.00203649529243,
                    "smoothness_avg": 0.0463463750398735,
                    "success_improvement": 0.0,
                    "time_improvement": 65.76490472936995,
                    "node_improvement": 89.92697053638882,
                    "length_improvement": 15.589043478498803,
                    "smoothness_improvement": 625.4214121382626,
                    "objective_score": 32.21000456660158
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02304682731628418,
                    "num_nodes_avg": 136.0,
                    "path_length_avg": 230.09301068249903,
                    "smoothness_avg": 0.08849989105200873,
                    "success_improvement": 0.0,
                    "time_improvement": 86.220263890156,
                    "node_improvement": 90.86205738090439,
                    "length_improvement": 23.188330174083777,
                    "smoothness_improvement": 2177.1659406631616,
                    "objective_score": 50.66490697481287
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02282891273498535,
                    "num_nodes_avg": 204.0,
                    "path_length_avg": 115.03810237530747,
                    "smoothness_avg": 0.10863321186734835,
                    "success_improvement": 0.0,
                    "time_improvement": 54.77338134763434,
                    "node_improvement": 74.06230133502861,
                    "length_improvement": 23.597169928095134,
                    "smoothness_improvement": 1281.8064364830614,
                    "objective_score": 36.99934854356269
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "BLITZ-BiRRT: Ultra-fast bidirectional RRT-Connect with hashed k-nearest parenting, single-hop connection, and capped leaf-only rewiring. It minimizes work per iteration, avoids chain growth in the passive tree, uses fast-decaying neighbor radii, and finishes with quick visibility pruning and few shortcuts.",
          "planning_mechanism": "Alternate expansions from start and goal: sample with goal/informed bias, steer one step, pick the best parent among k local hashed neighbors, insert after node and edge checks, optionally rewire a few leaf neighbors, then attempt a single line-of-sight connect from the opposite tree by inserting only the exact meeting node. On success, extract and quickly prune/shortcut the path; else continue.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=7.5,\n        goal_bias=0.2,\n        grid_cell_factor=1.6,\n        k_near=8,\n        ring_cap=2,\n        rewire_k=3,\n        smooth_iters=50\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.k_near = int(max(1, k_near))\n        self.ring_cap = int(max(1, ring_cap))\n        self.rewire_k = int(max(0, rewire_k))\n        self.smooth_iters = int(max(0, smooth_iters))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_radius = max(0.5, 0.45 * self.step)\n\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            Ta = tree_a if active_start else tree_b\n            Tb = tree_b if active_start else tree_a\n            Ga = grid_a if active_start else grid_b\n            Gb = grid_b if active_start else grid_a\n            attractor = self.goal if active_start else self.start\n\n            sample = self._sample(attractor, best_len)\n            if sample is None:\n                continue\n\n            near = self._nearest_limited(Ga, sample)\n            if near is None:\n                continue\n\n            newp = self._steer(near.position, sample, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(Ga, newp, self.dup_radius):\n                continue\n\n            parent, pcost = self._choose_parent_knn(Ga, newp, near, len(Ta))\n            if parent is None:\n                continue\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, pcost)\n            parent.add_child(nn)\n            Ta.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(Ga, nn)\n\n            if self.rewire_k > 0:\n                self._leaf_rewire(Ga, nn, self.rewire_k, edges)\n\n            meet_node, reached = self._try_direct_connect(Tb, Gb, nn.position, nodes, edges)\n            if reached:\n                if active_start:\n                    pa = self._trace_to_root(nn)\n                    pb = self._trace_to_root(meet_node)\n                    path = pa + pb[-2::-1]\n                else:\n                    pa = self._trace_to_root(meet_node)\n                    pb = self._trace_to_root(nn)\n                    path = pa + pb[-2::-1]\n\n                path = self._dedup(path)\n                best_len = self._path_len(path)\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0x9E3779B9 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= (q ^ (q >> 13) ^ ((q << 7) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 17) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(min(max(a[i], 0.0), self.bounds[i]) for i in range(self.dim))\n        if d2 <= step * step:\n            tgt = b\n        else:\n            d = d2 ** 0.5\n            r = step / d\n            tgt = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n        return tuple(min(max(tgt[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # Spatial hash grid\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest_limited(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        for r in range(0, self.ring_cap + 1):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found = True\n            if found:\n                return best\n        # fallback limited scan\n        cnt = 0\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                cnt += 1\n                if cnt >= 128:\n                    return best\n        return best\n\n    def _k_nearest_limited(self, grid, pos, k):\n        key = self._cell_key(pos)\n        cand = []\n        for r in range(0, self.ring_cap + 1):\n            cand.extend(self._grid_collect_ring(grid, key, r))\n            if len(cand) >= k:\n                break\n        if len(cand) < k:\n            for lst in grid.values():\n                cand.extend(lst)\n                if len(cand) >= 4 * k:\n                    break\n        # select k closest\n        scored = []\n        seen = set()\n        for n in cand:\n            if n in seen:\n                continue\n            seen.add(n)\n            scored.append((self._dist2(n.position, pos), n))\n        scored.sort(key=lambda x: x[0])\n        out = []\n        for i in range(min(k, len(scored))):\n            out.append(scored[i][1])\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell) + 1)\n        r2 = radius * radius\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                return True\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            return True\n        return False\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.2)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Parenting and lightweight rewiring\n    def _parent_radius(self, n_nodes):\n        base = self.step * 2.0\n        decay = pow(0.35, n_nodes / 2000.0)\n        return max(self.step * 1.1, base * decay)\n\n    def _choose_parent_knn(self, grid, newp, fallback, n_nodes):\n        cand = self._k_nearest_limited(grid, newp, self.k_near)\n        if fallback not in cand:\n            cand.append(fallback)\n        scored = []\n        for n in cand:\n            c = n.cost + self._dist(n.position, newp)\n            scored.append((c, n))\n        scored.sort(key=lambda x: x[0])\n        for c, n in scored:\n            if self._edge_free(n.position, newp):\n                return n, c\n        # fallback if none visible\n        if self._edge_free(fallback.position, newp):\n            return fallback, fallback.cost + self._dist(fallback.position, newp)\n        return None, 0.0\n\n    def _leaf_rewire(self, grid, nn, k, edges):\n        neigh = self._k_nearest_limited(grid, nn.position, k + 2)\n        for nb in neigh:\n            if nb is nn or nb is nn.parent:\n                continue\n            if len(nb.children) != 0:\n                continue\n            cand_cost = nn.cost + self._dist(nn.position, nb.position)\n            if cand_cost + 1e-12 < nb.cost and self._edge_free(nn.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, (oldp, nb))\n                nn.add_child(nb)\n                nb.cost = cand_cost\n                edges.append((nn, nb))\n\n    def _remove_edge(self, edges, e):\n        try:\n            idx = edges.index(e)\n            edges.pop(idx)\n        except:\n            pass\n\n    # Single-hop connect\n    def _try_direct_connect(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest_limited(grid, target_pos)\n        if cur is None:\n            return None, False\n        if self._edge_free(cur.position, target_pos):\n            if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    cur.add_child(nn)\n                    tree.append(nn)\n                    nodes.append(nn)\n                    edges.append((cur, nn))\n                    self._grid_add(grid, nn)\n                    return nn, True\n                return cur, True\n        return cur, False\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.6:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(20):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Path utilities\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._visibility_prune(path)\n        p2 = self._shortcut(p1, self.smooth_iters)\n        return self._dedup(p2)",
          "objective": -39.63489,
          "time_improvement": 74.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1481.0,
          "node_improvement": 91.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0037497520446777345,
                    "num_nodes_avg": 34.0,
                    "path_length_avg": 158.58377479850697,
                    "smoothness_avg": 0.06862027615570403,
                    "success_improvement": 0.0,
                    "time_improvement": 84.80115269876273,
                    "node_improvement": 91.4379249559305,
                    "length_improvement": 13.07772011221747,
                    "smoothness_improvement": 974.0563331514488,
                    "objective_score": 38.157259542716545
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028076863288879393,
                    "num_nodes_avg": 111.0,
                    "path_length_avg": 232.17028789754096,
                    "smoothness_avg": 0.0872747392675918,
                    "success_improvement": 0.0,
                    "time_improvement": 83.21279707599672,
                    "node_improvement": 92.54182624470873,
                    "length_improvement": 22.494875248593353,
                    "smoothness_improvement": 2145.641902808952,
                    "objective_score": 49.18897378599979
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02327275276184082,
                    "num_nodes_avg": 98.0,
                    "path_length_avg": 128.55489761473706,
                    "smoothness_avg": 0.11192261290302685,
                    "success_improvement": 0.0,
                    "time_improvement": 53.89408482264104,
                    "node_improvement": 87.53973299427845,
                    "length_improvement": 14.619958130688596,
                    "smoothness_improvement": 1323.6473748585636,
                    "objective_score": 31.55843719949829
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "SIRIUS-IRRC: Speed-Optimized Informed Rewire-Connect BiRRT. It fuses cached collision checking, informed prolate-ellipse sampling, adaptive hashed-neighborhood parenting, grandparent compression, and bounded radius-based RRT* rewiring. A balanced direct-then-greedy opposite-tree connect quickly bridges trees. Post-planning uses visibility pruning plus angle-aware shortcuts for shorter, smoother paths.",
          "planning_mechanism": "Alternate growth from start and goal. Each iteration: sample (goal/informed/uniform), find neighbors via a spatial hash, steer one step, choose the cheapest visible parent among k/radius-limited neighbors (with optional grandparent compression), insert after both node and edge checks, then locally rewire cheaper neighbors (radius-capped). Attempt a direct connect to the other tree; if blocked, take a few short, validated hops. On the first bridge, extract, visibility-prune, and angle-aware shortcut the path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        # detach\n        if self.parent is not None:\n            par = self.parent\n            i = 0\n            while i < len(par.children):\n                if par.children[i] is self:\n                    par.children.pop(i)\n                    break\n                i += 1\n        # attach\n        self.parent = new_parent\n        if new_parent is not None:\n            present = False\n            for c in new_parent.children:\n                if c is self:\n                    present = True\n                    break\n            if not present:\n                new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=3500,\n                 step_size=6.5,\n                 goal_bias=0.18,\n                 informed_bias=0.55,\n                 grid_cell_factor=1.4,\n                 dup_ratio=0.40,\n                 k_near=12,\n                 rewire_cap=8,\n                 connect_hops=12,\n                 obs_bin_factor=2.0,\n                 cache_quant=0.6,\n                 smooth_iters=80):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dup_ratio = float(dup_ratio)\n        self.k_near = int(max(1, k_near))\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_hops = int(connect_hops)\n        self.obs_bin_factor = float(obs_bin_factor)\n        self.cache_quant = float(cache_quant)\n        self.smooth_iters = int(max(0, smooth_iters))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_radius = max(0.25, self.step * self.dup_ratio)\n\n        self._build_obs_bins(max(4.0, self.step * self.obs_bin_factor))\n        self.edge_cache = {}\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_clear(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        Ta, Tb = [root_a], [root_b]\n        Ga, Gb = {}, {}\n        self._grid_put(Ga, root_a)\n        self._grid_put(Gb, root_b)\n        nodes.extend([root_a, root_b])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            grow_a = (it % 2 == 0)\n            T = Ta if grow_a else Tb\n            To = Tb if grow_a else Ta\n            G = Ga if grow_a else Gb\n            Go = Gb if grow_a else Ga\n            attract = self.goal if grow_a else self.start\n\n            s = self._informed_sample(attractor=attract, c_best=best_len)\n            if s is None:\n                continue\n\n            near = self._nearest(G, s)\n            if near is None:\n                continue\n\n            new_pos = self._step_toward(near.position, s, self.step)\n            if not self._in_bounds(new_pos):\n                continue\n\n            if self._nearby(G, new_pos, 0.9 * self.dup_radius):\n                continue\n\n            if self._point_blocked(new_pos):\n                continue\n\n            # choose parent among local neighbors (radius + k-cap), then optional compression\n            neigh = self._neighbors_limited(G, new_pos, self._neighbor_radius(len(T)), self.k_near)\n            if near not in neigh:\n                neigh.append(near)\n            best_parent = None\n            best_cost = 1e100\n            for cand in neigh:\n                seg_ok = self._edge_clear(cand.position, new_pos)\n                if not seg_ok:\n                    continue\n                c = cand.cost + self._dist(cand.position, new_pos)\n                if c < best_cost:\n                    best_cost = c\n                    best_parent = cand\n            if best_parent is None:\n                # fallback to nearest if visible\n                if self._edge_clear(near.position, new_pos):\n                    best_parent = near\n                    best_cost = near.cost + self._dist(near.position, new_pos)\n                else:\n                    continue\n\n            # grandparent compression if visible and cheaper\n            attach_parent = best_parent\n            if best_parent.parent is not None:\n                gp = best_parent.parent\n                if self._edge_clear(gp.position, new_pos):\n                    gp_cost = gp.cost + self._dist(gp.position, new_pos)\n                    if gp_cost + 1e-12 < best_cost:\n                        attach_parent = gp\n                        best_cost = gp_cost\n\n            # Both checks before add (node already checked). Confirm edge from chosen parent.\n            if not self._edge_clear(attach_parent.position, new_pos):\n                continue\n\n            nn = Node(new_pos, None, 0.0)\n            nn.attach(attach_parent)\n            nn.cost = best_cost\n            T.append(nn)\n            nodes.append(nn)\n            self._grid_put(G, nn)\n            self._add_edge(edges, attach_parent, nn)\n\n            # bounded RRT* rewiring within local radius\n            if self.rewire_cap > 0:\n                rewired = 0\n                rrad = self._rewire_radius(len(T))\n                neigh2 = self._neighbors_limited(G, nn.position, rrad, max(self.rewire_cap * 2, self.k_near))\n                for nb in neigh2:\n                    if nb is nn or nb is nn.parent:\n                        continue\n                    # Both checks before adding new edge\n                    if self._point_blocked(nb.position):\n                        continue\n                    newc = nn.cost + self._dist(nn.position, nb.position)\n                    if newc + 1e-12 < nb.cost and self._edge_clear(nn.position, nb.position):\n                        oldp = nb.parent\n                        if oldp is not None:\n                            self._remove_edge(edges, (oldp, nb))\n                        nb.attach(nn)\n                        nb.cost = newc\n                        self._add_edge(edges, nn, nb)\n                        self._propagate_cost_from(nb)\n                        rewired += 1\n                        if rewired >= self.rewire_cap:\n                            break\n\n            meet, bridged = self._connect_opposite(To, Go, nn.position, nodes, edges)\n            if bridged:\n                pa = self._path_to_root(nn)\n                pb = self._path_to_root(meet)\n                if len(pa) > 0 and len(pb) > 0 and pa[-1] == pb[-1]:\n                    combined = pa + pb[-2::-1]\n                else:\n                    combined = pa + pb[::-1]\n                combined = self._dedup(combined)\n                best_len = self._path_len(combined)\n                final = self._finalize_path(combined)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        x = 0x9E3779B9 ^ int(self.bounds[0] + (self.bounds[1] if self.dim >= 2 else 0.0))\n        for v in self.start + self.goal:\n            q = int(v * 1000003) & 0xffffffff\n            x ^= (q + 0x6A09E667 + ((x << 6) & 0xffffffff) + (x >> 2)) & 0xffffffff\n        x ^= ((len(self.obstacles) + 31) * 2654435761) & 0xffffffff\n        if x == 0:\n            x = 123456789\n        self._rng = x & 0xffffffff\n\n    def _rand(self):\n        x = self._rng\n        x ^= (x << 13) & 0xffffffff\n        x ^= (x >> 17) & 0xffffffff\n        x ^= (x << 5) & 0xffffffff\n        self._rng = x & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _step_toward(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            tgt = b\n        else:\n            d = d2 ** 0.5\n            r = step / d\n            tgt = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n        out = []\n        for i in range(self.dim):\n            v = tgt[i]\n            if v < 0.0:\n                v = 0.0\n            if v > self.bounds[i]:\n                v = self.bounds[i]\n            out.append(v)\n        return tuple(out)\n\n    # node grid\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        else:\n            return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_put(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best, bd = None, 1e100\n        found = False\n        for r in range(0, 3):\n            cand = self._collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bd:\n                    bd = d2\n                    best = n\n                    found = True\n            if found:\n                return best\n        for b in grid.values():\n            for n in b:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bd:\n                    bd = d2\n                    best = n\n        return best\n\n    def _nearby(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell) + 1)\n        r2 = radius * radius\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                return True\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            return True\n        return False\n\n    def _neighbors_limited(self, grid, pos, radius, kcap):\n        key = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell) + 1)\n        cand = []\n        seen = set()\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            for n in lst:\n                                if n in seen:\n                                    continue\n                                if self._dist(n.position, pos) <= radius + 1e-9:\n                                    cand.append((self._dist2(n.position, pos), n))\n                                    seen.add(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        for n in lst:\n                            if n in seen:\n                                continue\n                            if self._dist(n.position, pos) <= radius + 1e-9:\n                                cand.append((self._dist2(n.position, pos), n))\n                                seen.add(n)\n        # fallback: if not enough, add some from all buckets\n        if len(cand) < kcap:\n            for lst in grid.values():\n                for n in lst:\n                    if n in seen:\n                        continue\n                    cand.append((self._dist2(n.position, pos), n))\n                    seen.add(n)\n                    if len(cand) >= 4 * kcap:\n                        break\n                if len(cand) >= 4 * kcap:\n                    break\n        cand.sort(key=lambda x: x[0])\n        out = []\n        m = min(kcap, len(cand))\n        for i in range(m):\n            out.append(cand[i][1])\n        return out\n\n    def _neighbor_radius(self, n_nodes):\n        t = 1.0 / (1.0 + 0.002 * float(max(0, n_nodes)))\n        return self.step * (1.2 + 4.8 * t)\n\n    def _rewire_radius(self, n_nodes):\n        t = 1.0 / (1.0 + 0.003 * float(max(0, n_nodes)))\n        return self.step * (1.1 + 4.0 * t)\n\n    # obstacles and collision\n    def _build_obs_bins(self, cell):\n        self.obscell = float(cell)\n        self.obins = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obscell)\n                iy0 = int(max(0.0, y) // self.obscell)\n                iz0 = int(max(0.0, z) // self.obscell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obscell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obscell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obscell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obins:\n                                self.obins[key].append(idx)\n                            else:\n                                self.obins[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obscell)\n                iy0 = int(max(0.0, y) // self.obscell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obscell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obscell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        if key in self.obins:\n                            self.obins[key].append(idx)\n                        else:\n                            self.obins[key] = [idx]\n\n    def _point_blocked(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obscell)\n            iy = int(p[1] // self.obscell)\n            iz = int(p[2] // self.obscell)\n            bucket = self.obins.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obscell)\n            iy = int(p[1] // self.obscell)\n            bucket = self.obins.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_key(self, a, b):\n        s = int(1.0 / max(1e-12, self.cache_quant))\n        ka = tuple(int(a[i] * s + 0.5) for i in range(self.dim))\n        kb = tuple(int(b[i] * s + 0.5) for i in range(self.dim))\n        if ka <= kb:\n            return ('e', ka, kb, self.dim)\n        else:\n            return ('e', kb, ka, self.dim)\n\n    def _edge_clear(self, a, b):\n        k = self._edge_key(a, b)\n        c = self.edge_cache.get(k)\n        if c is not None:\n            return c\n        hit = self._segment_hits_any(a, b)\n        ok = not hit\n        self.edge_cache[k] = ok\n        return ok\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obscell)\n            iy0 = int(max(0.0, mny) // self.obscell)\n            iz0 = int(max(0.0, mnz) // self.obscell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obscell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obscell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obscell)\n            cand = {}\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self.obins.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                cand[idx] = True\n            if not cand:\n                return False\n            for idx in cand.keys():\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obscell)\n            iy0 = int(max(0.0, mny) // self.obscell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obscell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obscell)\n            cand = {}\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self.obins.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            cand[idx] = True\n            if not cand:\n                return False\n            for idx in cand.keys():\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # sampling\n    def _informed_sample(self, attractor, c_best):\n        r = self._rand()\n        if c_best is not None and r < self.informed_bias:\n            p = self._sample_in_ellipse(self.start, self.goal, c_best * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            if self._in_bounds(attractor) and (not self._point_blocked(attractor)):\n                return attractor\n        # uniform free resampling\n        for _ in range(10):\n            p = self._rand_point()\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        return None\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(12):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum + 1e-9:\n                return p\n        return None\n\n    def _rand_point(self):\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    # opposite-tree connect\n    def _connect_opposite(self, tree, grid, target, nodes, edges):\n        nearest = self._nearest(grid, target)\n        if nearest is None:\n            return None, False\n\n        # direct connection first\n        if self._edge_clear(nearest.position, target):\n            # Both checks before add; target point is already inside bounds and usually same as nn.position\n            if (self._in_bounds(target)) and (not self._point_blocked(target)):\n                # avoid duplicate node when too close\n                if self._dist2(nearest.position, target) <= (self.dup_radius * 0.5) ** 2:\n                    return nearest, True\n                meet = Node(target, None, 0.0)\n                meet.attach(nearest)\n                meet.cost = nearest.cost + self._dist(nearest.position, target)\n                tree.append(meet)\n                nodes.append(meet)\n                self._grid_put(grid, meet)\n                self._add_edge(edges, nearest, meet)\n                return meet, True\n            return nearest, False\n\n        # short-hop greedy connect\n        hop = 1.4 * self.step\n        cur = nearest\n        for _ in range(self.connect_hops):\n            nxtp = self._step_toward(cur.position, target, hop)\n            if not self._in_bounds(nxtp):\n                return cur, False\n            if self._nearby(grid, nxtp, 0.9 * self.dup_radius):\n                return cur, False\n            if self._point_blocked(nxtp):\n                return cur, False\n            if not self._edge_clear(cur.position, nxtp):\n                return cur, False\n            q = Node(nxtp, None, 0.0)\n            q.attach(cur)\n            q.cost = cur.cost + self._dist(cur.position, nxtp)\n            tree.append(q)\n            nodes.append(q)\n            self._grid_put(grid, q)\n            self._add_edge(edges, cur, q)\n            cur = q\n            if self._edge_clear(cur.position, target):\n                if (self._in_bounds(target)) and (not self._point_blocked(target)):\n                    if self._dist2(cur.position, target) <= (self.dup_radius * 0.5) ** 2:\n                        return cur, True\n                    meet = Node(target, None, 0.0)\n                    meet.attach(cur)\n                    meet.cost = cur.cost + self._dist(cur.position, target)\n                    tree.append(meet)\n                    nodes.append(meet)\n                    self._grid_put(grid, meet)\n                    self._add_edge(edges, cur, meet)\n                    return meet, True\n                return cur, False\n        return cur, False\n\n    # edges and costs\n    def _add_edge(self, edges, u, v):\n        for e in edges:\n            if e[0] is u and e[1] is v:\n                return\n        edges.append((u, v))\n\n    def _remove_edge(self, edges, e):\n        i = 0\n        while i < len(edges):\n            if edges[i][0] is e[0] and edges[i][1] is e[1]:\n                edges.pop(i)\n                return\n            i += 1\n\n    def _propagate_cost_from(self, node):\n        # BFS update of subtree costs\n        q = [node]\n        while q:\n            cur = q.pop(0)\n            if cur.parent is not None:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                q.append(ch)\n\n    # paths and post\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if (last is None) or (p != last):\n                out.append(p)\n                last = p\n        return out\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return path[:]\n        out = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            progressed = False\n            while j > i + 1:\n                if self._edge_clear(out[-1], path[j]):\n                    out.append(path[j])\n                    i = j\n                    progressed = True\n                    break\n                j -= 1\n            if not progressed:\n                out.append(path[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, path, iters):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        bestL = self._path_len(pts)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                continue\n            a, b = pts[i], pts[j]\n            if not self._edge_clear(a, b):\n                continue\n            # angle-aware acceptance: prefer removing sharp corners\n            before_ang = self._max_corner_angle(pts, i, j)\n            cand = pts[:i + 1] + pts[j:]\n            L = self._path_len(cand)\n            after_ang = self._max_corner_angle(cand, max(0, i - 1), min(len(cand) - 1, i + 1))\n            if (L + 1e-12 < bestL) or (after_ang + 1e-3 < before_ang):\n                pts = cand\n                bestL = L\n        return pts\n\n    def _max_corner_angle(self, pts, i0, i1):\n        # returns max interior angle (radians) in [i0+1, i1-1]\n        def ang(a, b, c):\n            ux = a[0] - b[0]\n            uy = a[1] - b[1]\n            vx = c[0] - b[0]\n            vy = c[1] - b[1]\n            uu = (ux * ux + uy * uy) ** 0.5\n            vv = (vx * vx + vy * vy) ** 0.5\n            if uu * vv < 1e-12:\n                return 3.14159265\n            dot = (ux * vx + uy * vy) / (uu * vv)\n            if dot < -1.0:\n                dot = -1.0\n            if dot > 1.0:\n                dot = 1.0\n            # acos approximation via atan2\n            s = ux * vy - uy * vx\n            c = dot\n            # atan2(|s|, c) gives angle between vectors\n            # polynomial approx not needed; Python has atan2 but no import, so approximate:\n            # use series for small angles is risky; fallback to 0..pi mapping:\n            # rough mapping using arcsin: angle = 2*arcsin(min(1,||u-v||/(2)))\n            wx = (ux / uu) - (vx / vv)\n            wy = (uy / uu) - (vy / vv)\n            norm = (wx * wx + wy * wy) ** 0.5\n            val = 0.5 * norm\n            if val > 1.0:\n                val = 1.0\n            # arcsin approx: asin(x) ~ x + x^3/6 for small x\n            a1 = val\n            a3 = (val * val * val) / 6.0\n            return 2.0 * (a1 + a3)\n        if len(pts) < 3:\n            return 0.0\n        i0 = max(0, i0)\n        i1 = min(len(pts) - 1, i1)\n        m = 0.0\n        for i in range(i0 + 1, i1):\n            a = pts[i - 1]\n            b = pts[i]\n            cpt = pts[i + 1]\n            m = max(m, ang(a, b, cpt))\n        return m\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._visibility_prune(path)\n        p2 = self._shortcut(p1, self.smooth_iters)\n        return self._dedup(p2)",
          "objective": -39.6301,
          "time_improvement": 68.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1626.0,
          "node_improvement": 91.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009522676467895508,
                    "num_nodes_avg": 38.0,
                    "path_length_avg": 151.69997096226274,
                    "smoothness_avg": 0.04259534591885625,
                    "success_improvement": 0.0,
                    "time_improvement": 61.527940187751284,
                    "node_improvement": 90.43062200956939,
                    "length_improvement": 16.850842075715118,
                    "smoothness_improvement": 566.7096609042333,
                    "objective_score": 31.40243560627562
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03968958854675293,
                    "num_nodes_avg": 122.0,
                    "path_length_avg": 232.26905906309653,
                    "smoothness_avg": 0.12076487049233034,
                    "success_improvement": 0.0,
                    "time_improvement": 75.86186396588214,
                    "node_improvement": 91.80272794463482,
                    "length_improvement": 22.461902590560534,
                    "smoothness_improvement": 3007.3671011879787,
                    "objective_score": 51.27253625004086
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01723639965057373,
                    "num_nodes_avg": 61.0,
                    "path_length_avg": 125.8983522887036,
                    "smoothness_avg": 0.11047695148392409,
                    "success_improvement": 0.0,
                    "time_improvement": 66.19482467014159,
                    "node_improvement": 92.2441195168468,
                    "length_improvement": 16.384309045145383,
                    "smoothness_improvement": 1305.2586683152026,
                    "objective_score": 36.21532616970572
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "FALCON-RRT*: Fast Adaptive Local-Connect Optimalizing Bidirectional RRT*. It blends hashed-grid adaptive KNN parenting, dynamic local rewiring with cost propagation, short micro-chain growth, and guided dual-tree bridging. AABB-binned collision with slab tests, informed-corridor sampling, and a three-stage smoother (visibility, corner-cut, shortcuts) jointly improve speed, length, and smoothness while preserving robustness.",
          "planning_mechanism": "Alternate tree growth with micro-chains toward biased samples; for each proposed point, select the best collision-free parent among adaptive KNN and commit; locally rewire neighbors and propagate improved costs; greedily extend the opposite tree a few steps toward the new node and bridge if line-of-sight holds; upon connection, compress by visibility, deterministically cut corners, and random-shortcut the path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        seq = []\n        cur = self\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        return seq[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=7.0,\n        goal_bias=0.20,\n        corridor_bias=0.35,\n        informed_bias=0.25,\n        grid_cell_factor=1.4,\n        k_near_base=8,\n        chain_steps=2,\n        connect_steps=3,\n        smooth_shortcuts=100,\n        corner_passes=2\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.k_near_base = int(max(1, k_near_base))\n        self.chain_steps = int(max(1, chain_steps))\n        self.connect_steps = int(max(1, connect_steps))\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self.corner_passes = int(max(0, corner_passes))\n\n        # runtime state\n        self._rng = 123456789\n\n    # ----------------- Public API -----------------\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n        self._edge_idx = {}\n\n        # Validate start/goal\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Init trees and grids\n        cell = max(1.0, self.step * self.grid_cell_factor)\n        self.cell = cell\n        self.dupe_radius = max(0.4, 0.35 * self.step)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            # Choose active and passive trees\n            active_start_side = (it % 2 == 0)\n            Ta = start_tree if active_start_side else goal_tree\n            Tb = goal_tree if active_start_side else start_tree\n            Ga = grid_a if active_start_side else grid_b\n            Gb = grid_b if active_start_side else grid_a\n            attractor = self.goal if active_start_side else self.start\n\n            # Sample\n            target = self._sample(attractor, best_len)\n            if target is None:\n                continue\n\n            # Nearest and micro-chain grow\n            nearest = self._nearest(Ga, target)\n            if nearest is None:\n                continue\n\n            last_new = self._extend_chain(Ta, Ga, nearest, target, nodes, edges)\n            if last_new is None:\n                continue\n\n            # Rewiring around the last new node\n            self._local_rewire(Ta, Ga, last_new, edges)\n\n            # Try growing the passive tree toward last_new and bridge\n            other_near = self._nearest(Gb, last_new.position)\n            if other_near is None:\n                continue\n            other_last = self._greedy_connect(Tb, Gb, other_near, last_new.position, nodes, edges, self.connect_steps)\n\n            if other_last is not None:\n                if self._edge_free(other_last.position, last_new.position):\n                    # Record bridge for output coherence\n                    self._add_edge_tuple(edges, self._edge_idx, other_last, last_new)\n                    # Assemble path without changing parents across trees\n                    if active_start_side:\n                        pa = last_new.path_from_root()\n                        pb = other_last.path_from_root()\n                        raw = pa + pb[-2::-1]\n                    else:\n                        pa = last_new.path_from_root()\n                        pb = other_last.path_from_root()\n                        raw = pb + pa[-2::-1]\n                    # Smooth\n                    path = self._finalize_path(raw)\n                    best_len = self._path_len(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # ----------------- RNG -----------------\n    def _seed_rng(self):\n        s = 0xA3C59AC3 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int((v + 1.2345) * 2654435761) & 0xffffffff\n            s ^= (q ^ (q >> 16) ^ ((q << 5) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ----------------- Geometry -----------------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(min(max(a[i], 0.0), self.bounds[i]) for i in range(self.dim))\n        if d2 <= step * step:\n            tgt = b\n        else:\n            d = d2 ** 0.5\n            r = step / d\n            tgt = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n        return tuple(min(max(tgt[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # ----------------- Spatial hash grid -----------------\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        r = 0\n        # expand until some candidates found\n        while r <= 4:\n            cand = self._collect_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                        found = True\n                if found:\n                    return best\n            r += 1\n        # fallback: limited scan\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _k_nearest(self, grid, pos, k):\n        key = self._cell_key(pos)\n        cand = []\n        r = 0\n        while len(cand) < k and r <= 5:\n            cand.extend(self._collect_ring(grid, key, r))\n            r += 1\n        # dedup and sort\n        seen = set()\n        scored = []\n        for n in cand:\n            if n in seen:\n                continue\n            seen.add(n)\n            scored.append((self._dist2(n.position, pos), n))\n        scored.sort(key=lambda x: x[0])\n        out = []\n        m = min(k, len(scored))\n        for i in range(m):\n            out.append(scored[i][1])\n        return out\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        cells = max(1, int(radius // self.cell) + 1)\n        r2 = radius * radius\n        if self.is3:\n            for dx in range(-cells, cells + 1):\n                for dy in range(-cells, cells + 1):\n                    for dz in range(-cells, cells + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                return True\n        else:\n            for dx in range(-cells, cells + 1):\n                for dy in range(-cells, cells + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            return True\n        return False\n\n    # ----------------- Obstacles and collision -----------------\n    def _build_obs_bins(self):\n        # obstacle bin cell slightly larger than step to limit candidates\n        self.obs_cell = max(4.0, self.step * 1.1)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            bucket = self.obin.get(key)\n                            if bucket is None:\n                                self.obin[key] = [idx]\n                            else:\n                                bucket.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        bucket = self.obin.get(key)\n                        if bucket is None:\n                            self.obin[key] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        # Collect potentially intersecting obstacles via segment AABB covered bins\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # ----------------- Parenting, rewiring, and edges -----------------\n    def _adaptive_k(self, n_nodes):\n        # scale neighbors sublinearly with tree size\n        return max(self.k_near_base, int(4 + (n_nodes ** 0.5)))\n\n    def _best_parent(self, grid, newp, fallback, step_cap):\n        # Gather candidates around newp; prefer those that can reach in one step\n        k = self._adaptive_k(len(grid))\n        cand = self._k_nearest(grid, newp, k)\n        if fallback not in cand:\n            cand.append(fallback)\n        best = None\n        best_cost = 1e100\n        for n in cand:\n            d = self._dist(n.position, newp)\n            if d > step_cap + 1e-9:\n                continue\n            # edge collision check\n            if not self._edge_free(n.position, newp):\n                continue\n            c = n.cost + d\n            if c < best_cost:\n                best_cost = c\n                best = n\n        return best, best_cost\n\n    def _local_rewire(self, tree, grid, nn, edges):\n        # Try to rewire nearby nodes to nn if cheaper and visible; then propagate cost improvements\n        k = self._adaptive_k(len(grid))\n        neigh = self._k_nearest(grid, nn.position, k)\n        for nb in neigh:\n            if nb is nn or nb is nn.parent:\n                continue\n            # Only consider if nn can reach within one step\n            d = self._dist(nn.position, nb.position)\n            if d > self.step + 1e-9:\n                continue\n            new_cost = nn.cost + d\n            if new_cost + 1e-12 < nb.cost and self._edge_free(nn.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge_tuple(edges, self._edge_idx, oldp, nb)\n                nn.add_child(nb)\n                delta = new_cost - nb.cost\n                nb.cost = new_cost\n                # propagate cost delta to subtree\n                stack = [nb]\n                while stack:\n                    cur = stack.pop()\n                    for ch in cur.children:\n                        ch.cost += delta\n                        stack.append(ch)\n                self._add_edge_tuple(edges, self._edge_idx, nn, nb)\n\n    def _add_edge_tuple(self, edges, edge_map, a, b):\n        edges.append((a, b))\n        edge_map[(id(a), id(b))] = len(edges) - 1\n\n    def _remove_edge_tuple(self, edges, edge_map, a, b):\n        key = (id(a), id(b))\n        idx = edge_map.get(key)\n        if idx is None:\n            return\n        last_idx = len(edges) - 1\n        if idx != last_idx:\n            edges[idx] = edges[last_idx]\n            pa, pb = edges[idx]\n            edge_map[(id(pa), id(pb))] = idx\n        edges.pop()\n        try:\n            del edge_map[key]\n        except:\n            pass\n\n    # ----------------- Growth/connection -----------------\n    def _extend_chain(self, tree, grid, start_node, target, nodes, edges):\n        cur = start_node\n        last = None\n        for _ in range(self.chain_steps):\n            prop = self._steer(cur.position, target, self.step)\n            if (not self._in_bounds(prop)) or self._point_blocked(prop):\n                break\n            if self._exists_close(grid, prop, self.dupe_radius):\n                break\n            parent, pcost = self._best_parent(grid, prop, cur, self.step)\n            if parent is None:\n                break\n            # Node collision and Edge collision checked above via _point_blocked and _edge_free(parent, prop)\n            nn = Node(prop, parent, pcost)\n            parent.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            self._grid_add(grid, nn)\n            self._add_edge_tuple(edges, self._edge_idx, parent, nn)\n            last = nn\n            cur = nn\n            # small early stop if close to target\n            if self._dist(cur.position, target) <= self.step:\n                break\n        return last\n\n    def _greedy_connect(self, tree, grid, from_node, target_pos, nodes, edges, max_steps):\n        cur = from_node\n        last_new = None\n        for _ in range(max_steps):\n            nxt = self._steer(cur.position, target_pos, self.step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                break\n            if not self._edge_free(cur.position, nxt):\n                break\n            if self._exists_close(grid, nxt, self.dupe_radius * 0.5):\n                # too dense to add another node here\n                break\n            nn = Node(nxt, cur, cur.cost + self._dist(cur.position, nxt))\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            self._grid_add(grid, nn)\n            self._add_edge_tuple(edges, self._edge_idx, cur, nn)\n            last_new = nn\n            cur = nn\n            if self._dist(cur.position, target_pos) <= self.step:\n                break\n        return last_new\n\n    # ----------------- Sampling -----------------\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        # informed sampling if path known\n        if best_len is not None and r < self.informed_bias:\n            p = self._sample_informed_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        # goal bias toward attractor\n        if r < self.goal_bias:\n            return attractor\n        # corridor-biased sampling\n        if r < self.goal_bias + self.corridor_bias:\n            t = self._rand()\n            base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n            width = max(self.step, 0.18 * self._dist(self.start, self.goal))\n            if self.is3:\n                # sample small random vector inside ball\n                for _ in range(5):\n                    vx = self._rand_range(-1.0, 1.0)\n                    vy = self._rand_range(-1.0, 1.0)\n                    vz = self._rand_range(-1.0, 1.0)\n                    s2 = vx * vx + vy * vy + vz * vz\n                    if s2 < 1e-12 or s2 > 1.0:\n                        continue\n                    inv = (s2 ** 0.5)\n                    vx /= inv\n                    vy /= inv\n                    vz /= inv\n                    rad = self._rand() * width\n                    p = (self._clamp(base[0] + vx * rad, 0.0, self.bounds[0]),\n                         self._clamp(base[1] + vy * rad, 0.0, self.bounds[1]),\n                         self._clamp(base[2] + vz * rad, 0.0, self.bounds[2]))\n                    if not self._point_blocked(p):\n                        return p\n            else:\n                # 2D: jitter perpendicular-ish\n                ang = self._rand_range(0.0, 6.283185307179586)\n                rad = self._rand() * width\n                p = (self._clamp(base[0] + rad * (1.0 * (ang - int(ang / 6.283185307179586) * 6.283185307179586) * 0.0 + (1.0) * (self._cos_sin(ang)[1])), 0.0, self.bounds[0]),\n                     self._clamp(base[1] + rad * (self._cos_sin(ang)[0]), 0.0, self.bounds[1]))\n                if not self._point_blocked(p):\n                    return p\n        # uniform in bounds, reject obstacles with a few attempts\n        for _ in range(8):\n            if self.is3:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n            else:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n            if not self._point_blocked(p):\n                return p\n        # fallback\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_informed_ellipse(self, f1, f2, max_sum):\n        # simple bounded retries to avoid wasting time\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half) for _ in range(self.dim)]\n        for _ in range(10):\n            if self.is3:\n                p = (self._clamp(c[0] + self._rand_range(-ext[0], ext[0]), 0.0, self.bounds[0]),\n                     self._clamp(c[1] + self._rand_range(-ext[1], ext[1]), 0.0, self.bounds[1]),\n                     self._clamp(c[2] + self._rand_range(-ext[2], ext[2]), 0.0, self.bounds[2]))\n            else:\n                p = (self._clamp(c[0] + self._rand_range(-ext[0], ext[0]), 0.0, self.bounds[0]),\n                     self._clamp(c[1] + self._rand_range(-ext[1], ext[1]), 0.0, self.bounds[1]))\n            if self._dist(p, f1) + self._dist(p, f2) <= max_sum and (not self._point_blocked(p)):\n                return p\n        return None\n\n    def _clamp(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    def _cos_sin(self, ang):\n        # Very rough polynomial approximations for cos/sin to avoid imports; acceptable for jitter\n        x = ang\n        # wrap to [-pi, pi]\n        pi = 3.141592653589793\n        two = 2.0 * pi\n        k = int(x / two)\n        x = x - k * two\n        if x > pi:\n            x -= two\n        if x < -pi:\n            x += two\n        x2 = x * x\n        # cos approx: 1 - x^2/2 + x^4/24\n        c = 1.0 - 0.5 * x2 + (x2 * x2) / 24.0\n        # sin approx: x - x^3/6 + x^5/120\n        s = x - (x * x2) / 6.0 + (x * x2 * x2) / 120.0\n        return (c, s)\n\n    # ----------------- Path utilities and smoothing -----------------\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return list(pts)\n        out = [pts[0]]\n        anchor = pts[0]\n        i = 1\n        while i < len(pts):\n            far = i\n            j = i\n            while j < len(pts):\n                if self._edge_free(anchor, pts[j]):\n                    far = j\n                    j += 1\n                else:\n                    break\n            out.append(pts[far])\n            anchor = pts[far]\n            i = far + 1\n        out[0] = pts[0]\n        out[-1] = pts[-1]\n        return out\n\n    def _corner_cut_pass(self, pts):\n        if len(pts) < 3:\n            return list(pts)\n        out = list(pts)\n        changed = False\n        i = 1\n        while i < len(out) - 1:\n            a = out[i - 1]\n            c = out[i + 1]\n            if self._edge_free(a, c):\n                out = out[:i] + out[i + 1:]\n                changed = True\n            else:\n                i += 1\n        return out, changed\n\n    def _shortcut_random(self, pts, attempts):\n        if len(pts) < 3:\n            return list(pts)\n        cur = list(pts)\n        n = len(cur)\n        tries = 0\n        while tries < attempts and n > 2:\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n                n = len(cur)\n            tries += 1\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._visibility_prune(path)\n        p2 = p1\n        for _ in range(self.corner_passes):\n            p2, changed = self._corner_cut_pass(p2)\n            if not changed:\n                break\n        p3 = self._shortcut_random(p2, self.smooth_shortcuts)\n        return self._dedup(p3)",
          "objective": -39.48194,
          "time_improvement": 80.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1729.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0066203117370605465,
                    "num_nodes_avg": 51.0,
                    "path_length_avg": 169.2632587687305,
                    "smoothness_avg": 0.052038861274425266,
                    "success_improvement": 0.0,
                    "time_improvement": 73.16593044572372,
                    "node_improvement": 87.15688743389575,
                    "length_improvement": 7.224125720885088,
                    "smoothness_improvement": 714.5211831407076,
                    "objective_score": 29.856860481951706
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01932368278503418,
                    "num_nodes_avg": 125.0,
                    "path_length_avg": 249.76071253052902,
                    "smoothness_avg": 0.12334472792906206,
                    "success_improvement": 0.0,
                    "time_improvement": 88.44633815345315,
                    "node_improvement": 91.6011556809783,
                    "length_improvement": 16.622685193802127,
                    "smoothness_improvement": 3073.748691231289,
                    "objective_score": 51.87625601847366
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010326528549194336,
                    "num_nodes_avg": 75.0,
                    "path_length_avg": 135.88985314178007,
                    "smoothness_avg": 0.11794162873048301,
                    "success_improvement": 0.0,
                    "time_improvement": 79.5419968476445,
                    "node_improvement": 90.46408137317228,
                    "length_improvement": 9.748429922675173,
                    "smoothness_improvement": 1400.2088119062716,
                    "objective_score": 36.71270106742981
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "FALCON-IRRTConnect: Fast Adaptive Local-Optimal RRT-Connect with hashed neighbors and obstacle-binned collisions. It couples rapid bidirectional connect growth for early success with light, radius-limited RRT*-style parent selection and bounded local rewiring. Coarse obstacle binning and cached segment tests cut collision cost; a uniform grid hash enables sublinear nearest/neighbor queries. After a connection, a compact shortcut + visibility + elastic refinement shortens and smooths the path.",
          "planning_mechanism": "Alternate expanding start/goal trees: sample (goal/informed biased), steer one step, pick best-cost parent from nearby nodes, add only if node- and edge-free, and locally rewire cheaper neighbors. Then greedily extend the opposite tree toward the new node, inserting the exact meeting node when visible. On success, extract the path and run shortcut, visibility prune, and elastic smoothing; return the improved path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5200,\n        step_size=5.5,\n        connect_mult=2.4,\n        goal_bias=0.14,\n        grid_cell_factor=1.5,\n        dup_radius_factor=0.38,\n        rewire_base=2.0,\n        rewire_decay=3200.0,\n        neighbor_cap=14,\n        smooth_iters=140,\n        elastic_sweeps=20\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_step = float(connect_mult) * self.step\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dup_radius_factor = float(dup_radius_factor)\n        self.rewire_base = float(rewire_base)\n        self.rewire_decay = float(rewire_decay)\n        self.neighbor_cap = int(neighbor_cap)\n        self.smooth_iters = int(max(0, smooth_iters))\n        self.elastic_sweeps = int(max(0, elastic_sweeps))\n        self._rng = 123456789\n\n    # --------- Public API ----------\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        # RNG seed from scene\n        self._seed_from_scene()\n\n        # Spatial hashing and parameters\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_radius = max(0.5, self.dup_radius_factor * self.step)\n\n        # Collision acceleration and caches\n        self._build_obs_bins()\n        self._edge_cache = {}  # canonical (a,b) -> bool (True if hits obstacle)\n        self._free_cache = {}  # canonical (a,b) -> bool (True if free)\n\n        # Validate start and goal\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight-line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            final = self._finalize_path(path)\n            return PlannerResult(True, final, nodes, edges)\n\n        # Initialize trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        Ta, Tb = [start_root], [goal_root]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, start_root)\n        self._grid_add(Gb, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = Ta if active_start else Tb\n            tree_b = Tb if active_start else Ta\n            grid_a = Ga if active_start else Gb\n            grid_b = Gb if active_start else Ga\n            attractor = self.goal if active_start else self.start\n\n            # Sampling with goal and informed elliptical bias\n            sample = self._sample(attractor, best_len)\n            if sample is None:\n                continue\n\n            # Nearest and steer\n            na = self._nearest(grid_a, sample)\n            if na is None:\n                continue\n            newp = self._steer(na.position, sample, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(grid_a, newp, self.dup_radius):\n                continue\n            # Edge collision check parent->newp before adding\n            if not self._edge_free(na.position, newp):\n                continue\n\n            # Cost-aware parent selection within adaptive radius\n            rew_rad = self._adaptive_rewire_radius(len(tree_a))\n            parent, new_cost = self._choose_parent(grid_a, newp, na, rew_rad)\n\n            # Validate chosen parent again (node+edge)\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._in_bounds(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            # Insert node\n            nn = Node(newp, parent, new_cost)\n            parent.add_child(nn)\n            tree_a.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(grid_a, nn)\n\n            # Local bounded rewiring\n            self._local_rewire(grid_a, nn, rew_rad, edges, cap=self.neighbor_cap)\n\n            # Try to greedily connect opposite tree toward new point\n            meet_node, reached = self._connect_toward(tree_b, grid_b, nn.position, nodes, edges)\n            if reached:\n                # Build full path with exact meeting node if inserted\n                if active_start:\n                    pa = self._trace_to_root(nn)\n                    pb = self._trace_to_root(meet_node)\n                    path = pa + pb[-2::-1]\n                else:\n                    pa = self._trace_to_root(meet_node)\n                    pb = self._trace_to_root(nn)\n                    path = pa + pb[-2::-1]\n\n                path = self._dedup(path)\n                best_len = self._path_len(path)\n\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # --------- RNG ----------\n    def _seed_from_scene(self):\n        s = 0x9E3779B9 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= (q ^ (q >> 13) ^ ((q << 7) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 17) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # --------- Geometry ----------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # --------- Spatial hash ----------\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        for r in range(0, 4):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found = True\n            if found:\n                return best\n        # fallback scan\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius, cap=None):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n                                if cap is not None and len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n                            if cap is not None and len(out) >= cap:\n                                return out\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        nb = self._neighbors_in_radius(grid, pos, radius, cap=1)\n        return len(nb) > 0\n\n    # --------- Obstacles / collision ----------\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.2)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy1, iy0 - 1, -1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        key = self._canon_seg(a, b)\n        val = self._free_cache.get(key)\n        if val is not None:\n            return val\n        blk = self._edge_hits_any(a, b)\n        res = not blk\n        self._free_cache[key] = res\n        self._edge_cache[key] = blk\n        return res\n\n    def _edge_hits_any(self, a, b):\n        key = self._canon_seg(a, b)\n        cached = self._edge_cache.get(key)\n        if cached is not None:\n            return cached\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                self._edge_cache[key] = False\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    self._edge_cache[key] = True\n                    return True\n            self._edge_cache[key] = False\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                self._edge_cache[key] = False\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    self._edge_cache[key] = True\n                    return True\n            self._edge_cache[key] = False\n            return False\n\n    def _canon_seg(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # --------- Parenting / rewiring ----------\n    def _adaptive_rewire_radius(self, n_nodes):\n        base = max(self.step * 1.2, self.step * self.rewire_base)\n        decay = pow(0.5, n_nodes / max(1.0, self.rewire_decay))\n        return max(self.step * 1.2, base * decay)\n\n    def _choose_parent(self, grid, newp, fallback, radius):\n        parent = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        neigh = self._neighbors_in_radius(grid, newp, radius, cap=self.neighbor_cap * 2)\n        for n in neigh:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                parent = n\n                best_cost = c\n        return parent, best_cost\n\n    def _local_rewire(self, grid, nn, radius, edges, cap=14):\n        neigh = self._neighbors_in_radius(grid, nn.position, radius, cap=cap)\n        for nb in neigh:\n            if nb is nn or nb is nn.parent:\n                continue\n            cand_cost = nn.cost + self._dist(nn.position, nb.position)\n            if cand_cost + 1e-12 < nb.cost and self._edge_free(nn.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, (oldp, nb))\n                nn.add_child(nb)\n                nb.cost = cand_cost\n                edges.append((nn, nb))\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _remove_edge(self, edges, e):\n        try:\n            idx = edges.index(e)\n            edges.pop(idx)\n        except:\n            pass\n\n    # --------- BiRRT-Connect toward target ----------\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < 64:\n            # If direct visibility, insert exact meeting node if valid\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                    if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        # Ensure node and edge checks before adding\n                        if (not self._point_in_obstacles(nn.position)) and self._edge_free(cur.position, nn.position):\n                            cur.add_child(nn)\n                            tree.append(nn)\n                            nodes.append(nn)\n                            edges.append((cur, nn))\n                            self._grid_add(grid, nn)\n                            return nn, True\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if self._too_close(grid, nxt, self.dup_radius * 0.75):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            # Checks before adding (node+edge already ensured above)\n            if self._point_in_obstacles(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                return cur, False\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n        # Final visibility attempt\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    if (not self._point_in_obstacles(nn.position)) and self._edge_free(cur.position, nn.position):\n                        cur.add_child(nn)\n                        tree.append(nn)\n                        nodes.append(nn)\n                        edges.append((cur, nn))\n                        self._grid_add(grid, nn)\n                        return nn, True\n            return cur, True\n        return cur, False\n\n    # --------- Sampling ----------\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.6:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(28):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # --------- Path utilities ----------\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _elastic_refine(self, pts, sweeps):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(sweeps):\n            changed = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                b = cur[i + 1]\n                # Try corner cut first\n                if self._edge_free(a, b):\n                    cur = cur[:i] + cur[i + 1:]\n                    changed = True\n                    break\n                # Try small relaxation toward midpoint\n                mid = tuple(0.5 * (a[k] + b[k]) for k in range(self.dim))\n                if self._in_bounds(mid) and (not self._point_in_obstacles(mid)):\n                    if self._edge_free(a, mid) and self._edge_free(mid, b):\n                        cur[i] = mid\n                        changed = True\n            if not changed:\n                break\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._shortcut(path, self.smooth_iters)\n        p2 = self._visibility_prune(p1)\n        p3 = self._elastic_refine(p2, self.elastic_sweeps)\n        return self._dedup(p3)",
          "objective": -39.28686,
          "time_improvement": 58.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 2409.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013451361656188964,
                    "num_nodes_avg": 62.0,
                    "path_length_avg": 158.49463611924995,
                    "smoothness_avg": 0.04911862032665335,
                    "success_improvement": 0.0,
                    "time_improvement": 45.4776770916583,
                    "node_improvement": 84.38680433140266,
                    "length_improvement": 13.126578434811004,
                    "smoothness_improvement": 668.8130709033614,
                    "objective_score": 24.8633155429009
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027135133743286133,
                    "num_nodes_avg": 156.0,
                    "path_length_avg": 245.64654428530534,
                    "smoothness_avg": 0.20810072097894103,
                    "success_improvement": 0.0,
                    "time_improvement": 83.77585872639358,
                    "node_improvement": 89.51824228986092,
                    "length_improvement": 17.996112973824765,
                    "smoothness_improvement": 5254.581439678919,
                    "objective_score": 62.203332600607524
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02812962532043457,
                    "num_nodes_avg": 229.0,
                    "path_length_avg": 122.99494476089357,
                    "smoothness_avg": 0.11045249123540399,
                    "success_improvement": 0.0,
                    "time_improvement": 44.27207935962878,
                    "node_improvement": 70.8836617927527,
                    "length_improvement": 18.312614079707338,
                    "smoothness_improvement": 1304.9475357594947,
                    "objective_score": 30.79392993451051
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "FROND-Connect Lite: a simplified bi-directional planner that blends uniform sampling with tiny goal bias, bounded single-step growth, dynamic neighbor radius, and light local rewiring. It maintains compact spatial hashes per tree for fast proximity, performs lazy one-step greedy bridging, and exits on the first valid connection. A two-pass collision-aware line-of-sight and shortcut post-smoother improves length and smoothness with minimal overhead.",
          "planning_mechanism": "Alternate expansion of the smaller tree. Sample uniformly (with small goal bias); if a path has been found, restrict samples to the prolate ellipsoid defined by start, goal, and current best length (informed sampling). Steer one step from the nearest node; validate node and edge; select a parent among a few nearest to minimize cost; insert and lightly rewire nearby nodes. Attempt a direct bridge to the opposite tree; otherwise, greedily grow it one step toward the new node and check for a clean join. On connection, assemble the start-to-goal path, apply two-stage LOS+shortcut smoothing, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            i = 0\n            while i < len(self.parent.children):\n                if self.parent.children[i] is self:\n                    self.parent.children.pop(i)\n                    break\n                i += 1\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=5.0,\n        goal_bias=0.08,\n        neighbor_cap=10,\n        rewire_cap=4,\n        shortcut_attempts=48\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.neighbor_cap = int(max(1, neighbor_cap))\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self._rng = 123456789\n\n    def plan(self, map):\n        # Setup\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self._build_obstacle_grid()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight-line success\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.children.append(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Trees and spatial hashes\n        self.cell = max(1.0, 1.25 * self.step)\n        self.dupe_eps = max(1e-3, 0.05 * self.step)\n\n        rootA = Node(self.start, None, 0.0)\n        rootB = Node(self.goal, None, 0.0)\n        nodes.extend([rootA, rootB])\n\n        treeA = [rootA]\n        treeB = [rootB]\n        gridA, gridB = {}, {}\n        seenA, seenB = set(), set()\n        self._grid_insert(gridA, rootA)\n        self._grid_insert(gridB, rootB)\n        seenA.add(self._dupe_key(rootA.position))\n        seenB.add(self._dupe_key(rootB.position))\n\n        # Informed sampling state\n        have_path = False\n        best_len = 1e100\n        direct_dist = self._dist(self.start, self.goal)\n\n        # Main loop\n        for it in range(self.max_iter):\n            # Alternate growth from the smaller tree\n            useA = (len(treeA) <= len(treeB))\n            active_tree = treeA if useA else treeB\n            passive_tree = treeB if useA else treeA\n            active_grid = gridA if useA else gridB\n            passive_grid = gridB if useA else gridA\n            seen_active = seenA if useA else seenB\n            seen_passive = seenB if useA else seenA\n            attractor = self.goal if useA else self.start\n\n            # Sample\n            s = self._sample(attractor, have_path, best_len, direct_dist)\n            if s is None:\n                continue\n\n            qnear = self._nearest(active_grid, s)\n            if qnear is None:\n                continue\n\n            qpos = self._steer(qnear.position, s, self.step)\n            if not self._in_bounds(qpos):\n                continue\n\n            # Both checks required before adding any node/edge\n            if self._point_blocked(qpos):\n                continue\n\n            # Choose parent among few nearest within dynamic radius\n            parent, new_cost = self._choose_parent(active_grid, qpos, active_tree)\n            if parent is None:\n                continue\n            if not self._edge_free(parent.position, qpos):\n                continue\n\n            # Deduplicate spatially\n            pk = self._dupe_key(qpos)\n            if pk in seen_active:\n                continue\n\n            # Add node\n            qnew = Node(qpos, parent, new_cost)\n            parent.children.append(qnew)\n            active_tree.append(qnew)\n            nodes.append(qnew)\n            edges.append((parent, qnew))\n            self._grid_insert(active_grid, qnew)\n            seen_active.add(pk)\n\n            # Light local rewiring\n            if self.rewire_cap > 0:\n                self._rewire_neighbors(active_grid, qnew, edges)\n\n            # Try to directly bridge\n            meet = self._nearest(passive_grid, qnew.position)\n            bridged = False\n            meet_node = None\n            if meet is not None and self._edge_free(meet.position, qnew.position):\n                bridged = True\n                meet_node = meet\n            else:\n                # Greedy one-step connect toward qnew\n                if meet is not None:\n                    nxt = self._steer(meet.position, qnew.position, self.step)\n                    if self._in_bounds(nxt) and (not self._point_blocked(nxt)) and self._edge_free(meet.position, nxt):\n                        k = self._dupe_key(nxt)\n                        if k not in seen_passive:\n                            nc = Node(nxt, meet, meet.cost + self._dist(meet.position, nxt))\n                            meet.children.append(nc)\n                            passive_tree.append(nc)\n                            nodes.append(nc)\n                            edges.append((meet, nc))\n                            self._grid_insert(passive_grid, nc)\n                            seen_passive.add(k)\n                            meet = nc\n                            if self._edge_free(meet.position, qnew.position):\n                                bridged = True\n                                meet_node = meet\n\n            if bridged and meet_node is not None:\n                # Assemble path\n                path = self._assemble_path(qnew, meet_node, useA)\n                # Smooth\n                path = self._postprocess(path)\n                L = self._path_len(path)\n                have_path = True\n                best_len = L if L < best_len else best_len\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        self._rng = (s ^ 0x9E3779B9) & 0xffffffff\n        if self._rng == 0:\n            self._rng = 123456789\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            q = [self._clamp(b[i], 0.0, self.bounds[i]) for i in range(self.dims)]\n            return tuple(q)\n        d = d2 ** 0.5\n        r = step / d\n        q = [self._clamp(a[i] + (b[i] - a[i]) * r, 0.0, self.bounds[i]) for i in range(self.dims)]\n        return tuple(q)\n\n    # Obstacles and collision\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, 2.0 * self.step)\n        self._ogrid = {}\n        if self.is3d:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                cx = cx0\n                while cx <= cx1:\n                    cy = cy0\n                    while cy <= cy1:\n                        cz = cz0\n                        while cz <= cz1:\n                            k = (cx, cy, cz)\n                            b = self._ogrid.get(k)\n                            if b is None:\n                                self._ogrid[k] = [idx]\n                            else:\n                                b.append(idx)\n                            cz += 1\n                        cy += 1\n                    cx += 1\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cx = cx0\n                while cx <= cx1:\n                    cy = cy0\n                    while cy <= cy1:\n                        k = (cx, cy)\n                        b = self._ogrid.get(k)\n                        if b is None:\n                            self._ogrid[k] = [idx]\n                        else:\n                            b.append(idx)\n                        cy += 1\n                    cx += 1\n\n    def _point_blocked(self, p):\n        if self.is3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self._ogrid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            x0, y0, z0 = p\n            i = 0\n            while i < len(bucket):\n                x, y, z, w, h, d = self.obstacles[bucket[i]]\n                if x <= x0 <= x + w and y <= y0 <= y + h and z <= z0 <= z + d:\n                    return True\n                i += 1\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self._ogrid.get((cx, cy))\n            if not bucket:\n                return False\n            x0, y0 = p\n            i = 0\n            while i < len(bucket):\n                x, y, w, h = self.obstacles[bucket[i]]\n                if x <= x0 <= x + w and y <= y0 <= y + h:\n                    return True\n                i += 1\n            return False\n\n    def _seg_aabb_hit(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(self.dims):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _edge_free(self, a, b):\n        if self.is3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            seen = set()\n            cx = cx0\n            while cx <= cx1:\n                cy = cy0\n                while cy <= cy1:\n                    cz = cz0\n                    while cz <= cz1:\n                        lst = self._ogrid.get((cx, cy, cz))\n                        if lst:\n                            j = 0\n                            while j < len(lst):\n                                seen.add(lst[j])\n                                j += 1\n                        cz += 1\n                    cy += 1\n                cx += 1\n            if not seen:\n                return True\n            for idx in seen:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_hit(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return False\n            return True\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            seen = set()\n            cx = cx0\n            while cx <= cx1:\n                cy = cy0\n                while cy <= cy1:\n                    lst = self._ogrid.get((cx, cy))\n                    if lst:\n                        j = 0\n                        while j < len(lst):\n                            seen.add(lst[j])\n                            j += 1\n                    cy += 1\n                cx += 1\n            if not seen:\n                return True\n            for idx in seen:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_hit(a, b, (x, y), (x + w, y + h)):\n                    return False\n            return True\n\n    # Spatial hashing for trees\n    def _cell_of(self, pos):\n        if self.is3d:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_insert(self, grid, node):\n        k = self._cell_of(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.is3d:\n            dx = -r\n            while dx <= r:\n                dy = -r\n                while dy <= r:\n                    dz = -r\n                    while dz <= r:\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n                        dz += 1\n                    dy += 1\n                dx += 1\n        else:\n            dx = -r\n            while dx <= r:\n                dy = -r\n                while dy <= r:\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n                    dy += 1\n                dx += 1\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_of(pos)\n        best = None\n        bestd2 = 1e100\n        r = 0\n        # Try a few expanding rings\n        while r <= 3:\n            cand = self._ring_collect(grid, key, r)\n            if cand:\n                i = 0\n                while i < len(cand):\n                    n = cand[i]\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd2:\n                        bestd2 = d2\n                        best = n\n                    i += 1\n                if best is not None:\n                    return best\n            r += 1\n        # Fallback: scan all buckets shallowly\n        for lst in grid.values():\n            i = 0\n            while i < len(lst):\n                n = lst[i]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n                i += 1\n        return best\n\n    def _dupe_key(self, pos):\n        if self.is3d:\n            return (int(pos[0] / self.dupe_eps), int(pos[1] / self.dupe_eps), int(pos[2] / self.dupe_eps))\n        return (int(pos[0] / self.dupe_eps), int(pos[1] / self.dupe_eps))\n\n    # Parent selection and rewiring\n    def _dynamic_radius(self, ncount):\n        # RRT* inspired radius: base on density, clamped to a few steps\n        from_density = (max(1.0, (self._logf(ncount + 1) / (ncount + 1.0))) ** (1.0 / max(2.0, float(self.dims))))\n        r = max(1.2 * self.step, 3.0 * self.step * from_density)\n        hi = 6.0 * self.step\n        if r > hi:\n            r = hi\n        return r\n\n    def _k_near_within(self, grid, pos, radius, kcap):\n        key = self._cell_of(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        keep = []\n        keepd = []\n        cand = self._ring_collect(grid, key, rc)\n        i = 0\n        while i < len(cand):\n            n = cand[i]\n            d2 = self._dist2(n.position, pos)\n            if d2 <= r2:\n                if len(keep) < kcap:\n                    keep.append(n)\n                    keepd.append(d2)\n                else:\n                    # Replace worst\n                    wj = 0\n                    wv = keepd[0]\n                    j = 1\n                    while j < len(keepd):\n                        if keepd[j] > wv:\n                            wv = keepd[j]\n                            wj = j\n                        j += 1\n                    if d2 < keepd[wj]:\n                        keepd[wj] = d2\n                        keep[wj] = n\n            i += 1\n        # Light ordering\n        m = len(keep)\n        j = 1\n        while j < m:\n            k = j\n            while k > 0 and keepd[k] < keepd[k - 1]:\n                keepd[k], keepd[k - 1] = keepd[k - 1], keepd[k]\n                keep[k], keep[k - 1] = keep[k - 1], keep[k]\n                k -= 1\n            j += 1\n        return keep\n\n    def _choose_parent(self, grid, new_pos, tree):\n        r = self._dynamic_radius(len(tree))\n        cand = self._k_near_within(grid, new_pos, r, self.neighbor_cap)\n        if not cand:\n            # fallback to nearest\n            n = self._nearest(grid, new_pos)\n            cand = [n] if n is not None else []\n        best_parent = None\n        best_cost = 1e100\n        i = 0\n        while i < len(cand):\n            n = cand[i]\n            if n is not None and self._edge_free(n.position, new_pos):\n                c = n.cost + self._dist(n.position, new_pos)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best_parent = n\n            i += 1\n        if best_parent is None:\n            return None, None\n        return best_parent, best_cost\n\n    def _rewire_neighbors(self, grid, new_node, edges):\n        r = self._dynamic_radius(1) + 2.0 * self.step\n        neigh = self._k_near_within(grid, new_node.position, r, max(2, self.rewire_cap * 2))\n        changed = 0\n        i = 0\n        while i < len(neigh) and changed < self.rewire_cap:\n            n = neigh[i]\n            if n is new_node or n.parent is None:\n                i += 1\n                continue\n            via_cost = new_node.cost + self._dist(new_node.position, n.position)\n            if via_cost + 1e-9 < n.cost and self._edge_free(new_node.position, n.position):\n                # Update edges list: remove old edge\n                oldp = n.parent\n                ei = 0\n                while ei < len(edges):\n                    if edges[ei][0] is oldp and edges[ei][1] is n:\n                        edges.pop(ei)\n                        break\n                    ei += 1\n                n.attach(new_node)\n                n.cost = via_cost\n                edges.append((new_node, n))\n                # Propagate to descendants (bounded)\n                q = [n]\n                budget = 128\n                while q and budget > 0:\n                    cur = q.pop()\n                    cj = 0\n                    while cj < len(cur.children) and budget > 0:\n                        ch = cur.children[cj]\n                        ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                        q.append(ch)\n                        cj += 1\n                        budget -= 1\n                changed += 1\n            i += 1\n\n    # Sampling\n    def _sample(self, attractor, have_path, c_best, c_min):\n        tries = 24\n        while tries > 0:\n            tries -= 1\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attractor\n            else:\n                if self.is3d:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n            if have_path:\n                if not self._informed_accept(p, c_best, c_min):\n                    continue\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        # fallback: attractor if valid\n        if self._in_bounds(attractor) and (not self._point_blocked(attractor)):\n            return attractor\n        return None\n\n    def _informed_accept(self, p, c_best, c_min):\n        # Accept if within prolate ellipsoid with foci at start and goal with major axis c_best\n        if c_best >= 1e99:\n            return True\n        if c_best <= c_min + 1e-9:\n            return True\n        dsum = self._dist(self.start, p) + self._dist(p, self.goal)\n        return dsum <= c_best + 1e-9\n\n    # Path assembly and postprocess\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _assemble_path(self, a_side_node, b_side_node, active_was_A):\n        pa = self._path_to_root(a_side_node)\n        pb = self._path_to_root(b_side_node)\n        if active_was_A:\n            # active tree grew from start\n            pb.reverse()\n            # remove duplicate join if any\n            if pa[-1] == pb[0]:\n                pb = pb[1:]\n            return pa + pb\n        else:\n            # active tree grew from goal\n            pa.reverse()\n            if pb[-1] == pa[0]:\n                pa = pa[1:]\n            return pb + pa\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        i = 1\n        while i < len(path):\n            L += self._dist(path[i - 1], path[i])\n            i += 1\n        return L\n\n    def _los_pass(self, path):\n        if len(path) < 3:\n            return path[:]\n        out = [path[0]]\n        anchor = path[0]\n        i = 1\n        while i < len(path) - 1:\n            if self._edge_free(anchor, path[i + 1]):\n                i += 1\n            else:\n                out.append(path[i])\n                anchor = path[i]\n                i += 1\n        out.append(path[-1])\n        return out\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        # Deterministic forward collapse\n        i = 0\n        while i < len(pts) - 2:\n            j = len(pts) - 1\n            improved = False\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    del pts[i + 1:j]\n                    improved = True\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n        # Random shortcuts\n        attempts = 0\n        nmax = self.shortcut_attempts\n        while attempts < nmax and len(pts) > 2:\n            a = int(self._rand_range(0, len(pts) - 2))\n            b = int(self._rand_range(a + 2, len(pts)))\n            if b <= a + 1 or b > len(pts) - 1:\n                attempts += 1\n                continue\n            if self._edge_free(pts[a], pts[b]):\n                pts = pts[:a + 1] + pts[b:]\n            attempts += 1\n        return pts\n\n    def _postprocess(self, path):\n        p = self._los_pass(path)\n        p = self._shortcut(p)\n        p = self._los_pass(p)\n        return p\n\n    # Math helpers\n    def _logf(self, x):\n        # Natural log via simple series approximation around x in reasonable range; fallback to binary log ratio\n        # For planning, roughness is fine; keep deterministic and import-free\n        # ln(x) ~ 2 * atanh((x-1)/(x+1)) series truncated\n        if x <= 0.0:\n            return -1e9\n        y = (x - 1.0) / (x + 1.0)\n        y2 = y * y\n        s = y\n        num = y\n        k = 1\n        # few terms for stability\n        while k < 7:\n            num *= y2\n            s += num / (2 * k + 1)\n            k += 1\n        return 2.0 * s",
          "objective": -39.06424,
          "time_improvement": 76.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1059.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007495331764221192,
                    "num_nodes_avg": 44.0,
                    "path_length_avg": 151.6380154090941,
                    "smoothness_avg": 0.0381690487238861,
                    "success_improvement": 0.0,
                    "time_improvement": 69.71850793020877,
                    "node_improvement": 88.9196675900277,
                    "length_improvement": 16.88480089615542,
                    "smoothness_improvement": 497.4284979447484,
                    "objective_score": 33.53357540647963
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03869636058807373,
                    "num_nodes_avg": 171.0,
                    "path_length_avg": 230.88339478788347,
                    "smoothness_avg": 0.06923517006476078,
                    "success_improvement": 0.0,
                    "time_improvement": 76.46591839066528,
                    "node_improvement": 88.5103809715783,
                    "length_improvement": 22.924477209761378,
                    "smoothness_improvement": 1681.4707938436097,
                    "objective_score": 45.10181581227446
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009676718711853027,
                    "num_nodes_avg": 84.0,
                    "path_length_avg": 127.32231777309157,
                    "smoothness_avg": 0.08628620718970545,
                    "success_improvement": 0.0,
                    "time_improvement": 81.02137457337125,
                    "node_improvement": 89.31977113795296,
                    "length_improvement": 15.438578972364697,
                    "smoothness_improvement": 997.5541864677477,
                    "objective_score": 38.55733068776893
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "AURORA-BiRRT*: Adaptive Unified Rewire-Optimized Receding-Envelope BiRRT with Curvature-Aware Smoothing. It grows two trees with adaptive step sizing in clutter, dynamic-radius best-parent selection, bounded rewiring, and multi-step micro-bridging. Sampling blends goal, corridor, and informed prolate-ellipse regions using an incumbent path. A voxelized obstacle index accelerates exact slab-based segment-AABB checks. On connection, visibility compression, probabilistic shortcuts, and an angle-aware elastic smoother produce shorter, smoother paths quickly and robustly.",
          "planning_mechanism": "Alternate expanding start/goal trees. Each iteration: biased target sampling (goal/corridor/informed/uniform), ring-hash nearest, adaptive steer with local clutter feedback, and strict node+edge collision checks. Select a least-cost parent from radius-limited neighbors, insert, then leap to a visible ancestor and rewire a few cheaper neighbors. Attempt direct or multi-step micro-bridge to the opposite tree. Maintain an incumbent best length to focus informed sampling. On success, assemble and postprocess the path (visibility prune, bounded shortcuts, curvature-aware elastic smoothing) and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        pts = []\n        cur = self\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=7.0,\n        goal_bias=0.2,\n        corridor_bias=0.4,\n        informed_bias=0.5,\n        grid_cell_factor=1.25,\n        dupe_radius_factor=0.35,\n        connect_factor=2.75,\n        rewire_radius_mult=2.0,\n        neighbor_cap=48,\n        bridge_trials=2,\n        rewire_cap=8,\n        shortcut_trials=120,\n        smooth_iters=18\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dupe_radius_factor = float(dupe_radius_factor)\n        self.connect_factor = float(connect_factor)\n        self.rewire_radius_mult = float(rewire_radius_mult)\n        self.neighbor_cap = int(neighbor_cap)\n        self.bridge_trials = int(max(0, bridge_trials))\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.shortcut_trials = int(max(0, shortcut_trials))\n        self.smooth_iters = int(max(0, smooth_iters))\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if getattr(map, \"obstacles\", None) else []\n\n        # Validate endpoints\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_rng()\n        self._build_obs_index()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if self._segment_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Derived params\n        self.cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_r = max(0.5, self.step_size * self.dupe_radius_factor)\n        self.connect_dist = max(self.step_size, self.connect_factor * self.step_size)\n        self.corridor_w = max(self.step_size, 0.2 * self._dist(self.start, self.goal))\n\n        # Trees and grids\n        nodes = []\n        edges = []\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_put(Ga, a_root)\n        self._grid_put(Gb, b_root)\n\n        best_len = float('inf')\n        best_path = None\n\n        for it in range(self.max_iter):\n            grow_a = (it % 2 == 0)\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            attractor = self.goal if grow_a else self.start\n\n            target = self._sample_target(attractor, best_len)\n            if target is None:\n                continue\n\n            near = self._nearest(G, target, T)\n            if near is None:\n                continue\n\n            new_pos = self._steer_adaptive(near.position, target)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._point_blocked(new_pos):\n                continue\n            if self._has_duplicate(G, new_pos, self.dupe_r):\n                continue\n\n            parent, new_cost = self._choose_parent(G, T, new_pos)\n            if parent is None:\n                continue\n            if self._point_blocked(new_pos) or not self._segment_free(parent.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            T.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_put(G, new_node)\n\n            # Ancestor visibility leap\n            self._ancestor_leap(new_node, edges)\n\n            # Local bounded rewiring\n            self._rewire_local(G, new_node, edges)\n\n            # Try to connect to the opposite tree\n            other = self._nearest(Gopp, new_node.position, Topp)\n            connected = False\n            end_node = None\n            if other is not None:\n                if self._dist(new_node.position, other.position) <= self.connect_dist and self._segment_free(new_node.position, other.position):\n                    connected = True\n                    end_node = other\n                else:\n                    # Micro-bridge steps from the opposite tree\n                    head = other\n                    for _ in range(self.bridge_trials):\n                        step_p = self._steer_adaptive(head.position, new_node.position)\n                        if not self._in_bounds(step_p) or self._point_blocked(step_p):\n                            break\n                        if self._has_duplicate(Gopp, step_p, self.dupe_r):\n                            break\n                        if not self._segment_free(head.position, step_p):\n                            break\n                        q = Node(step_p, head, head.cost + self._dist(head.position, step_p))\n                        head.add_child(q)\n                        Topp.append(q)\n                        nodes.append(q)\n                        edges.append((head, q))\n                        self._grid_put(Gopp, q)\n                        self._ancestor_leap(q, edges)\n                        self._rewire_local(Gopp, q, edges)\n                        head = q\n                        if self._segment_free(new_node.position, head.position):\n                            connected = True\n                            end_node = head\n                            break\n\n            if connected and end_node is not None:\n                path = self._assemble(new_node, end_node, grow_a)\n                path = self._postprocess(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Maintain incumbent for informed sampling\n            if other is not None and self._segment_free(new_node.position, other.position):\n                tmp = self._assemble(new_node, other, grow_a)\n                L = self._path_len(tmp)\n                if L < best_len:\n                    best_len = L\n                    best_path = tmp\n\n        if best_path is not None:\n            best_path = self._postprocess(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            s = (s * 2654435761 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 13) * 1103515245\n        self._rng = s if s != 0 else 2463534242\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry and bounds\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer_adaptive(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        # Base step\n        step = self.step_size if d > self.step_size else d\n        # Estimate local clutter by obstacle index buckets overlapped by tentative step box\n        dirv = tuple((b[i] - a[i]) / d for i in range(self.dims))\n        trial = tuple(a[i] + dirv[i] * step for i in range(self.dims))\n        clutter = self._box_bucket_density(a, trial)\n        if clutter > 10 and step > 0.5 * self.step_size:\n            step *= 0.6\n            trial = tuple(a[i] + dirv[i] * step for i in range(self.dims))\n            clutter = self._box_bucket_density(a, trial)\n            if clutter > 14 and step > 0.3 * self.step_size:\n                step *= 0.6\n                trial = tuple(a[i] + dirv[i] * step for i in range(self.dims))\n        return self._clamp(trial)\n\n    # Sampling\n    def _sample_target(self, attractor, best_len):\n        for _ in range(16):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._sample_informed(best_len * 1.02)\n                if p is not None and not self._point_blocked(p):\n                    return p\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attractor\n            elif r < self.goal_bias + self.corridor_bias:\n                t = self._rand()\n                base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n                if self.dims == 3:\n                    p = (self._rand_range(base[0] - self.corridor_w, base[0] + self.corridor_w),\n                         self._rand_range(base[1] - self.corridor_w, base[1] + self.corridor_w),\n                         self._rand_range(base[2] - self.corridor_w, base[2] + self.corridor_w))\n                else:\n                    p = (self._rand_range(base[0] - self.corridor_w, base[0] + self.corridor_w),\n                         self._rand_range(base[1] - self.corridor_w, base[1] + self.corridor_w))\n            else:\n                if self.dims == 3:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n            p = self._clamp(p)\n            if not self._point_blocked(p):\n                return p\n        return None\n\n    def _sample_informed(self, max_sum):\n        c = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        # Axis-aligned rejection in prolate envelope\n        for _ in range(24):\n            if self.dims == 3:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half),\n                     self._rand_range(c[2] - half, c[2] + half))\n            else:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half))\n            if self._in_bounds(p) and (self._dist(p, self.start) + self._dist(p, self.goal)) <= max_sum:\n                return p\n        return None\n\n    # Node grid\n    def _cell_of(self, pos):\n        return tuple(int(pos[i] // self.cell) for i in range(self.dims))\n\n    def _grid_put(self, grid, node):\n        k = self._cell_of(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _ring_nodes(self, grid, key, r):\n        out = []\n        if self.dims == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos, tree):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        for r in range(0, 4):\n            cand = self._ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback limited scan\n        if not tree:\n            return None\n        step = max(1, len(tree) // 64)\n        for i in range(0, len(tree), step):\n            n = tree[i]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, cap):\n        key = self._cell_of(pos)\n        r = max(1, int(radius // self.cell) + 1)\n        cand = self._ring_nodes(grid, key, r)\n        out = []\n        rr = radius * radius\n        for n in cand:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= rr:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _has_duplicate(self, grid, pos, radius):\n        return len(self._neighbors(grid, pos, radius, self.neighbor_cap)) > 0\n\n    # Parent selection and optimization\n    def _choose_parent(self, grid, tree, new_pos):\n        n = max(1, len(tree))\n        # RRT* radius ~ (log(n)/n)^{1/d} scaled\n        base = (self.rewire_radius_mult * self.step_size)\n        dyn_r = max(self.step_size, base * ((1.0 + self._log1p(n)) / n) ** (1.0 / max(1, self.dims)))\n        neigh = self._neighbors(grid, new_pos, dyn_r, self.neighbor_cap)\n        if not neigh:\n            # fallback to nearest in tree\n            near = None\n            bestd = 1e100\n            for m in tree:\n                d = self._dist(m.position, new_pos)\n                if d < bestd:\n                    bestd = d\n                    near = m\n            neigh = [near] if near is not None else []\n        best_p = None\n        best_c = 1e100\n        for p in neigh:\n            d = self._dist(p.position, new_pos)\n            gc = p.cost + d\n            if gc + 1e-9 < best_c and self._segment_free(p.position, new_pos):\n                best_c = gc\n                best_p = p\n        if best_p is None:\n            return None, None\n        return best_p, best_c\n\n    def _log1p(self, x):\n        # simple series for small x; adequate for our integer n\n        return 0.5 if x <= 1.0 else self._fast_log(x + 1.0)\n\n    def _fast_log(self, x):\n        # crude monotonic approximation using change-of-base and piecewise\n        y = 0.0\n        t = x\n        while t > 2.718281828:\n            t *= 0.367879441  # divide by e\n            y += 1.0\n        # linear tail\n        return y + (t - 1.0) / 2.718281828\n\n    def _ancestor_leap(self, node, edges):\n        curp = node.parent\n        if curp is None:\n            return\n        bestp = curp\n        bestc = node.cost\n        anc = curp.parent\n        while anc is not None:\n            if self._segment_free(anc.position, node.position):\n                c = anc.cost + self._dist(anc.position, node.position)\n                if c + 1e-9 < bestc:\n                    bestc = c\n                    bestp = anc\n            anc = anc.parent\n        if bestp is not curp:\n            self._reparent(node, bestp, edges)\n\n    def _rewire_local(self, grid, node, edges):\n        radius = max(self.step_size, self.rewire_radius_mult * self.step_size)\n        neigh = self._neighbors(grid, node.position, radius, self.neighbor_cap)\n        improvements = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if node.cost + d + 1e-9 < nb.cost and self._segment_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n                improvements += 1\n                if improvements >= self.rewire_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        if child.parent is new_parent:\n            return\n        if not self._segment_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._remove_edge(edges, old, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        # propagate cost to subtree\n        stack = [child]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if abs(newc - ch.cost) > 1e-12:\n                    ch.cost = newc\n                    stack.append(ch)\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is p and e[1] is c:\n                edges.pop(i)\n                return\n\n    # Obstacles and collision\n    def _build_obs_index(self):\n        # Cell size for obstacle spatial index\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.dims == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obs_grid.get(key)\n                            if b is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obs_grid.get(key)\n                        if b is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_blocked(self, p):\n        if self.dims == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _segment_free(self, a, b):\n        return not self._segment_hits(a, b)\n\n    def _box_bucket_density(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            s = 0\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obs_grid.get((i, j, k))\n                        if bkt:\n                            s += len(bkt)\n            return s\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            s = 0\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obs_grid.get((i, j))\n                    if bkt:\n                        s += len(bkt)\n            return s\n\n    def _segment_hits(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obs_grid.get((i, j, k))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit3d(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obs_grid.get((i, j))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit2d(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit2d(self, p0, p1, bmin, bmax):\n        # Slab method\n        t0, t1 = 0.0, 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _seg_box_hit3d(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Path assembly and postprocess\n    def _assemble(self, u, v, a_side):\n        pu = u.path_from_root()\n        pv = v.path_from_root()\n        if a_side:\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _postprocess(self, path):\n        if len(path) < 2:\n            return path[:]\n        p = self._visibility_prune(path)\n        p = self._shortcut(p, self.shortcut_trials)\n        p = self._elastic_angle_smooth(p, self.smooth_iters)\n        return p\n\n    def _visibility_prune(self, path):\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._segment_free(out[-1], path[j]):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i + 1])\n                i += 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = list(path)\n        best = self._path_len(pts)\n        n = len(pts)\n        fail = 0\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1:\n                fail += 1\n                if fail > 24:\n                    break\n                continue\n            a, b = pts[i], pts[j - 1]\n            if self._segment_free(a, b):\n                cand = pts[:i + 1] + pts[j - 1:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    pts = cand\n                    best = L\n                    n = len(pts)\n                    fail = 0\n                else:\n                    fail += 1\n            else:\n                fail += 1\n            if fail > 48:\n                break\n        return pts\n\n    def _elastic_angle_smooth(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return path[:]\n        pts = list(path)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                b = pts[i]\n                c = pts[i + 1]\n                # Angle-aware midpoint pull\n                mid = tuple(0.25 * a[k] + 0.5 * b[k] + 0.25 * c[k] for k in range(self.dims))\n                if self._point_blocked(mid):\n                    continue\n                if self._segment_free(a, mid) and self._segment_free(mid, c):\n                    if mid != b:\n                        pts[i] = mid\n                        moved = True\n                # Try skip if possible\n                if self._segment_free(a, c):\n                    pts[i] = c  # will be removed next pass by neighbors\n                    moved = True\n            # Compact duplicates\n            comp = [pts[0]]\n            for p in pts[1:]:\n                if p != comp[-1]:\n                    comp.append(p)\n            pts = comp\n            if not moved:\n                break\n            if len(pts) < 3:\n                break\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        return pts",
          "objective": -39.0221,
          "time_improvement": 68.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1312.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009383320808410645,
                    "num_nodes_avg": 51.0,
                    "path_length_avg": 148.31907804876715,
                    "smoothness_avg": 0.03583382190014427,
                    "success_improvement": 0.0,
                    "time_improvement": 61.966642474939334,
                    "node_improvement": 87.15688743389575,
                    "length_improvement": 18.703963055278603,
                    "smoothness_improvement": 460.8771271269766,
                    "objective_score": 32.11675621128384
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.043584227561950684,
                    "num_nodes_avg": 172.0,
                    "path_length_avg": 228.72791182641134,
                    "smoothness_avg": 0.08818936081319215,
                    "success_improvement": 0.0,
                    "time_improvement": 73.9409183696743,
                    "node_improvement": 88.44319021702614,
                    "length_improvement": 23.644039464437803,
                    "smoothness_improvement": 2169.175773952521,
                    "objective_score": 47.21457805932758
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01668705940246582,
                    "num_nodes_avg": 82.0,
                    "path_length_avg": 122.67227871244054,
                    "smoothness_avg": 0.1106371606216832,
                    "success_improvement": 0.0,
                    "time_improvement": 66.9410768359495,
                    "node_improvement": 89.57406230133503,
                    "length_improvement": 18.526913505383728,
                    "smoothness_improvement": 1307.2965167220898,
                    "objective_score": 37.73495373762554
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "SPARK-Lite: an ultra-fast bi-directional RRT-Connect variant with quasi-random sampling, single-shot exact meeting, compact spatial hashing, and obstacle binning. It minimizes collision checks via direct-connect attempts only (no greedy multi-step linking), tight duplicate-spacing, and tiny-ring approximate nearest queries. Post-processing is a minimal visibility prune with a few shortcuts for near-zero overhead.",
          "planning_mechanism": "Alternate growing start/goal trees. Each iteration: draw a free sample from a Halton-guided sequence with a small goal bias; steer one step from the nearest node (approximate via a 1\u20132 ring spatial hash); if node and edge are collision-free and not too close to existing nodes, insert it. Immediately attempt a single direct connection to the opposite tree and to the goal via exact meeting nodes (with full node+edge checks). On success, stitch roots through the meeting point and apply a fast visibility prune and a few shortcuts, then return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=7.5,\n        goal_bias=0.08,\n        grid_cell_factor=1.0,\n        min_separation_mult=0.6,\n        smooth_shortcuts=12\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.min_sep_mult = float(min_separation_mult)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self._rng = 1\n        self._hidx = 1\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step * self.min_sep_mult)\n\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Direct path fast check\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize trees and grids\n        root_s = Node(self.start, None, 0.0)\n        root_g = Node(self.goal, None, 0.0)\n        Ta = [root_s]\n        Tb = [root_g]\n        Ga = {}\n        Gb = {}\n        self._grid_add(Ga, root_s)\n        self._grid_add(Gb, root_g)\n        nodes.extend([root_s, root_g])\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            T_src = Ta if active_start else Tb\n            T_dst = Tb if active_start else Ta\n            G_src = Ga if active_start else Gb\n            G_dst = Gb if active_start else Ga\n            attractor = self.goal if active_start else self.start\n\n            q_rand = self._sample_free(attractor)\n            if q_rand is None:\n                continue\n\n            n_near = self._nearest(G_src, q_rand, T_src)\n            if n_near is None:\n                continue\n\n            q_new = self._steer(n_near.position, q_rand, self.step)\n            if (not self._in_bounds(q_new)) or self._point_in_obstacles(q_new):\n                continue\n            if not self._edge_free(n_near.position, q_new):\n                continue\n            if self._too_close(G_src, q_new, self.min_sep):\n                continue\n\n            nn = self._insert_node(T_src, G_src, n_near, q_new, nodes, edges)\n            if nn is None:\n                continue\n\n            # Try direct connect to global goal from start side (and vice-versa symmetrically)\n            if active_start:\n                if self._in_bounds(self.goal) and (not self._point_in_obstacles(self.goal)):\n                    if self._edge_free(nn.position, self.goal):\n                        meet = self._insert_node(T_src, G_src, nn, self.goal, nodes, edges)\n                        if meet is not None:\n                            pa = self._trace_to_root(meet)\n                            pb = self._trace_to_root(root_g)\n                            path = pa + pb[-2::-1]\n                            path = self._finalize_path(path)\n                            return PlannerResult(True, path, nodes, edges)\n            else:\n                if self._in_bounds(self.start) and (not self._point_in_obstacles(self.start)):\n                    if self._edge_free(nn.position, self.start):\n                        meet = self._insert_node(T_src, G_src, nn, self.start, nodes, edges)\n                        if meet is not None:\n                            pa = self._trace_to_root(meet)\n                            pb = self._trace_to_root(root_s)\n                            path = pa + pb[-2::-1]\n                            path = self._finalize_path(path)\n                            return PlannerResult(True, path, nodes, edges)\n\n            # Single-shot exact meeting with opposite tree\n            n_other = self._nearest(G_dst, nn.position, T_dst)\n            if n_other is not None and self._edge_free(n_other.position, nn.position):\n                # Prefer inserting exact meeting in the opposite tree for a clean junction\n                if (not self._too_close(G_dst, nn.position, self.min_sep)) and (not self._point_in_obstacles(nn.position)):\n                    meetB = self._insert_node(T_dst, G_dst, n_other, nn.position, nodes, edges)\n                else:\n                    meetB = n_other\n                if meetB is not None:\n                    if active_start:\n                        pa = self._trace_to_root(nn)\n                        pb = self._trace_to_root(meetB)\n                        path = pa + pb[-2::-1]\n                    else:\n                        pa = self._trace_to_root(meetB)\n                        pb = self._trace_to_root(nn)\n                        path = pa + pb[-2::-1]\n                    path = self._finalize_path(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG and Halton\n    def _seed_rng(self):\n        s = 0xC0FFEE\n        for v in self.start + self.goal:\n            iv = int(v * 9973)\n            s ^= (iv * 110351) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 1\n        self._rng = s & 0xffffffff\n        self._hidx = 1\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _radical_inverse(self, base, i):\n        inv = 1.0 / base\n        f = inv\n        x = 0.0\n        n = i\n        while n > 0:\n            x += (n % base) * f\n            n //= base\n            f *= inv\n        return x\n\n    def _halton_point(self, idx):\n        if self.is3:\n            return (\n                self._radical_inverse(2, idx) * self.bounds[0],\n                self._radical_inverse(3, idx) * self.bounds[1],\n                self._radical_inverse(5, idx) * self.bounds[2],\n            )\n        else:\n            return (\n                self._radical_inverse(2, idx) * self.bounds[0],\n                self._radical_inverse(3, idx) * self.bounds[1],\n            )\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        out = []\n        for i in range(self.dim):\n            out.append(a[i] + (b[i] - a[i]) * r)\n        return self._clamp(tuple(out))\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # Spatial hash\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        else:\n            return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos, T_list):\n        key = self._cell_key(pos)\n        # Tiny rings for speed; fallback to small random sample from tree\n        for r in (0, 1, 2):\n            cand = self._collect_ring(grid, key, r)\n            if cand:\n                best = None\n                bestd = 1e100\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                return best\n        # Fallback: approximate NN by sampling a handful of nodes\n        if not T_list:\n            return None\n        m = min(32, len(T_list))\n        best = None\n        bestd = 1e100\n        for _ in range(m):\n            j = int(self._rand_range(0, len(T_list)))\n            if j >= len(T_list):\n                j = len(T_list) - 1\n            n = T_list[j]\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius, limit=None):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n                                if limit is not None and len(out) >= limit:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n                            if limit is not None and len(out) >= limit:\n                                return out\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        lst = self._neighbors_in_radius(grid, pos, radius, limit=1)\n        return len(lst) > 0\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            bucket = self.obin.get(key)\n                            if bucket is None:\n                                self.obin[key] = [idx]\n                            else:\n                                bucket.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        bucket = self.obin.get(key)\n                        if bucket is None:\n                            self.obin[key] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Sampling\n    def _sample_free(self, attractor):\n        # Try goal bias, then Halton, then random; attempt a few times to avoid obstacle samples\n        tries = 0\n        while tries < 12:\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attractor\n            else:\n                if r < 0.6:\n                    p = self._halton_point(self._hidx)\n                    self._hidx += 1\n                else:\n                    if self.is3:\n                        p = (\n                            self._rand_range(0.0, self.bounds[0]),\n                            self._rand_range(0.0, self.bounds[1]),\n                            self._rand_range(0.0, self.bounds[2]),\n                        )\n                    else:\n                        p = (\n                            self._rand_range(0.0, self.bounds[0]),\n                            self._rand_range(0.0, self.bounds[1]),\n                        )\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n            tries += 1\n        return None\n\n    # Insert node with checks already verified\n    def _insert_node(self, tree, grid, parent, pos, nodes, edges):\n        if (not self._in_bounds(pos)) or self._point_in_obstacles(pos):\n            return None\n        if not self._edge_free(parent.position, pos):\n            return None\n        if self._too_close(grid, pos, self.min_sep):\n            return None\n        new_cost = parent.cost + self._dist(parent.position, pos)\n        nn = Node(pos, parent, new_cost)\n        parent.add_child(nn)\n        tree.append(nn)\n        nodes.append(nn)\n        edges.append((parent, nn))\n        self._grid_add(grid, nn)\n        return nn\n\n    # Path utilities\n    def _trace_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        return out[::-1]\n\n    def _edge_simplify(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._edge_simplify(path)\n        p2 = self._shortcut(p1, self.smooth_shortcuts)\n        out = []\n        last = None\n        for p in p2:\n            if (last is None) or (p != last):\n                out.append(p)\n                last = p\n        return out",
          "objective": -38.98061,
          "time_improvement": 78.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 1939.0,
          "node_improvement": 91.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01192178726196289,
                    "num_nodes_avg": 58.0,
                    "path_length_avg": 190.28222135597667,
                    "smoothness_avg": 0.05947656957302187,
                    "success_improvement": 0.0,
                    "time_improvement": 51.67749173986195,
                    "node_improvement": 85.39410727776378,
                    "length_improvement": -4.296700739960651,
                    "smoothness_improvement": 830.9374692558246,
                    "objective_score": 17.079914424261318
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.016370940208435058,
                    "num_nodes_avg": 96.0,
                    "path_length_avg": 235.03136664902294,
                    "smoothness_avg": 0.11934863343125808,
                    "success_improvement": 0.0,
                    "time_improvement": 90.21178781589272,
                    "node_improvement": 93.54968756299134,
                    "length_improvement": 21.53976480976291,
                    "smoothness_improvement": 2970.9263015322663,
                    "objective_score": 54.84202673828689
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.003277277946472168,
                    "num_nodes_avg": 40.0,
                    "path_length_avg": 133.2685295932742,
                    "smoothness_avg": 0.1662596391706955,
                    "success_improvement": 0.0,
                    "time_improvement": 93.50734738778176,
                    "node_improvement": 94.91417673235854,
                    "length_improvement": 11.489388209578951,
                    "smoothness_improvement": 2014.8103382412316,
                    "objective_score": 45.01988883328806
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "RAPIDS-IRRT*: Rapid Adaptive Prolate Informed Dual-tree RRT* with Indexed Obstacles and Segment Cache. It combines two balanced RRT* trees, a coarse hash-grid for O(1)-ish neighbors, a large, quantized edge-collision cache over obstacle bins, dynamic radius best-parent selection and bounded rewiring. After the first solution, it switches to ellipsoidal informed sampling to shrink path length quickly. Fast LOS bridging, duplicate suppression, and early visibility postprocessing reduce expansions and time.",
          "planning_mechanism": "Alternating tree growth with goal/corridor/informed-biased sampling. For each sample, find a nearby anchor from the hash-grid, steer, pick the least-cost parent among local neighbors (dynamic radius), verify point and edge, insert and lightly rewire neighbors. Probe the opposite tree with direct LOS or a short micro-bridge; on success assemble, visibility-collapse, shortcut, and round, then return. Collision checks use binned AABBs and a coarse LRU segment cache; nearest/neighbor queries use a coarse spatial grid with ring expansion and frontier fallback for speed.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = None\n        self.cost = float(cost)\n        self.children = []\n        if parent is not None:\n            self.attach(parent)\n\n    def attach(self, parent):\n        # Ensure proper detachment and consistent child registration\n        if self.parent is parent:\n            if parent is not None:\n                found = False\n                for ch in parent.children:\n                    if ch is self:\n                        found = True\n                        break\n                if not found:\n                    parent.children.append(self)\n            return\n        if self.parent is not None:\n            old = self.parent\n            for i in range(len(old.children) - 1, -1, -1):\n                if old.children[i] is self:\n                    old.children.pop(i)\n                    break\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=4500,\n                 step_size=6.0,\n                 goal_bias=0.35,\n                 corridor_bias=0.30,\n                 informed_bias=0.55,\n                 grid_cell_factor=2.0,\n                 base_neighbor_radius=18.0,\n                 dupe_radius_ratio=0.30,\n                 k_parent_cap=24,\n                 k_rewire=10,\n                 connect_hops=3,\n                 smoothing_shortcuts=120,\n                 smoothing_rounds=4):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.cell_factor = float(grid_cell_factor)\n        self.base_nei = float(base_neighbor_radius)\n        self.dupe_ratio = float(dupe_radius_ratio)\n        self.k_parent_cap = int(max(6, k_parent_cap))\n        self.k_rewire = int(max(0, k_rewire))\n        self.connect_hops = int(max(1, connect_hops))\n        self.smoothing_shortcuts = int(max(0, smoothing_shortcuts))\n        self.smoothing_rounds = int(max(0, smoothing_rounds))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", [])) if getattr(map, \"obstacles\", None) is not None else []\n        nodes = []\n        edges = []\n        self._edge_idx = {}  # (id(p), id(c)) -> index\n        self._seed_rng()\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Build obstacle bins and segment cache\n        self._build_obs_bins()\n        self._seg_cache = {}\n        self._seg_tick = 0\n        self._seg_cap = 16384  # larger cache for reuse\n\n        # Endpoint validity\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight-line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            nodes.extend([n0, n1])\n            self._add_edge(edges, n0, n1)\n            path = [self.start, self.goal]\n            path = self._postprocess(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Spatial params\n        self.cell = max(1.0, self.step * self.cell_factor)\n        self.dupe_radius = max(0.5, self.step * self.dupe_ratio)\n\n        # Trees\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        A, B = [a_root], [b_root]\n        GA, GB = {}, {}\n        self._grid_add(GA, a_root)\n        self._grid_add(GB, b_root)\n        nodes.extend([a_root, b_root])\n        frontierA, frontierB = [a_root], [b_root]\n\n        # Informed sampling state\n        cmin = self._dist(self.start, self.goal)\n        best_path = None\n        best_len = 1e100\n\n        for it in range(self.max_iter):\n            # Alternate growth with slight bias toward smaller tree\n            if it % 3 == 2:\n                growA = (len(A) <= len(B))\n            else:\n                growA = (it % 2 == 0)\n            T = A if growA else B\n            O = B if growA else A\n            G = GA if growA else GB\n            GO = GB if growA else GA\n            frontier = frontierA if growA else frontierB\n            frontierO = frontierB if growA else frontierA\n            attract = self.goal if growA else self.start\n\n            # Dynamic neighbor radius (decreases with total nodes)\n            n_tot = max(2, len(A) + len(B))\n            r_nei = max(1.5 * self.step, self.base_nei / ((n_tot) ** (1.0 / (self.dim + 1.0))))\n\n            # Sampling\n            target = self._sample_target(attract, best_len, cmin)\n            if target is None:\n                continue\n\n            # Nearest anchor\n            qnear = self._nearest(G, frontier, target, max_rings=2)\n            if qnear is None:\n                qnear = T[-1]\n            qnew_pos = self._steer(qnear.position, target, self.step)\n            if (not self._in_bounds(qnew_pos)) or self._point_blocked(qnew_pos):\n                continue\n            if self._has_close(G, qnew_pos, self.dupe_radius):\n                continue\n\n            # Choose best parent among neighbors\n            parent, bestc = self._choose_parent(G, qnew_pos, qnear, r_nei)\n            if parent is None:\n                continue\n\n            # Mandatory checks before insertion\n            if self._point_blocked(qnew_pos):\n                continue\n            if not self._edge_free(parent.position, qnew_pos):\n                continue\n\n            # Insert node\n            qnode = Node(qnew_pos, parent, bestc)\n            T.append(qnode)\n            nodes.append(qnode)\n            self._grid_add(G, qnode)\n            self._add_edge(edges, parent, qnode)\n\n            frontier.append(qnode)\n            if len(frontier) > 160:\n                del frontier[:16]\n\n            # Local rewiring\n            if self.k_rewire > 0:\n                self._rewire_local(qnode, G, edges, r_nei, k=self.k_rewire)\n\n            # Try to connect to opposite tree\n            other_near = self._nearest(GO, frontierO, qnode.position, max_rings=2)\n            connected = False\n            meet = None\n            if other_near is not None:\n                if self._edge_free(qnode.position, other_near.position):\n                    connected = True\n                    meet = other_near\n                else:\n                    # Short micro-bridge on O toward qnode\n                    mb = self._micro_bridge(O, GO, other_near, qnode.position)\n                    if mb is not None and self._edge_free(qnode.position, mb.position):\n                        connected = True\n                        meet = mb\n\n            if connected and meet is not None:\n                path = self._assemble_path(qnode, meet, growA)\n                path = self._postprocess(path)\n                L = self._path_len(path)\n                if L < best_len:\n                    best_len = L\n                    best_path = path\n                # Return immediately to reduce planning time\n                return PlannerResult(True, best_path, nodes, edges)\n\n        # If loop ends without connection, return best if any\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            s ^= (int(v * 2654435761) & 0xffffffff)\n            s = (s * 1664525 + 1013904223) & 0xffffffff\n        s ^= len(self.obstacles) * 374761393\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        x = self._rng & 0xffffffff\n        x ^= (x << 13) & 0xffffffff\n        x ^= (x >> 17) & 0xffffffff\n        x ^= (x << 5) & 0xffffffff\n        self._rng = x & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Obstacles and collisions\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.8)\n        self._obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self._obin.get(key)\n                            if lst is None:\n                                self._obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self._obin.get(key)\n                        if lst is None:\n                            self._obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_bucket(self, p):\n        if self.is3:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell),\n                                   int(p[2] // self.obs_cell)))\n        else:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell)))\n\n    def _point_blocked(self, p):\n        bucket = self._point_bucket(p)\n        if not bucket:\n            return False\n        if self.is3:\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _seg_box_intersect(self, a, b, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(self.dim):\n            p = a[i]\n            d = b[i] - a[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _edge_cache_key(self, a, b):\n        s = self.obs_cell if self.obs_cell > 0 else 1.0\n        qa = []\n        qb = []\n        for i in range(self.dim):\n            qa.append(int(a[i] / s * 4.0))\n            qb.append(int(b[i] / s * 4.0))\n        ka = tuple(qa)\n        kb = tuple(qb)\n        if ka <= kb:\n            return (ka, kb)\n        else:\n            return (kb, ka)\n\n    def _cache_seg(self, key, val):\n        self._seg_cache[key] = val\n        self._seg_tick += 1\n        if self._seg_tick >= self._seg_cap:\n            self._seg_cache.clear()\n            self._seg_tick = 0\n\n    def _edge_free(self, a, b):\n        key = self._edge_cache_key(a, b)\n        hit = self._seg_cache.get(key)\n        if hit is not None:\n            return hit\n        if self.is3:\n            mn = (min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2]))\n            mx = (max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2]))\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            iz0 = int(max(0.0, mn[2]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mx[2]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self._obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if cand:\n                for idx in cand:\n                    ox, oy, oz, w, h, d = self.obstacles[idx]\n                    if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                        self._cache_seg(key, False)\n                        return False\n            self._cache_seg(key, True)\n            return True\n        else:\n            mn = (min(a[0], b[0]), min(a[1], b[1]))\n            mx = (max(a[0], b[0]), max(a[1], b[1]))\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self._obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if cand:\n                for idx in cand:\n                    ox, oy, w, h = self.obstacles[idx]\n                    if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                        self._cache_seg(key, False)\n                        return False\n            self._cache_seg(key, True)\n            return True\n\n    # Grid utilities\n    def _cell_key(self, pos):\n        if self.is3:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, frontier, pos, max_rings=2):\n        kk = self._cell_key(pos)\n        best = None\n        bd = 1e100\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring(grid, kk, r)\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bd:\n                        bd = d2\n                        best = n\n                if best is not None:\n                    return best\n        # fallback to recent frontier\n        if frontier:\n            lim = min(32, len(frontier))\n            for i in range(lim):\n                n = frontier[-1 - i]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bd:\n                    bd = d2\n                    best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, cap=None):\n        kk = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        limit = self.k_parent_cap if cap is None else int(cap)\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((kk[0] + dx, kk[1] + dy, kk[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n                                if len(out) >= limit:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((kk[0] + dx, kk[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n                            if len(out) >= limit:\n                                return out\n        return out\n\n    def _has_close(self, grid, pos, radius):\n        ns = self._neighbors(grid, pos, radius, cap=8)\n        return len(ns) > 0\n\n    # Parent selection (pure geometric cost)\n    def _choose_parent(self, grid, new_pos, fallback, radius):\n        cand = self._neighbors(grid, new_pos, radius, cap=self.k_parent_cap)\n        if fallback not in cand:\n            cand.append(fallback)\n        cand.sort(key=lambda n: self._dist2(n.position, new_pos))\n        best = None\n        best_cost = 1e100\n        for p in cand:\n            # Both checks for the candidate edge\n            if not self._edge_free(p.position, new_pos):\n                continue\n            d = self._dist(p.position, new_pos)\n            c = p.cost + d\n            if c < best_cost:\n                best_cost = c\n                best = p\n        return best, best_cost\n\n    # Rewiring with subtree cost updates\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _propagate_delta(self, node, delta):\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    def _rewire_local(self, new_node, grid, edges, radius, k=10):\n        neigh = self._neighbors(grid, new_node.position, radius, cap=48)\n        if not neigh:\n            return\n        neigh.sort(key=lambda n: self._dist2(n.position, new_node.position))\n        count = 0\n        for nb in neigh:\n            if count >= k:\n                break\n            if nb is new_node or nb is new_node.parent:\n                continue\n            if self._is_ancestor(nb, new_node):\n                continue\n            if self._point_blocked(nb.position):\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            cand_cost = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand_cost + 1e-9 < nb.cost:\n                oldp = nb.parent\n                old_cost = nb.cost\n                if oldp is not None:\n                    # detach from old parent\n                    for i in range(len(oldp.children) - 1, -1, -1):\n                        if oldp.children[i] is nb:\n                            oldp.children.pop(i)\n                            break\n                    self._remove_edge(edges, oldp, nb)\n                nb.attach(new_node)\n                nb.cost = cand_cost\n                self._add_edge(edges, new_node, nb)\n                self._propagate_delta(nb, cand_cost - old_cost)\n                count += 1\n\n    # Micro-bridge: create short chain in opposite tree, commit only if closure works\n    def _micro_bridge(self, tree, grid, near_node, target_pos):\n        cur = near_node.position\n        chain = []\n        last_ok = None\n        for _ in range(self.connect_hops):\n            nxt = self._steer(cur, target_pos, self.step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                return None\n            if self._has_close(grid, nxt, self.dupe_radius * 0.7):\n                return None\n            if not self._edge_free(cur, nxt):\n                return None\n            chain.append(nxt)\n            cur = nxt\n            last_ok = cur\n            if self._edge_free(cur, target_pos):\n                break\n        if last_ok is None:\n            return None\n        # Commit with checks\n        prev = near_node\n        for p in chain:\n            if self._point_blocked(p):\n                return None\n            if not self._edge_free(prev.position, p):\n                return None\n            nn = Node(p, prev, prev.cost + self._dist(prev.position, p))\n            tree.append(nn)\n            self._grid_add(grid, nn)\n            prev = nn\n        return prev\n\n    # Edge list maintenance\n    def _add_edge(self, edges, p, c):\n        edges.append((p, c))\n        self._edge_idx[(id(p), id(c))] = len(edges) - 1\n\n    def _remove_edge(self, edges, p, c):\n        key = (id(p), id(c))\n        idx = self._edge_idx.get(key)\n        if idx is None:\n            return\n        last_idx = len(edges) - 1\n        if idx != last_idx:\n            lp, lc = edges[last_idx]\n            edges[idx] = (lp, lc)\n            self._edge_idx[(id(lp), id(lc))] = idx\n        edges.pop()\n        del self._edge_idx[key]\n\n    # Sampling\n    def _sample_target(self, attract, c_best, c_min):\n        tries = 28\n        while tries > 0:\n            tries -= 1\n            r = self._rand()\n            if c_best < 1e99 and r < self.informed_bias:\n                p = self._sample_in_ellipse(c_best, c_min)\n            elif r < self.goal_bias + (0.0 if c_best < 1e99 else 0.0):\n                p = attract\n            elif r < self.goal_bias + self.corridor_bias:\n                p = self._corridor_point()\n            else:\n                p = self._uniform_point()\n            if p is not None and self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        return None\n\n    def _uniform_point(self):\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _corridor_point(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step, 0.10 * sg)\n        if self.is3:\n            return self._clamp((base[0] + self._rand_range(-w, w),\n                                base[1] + self._rand_range(-w, w),\n                                base[2] + self._rand_range(-w, w)))\n        else:\n            return self._clamp((base[0] + self._rand_range(-w, w),\n                                base[1] + self._rand_range(-w, w)))\n\n    def _sample_in_ellipse(self, c_best, c_min):\n        # Prolate hyperspheroid with foci at start and goal\n        if c_best < c_min + 1e-9:\n            return None\n        a = 0.5 * c_best  # major radius\n        if a <= 1e-9:\n            return None\n        if self.is3:\n            b_sq = a * a - (c_min * c_min) * 0.25\n            if b_sq <= 1e-9:\n                return None\n            b = b_sq ** 0.5\n            # Unit vector along start->goal\n            u = (self.goal[0] - self.start[0], self.goal[1] - self.start[1], self.goal[2] - self.start[2])\n            un = self._norm(u)\n            if un <= 1e-12:\n                return None\n            e1 = (u[0] / un, u[1] / un, u[2] / un)\n            # Build orthonormal basis\n            ref = (1.0, 0.0, 0.0) if abs(e1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            e2 = self._cross(e1, ref)\n            e2n = self._norm(e2)\n            if e2n <= 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                e2 = self._cross(e1, ref)\n                e2n = self._norm(e2)\n                if e2n <= 1e-12:\n                    return None\n            e2 = (e2[0] / e2n, e2[1] / e2n, e2[2] / e2n)\n            e3 = self._cross(e1, e2)\n            # Sample inside unit ball\n            for _ in range(10):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                z = self._rand_range(-1.0, 1.0)\n                if x * x + y * y + z * z <= 1.0:\n                    # scale\n                    rx = (self._rand() ** (1.0 / 3.0))\n                    x *= rx\n                    y *= rx\n                    z *= rx\n                    # transform to ellipse\n                    cx = a * x\n                    cy = b * y\n                    cz = b * z\n                    # rotate and translate to center\n                    center = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dim))\n                    vx = (e1[0] * cx + e2[0] * cy + e3[0] * cz)\n                    vy = (e1[1] * cx + e2[1] * cy + e3[1] * cz)\n                    vz = (e1[2] * cx + e2[2] * cy + e3[2] * cz)\n                    p = (center[0] + vx, center[1] + vy, center[2] + vz)\n                    if self._in_bounds(p):\n                        return p\n            return None\n        else:\n            b_sq = a * a - (c_min * c_min) * 0.25\n            if b_sq <= 1e-9:\n                return None\n            b = b_sq ** 0.5\n            dx = self.goal[0] - self.start[0]\n            dy = self.goal[1] - self.start[1]\n            un = (dx * dx + dy * dy) ** 0.5\n            if un <= 1e-12:\n                return None\n            cos_t = dx / un\n            sin_t = dy / un\n            center = ((self.start[0] + self.goal[0]) * 0.5,\n                      (self.start[1] + self.goal[1]) * 0.5)\n            # Sample inside unit disk\n            for _ in range(12):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                if x * x + y * y <= 1.0:\n                    r = (self._rand() ** 0.5)\n                    x *= r\n                    y *= r\n                    # scale\n                    ex = a * x\n                    ey = b * y\n                    # rotate\n                    rx = cos_t * ex - sin_t * ey\n                    ry = sin_t * ex + cos_t * ey\n                    p = (center[0] + rx, center[1] + ry)\n                    if self._in_bounds(p):\n                        return p\n            return None\n\n    def _norm(self, v):\n        s = 0.0\n        for i in range(len(v)):\n            s += v[i] * v[i]\n        return s ** 0.5\n\n    def _cross(self, a, b):\n        return (a[1] * b[2] - a[2] * b[1],\n                a[2] * b[0] - a[0] * b[2],\n                a[0] * b[1] - a[1] * b[0])\n\n    # Path utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _assemble_path(self, a_end, b_end, a_side_grew):\n        if a_side_grew:\n            pa = self._path_to_root(a_end)\n            pb = self._path_to_root(b_end)\n            if pa and pb and pa[0] == pb[-1]:\n                pb = pb[:-1]\n            return pa + pb[::-1]\n        else:\n            pa = self._path_to_root(a_end)\n            pb = self._path_to_root(b_end)\n            if pa and pb and pb[0] == pa[-1]:\n                pa = pa[:-1]\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _vis_collapse(self, pts, passes=2):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            i = 0\n            changed = False\n            while i < len(cur) - 2:\n                j = len(cur) - 1\n                while j > i + 1:\n                    if self._edge_free(cur[i], cur[j]):\n                        if j > i + 1:\n                            del cur[i + 1:j]\n                            changed = True\n                        break\n                    j -= 1\n                i += 1\n            if not changed:\n                break\n        return cur\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        stall = 0\n        while tries < attempts and len(cur) > 2:\n            n = len(cur)\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j > n - 1:\n                tries += 1\n                continue\n            a, b = cur[i], cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-12 <= bestL:\n                    cur = cand\n                    bestL = L\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            tries += 1\n            if stall > 28:\n                break\n        return cur\n\n    def _round_corners(self, pts, passes):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                c = cur[i + 1]\n                mid = tuple(0.5 * a[k] + 0.5 * c[k] for k in range(self.dim))\n                if (not self._in_bounds(mid)) or self._point_blocked(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if cur[i] != mid:\n                        cur[i] = mid\n                        moved = True\n            if not moved:\n                break\n        return cur\n\n    def _postprocess(self, path):\n        if len(path) < 3:\n            return path[:]\n        p = self._vis_collapse(path, passes=2)\n        p = self._shortcut(p, self.smoothing_shortcuts)\n        p = self._round_corners(p, self.smoothing_rounds)\n        return p",
          "objective": -38.81705,
          "time_improvement": 73.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1331.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007626032829284668,
                    "num_nodes_avg": 42.0,
                    "path_length_avg": 150.30466036531917,
                    "smoothness_avg": 0.042772972605090796,
                    "success_improvement": 0.0,
                    "time_improvement": 69.08944722064112,
                    "node_improvement": 89.42331906320827,
                    "length_improvement": 17.615633924011192,
                    "smoothness_improvement": 569.4899042663268,
                    "objective_score": 34.143664041930684
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04364337921142578,
                    "num_nodes_avg": 179.0,
                    "path_length_avg": 226.32721347498054,
                    "smoothness_avg": 0.08650527069846632,
                    "success_improvement": 0.0,
                    "time_improvement": 73.90555150077547,
                    "node_improvement": 87.97285493516092,
                    "length_improvement": 24.445461674416084,
                    "smoothness_improvement": 2125.842922299545,
                    "objective_score": 47.468157066380016
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01258089542388916,
                    "num_nodes_avg": 77.0,
                    "path_length_avg": 135.9262852877516,
                    "smoothness_avg": 0.10978088951272895,
                    "success_improvement": 0.0,
                    "time_improvement": 75.07584499328578,
                    "node_improvement": 90.20979020979021,
                    "length_improvement": 9.724233426033248,
                    "smoothness_improvement": 1296.4048114195507,
                    "objective_score": 34.83931761070344
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SPARK-BiRRT*: A compact, robust bidirectional RRT* variant with simple grid-accelerated proximity, fixed-radius cost-aware parent selection, bounded local rewiring, and an RRT-Connect style greedy meet. It enforces strict node/edge collision checks, uses minimal duplicate suppression, and finishes with visibility pruning and short-cutting for smooth, short paths.",
          "planning_mechanism": "Alternate growth from start and goal trees. Each step: sample (goal-biased), steer one step, select the best-cost parent among nearby neighbors with collision-free edge, insert, and locally rewire a few neighbors if it reduces cost. Attempt a greedy extend from the opposite tree toward the new node; if the trees meet with a collision-free link, assemble and refine the path and return. Early straight-line and bounds/obstacle checks provide fast exits; a simple grid boosts nearest/neighbor queries.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        return pts[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step=6.0,\n        goal_bias=0.15,\n        neighbor_radius_factor=2.0,\n        rewire_cap=16,\n        dup_ratio=0.2,\n        smooth_attempts=60\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step)\n        self.goal_bias = float(goal_bias)\n        self.neighbor_radius_factor = float(neighbor_radius_factor)\n        self.rewire_cap = int(rewire_cap)\n        self.dup_ratio = float(dup_ratio)\n        self.smooth_attempts = int(max(0, smooth_attempts))\n        self._rng = 1234567\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n        nodes = []\n        edges = []\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self._build_obstacle_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            a = Node(self.start, None, 0.0)\n            b = Node(self.goal, a, self._dist(self.start, self.goal))\n            a.add_child(b)\n            nodes.extend([a, b])\n            edges.append((a, b))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        self.node_cell = max(1.0, self.step)\n        self.dup_radius = max(0.2, self.step * self.dup_ratio)\n\n        ra = Node(self.start, None, 0.0)\n        rb = Node(self.goal, None, 0.0)\n        Ta, Tb = [ra], [rb]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, ra)\n        self._grid_add(Gb, rb)\n        nodes.extend([ra, rb])\n\n        for it in range(self.max_iter):\n            grow_a = (it & 1) == 0\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            attractor = self.goal if grow_a else self.start\n\n            s = self._sample(attractor)\n            if s is None:\n                continue\n\n            base = self._nearest(G, s, T)\n            if base is None:\n                continue\n\n            newp = self._steer(base.position, s, self.step)\n            if not self._in_bounds(newp):\n                continue\n            if self._point_blocked(newp):\n                continue\n\n            radius = self.neighbor_radius_factor * self.step\n            parent = self._choose_parent(G, newp, base, radius)\n            if parent is None:\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            if self._too_close(G, newp, self.dup_radius):\n                # attempt direct cross-tree visibility even if skipping insert\n                opp = self._nearest(Gopp, newp, Topp)\n                if opp is not None and self._edge_free(newp, opp.position):\n                    raw = self._assemble_virtual(newp, parent, opp, grow_a)\n                    path = self._refine(raw)\n                    return PlannerResult(True, path, Ta + Tb, edges)\n                continue\n\n            new_cost = parent.cost + self._dist(parent.position, newp)\n            q = Node(newp, parent, new_cost)\n            parent.add_child(q)\n            T.append(q)\n            nodes.append(q)\n            edges.append((parent, q))\n            self._grid_add(G, q)\n\n            self._rewire_local(G, q, radius, edges)\n\n            meet = self._connect_extend(Topp, Gopp, q.position, nodes, edges)\n            if meet is not None and self._edge_free(q.position, meet.position):\n                raw = self._assemble(q, meet, grow_a)\n                path = self._refine(raw)\n                return PlannerResult(True, path, Ta + Tb, edges)\n\n        return PlannerResult(False, [], Ta + Tb, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 2166136261\n        for v in self.start + self.goal:\n            x = int((v + 0.5) * 2654435761) & 0xffffffff\n            s ^= x\n            s = (s * 16777619) & 0xffffffff\n        s ^= (len(self.obstacles) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 1234567\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Grid for nodes\n    def _cell_key(self, p):\n        return tuple(int(p[i] // self.node_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_neighbors_cells(self, key, span):\n        if self.dim == 3:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        yield (key[0] + dx, key[1] + dy, key[2] + dz)\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    yield (key[0] + dx, key[1] + dy)\n\n    def _nearest(self, grid, pos, tree):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for span in range(0, 2):\n            found = False\n            for ck in self._grid_neighbors_cells(key, span):\n                lst = grid.get(ck)\n                if not lst:\n                    continue\n                for n in lst:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                        found = True\n            if found:\n                return best\n        # fallback sparse scan\n        if not tree:\n            return None\n        step = max(1, len(tree) // 64)\n        for i in range(0, len(tree), step):\n            n = tree[i]\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius, cap):\n        out = []\n        key = self._cell_key(pos)\n        span = int(radius // self.node_cell) + 1\n        r2 = radius * radius\n        for ck in self._grid_neighbors_cells(key, span):\n            lst = grid.get(ck)\n            if not lst:\n                continue\n            for n in lst:\n                if self._dist2(n.position, pos) <= r2:\n                    out.append(n)\n                    if len(out) >= cap:\n                        return out\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        res = self._neighbors_in_radius(grid, pos, radius, 1)\n        return len(res) > 0\n\n    # Obstacles\n    def _build_obstacle_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self.dim == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_blocked(self, p):\n        if not self.obstacles:\n            return False\n        if self.dim == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            lst = self.obin.get((ix, iy, iz))\n            if not lst:\n                return False\n            x, y, z = p\n            for idx in lst:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            lst = self.obin.get((ix, iy))\n            if not lst:\n                return False\n            x, y = p\n            for idx in lst:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _bucket_candidates(self, a, b):\n        if not self.obstacles:\n            return []\n        if self.dim == 3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self.obin.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            return list(cand)\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self.obin.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            return list(cand)\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    def _edge_free(self, a, b):\n        cand = self._bucket_candidates(a, b)\n        if not cand:\n            return True\n        if self.dim == 3:\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    # Parent selection and rewiring\n    def _choose_parent(self, grid, new_pos, fallback, radius):\n        cand = self._neighbors_in_radius(grid, new_pos, radius, 64)\n        if fallback not in cand:\n            cand.append(fallback)\n        best = None\n        bestc = 1e100\n        for n in cand:\n            if not self._edge_free(n.position, new_pos):\n                continue\n            c = n.cost + self._dist(n.position, new_pos)\n            if c < bestc:\n                bestc = c\n                best = n\n        return best\n\n    def _rewire_local(self, grid, pivot, radius, edges):\n        neigh = self._neighbors_in_radius(grid, pivot.position, radius, 64)\n        options = []\n        for nb in neigh:\n            if nb is pivot:\n                continue\n            newc = pivot.cost + self._dist(pivot.position, nb.position)\n            options.append((newc, nb))\n        options.sort(key=lambda x: x[0])\n        changed = 0\n        for newc, nb in options:\n            if changed >= self.rewire_cap:\n                break\n            if nb is pivot or nb.parent is pivot:\n                continue\n            if self._is_ancestor(nb, pivot):\n                continue\n            if newc + 1e-9 < nb.cost and self._edge_free(pivot.position, nb.position):\n                self._reparent(nb, pivot, edges)\n                changed += 1\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        old = child.parent\n        if old is new_parent:\n            return\n        if old is not None:\n            old.remove_child(child)\n            self._remove_edge(edges, old, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        stack = [child]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                stack.append(ch)\n\n    def _remove_edge(self, edges, parent, child):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is parent and e[1] is child:\n                edges.pop(i)\n                return\n\n    # Connect\n    def _connect_extend(self, tree, grid, target_point, nodes, edges):\n        base = self._nearest(grid, target_point, tree)\n        if base is None:\n            return None\n        last = base\n        for _ in range(64):\n            nxt = self._steer(last.position, target_point, self.step)\n            if nxt == last.position:\n                break\n            if not self._in_bounds(nxt):\n                break\n            if self._point_blocked(nxt):\n                break\n            if not self._edge_free(last.position, nxt):\n                break\n            if self._too_close(grid, nxt, self.dup_radius):\n                break\n            nn = Node(nxt, last, last.cost + self._dist(last.position, nxt))\n            last.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((last, nn))\n            self._grid_add(grid, nn)\n            last = nn\n            if nxt == target_point:\n                return nn\n        return last if last is not base else None\n\n    # Sampling\n    def _sample(self, attractor):\n        r = self._rand()\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        if self.dim == 3:\n            p = (self._rand_range(0.0, self.bounds[0]),\n                 self._rand_range(0.0, self.bounds[1]),\n                 self._rand_range(0.0, self.bounds[2]))\n        else:\n            p = (self._rand_range(0.0, self.bounds[0]),\n                 self._rand_range(0.0, self.bounds[1]))\n        if self._in_bounds(p) and (not self._point_blocked(p)):\n            return p\n        return None\n\n    # Path assembly and refinement\n    def _assemble(self, u, v, u_from_start):\n        pu = u.path_to_root()\n        pv = v.path_to_root()\n        if u_from_start:\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _assemble_virtual(self, meet_pos, parent_u, v, u_from_start):\n        if u_from_start:\n            pu = parent_u.path_to_root() + [meet_pos]\n            pv = v.path_to_root()\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            pv = v.path_to_root() + [meet_pos]\n            pu = parent_u.path_to_root()\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _vis_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcuts(self, pts, attempts):\n        if len(pts) < 3 or attempts <= 0:\n            return pts[:]\n        cur = list(pts)\n        best = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, len(cur) - 2))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a, b = cur[i], cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    cur = cand\n                    best = L\n            tries += 1\n        return cur\n\n    def _refine(self, path):\n        if len(path) < 2:\n            return path[:]\n        p0 = self._vis_prune(path)\n        p1 = self._shortcuts(p0, self.smooth_attempts)\n        return p1",
          "objective": -38.56957,
          "time_improvement": 79.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1314.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009466433525085449,
                    "num_nodes_avg": 64.0,
                    "path_length_avg": 165.10553855497093,
                    "smoothness_avg": 0.03536083821899584,
                    "success_improvement": 0.0,
                    "time_improvement": 61.75516431608331,
                    "node_improvement": 83.8831528582221,
                    "length_improvement": 9.503038053339562,
                    "smoothness_improvement": 453.47390541650066,
                    "objective_score": 26.495741653911235
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.020602655410766602,
                    "num_nodes_avg": 139.0,
                    "path_length_avg": 237.1292833035105,
                    "smoothness_avg": 0.0881421654330121,
                    "success_improvement": 0.0,
                    "time_improvement": 87.47002130336207,
                    "node_improvement": 90.66048511724787,
                    "length_improvement": 20.839419845312214,
                    "smoothness_improvement": 2167.9614028270303,
                    "objective_score": 49.584465312331105
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0067710399627685545,
                    "num_nodes_avg": 71.0,
                    "path_length_avg": 132.9628532997944,
                    "smoothness_avg": 0.11158882198085847,
                    "success_improvement": 0.0,
                    "time_improvement": 86.72018532018375,
                    "node_improvement": 90.97266369993643,
                    "length_improvement": 11.692403848967308,
                    "smoothness_improvement": 1319.4015789664647,
                    "objective_score": 39.62850580026783
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "FLASH-Connect: a fast, low-dispersion, edge-cached BiRRT-Connect with hash-grid nearest search, per-cell caps, and one-shot limited connection. It minimizes planning time by deterministic Halton sampling, bounded tree growth without rewiring, immediate bridge attempts, and lightweight post-shortcutting.",
          "planning_mechanism": "Alternate expansion from start and goal trees toward a Halton-guided target. Each step inserts only if both the node and edge are collision-free and not too close to existing nodes. After insertion, attempt a direct bridge to the opposite tree; if blocked, perform at most a couple of connect steps on the other tree, again validating both node and edge per step. An LRU-like edge-collision cache accelerates repeated checks. On success, return immediately after quick line-of-sight collapse and a few shortcut passes.",
          "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = tuple(position)\n        self.parent = parent\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=9.0,\n        goal_bias=0.2,\n        grid_cell_factor=1.25,\n        per_cell_cap=8,\n        dupe_radius_ratio=0.5,\n        connect_steps=2,\n        edge_cache_capacity=30000,\n        edge_cache_quant=1.0,\n        smoothing_iters=20\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.per_cell_cap = int(per_cell_cap)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.connect_steps = int(connect_steps)\n        self.edge_cache_capacity = int(edge_cache_capacity)\n        self.edge_cache_quant = float(edge_cache_quant)\n        self.smoothing_iters = int(smoothing_iters)\n        # internal states\n        self._rnd_state = 2463534242\n        self._hidx = 1\n\n    def plan(self, map):\n        # Scene setup\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # seed RNG deterministically from scene\n        self._seed_from_scene()\n\n        # build spatial indices\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self._build_obstacle_grid()\n\n        # quick endpoint checks\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # edge cache\n        self._tick = 0\n        self._ecache = {}\n        self._ecache_last_prune = 0\n\n        # early straight line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None)\n            n1 = Node(self.goal, n0)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # trees and grids\n        nodes = []\n        edges = []\n\n        root_a = Node(self.start, None)\n        root_b = Node(self.goal, None)\n        nodes.extend([root_a, root_b])\n\n        tree_a = [root_a]\n        tree_b = [root_b]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, root_a)\n        self._grid_insert(grid_b, root_b)\n\n        # main loop\n        for it in range(self.max_iter):\n            grow_from_a = (it % 2 == 0)\n            source_tree = tree_a if grow_from_a else tree_b\n            source_grid = grid_a if grow_from_a else grid_b\n            target_tree = tree_b if grow_from_a else tree_a\n            target_grid = grid_b if grow_from_a else grid_a\n            attractor = self.goal if grow_from_a else self.start\n\n            q_rand = self._sample(attractor)\n            if q_rand is None:\n                continue\n\n            near = self._nearest(source_grid, q_rand)\n            if near is None:\n                continue\n\n            q_new = self._steer_valid(near.position, q_rand)\n            if q_new is None:\n                continue\n            if self._has_nearby(source_grid, q_new, self.dupe_radius):\n                continue\n\n            # per-cell cap\n            ckey = self._cell_of(q_new)\n            bucket = source_grid.get(ckey)\n            if bucket and len(bucket) >= self.per_cell_cap:\n                continue\n\n            # Insertion (both node and edge already validated in _steer_valid)\n            new_node = Node(q_new, near)\n            source_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((near, new_node))\n            self._grid_insert(source_grid, new_node)\n\n            # Try to connect to opposite tree\n            other_near = self._nearest(target_grid, new_node.position)\n            if other_near is not None:\n                # direct bridge\n                if self._edge_free(new_node.position, other_near.position):\n                    path = self._assemble_path(new_node, other_near)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # limited connect steps\n                p = other_near\n                steps = 0\n                while steps < self.connect_steps:\n                    step_pos = self._steer_once(p.position, new_node.position)\n                    if step_pos is None:\n                        break\n                    if self._has_nearby(target_grid, step_pos, self.dupe_radius):\n                        break\n                    cell2 = self._cell_of(step_pos)\n                    buck2 = target_grid.get(cell2)\n                    if buck2 and len(buck2) >= self.per_cell_cap:\n                        break\n                    q2 = Node(step_pos, p)\n                    target_tree.append(q2)\n                    nodes.append(q2)\n                    edges.append((p, q2))\n                    self._grid_insert(target_grid, q2)\n                    if self._edge_free(new_node.position, q2.position):\n                        path = self._assemble_path(new_node, q2)\n                        path = self._postprocess(path)\n                        return PlannerResult(True, path, nodes, edges)\n                    p = q2\n                    steps += 1\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG and Halton\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= len(self.obstacles) * 2654435761\n        s ^= int(self.step_size * 1000) & 0xffffffff\n        self._rnd_state = (s ^ 0x9E3779B9) & 0xffffffff\n        if self._rnd_state == 0:\n            self._rnd_state = 2463534242\n        self._hidx = 1\n\n    def _rand(self):\n        self._rnd_state = (1664525 * self._rnd_state + 1013904223) & 0xffffffff\n        return self._rnd_state / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _vdc(self, n, base):\n        v = 0.0\n        denom = 1.0\n        while n > 0:\n            n, r = divmod(n, base)\n            denom *= base\n            v += r / denom\n        return v\n\n    def _halton_point(self, idx):\n        bases = (2, 3, 5)\n        if self.dims == 2:\n            x = self._vdc(idx, bases[0]) * self.bounds[0]\n            y = self._vdc(idx, bases[1]) * self.bounds[1]\n            return (x, y)\n        else:\n            x = self._vdc(idx, bases[0]) * self.bounds[0]\n            y = self._vdc(idx, bases[1]) * self.bounds[1]\n            z = self._vdc(idx, bases[2]) * self.bounds[2]\n            return (x, y, z)\n\n    # Sampling with goal bias and Halton fallback\n    def _sample(self, attractor):\n        for _ in range(24):\n            if self._rand() < self.goal_bias:\n                p = attractor\n            else:\n                # Halton with tiny jitter to avoid grid alignment with obstacles\n                p = self._halton_point(self._hidx)\n                self._hidx += 1\n                jitter = 0.001 * self.cell_size\n                if self.dims == 2:\n                    p = (min(max(p[0] + self._rand_range(-jitter, jitter), 0.0), self.bounds[0]),\n                         min(max(p[1] + self._rand_range(-jitter, jitter), 0.0), self.bounds[1]))\n                else:\n                    p = (min(max(p[0] + self._rand_range(-jitter, jitter), 0.0), self.bounds[0]),\n                         min(max(p[1] + self._rand_range(-jitter, jitter), 0.0), self.bounds[1]),\n                         min(max(p[2] + self._rand_range(-jitter, jitter), 0.0), self.bounds[2]))\n            if self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer_once(self, a, b):\n        # Try to step toward b by at most step_size\n        d = self._dist(a, b)\n        if d < 1e-12:\n            return None\n        r = min(1.0, self.step_size / d)\n        q = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n        if not self._within_bounds(q):\n            return None\n        if self._point_in_obstacles(q):\n            return None\n        if not self._edge_free(a, q):\n            return None\n        return q\n\n    def _steer_valid(self, a, b):\n        # Fast attempt: if target within 1.5*step and edge is free, go there; else single step\n        d = self._dist(a, b)\n        max_jump = 1.5 * self.step_size\n        if d <= max_jump:\n            q = b\n            # clamp to bounds\n            q = tuple(min(max(q[i], 0.0), self.bounds[i]) for i in range(self.dims))\n            if not self._point_in_obstacles(q) and self._edge_free(a, q):\n                return q\n        # try normal step\n        q = self._steer_once(a, b)\n        if q is not None:\n            return q\n        # last attempt: slightly shorter step to sneak around grazing edges\n        if d > 1e-9:\n            r = min(1.0, (0.6 * self.step_size) / d)\n            q2 = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n            if self._within_bounds(q2) and (not self._point_in_obstacles(q2)) and self._edge_free(a, q2):\n                return q2\n        return None\n\n    # Node grid utilities\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_of(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 4):\n            cand = self._grid_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback: scan grid buckets\n        for b in grid.values():\n            for n in b:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    # Obstacle grid\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 2.0)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            x0, y0, z0 = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= x0 <= x + w and y <= y0 <= y + h and z <= z0 <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            x0, y0 = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= x0 <= x + w and y <= y0 <= y + h:\n                    return True\n            return False\n\n    # Edge collision with cache\n    def _edge_key(self, a, b):\n        q = max(0.25, self.edge_cache_quant)\n        qa = tuple(int(a[i] / q) for i in range(self.dims))\n        qb = tuple(int(b[i] / q) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self._ecache.get(key)\n        if hit is not None:\n            # refresh LRU tick\n            self._tick += 1\n            self._ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self._ecache[key] = (free, self._tick)\n        if len(self._ecache) - self._ecache_last_prune > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self._ecache:\n            return\n        cutoff = self._tick - 4000\n        to_del = []\n        for k, v in self._ecache.items():\n            if v[1] < cutoff:\n                to_del.append(k)\n        if not to_del:\n            i = 0\n            for k in list(self._ecache.keys()):\n                if (i % 3) == 0:\n                    to_del.append(k)\n                i += 1\n        for k in to_del:\n            if k in self._ecache:\n                del self._ecache[k]\n        self._ecache_last_prune = len(self._ecache)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x0, y0, z0, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x0, y0, z0), (x0 + w, y0 + h, z0 + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x0, y0, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x0, y0), (x0 + w, y0 + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect(self, p0, p1, bmin, bmax):\n        # slab intersection for 2D/3D segment vs AABB\n        tmin = 0.0\n        tmax = 1.0\n        n = self.dims\n        for i in range(n):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Path assembly and postprocess\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _assemble_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return pa + pb[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _los_collapse(self, path):\n        if len(path) < 3:\n            return path[:]\n        out = [path[0]]\n        last = 0\n        k = 1\n        while k < len(path) - 1:\n            if self._edge_free(path[last], path[k + 1]):\n                k += 1\n                continue\n            out.append(path[k])\n            last = k\n            k += 1\n        out.append(path[-1])\n        return out\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best = self._path_len(pts)\n        n = len(pts)\n        iters = min(self.smoothing_iters, max(1, n - 2))\n        for t in range(iters):\n            i = (t % (n - 2))\n            j = min(n - 1, i + 2 + (t % max(1, (n - i - 1))))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= best + 1e-12:\n                    pts = new_pts\n                    best = L\n                    n = len(pts)\n        return pts\n\n    def _postprocess(self, path):\n        p = self._los_collapse(path)\n        p = self._shortcut(p)\n        return p",
          "objective": -38.51088,
          "time_improvement": 67.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1919.0,
          "node_improvement": 85.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01389298439025879,
                    "num_nodes_avg": 79.0,
                    "path_length_avg": 164.28407730787757,
                    "smoothness_avg": 0.04754812951617681,
                    "success_improvement": 0.0,
                    "time_improvement": 43.68765033257988,
                    "node_improvement": 80.10576680936792,
                    "length_improvement": 9.953293979757886,
                    "smoothness_improvement": 644.2314793440236,
                    "objective_score": 22.299428884348814
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.015888690948486328,
                    "num_nodes_avg": 96.0,
                    "path_length_avg": 256.1129773273841,
                    "smoothness_avg": 0.12192815124399099,
                    "success_improvement": 0.0,
                    "time_improvement": 90.5001254447587,
                    "node_improvement": 93.54968756299134,
                    "length_improvement": 14.502116364807549,
                    "smoothness_improvement": 3037.299152805466,
                    "objective_score": 51.03780321633946
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016379070281982423,
                    "num_nodes_avg": 140.0,
                    "path_length_avg": 121.59420940833631,
                    "smoothness_avg": 0.17113765919663135,
                    "success_improvement": 0.0,
                    "time_improvement": 67.55123758529757,
                    "node_improvement": 82.19961856325493,
                    "length_improvement": 19.24291580502608,
                    "smoothness_improvement": 2076.858392913151,
                    "objective_score": 42.195412723170676
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "RAPTOR-BiRRT*: Rapid Adaptive-Parenting Two-way RRT*-Connect with hashed k-nearest selection, cached collision checks, bounded rewiring, and seam-preserving join. It accelerates planning via a compact spatial hash and a lazy edge-collision cache, reduces detours with adaptive-radius parent choice and limited local rewiring, and finishes with visibility pruning plus shortcut smoothing for shorter, smoother paths.",
          "planning_mechanism": "Alternate expansions from start and goal. Each iteration: sample with goal/informed bias, steer one step, choose the lowest-cost visible parent among k nearest within an adaptive radius, verify node and edge collisions, add the node, and locally rewire cheaper neighbors. Attempt a one-shot line-of-sight connect to the opposite tree (falling back to a few greedy steps). On meeting, build a seam-preserving path, prune by visibility, and apply bounded shortcuts.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def detach_from_parent(self):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = None\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=6.0,\n        goal_bias=0.2,\n        grid_cell_factor=1.5,\n        k_near=10,\n        parent_radius_scale=2.4,\n        rewire_radius_scale=2.8,\n        rewire_cap=24,\n        connect_steps=8,\n        smooth_attempts=120\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.k_near = int(max(1, k_near))\n        self.parent_radius_scale = float(parent_radius_scale)\n        self.rewire_radius_scale = float(rewire_radius_scale)\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_steps = int(max(0, connect_steps))\n        self.smooth_attempts = int(max(0, smooth_attempts))\n\n        self._rng = 123456789\n        self.ecache = {}\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n\n        # Spatial grid for nodes\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_radius = max(0.5, 0.4 * self.step)\n\n        # Obstacle bins\n        self._build_obs_bins()\n\n        # Start/goal collision check\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Trivial straight path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize bidirectional trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        Ta = [start_root]\n        Tb = [goal_root]\n        Ga = {}\n        Gb = {}\n        self._grid_add(Ga, start_root)\n        self._grid_add(Gb, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_path = None\n        best_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            if active_start:\n                tree_grow, tree_other = Ta, Tb\n                grid_grow, grid_other = Ga, Gb\n                attractor = self.goal\n            else:\n                tree_grow, tree_other = Tb, Ta\n                grid_grow, grid_other = Gb, Ga\n                attractor = self.start\n\n            # Sample\n            sample = self._sample(attractor, best_len)\n            if sample is None:\n                continue\n\n            # Nearest\n            near = self._nearest(grid_grow, tree_grow, sample)\n            if near is None:\n                continue\n\n            # Steer\n            newp = self._steer(near.position, sample, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(grid_grow, newp, self.dup_radius):\n                continue\n\n            # Choose parent among k-nearest within adaptive radius\n            pradius = self._adaptive_radius(len(tree_grow), scale=self.parent_radius_scale)\n            knn = self._k_nearest(grid_grow, newp, self.k_near, pradius)\n            if near not in knn:\n                knn.append(near)\n            parent, pcost = self._choose_parent(newp, knn)\n            if parent is None:\n                continue\n\n            # Final node+edge collision checks before insertion\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            # Insert node\n            nn = Node(newp, parent, pcost)\n            parent.add_child(nn)\n            tree_grow.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(grid_grow, nn)\n\n            # Local rewiring (bounded)\n            if self.rewire_cap > 0:\n                rrad = self._adaptive_radius(len(tree_grow), scale=self.rewire_radius_scale)\n                neigh = self._grid_neighbors_within(grid_grow, newp, rrad)\n                self._rewire_from(nn, neigh, edges)\n\n            # Try to connect opposite tree\n            meet_node, reached = self._try_connect(tree_other, grid_other, nn.position, nodes, edges)\n            if reached:\n                # Build seam-preserving path (include meet once)\n                if active_start:\n                    path_a = self._trace_to_root(nn)\n                    path_b = self._trace_to_root(meet_node)\n                    if path_a[-1] == path_b[-1]:\n                        merged = path_a + path_b[-2::-1]\n                    else:\n                        merged = path_a + path_b[::-1]\n                else:\n                    path_a = self._trace_to_root(meet_node)\n                    path_b = self._trace_to_root(nn)\n                    if path_a[-1] == path_b[-1]:\n                        merged = path_a + path_b[-2::-1]\n                    else:\n                        merged = path_a + path_b[::-1]\n\n                merged = self._dedup(merged)\n                best_path = merged\n                best_len = self._path_len(merged)\n\n                # Finalize and return (fast and short)\n                final = self._finalize_path(best_path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0x9E3779B9 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= (q ^ (q >> 13) ^ ((q << 7) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 23) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(min(max(a[i], 0.0), self.bounds[i]) for i in range(self.dim))\n        if d2 <= step * step:\n            tgt = b\n        else:\n            d = d2 ** 0.5\n            r = step / d\n            tgt = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n        return tuple(min(max(tgt[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # Spatial hash grid\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, tree, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        # expand rings until found\n        for r in range(0, 6):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n            if best is not None:\n                return best\n        # fallback full scan\n        for n in tree:\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        return best\n\n    def _k_nearest(self, grid, pos, k, radius):\n        key = self._cell_key(pos)\n        cand = []\n        # gather rings until enough candidates\n        for r in range(0, 6):\n            cand.extend(self._grid_collect_ring(grid, key, r))\n            if len(cand) >= k:\n                break\n        # filter by radius and unique\n        seen = set()\n        scored = []\n        for n in cand:\n            if id(n) in seen:\n                continue\n            seen.add(id(n))\n            d2 = self._dist2(n.position, pos)\n            if d2 <= radius * radius:\n                scored.append((d2, n))\n        scored.sort(key=lambda x: x[0])\n        out = []\n        for i in range(min(k, len(scored))):\n            out.append(scored[i][1])\n        # if still empty, allow nearest from ring candidates\n        if not out and scored:\n            out.append(scored[0][1])\n        return out\n\n    def _grid_neighbors_within(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        out = []\n        span = max(1, int(radius // self.cell) + 1)\n        r2 = radius * radius\n        if self.is3:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        lst = self._grid_neighbors_within(grid, pos, radius)\n        return len(lst) > 0\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.2)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _edge_key(self, a, b):\n        # order-invariant rounded key\n        ra = tuple(int(round(x * 10.0)) for x in a)\n        rb = tuple(int(round(x * 10.0)) for x in b)\n        if ra <= rb:\n            return (ra, rb)\n        else:\n            return (rb, ra)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            return hit\n        ok = not self._segment_hits_any(a, b)\n        if len(self.ecache) > 40000:\n            self.ecache.clear()\n        self.ecache[key] = ok\n        return ok\n\n    # Parenting and rewiring\n    def _adaptive_radius(self, n_nodes, scale=2.4):\n        if n_nodes <= 1:\n            return self.step * scale\n        # RRT* style fade with log(n)/n\n        base = self.step * scale\n        decay = (self._log(n_nodes + 1) / (n_nodes + 1.0)) ** (1.0 / max(2, self.dim))\n        r = max(self.step * 1.25, base * (0.9 + 0.6 * decay))\n        return r\n\n    def _log(self, x):\n        # natural log via series around 1 for x>0; fallback to change-of-base using ln(1+y)\n        # For stability, use simple Newton iteration on exp; approximate ln using binary search between [0, max]\n        # Simpler: use change to base-2 via bit shifts approximation\n        # Here use a minimal iterative approach\n        if x <= 0:\n            return -1e9\n        y = 0.0\n        v = x\n        # normalize v to [1,2)\n        k = 0\n        while v >= 2.0:\n            v *= 0.5\n            k += 1\n        while v < 1.0:\n            v *= 2.0\n            k -= 1\n        # series ln(v) around 1: ln(v) ~ 2*(t + t^3/3 + t^5/5 + ...), t=(v-1)/(v+1)\n        t = (v - 1.0) / (v + 1.0)\n        t2 = t * t\n        s = 0.0\n        num = t\n        for n in range(1, 7, 2):\n            s += num / n\n            num *= t2\n        ln2 = 0.6931471805599453\n        return 2.0 * s + k * ln2\n\n    def _choose_parent(self, newp, candidates):\n        best = None\n        best_cost = 1e100\n        for n in candidates:\n            # edge check deferred to minimize calls\n            g = n.cost + self._dist(n.position, newp)\n            if g + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                best = n\n                best_cost = g\n        if best is None:\n            return None, 0.0\n        return best, best_cost\n\n    def _rewire_from(self, pivot, neighbors, edges):\n        if not neighbors:\n            return\n        rewired = 0\n        for nb in neighbors:\n            if rewired >= self.rewire_cap:\n                break\n            if nb is pivot or nb.parent is None:\n                continue\n            cand_cost = pivot.cost + self._dist(pivot.position, nb.position)\n            if cand_cost + 1e-12 < nb.cost and self._edge_free(pivot.position, nb.position):\n                oldp = nb.parent\n                nb.detach_from_parent()\n                pivot.add_child(nb)\n                try:\n                    idx = edges.index((oldp, nb))\n                    edges.pop(idx)\n                except:\n                    pass\n                edges.append((pivot, nb))\n                old_cost = nb.cost\n                nb.cost = cand_cost\n                self._propagate_cost(nb)\n                rewired += 1\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if newc + 1e-12 < ch.cost:\n                    ch.cost = newc\n                else:\n                    ch.cost = newc\n                stack.append(ch)\n\n    # Connect attempt\n    def _try_connect(self, tree, grid, target_pos, nodes, edges):\n        # Direct one-shot connect to nearest opposite node\n        nearest = self._nearest(grid, tree, target_pos)\n        if nearest and self._edge_free(nearest.position, target_pos):\n            # If target_pos too close to existing node, treat as meeting at that node\n            if self._dist(nearest.position, target_pos) <= self.dup_radius * 0.75:\n                return nearest, True\n            if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                meet = Node(target_pos, nearest, nearest.cost + self._dist(nearest.position, target_pos))\n                nearest.add_child(meet)\n                tree.append(meet)\n                nodes.append(meet)\n                edges.append((nearest, meet))\n                self._grid_add(grid, meet)\n                # light seam rewiring\n                rrad = self._adaptive_radius(len(tree), scale=self.rewire_radius_scale * 0.8)\n                neigh = self._grid_neighbors_within(grid, target_pos, rrad)\n                self._rewire_from(meet, neigh, edges)\n                return meet, True\n            return nearest, False\n\n        # Greedy bounded steps toward target\n        cur = nearest\n        steps = 0\n        while cur is not None and steps < self.connect_steps:\n            nxtp = self._steer(cur.position, target_pos, self.step)\n            if (not self._in_bounds(nxtp)) or self._point_in_obstacles(nxtp):\n                return cur, False\n            if not self._edge_free(cur.position, nxtp):\n                return cur, False\n            # choose parent locally (cur or neighbor within small radius)\n            pr = max(self.step * 1.25, self._adaptive_radius(len(tree), scale=self.parent_radius_scale * 0.6))\n            neigh = self._grid_neighbors_within(grid, nxtp, pr)\n            if cur not in neigh:\n                neigh.append(cur)\n            bestp, bestc = self._choose_parent(nxtp, neigh)\n            if bestp is None:\n                return cur, False\n            # final checks before add\n            if self._point_in_obstacles(nxtp) or (not self._edge_free(bestp.position, nxtp)):\n                return cur, False\n            nn = Node(nxtp, bestp, bestc)\n            bestp.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((bestp, nn))\n            self._grid_add(grid, nn)\n            # small local rewire\n            self._rewire_from(nn, neigh, edges)\n            cur = nn\n            steps += 1\n            if self._dist(cur.position, target_pos) <= self.step and self._edge_free(cur.position, target_pos):\n                if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                    final = Node(target_pos, cur, cur.cost + self._dist(cur.position, target_pos))\n                    cur.add_child(final)\n                    tree.append(final)\n                    nodes.append(final)\n                    edges.append((cur, final))\n                    self._grid_add(grid, final)\n                    return final, True\n                return cur, False\n        return cur, False\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.6:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            if self._in_bounds(attractor) and (not self._point_in_obstacles(attractor)):\n                return attractor\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(15):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Path utilities\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        # Greedy corner cull\n        k = 1\n        while k < len(cur) - 1:\n            if self._edge_free(cur[k - 1], cur[k + 1]):\n                cur.pop(k)\n            else:\n                k += 1\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._visibility_prune(path)\n        p2 = self._shortcut(p1, self.smooth_attempts)\n        return self._dedup(p2)",
          "objective": -38.45865,
          "time_improvement": 69.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1355.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.006320738792419433,
                    "num_nodes_avg": 40.0,
                    "path_length_avg": 153.28064096609592,
                    "smoothness_avg": 0.04475071007809341,
                    "success_improvement": 0.0,
                    "time_improvement": 74.38018765178215,
                    "node_improvement": 89.92697053638882,
                    "length_improvement": 15.984451799295094,
                    "smoothness_improvement": 600.4457904444797,
                    "objective_score": 34.9069563273341
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06322317123413086,
                    "num_nodes_avg": 229.0,
                    "path_length_avg": 234.02056344335762,
                    "smoothness_avg": 0.08682989071145224,
                    "success_improvement": 0.0,
                    "time_improvement": 62.198761518109656,
                    "node_improvement": 84.61331720755224,
                    "length_improvement": 21.877200014171095,
                    "smoothness_improvement": 2134.1956290480175,
                    "objective_score": 42.45692660917564
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014822864532470703,
                    "num_nodes_avg": 83.0,
                    "path_length_avg": 125.04636269503999,
                    "smoothness_avg": 0.11244887119936313,
                    "success_improvement": 0.0,
                    "time_improvement": 70.63425449437379,
                    "node_improvement": 89.446916719644,
                    "length_improvement": 16.950159965872018,
                    "smoothness_improvement": 1330.3413415436141,
                    "objective_score": 38.01207903555342
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "IBEX-Lite: Informed BiRRT* with Elastic Micro-Connect. It blends fast bidirectional growth, visibility-based best-parent insertion with light rewiring, obstacle-binned collision checks, and a commit-only micro-bridge to connect trees. After connection it runs multi-pass visibility compression, shortcutting, and safe corner rounding. The design targets high success, short and smooth paths with low planning time.",
          "planning_mechanism": "Alternate growing the two trees (balanced), sampling via goal/corridor-biased free points. For each sample: pick a nearby anchor with a hash grid, steer one step, and select the least-cost visible parent among local neighbors with a small turn-angle penalty; insert only after node and edge checks, then lightly rewire neighbors. Probe the opposite tree: first try direct LOS; else simulate a few greedy steps; if a connector exists, commit the whole micro-bridge and return the assembled, smoothed path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            # detach from old parent\n            i = 0\n            while i < len(self.parent.children):\n                if self.parent.children[i] is self:\n                    self.parent.children.pop(i)\n                    break\n                i += 1\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=6.0,\n                 goal_bias=0.3,\n                 corridor_bias=0.25,\n                 grid_cell_factor=1.8,\n                 neighbor_radius_factor=2.2,\n                 dupe_radius_ratio=0.3,\n                 k_rewire=4,\n                 connect_hops=3,\n                 edge_res=0.8,\n                 smooth_shortcuts=80,\n                 smooth_rounds=6):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.cell_factor = float(grid_cell_factor)\n        self.nei_factor = float(neighbor_radius_factor)\n        self.dupe_ratio = float(dupe_radius_ratio)\n        self.k_rewire = int(max(0, k_rewire))\n        self.connect_hops = int(max(1, connect_hops))\n        self.edge_res = float(edge_res)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self.smooth_rounds = int(max(0, smooth_rounds))\n        self._rng = 123456789\n\n    def plan(self, map):\n        # Setup\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", [])) if getattr(map, \"obstacles\", None) is not None else []\n\n        self._seed_rng()\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], [], [])\n        # Build obstacle bins before collision tests\n        self._build_obs_bins()\n\n        # Validate endpoints\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        nodes = []\n        edges = []\n\n        # Early straight-line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Derived spatial params\n        self.cell = max(1.0, self.step * self.cell_factor)\n        self.nei_radius = max(1.5 * self.step, self.step * self.nei_factor)\n        self.dupe_radius = max(0.35, self.step * self.dupe_ratio)\n\n        # Initialize two trees and grids\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        A, B = [a_root], [b_root]\n        nodes.extend([a_root, b_root])\n        GA, GB = {}, {}\n        self._grid_add(GA, a_root)\n        self._grid_add(GB, b_root)\n        frontierA, frontierB = [a_root], [b_root]\n\n        for it in range(self.max_iter):\n            # Balanced alternating\n            if it % 3 == 2:\n                growA = (len(A) <= len(B))\n            else:\n                growA = (it % 2 == 0)\n\n            T = A if growA else B\n            O = B if growA else A\n            G = GA if growA else GB\n            GO = GB if growA else GA\n            frontier = frontierA if growA else frontierB\n            frontierO = frontierB if growA else frontierA\n            attract = self.goal if growA else self.start\n\n            target = self._sample_target(attract)\n            if target is None:\n                continue\n\n            # nearest anchor\n            qnear = self._nearest(G, frontier, target, max_rings=2)\n            if qnear is None:\n                qnear = T[-1]\n\n            qnew_pos = self._steer(qnear.position, target, self.step)\n            if (not self._in_bounds(qnew_pos)) or self._point_blocked(qnew_pos):\n                continue\n            if self._has_close(G, qnew_pos, self.dupe_radius):\n                continue\n\n            parent, bestc = self._choose_parent(G, qnew_pos, qnear)\n            if parent is None:\n                continue\n\n            # Both checks before insertion\n            if self._point_blocked(qnew_pos):\n                continue\n            if not self._edge_free(parent.position, qnew_pos):\n                continue\n\n            qnode = Node(qnew_pos, parent, bestc)\n            qnode.attach(parent)\n            T.append(qnode)\n            nodes.append(qnode)\n            edges.append((parent, qnode))\n            self._grid_add(G, qnode)\n            frontier.append(qnode)\n            if len(frontier) > 160:\n                del frontier[:16]\n\n            # Local light rewiring\n            if self.k_rewire > 0:\n                self._rewire_local(qnode, G, edges, k=self.k_rewire)\n\n            # Try to connect to opposite tree\n            other_near = self._nearest(GO, frontierO, qnode.position, max_rings=2)\n            if other_near is not None:\n                # Direct bridge\n                if self._edge_free(qnode.position, other_near.position):\n                    path = self._assemble_path(qnode, other_near, growA)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # Elastic micro-bridge (commit only if it completes)\n                qlast = self._micro_bridge(O, GO, other_near, qnode.position)\n                if qlast is not None and self._edge_free(qnode.position, qlast.position):\n                    path = self._assemble_path(qnode, qlast, growA)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            s ^= (int(v * 2654435761) & 0xffffffff)\n            s = (s * 1664525 + 1013904223) & 0xffffffff\n        s ^= len(self.obstacles) * 374761393\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        # xorshift32\n        x = self._rng & 0xffffffff\n        x ^= (x << 13) & 0xffffffff\n        x ^= (x >> 17) & 0xffffffff\n        x ^= (x << 5) & 0xffffffff\n        self._rng = x & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Obstacle bins and collisions\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self._obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self._obin.get(key)\n                            if lst is None:\n                                self._obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self._obin.get(key)\n                        if lst is None:\n                            self._obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_bucket(self, p):\n        if self.is3:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell),\n                                   int(p[2] // self.obs_cell)))\n        else:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell)))\n\n    def _point_blocked(self, p):\n        bucket = self._point_bucket(p)\n        if not bucket:\n            return False\n        if self.is3:\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _seg_box_intersect(self, a, b, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(self.dim):\n            p = a[i]\n            d = b[i] - a[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _edge_free(self, a, b):\n        # Quickly reject with obstacle bin candidate list based on segment bbox coverage\n        if self.is3:\n            mn = (min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2]))\n            mx = (max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2]))\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            iz0 = int(max(0.0, mn[2]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mx[2]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self._obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return True\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            mn = (min(a[0], b[0]), min(a[1], b[1]))\n            mx = (max(a[0], b[0]), max(a[1], b[1]))\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self._obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return True\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    # Grid utilities\n    def _cell_key(self, pos):\n        if self.is3:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, frontier, pos, max_rings=2):\n        kk = self._cell_key(pos)\n        best = None\n        bd = 1e100\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring(grid, kk, r)\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bd:\n                        bd = d2\n                        best = n\n                if best is not None:\n                    return best\n        # fallback to recent frontier\n        if frontier:\n            lim = min(24, len(frontier))\n            for i in range(lim):\n                n = frontier[-1 - i]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bd:\n                    bd = d2\n                    best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, cap=20):\n        kk = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((kk[0] + dx, kk[1] + dy, kk[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n                                if len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((kk[0] + dx, kk[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n                            if len(out) >= cap:\n                                return out\n        return out\n\n    def _has_close(self, grid, pos, radius):\n        ns = self._neighbors(grid, pos, radius, cap=6)\n        return len(ns) > 0\n\n    # Parent selection with small turn penalty\n    def _choose_parent(self, grid, new_pos, fallback):\n        cand = self._neighbors(grid, new_pos, self.nei_radius, cap=24)\n        if fallback not in cand:\n            cand.append(fallback)\n        best = None\n        best_cost = 1e100\n        for p in cand:\n            d = self._dist(p.position, new_pos)\n            if d > 1.6 * self.step:\n                continue\n            if not self._edge_free(p.position, new_pos):\n                continue\n            c = p.cost + d\n            # Turn penalty: prefer smoother joins\n            if p.parent is not None:\n                u = tuple(p.position[i] - p.parent.position[i] for i in range(self.dim))\n                v = tuple(new_pos[i] - p.position[i] for i in range(self.dim))\n                nu = max(1e-12, self._dist((0.0,) * self.dim, u))\n                nv = max(1e-12, self._dist((0.0,) * self.dim, v))\n                dot = 0.0\n                for i in range(self.dim):\n                    dot += u[i] * v[i]\n                cosang = max(-1.0, min(1.0, dot / (nu * nv)))\n                # angle in [0, pi]; penalty scaled by step\n                ang = (1.0 - cosang)  # cheaper than acos, monotonic\n                c += 0.08 * self.step * ang\n            if c < best_cost:\n                best_cost = c\n                best = p\n        return best, best_cost\n\n    # Light rewiring around a new node\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                edges.pop(i)\n                return\n\n    def _propagate_delta(self, node, delta):\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    def _rewire_local(self, new_node, grid, edges, k=4):\n        neigh = self._neighbors(grid, new_node.position, self.nei_radius, cap=32)\n        if not neigh:\n            return\n        # Prefer closest neighbors\n        neigh.sort(key=lambda n: self._dist2(n.position, new_node.position))\n        count = 0\n        for nb in neigh:\n            if count >= k:\n                break\n            if nb is new_node or nb is new_node.parent:\n                continue\n            if self._is_ancestor(nb, new_node):\n                continue\n            # Both checks before adding new edge\n            if self._point_blocked(nb.position):\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            cand_cost = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand_cost + 1e-9 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    # detach from old parent\n                    i = 0\n                    while i < len(oldp.children):\n                        if oldp.children[i] is nb:\n                            oldp.children.pop(i)\n                            break\n                        i += 1\n                    self._remove_edge(edges, oldp, nb)\n                nb.attach(new_node)\n                edges.append((new_node, nb))\n                delta = cand_cost - nb.cost\n                nb.cost = cand_cost\n                self._propagate_delta(nb, delta)\n                count += 1\n\n    # Micro-bridge: simulate a few steps on opposite tree, commit only if connection completes\n    def _micro_bridge(self, tree, grid, near_node, target_pos):\n        cur = near_node.position\n        chain = []\n        success = False\n        last = None\n        for _ in range(self.connect_hops):\n            nxt = self._steer(cur, target_pos, self.step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                break\n            if self._has_close(grid, nxt, self.dupe_radius * 0.7):\n                break\n            if not self._edge_free(cur, nxt):\n                break\n            chain.append(nxt)\n            cur = nxt\n            # if we can close the final link to target, mark success\n            if self._edge_free(cur, target_pos):\n                success = True\n                last = cur\n                break\n        if not success or last is None:\n            return None\n        # Commit the chain to the opposite tree with both checks on each segment\n        prev = near_node\n        for p in chain:\n            if self._point_blocked(p):\n                return None\n            if not self._edge_free(prev.position, p):\n                return None\n            nn = Node(p, prev, prev.cost + self._dist(prev.position, p))\n            nn.attach(prev)\n            tree.append(nn)\n            self._grid_add(grid, nn)\n            prev = nn\n        return prev\n\n    # Sampling\n    def _sample_target(self, attract):\n        for _ in range(28):\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attract\n            elif r < self.goal_bias + self.corridor_bias:\n                p = self._corridor_point()\n            else:\n                if self.is3:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        return None\n\n    def _corridor_point(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step, 0.08 * sg)\n        if self.is3:\n            return self._clamp((base[0] + self._rand_range(-w, w),\n                                base[1] + self._rand_range(-w, w),\n                                base[2] + self._rand_range(-w, w)))\n        else:\n            return self._clamp((base[0] + self._rand_range(-w, w),\n                                base[1] + self._rand_range(-w, w)))\n\n    # Path assembly and utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _assemble_path(self, a_end, b_end, a_side_grew):\n        if a_side_grew:\n            pa = self._path_to_root(a_end)\n            pb = self._path_to_root(b_end)\n            if pa and pb and pa[0] == pb[-1]:\n                pb = pb[:-1]\n            return pa + pb[::-1]\n        else:\n            pa = self._path_to_root(a_end)\n            pb = self._path_to_root(b_end)\n            if pa and pb and pb[0] == pa[-1]:\n                pa = pa[:-1]\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # Smoothing\n    def _vis_collapse(self, pts, passes=2):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            i = 0\n            changed = False\n            while i < len(cur) - 2:\n                j = len(cur) - 1\n                while j > i + 1:\n                    if self._edge_free(cur[i], cur[j]):\n                        if j > i + 1:\n                            del cur[i + 1:j]\n                            changed = True\n                        break\n                    j -= 1\n                i += 1\n            if not changed:\n                break\n        return cur\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            n = len(cur)\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j > n - 1:\n                tries += 1\n                continue\n            a, b = cur[i], cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-12 <= bestL:\n                    cur = cand\n                    bestL = L\n            tries += 1\n        return cur\n\n    def _round_corners(self, pts, passes):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                c = cur[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                if (not self._in_bounds(mid)) or self._point_blocked(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if cur[i] != mid:\n                        cur[i] = mid\n                        moved = True\n            if not moved:\n                break\n        return cur\n\n    def _postprocess(self, path):\n        if len(path) < 3:\n            return path[:]\n        p = self._vis_collapse(path, passes=2)\n        p = self._shortcut(p, self.smooth_shortcuts)\n        p = self._round_corners(p, self.smooth_rounds)\n        return p",
          "objective": -37.68839,
          "time_improvement": 61.0,
          "length_improvement": 21.0,
          "smoothness_improvement": 1336.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011586189270019531,
                    "num_nodes_avg": 61.0,
                    "path_length_avg": 150.2550697876198,
                    "smoothness_avg": 0.041941448754662616,
                    "success_improvement": 0.0,
                    "time_improvement": 53.03776905243485,
                    "node_improvement": 84.63863006799295,
                    "length_improvement": 17.64281530546121,
                    "smoothness_improvement": 556.4747503241836,
                    "objective_score": 29.279393650628094
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03080716133117676,
                    "num_nodes_avg": 131.0,
                    "path_length_avg": 228.48646410685174,
                    "smoothness_avg": 0.08768701591384163,
                    "success_improvement": 0.0,
                    "time_improvement": 81.58034736794089,
                    "node_improvement": 91.19801115366526,
                    "length_improvement": 23.72464166291407,
                    "smoothness_improvement": 2156.250077867826,
                    "objective_score": 49.490139597469835
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026394367218017578,
                    "num_nodes_avg": 112.0,
                    "path_length_avg": 116.65576078031737,
                    "smoothness_avg": 0.10957624060714707,
                    "success_improvement": 0.0,
                    "time_improvement": 47.70981892140697,
                    "node_improvement": 85.75969485060394,
                    "length_improvement": 22.5227982401031,
                    "smoothness_improvement": 1293.8016924461601,
                    "objective_score": 34.29563308271475
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "BASIL-RRT: Bi-directional Adaptive Simplified Informed Lite with Rewire and Visibility. Two trees grow toward each other with simple grid-accelerated nearest search, duplicate suppression, best-parent selection, visibility jumps to higher ancestors, and light local rewiring. Guided sampling uses corridor and informed-ellipse biases to shorten routes. On connection, deterministic visibility compression, shortcutting, and elastic smoothing yield short, smooth paths efficiently.",
          "planning_mechanism": "Initialize bidirectional trees and spatial hashes. Repeat: sample a biased target (goal/corridor/informed/uniform), pick the nearest via grid, steer by a fixed step, and validate both node and edge. Choose the least-cost feasible parent from nearby nodes, insert, then visibility-jump to a visible ancestor and locally rewire cheaper neighbors. Probe the opposite tree for a direct or short bridge; if connected, assemble the path and postprocess with visibility compression, randomized shortcuts, and elastic smoothing. Maintain an incumbent best path for informed sampling.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=7.0,\n        goal_bias=0.15,\n        corridor_bias=0.45,\n        informed_bias=0.5,\n        cell_size_factor=1.2,\n        dupe_ratio=0.3,\n        connect_dist_factor=2.5,\n        rewire_mult=2.5,\n        neighbor_cap=32,\n        shortcuts=120,\n        elastic_iters=10\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.cell_size_factor = float(cell_size_factor)\n        self.dupe_ratio = float(dupe_ratio)\n        self.connect_dist_factor = float(connect_dist_factor)\n        self.rewire_mult = float(rewire_mult)\n        self.neighbor_cap = int(neighbor_cap)\n        self.shortcuts = int(max(0, shortcuts))\n        self.elastic_iters = int(max(0, elastic_iters))\n        self._rnd = 2463534242\n\n    # Public entry\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if getattr(map, \"obstacles\", None) else []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        self._seed_from_scene()\n        self._build_obstacle_grid()\n\n        # Endpoint validity\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Parameters\n        self.cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_ratio)\n        self.connect_dist = max(self.step_size, self.connect_dist_factor * self.step_size)\n        corridor_w = max(self.step_size, 0.2 * self._dist(self.start, self.goal))\n\n        # Trees and grids\n        nodes = []\n        edges = []\n\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_insert(Ga, a_root)\n        self._grid_insert(Gb, b_root)\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            T = Ta if side_a else Tb\n            G = Ga if side_a else Gb\n            T_opp = Tb if side_a else Ta\n            G_opp = Gb if side_a else Ga\n            attractor = self.goal if side_a else self.start\n\n            # Target sampling\n            target = self._sample_target(attractor, best_len, corridor_w)\n            if target is None:\n                continue\n\n            # Nearest and steer\n            near = self._nearest_grid(G, target)\n            if near is None:\n                continue\n            new_pos = self._steer(near.position, target)\n            if not self._within_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if self._has_nearby(G, new_pos, self.dupe_radius):\n                continue\n\n            # Best-parent selection with local neighbors\n            parent, new_cost = self._choose_parent(T, G, new_pos)\n            if parent is None:\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            # Insert node\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            T.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(G, new_node)\n\n            # Visibility jump to a cheaper visible ancestor\n            self._visibility_jump(new_node, edges)\n\n            # Local rewiring (length/cost reduction)\n            self._rewire_neighbors(G, new_node, edges)\n\n            # Try connect to opposite tree\n            other_near = self._nearest_grid(G_opp, new_node.position)\n            if other_near is not None:\n                dno = self._dist(new_node.position, other_near.position)\n                if dno <= self.connect_dist and self._edge_free(new_node.position, other_near.position):\n                    path = self._assemble_path(new_node, other_near, side_a)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # One-step probe from opposite tree\n                step_p = self._steer(other_near.position, new_node.position)\n                if self._within_bounds(step_p) and not self._point_in_obstacles(step_p):\n                    if not self._has_nearby(G_opp, step_p, self.dupe_radius):\n                        if self._edge_free(other_near.position, step_p):\n                            q = Node(step_p, other_near, other_near.cost + self._dist(other_near.position, step_p))\n                            other_near.add_child(q)\n                            T_opp.append(q)\n                            nodes.append(q)\n                            edges.append((other_near, q))\n                            self._grid_insert(G_opp, q)\n                            self._visibility_jump(q, edges)\n                            self._rewire_neighbors(G_opp, q, edges)\n                            if self._edge_free(new_node.position, q.position):\n                                path = self._assemble_path(new_node, q, side_a)\n                                path = self._postprocess(path)\n                                return PlannerResult(True, path, nodes, edges)\n\n            # Maintain incumbent best for informed sampling\n            if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                tmp = self._assemble_path(new_node, other_near, side_a)\n                L = self._path_len(tmp)\n                if L < best_len:\n                    best_len = L\n                    best_path = tmp\n\n        if best_path is not None:\n            best_path = self._postprocess(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 1) * 2654435761\n        self._rnd = (s ^ 0x9E3779B9) & 0xffffffff\n        if self._rnd == 0:\n            self._rnd = 2463534242\n\n    def _rand(self):\n        self._rnd = (1664525 * self._rnd + 1013904223) & 0xffffffff\n        return self._rnd / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= self.step_size:\n            return self._clamp(b)\n        r = self.step_size / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Sampling\n    def _sample_target(self, attractor, best_len, corridor_w):\n        for _ in range(16):\n            if best_len < float('inf') and self._rand() < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p is not None and not self._point_in_obstacles(p):\n                    return p\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attractor\n            elif r < self.goal_bias + self.corridor_bias:\n                t = self._rand()\n                base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n                if self.dims == 3:\n                    p = (self._rand_range(base[0] - corridor_w, base[0] + corridor_w),\n                         self._rand_range(base[1] - corridor_w, base[1] + corridor_w),\n                         self._rand_range(base[2] - corridor_w, base[2] + corridor_w))\n                else:\n                    p = (self._rand_range(base[0] - corridor_w, base[0] + corridor_w),\n                         self._rand_range(base[1] - corridor_w, base[1] + corridor_w))\n            else:\n                p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            p = self._clamp(p)\n            if not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if self._within_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Node spatial grid\n    def _cell_of(self, pos, cell=None):\n        cs = self.cell_size if cell is None else cell\n        if self.dims == 3:\n            return (int(pos[0] // cs), int(pos[1] // cs), int(pos[2] // cs))\n        return (int(pos[0] // cs), int(pos[1] // cs))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _nearest_grid(self, grid, pos):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        # Expand rings up to 3\n        for r in range(0, 4):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback: scan all buckets\n        for b in grid.values():\n            for n in b:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.dims == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _neighbors_within_radius(self, grid, pos, radius, cap):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        out = []\n        rr = radius * radius\n        for n in cand:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= rr:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _has_nearby(self, grid, pos, radius):\n        neigh = self._neighbors_within_radius(grid, pos, radius, self.neighbor_cap)\n        return len(neigh) > 0\n\n    # Parent selection and optimization\n    def _choose_parent(self, tree, grid, new_pos):\n        n = len(tree)\n        # Dynamic radius ~ n^{-1/d}\n        dyn_r = max(self.step_size, self.rewire_mult * self.step_size * (1.0 / (1.0 + n)) ** (1.0 / max(1, self.dims)))\n        neigh = self._neighbors_within_radius(grid, new_pos, dyn_r, self.neighbor_cap)\n        if not neigh:\n            near = None\n            bestd = 1e100\n            for m in tree:\n                d = self._dist(m.position, new_pos)\n                if d < bestd:\n                    bestd = d\n                    near = m\n            neigh = [near] if near is not None else []\n        best_parent = None\n        best_cost = 1e100\n        for p in neigh:\n            d = self._dist(p.position, new_pos)\n            if d > dyn_r + 1e-9:\n                continue\n            if not self._edge_free(p.position, new_pos):\n                continue\n            gc = p.cost + d\n            if gc < best_cost:\n                best_cost = gc\n                best_parent = p\n        if best_parent is None:\n            return None, None\n        return best_parent, best_cost\n\n    def _visibility_jump(self, node, edges):\n        cur_parent = node.parent\n        if cur_parent is None:\n            return\n        best_parent = cur_parent\n        best_cost = node.cost\n        anc = cur_parent.parent\n        while anc is not None:\n            if self._edge_free(anc.position, node.position):\n                c = anc.cost + self._dist(anc.position, node.position)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best_parent = anc\n            anc = anc.parent\n        if best_parent is not cur_parent:\n            self._reparent(node, best_parent, edges)\n\n    def _rewire_neighbors(self, grid, node, edges):\n        # Use same dynamic radius as parent selection from this node's tree size (approx via node.cost order not needed)\n        radius = max(self.step_size, self.rewire_mult * self.step_size * 0.9)\n        neigh = self._neighbors_within_radius(grid, node.position, radius, self.neighbor_cap)\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if node.cost + d + 1e-9 < nb.cost and self._edge_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        if child.parent is new_parent:\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old_parent = child.parent\n        if old_parent is not None:\n            old_parent.remove_child(child)\n            self._edges_remove(edges, old_parent, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        self._propagate_costs(child)\n\n    def _edges_remove(self, edges, parent, child):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is parent and e[1] is child:\n                edges.pop(i)\n                break\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if abs(newc - ch.cost) > 1e-12:\n                    ch.cost = newc\n                    stack.append(ch)\n\n    # Obstacles\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.dims == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.dims == 3:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Path assembly and post-process\n    def _assemble_path(self, u, v, side_a):\n        # u in current tree, v in opposite\n        pu = u.path_from_root()\n        pv = v.path_from_root()\n        if side_a:\n            # start -> u then v -> goal\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _postprocess(self, path):\n        if len(path) < 2:\n            return path[:]\n        p = self._visibility_compress(path)\n        p = self._shortcut(p, self.shortcuts)\n        p = self._elastic(p, self.elastic_iters)\n        return p\n\n    def _visibility_compress(self, path):\n        out = [path[0]]\n        anchor = path[0]\n        i = 1\n        while i < len(path):\n            far = i\n            j = i\n            while j < len(path):\n                if self._edge_free(anchor, path[j]):\n                    far = j\n                    j += 1\n                else:\n                    break\n            out.append(path[far])\n            anchor = path[far]\n            i = far + 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = path[:]\n        best = self._path_len(pts)\n        n = len(pts)\n        noimp = 0\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j > n:\n                noimp += 1\n                if noimp > 16:\n                    break\n                continue\n            a, b = pts[i], pts[j - 1]\n            if self._edge_free(a, b):\n                candidate = pts[:i + 1] + pts[j - 1:]\n                L = self._path_len(candidate)\n                if L <= best + 1e-12:\n                    pts = candidate\n                    best = L\n                    n = len(pts)\n                    noimp = 0\n                else:\n                    noimp += 1\n            else:\n                noimp += 1\n            if noimp > 24:\n                break\n        return pts\n\n    def _elastic(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return path[:]\n        pts = list(path)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dims))\n                if self._point_in_obstacles(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if mid != pts[i]:\n                        pts[i] = mid\n                        moved = True\n            if not moved:\n                break\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        return pts",
          "objective": -37.60553,
          "time_improvement": 63.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1737.0,
          "node_improvement": 84.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01027677059173584,
                    "num_nodes_avg": 56.0,
                    "path_length_avg": 152.97087548687767,
                    "smoothness_avg": 0.05880624031240139,
                    "success_improvement": 0.0,
                    "time_improvement": 58.34522786771023,
                    "node_improvement": 85.89775875094435,
                    "length_improvement": 16.154239167002743,
                    "smoothness_improvement": 820.4453606838263,
                    "objective_score": 31.298338663933844
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.048004674911499026,
                    "num_nodes_avg": 233.0,
                    "path_length_avg": 260.1076340388263,
                    "smoothness_avg": 0.1240816945243068,
                    "success_improvement": 0.0,
                    "time_improvement": 71.29792559985403,
                    "node_improvement": 84.34455418934354,
                    "length_improvement": 13.168584974709937,
                    "smoothness_improvement": 3092.7113725425193,
                    "objective_score": 44.754085527494766
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021122431755065917,
                    "num_nodes_avg": 136.0,
                    "path_length_avg": 118.36585536678952,
                    "smoothness_avg": 0.1098386556019516,
                    "success_improvement": 0.0,
                    "time_improvement": 58.154110224750575,
                    "node_improvement": 82.70820089001907,
                    "length_improvement": 21.38703484172179,
                    "smoothness_improvement": 1297.1395918106139,
                    "objective_score": 36.764151931511314
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "ABLE-RRT: Adaptive Best-Parent Light Elastic Bidirectional RRT-Connect. Two grids grow start/goal trees with mixture-biased sampling. Each extension selects a locally optimal parent within one-step radius to reduce path cost, enforces strict node/edge collision checks, and performs greedy connect to the opposite tree. AABB-pruned edge checks accelerate collision tests. Upon connection, a light two-stage smoother (visibility compression + shortcutting + optional rubber-band) improves length and smoothness while keeping runtime low.",
          "planning_mechanism": "Initialize bidirectional trees and coarse grids. Each iteration: sample (goal/corridor/uniform), find a near node via grid, propose a one-step point, choose the best parent among nearby nodes that can reach it collision-free, then insert. Greedily connect the other tree toward the new node; if a short, collision-free bridge closes the gap, assemble the path and apply lightweight smoothing.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=7.0,\n        goal_bias=0.20,\n        corridor_bias=0.40,\n        cell_size_factor=2.0,\n        edge_resolution=1.0,\n        dupe_radius_ratio=0.40,\n        neighbor_radius_ratio=1.25,\n        smooth_shortcuts=80,\n        rubber_iters=6\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.cell_size_factor = float(cell_size_factor)\n        self.edge_resolution = float(edge_resolution)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.neighbor_radius_ratio = float(neighbor_radius_ratio)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self.rubber_iters = int(max(0, rubber_iters))\n\n    def plan(self, map):\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        obstacles = list(map.obstacles)\n\n        # Validate start/goal\n        if not self._within_bounds(start, bounds) or not self._within_bounds(goal, bounds):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight line\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_resolution):\n            n0 = Node(start, None, 0.0)\n            n1 = Node(goal, n0, self._distance(start, goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [start, goal], [n0, n1], [(n0, n1)])\n\n        # Init trees and grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n        cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        grid_start, grid_goal = {}, {}\n        self._grid_insert(grid_start, start_root.position, start_root, cell_size, dim)\n        self._grid_insert(grid_goal, goal_root.position, goal_root, cell_size, dim)\n\n        dsg = self._distance(start, goal)\n        corridor_w = max(self.step_size, 0.18 * dsg)\n        dupe_radius = max(0.5, self.dupe_radius_ratio * self.step_size)\n        neighbor_radius = max(self.step_size, self.neighbor_radius_ratio * self.step_size)\n\n        for it in range(self.max_iter):\n            # Alternate growth\n            if it % 2 == 0:\n                grow_tree, grow_grid, grow_root = start_tree, grid_start, start_root\n                other_tree, other_grid, other_root = goal_tree, grid_goal, goal_root\n                other_root_pos = goal\n                a_is_start_side = True\n            else:\n                grow_tree, grow_grid, grow_root = goal_tree, grid_goal, goal_root\n                other_tree, other_grid, other_root = start_tree, grid_start, start_root\n                other_root_pos = start\n                a_is_start_side = False\n\n            target = self._sample_target(bounds, obstacles, is_3d, start, goal, corridor_w, other_root_pos)\n            a_near = self._nearest_from_grid(grow_tree, grow_grid, target, cell_size, dim)\n\n            # Propose a one-step point\n            proposed = self._steer(a_near.position, target, self.step_size)\n            if not self._within_bounds(proposed, bounds):\n                continue\n            if self._is_in_obstacle(proposed, obstacles, is_3d):\n                continue\n            if self._exists_close(grow_grid, proposed, dupe_radius, cell_size, dim):\n                continue\n\n            # Choose best parent among neighbors that can reach proposed within one step\n            candidates = self._neighbors_within_radius(grow_grid, proposed, neighbor_radius, cell_size, dim)\n            if a_near not in candidates:\n                candidates.append(a_near)\n            best_parent = None\n            best_cost = float('inf')\n            for cand in candidates:\n                dcp = self._distance(cand.position, proposed)\n                if dcp > self.step_size + 1e-9:\n                    continue\n                if self._is_edge_in_obstacle(cand.position, proposed, obstacles, is_3d, self.edge_resolution):\n                    continue\n                cost = cand.cost + dcp\n                if cost < best_cost:\n                    best_cost = cost\n                    best_parent = cand\n            if best_parent is None:\n                continue\n\n            # Commit new node (both node and edge already validated)\n            new_node = Node(proposed, best_parent, best_cost)\n            best_parent.add_child(new_node)\n            grow_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            self._grid_insert(grow_grid, new_node.position, new_node, cell_size, dim)\n\n            # Greedy connect from the other tree toward new_node\n            b_near = self._nearest_from_grid(other_tree, other_grid, new_node.position, cell_size, dim)\n            b_last = self._greedy_extend(other_tree, other_grid, b_near, new_node.position,\n                                         nodes, edges, obstacles, is_3d, bounds, cell_size, dim)\n            if b_last is None:\n                continue\n\n            # Try final short bridge\n            if self._distance(b_last.position, new_node.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(b_last.position, new_node.position, obstacles, is_3d, self.edge_resolution):\n                    edges.append((b_last, new_node))\n                    # Assemble path\n                    if a_is_start_side:\n                        pa = new_node.path_from_root()\n                        pb = b_last.path_from_root()\n                        raw_path = pa + pb[::-1]\n                    else:\n                        pa = new_node.path_from_root()\n                        pb = b_last.path_from_root()\n                        raw_path = pb + pa[::-1]\n                    # Smooth\n                    path = self._compress_visibility(raw_path, obstacles, is_3d)\n                    path = self._shortcut_path(path, obstacles, is_3d, bounds, self.smooth_shortcuts)\n                    path = self._rubber_band(path, obstacles, is_3d, self.rubber_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---- Geometry utilities ----\n    def _distance(self, a, b):\n        s = 0.0\n        for i in range(len(a)):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p, bounds):\n        for i in range(len(bounds)):\n            if p[i] < 0.0 or p[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._distance(from_pos, to_pos)\n        if d <= step:\n            return tuple(to_pos[i] for i in range(len(to_pos)))\n        r = step / (d + 1e-12)\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    # ---- Sampling ----\n    def _sample_target(self, bounds, obstacles, is_3d, start, goal, corridor_w, other_root_pos):\n        import random  # Local import to avoid global requirement; acceptable inline\n        r = random.random()\n        if r < self.goal_bias:\n            return other_root_pos\n        elif r < self.goal_bias + self.corridor_bias:\n            t = random.random()\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(len(bounds)))\n            if len(bounds) == 3:\n                return (\n                    self._clamp(base[0] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[0]),\n                    self._clamp(base[1] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[1]),\n                    self._clamp(base[2] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[2]),\n                )\n            else:\n                return (\n                    self._clamp(base[0] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[0]),\n                    self._clamp(base[1] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[1]),\n                )\n        else:\n            # rejection sample in free space\n            for _ in range(32):\n                if len(bounds) == 3:\n                    p = (random.uniform(0.0, bounds[0]),\n                         random.uniform(0.0, bounds[1]),\n                         random.uniform(0.0, bounds[2]))\n                else:\n                    p = (random.uniform(0.0, bounds[0]),\n                         random.uniform(0.0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback (may be occupied; extension will reject)\n            if len(bounds) == 3:\n                return (random.uniform(0.0, bounds[0]),\n                        random.uniform(0.0, bounds[1]),\n                        random.uniform(0.0, bounds[2]))\n            else:\n                return (random.uniform(0.0, bounds[0]),\n                        random.uniform(0.0, bounds[1]))\n\n    def _clamp(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # ---- Collision utilities ----\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for x, y, z, w, h, d in obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for x, y, w, h in obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _seg_aabb_overlap(self, a, b, obs, is_3d):\n        if is_3d:\n            x, y, z, w, h, d = obs\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            if maxx < x or minx > x + w or maxy < y or miny > y + h or maxz < z or minz > z + d:\n                return False\n            return True\n        else:\n            x, y, w, h = obs\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            if maxx < x or minx > x + w or maxy < y or miny > y + h:\n                return False\n            return True\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._distance(a, b)\n        steps = int(max(1, d / max(1e-9, resolution)))\n        # Pre-filter obstacles by segment AABB overlap\n        relevant = []\n        for obs in obstacles:\n            if self._seg_aabb_overlap(a, b, obs, is_3d):\n                relevant.append(obs)\n        if not relevant:\n            return False\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(len(a)))\n            if self._is_in_obstacle(p, relevant, is_3d):\n                return True\n        return False\n\n    # ---- Grid NN and neighborhood ----\n    def _cell_index(self, pos, cell_size, dim):\n        if dim == 2:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size))\n        else:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size), int(pos[2] // cell_size))\n\n    def _grid_insert(self, grid, pos, node, cell_size, dim):\n        idx = self._cell_index(pos, cell_size, dim)\n        bucket = grid.get(idx)\n        if bucket is None:\n            grid[idx] = [node]\n        else:\n            bucket.append(node)\n\n    def _nearest_from_grid(self, tree, grid, point, cell_size, dim, max_rings=3):\n        if len(tree) < 32:\n            best = None\n            bestd = float('inf')\n            for n in tree:\n                d = self._distance(n.position, point)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            return best\n        center = self._cell_index(point, cell_size, dim)\n        best = None\n        bestd = float('inf')\n        found = False\n        for r in range(0, max_rings + 1):\n            cand = []\n            if dim == 2:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        idx = (center[0] + dx, center[1] + dy)\n                        if idx in grid:\n                            cand.extend(grid[idx])\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            idx = (center[0] + dx, center[1] + dy, center[2] + dz)\n                            if idx in grid:\n                                cand.extend(grid[idx])\n            if cand:\n                for n in cand:\n                    d = self._distance(n.position, point)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                        found = True\n            if found:\n                break\n        if best is None:\n            # fallback linear\n            best = tree[0]\n            bestd = self._distance(best.position, point)\n            for n in tree:\n                d = self._distance(n.position, point)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors_within_radius(self, grid, point, radius, cell_size, dim):\n        cells = int(radius / max(1e-9, cell_size)) + 1\n        center = self._cell_index(point, cell_size, dim)\n        out = []\n        if dim == 2:\n            for dx in range(-cells, cells + 1):\n                for dy in range(-cells, cells + 1):\n                    idx = (center[0] + dx, center[1] + dy)\n                    if idx in grid:\n                        out.extend(grid[idx])\n        else:\n            for dx in range(-cells, cells + 1):\n                for dy in range(-cells, cells + 1):\n                    for dz in range(-cells, cells + 1):\n                        idx = (center[0] + dx, center[1] + dy, center[2] + dz)\n                        if idx in grid:\n                            out.extend(grid[idx])\n        # filter by true distance\n        rr = radius * radius\n        fil = []\n        for n in out:\n            s = 0.0\n            p = n.position\n            for i in range(dim):\n                d = p[i] - point[i]\n                s += d * d\n            if s <= rr:\n                fil.append(n)\n        return fil\n\n    def _exists_close(self, grid, pos, radius, cell_size, dim):\n        neigh = self._neighbors_within_radius(grid, pos, radius, cell_size, dim)\n        return len(neigh) > 0\n\n    # ---- Extend/connect ----\n    def _greedy_extend(self, tree, grid, from_node, target_pos, nodes, edges, obstacles, is_3d, bounds, cell_size, dim):\n        current = from_node\n        last_new = None\n        while True:\n            step_pos = self._steer(current.position, target_pos, self.step_size)\n            if not self._within_bounds(step_pos, bounds):\n                break\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                break\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d, self.edge_resolution):\n                break\n            new_node = Node(step_pos, current, current.cost + self._distance(current.position, step_pos))\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node.position, new_node, cell_size, dim)\n            last_new = new_node\n            current = new_node\n            if self._distance(current.position, target_pos) <= self.step_size:\n                break\n        return last_new\n\n    # ---- Smoothing ----\n    def _compress_visibility(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        last = path[0]\n        i = 1\n        while i < len(path):\n            far = i\n            j = i\n            while j < len(path):\n                if self._is_edge_in_obstacle(last, path[j], obstacles, is_3d, self.edge_resolution):\n                    break\n                far = j\n                j += 1\n            out.append(path[far])\n            last = path[far]\n            i = far + 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds, attempts):\n        if len(path) < 3:\n            return list(path)\n        import random\n        pts = list(path)\n        n = len(pts)\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_resolution):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts\n\n    def _rubber_band(self, path, obstacles, is_3d, iters):\n        if len(path) < 3 or iters <= 0:\n            return list(path)\n        pts = list(path)\n        for _ in range(iters):\n            changed = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(len(a)))\n                if self._is_in_obstacle(mid, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(a, mid, obstacles, is_3d, self.edge_resolution):\n                    continue\n                if self._is_edge_in_obstacle(mid, c, obstacles, is_3d, self.edge_resolution):\n                    continue\n                if mid != pts[i]:\n                    pts[i] = mid\n                    changed = True\n            if not changed:\n                break\n        return pts",
          "objective": -37.59775,
          "time_improvement": 66.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1905.0,
          "node_improvement": 85.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009185576438903808,
                    "num_nodes_avg": 64.4,
                    "path_length_avg": 170.56202690395023,
                    "smoothness_avg": 0.04785735504538155,
                    "success_improvement": 0.0,
                    "time_improvement": 62.768158532802346,
                    "node_improvement": 83.782422563586,
                    "length_improvement": 6.512250325673065,
                    "smoothness_improvement": 649.0715303700621,
                    "objective_score": 25.983155407094852
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027295637130737304,
                    "num_nodes_avg": 154.6,
                    "path_length_avg": 240.5028644826979,
                    "smoothness_avg": 0.12901280114279629,
                    "success_improvement": 0.0,
                    "time_improvement": 83.67989348599582,
                    "node_improvement": 89.61230934623397,
                    "length_improvement": 19.713221344549247,
                    "smoothness_improvement": 3219.5922975687886,
                    "objective_score": 53.02986234037223
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02437562942504883,
                    "num_nodes_avg": 141.5,
                    "path_length_avg": 127.88160399822759,
                    "smoothness_avg": 0.15294445433893913,
                    "success_improvement": 0.0,
                    "time_improvement": 51.70916332215004,
                    "node_improvement": 82.00890019071836,
                    "length_improvement": 15.067127691977475,
                    "smoothness_improvement": 1845.4421700060007,
                    "objective_score": 33.7802364618615
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "FLASH-Connect-Lite: Fast Lattice-Hashed Spatially-Indexed BiRRT-Connect. It accelerates planning with a uniform spatial hash for obstacles and nodes, greedy multi-step RRT-Connect extensions, bounded per-cell admissions, near-duplicate suppression, and collision-check caching. The spatial hash prunes obstacle checks to local bins, drastically reducing segment and point collision costs; greedy connect minimizes iterations and edge tests; and early visibility pruning plus bounded shortcutting quickly yields usable, smooth paths.",
          "planning_mechanism": "Alternate extending start/goal trees: sample with goal bias, find a near node via lattice-hash rings, and greedily extend multiple steps toward the sample while enforcing in-bounds, node-collision, and edge-collision checks and skipping near-duplicates/excess cells. After each insertion, attempt a greedy connect from the opposite tree toward the new node; on first line-of-sight bridge, extract the path, visibility-prune, and shortcut-smooth, then stop. Obstacle and node queries use a spatial hash; edge checks use cached segment results.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        goal_bias=0.35,\n        grid_cell_factor=1.8,\n        max_per_cell=6,\n        min_sep_factor=0.6,\n        ring_max=3,\n        min_nn_candidates=16,\n        connect_max_steps=48,\n        smoothing_iters=40\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.max_per_cell = max_per_cell\n        self.min_sep_factor = min_sep_factor\n        self.ring_max = ring_max\n        self.min_nn_candidates = min_nn_candidates\n        self.connect_max_steps = connect_max_steps\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        self._lcg_state = 2463534242\n\n        # Spatial indices and caches\n        self._obs_grid = {}\n        self._obs_cell = 4.0\n        self._edge_cache = {}\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        self.is_3d = is_3d\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Parameters derived from map/step\n        self.edge_res = max(0.5, min(1.0, self.step_size * 0.5))\n        self.nn_cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.3, self.step_size * self.min_sep_factor)\n        self._obs_cell = max(2.0, self.step_size)  # coarse but effective for pruning\n\n        # Reset RNG and caches\n        self._lcg_state = 2463534242\n        self._edge_cache = {}\n\n        # Build obstacle spatial hash\n        self._build_obs_grid(obstacles, is_3d)\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start) or self._is_in_obstacle(goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line attempt\n        if not self._edge_blocked(start, goal):\n            path = [start, goal]\n            path = self._visibility_prune(path)\n            path = self._shortcut_smooth(path, min(10, self.smoothing_iters))\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Initialize trees and their spatial hashes\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n\n        self._grid_add(grid_start, counts_start, start_root)\n        self._grid_add(grid_goal, counts_goal, goal_root)\n\n        # Main planning loop\n        for it in range(self.max_iter):\n            a_is_start = (it % 2 == 0)\n            tree_a = start_tree if a_is_start else goal_tree\n            tree_b = goal_tree if a_is_start else start_tree\n            grid_a = grid_start if a_is_start else grid_goal\n            grid_b = grid_goal if a_is_start else grid_start\n            counts_a = counts_start if a_is_start else counts_goal\n            counts_b = counts_goal if a_is_start else counts_start\n            attractor = goal if a_is_start else start\n\n            # Sample target with goal bias\n            target = self._guided_sample(attractor)\n\n            # Greedy extend Tree A toward target (multi-step RRT-Connect style)\n            new_node = self._extend_greedy(tree_a, grid_a, counts_a, nodes, edges, target)\n            if new_node is None:\n                continue\n\n            # Attempt fast direct bridge to Tree B\n            other_near = self._nearest_hashed(grid_b, tree_b, new_node.position)\n            if other_near is not None and not self._edge_blocked(new_node.position, other_near.position):\n                path = self._extract_path(new_node, other_near, a_is_start)\n                path = self._visibility_prune(path)\n                path = self._shortcut_smooth(path, self.smoothing_iters)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Otherwise greedy-connect Tree B toward new_node\n            hit_node = self._connect_greedy(tree_b, grid_b, counts_b, nodes, edges, new_node.position)\n            if hit_node is not None:\n                # Final LOS check between the connection endpoints\n                if not self._edge_blocked(new_node.position, hit_node.position):\n                    path = self._extract_path(new_node, hit_node, a_is_start)\n                    path = self._visibility_prune(path)\n                    path = self._shortcut_smooth(path, self.smoothing_iters)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG utilities\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry helpers\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer_step(self, from_pos, to_pos):\n        d = self._dist(from_pos, to_pos)\n        if d <= 1e-9:\n            return self._clamp(from_pos)\n        if d <= self.step_size:\n            return self._clamp(to_pos)\n        r = self.step_size / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Obstacle spatial hash\n    def _obs_key(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self._obs_cell), int(pos[1] // self._obs_cell), int(pos[2] // self._obs_cell))\n        else:\n            return (int(pos[0] // self._obs_cell), int(pos[1] // self._obs_cell))\n\n    def _build_obs_grid(self, obstacles, is_3d):\n        self._obs_grid = {}\n        if is_3d:\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                x2, y2, z2 = x + w, y + h, z + d\n                ix0 = int(x // self._obs_cell)\n                iy0 = int(y // self._obs_cell)\n                iz0 = int(z // self._obs_cell)\n                ix1 = int(x2 // self._obs_cell)\n                iy1 = int(y2 // self._obs_cell)\n                iz1 = int(z2 // self._obs_cell)\n                for ix in range(ix0, ix1 + 1):\n                    for iy in range(iy0, iy1 + 1):\n                        for iz in range(iz0, iz1 + 1):\n                            key = (ix, iy, iz)\n                            bucket = self._obs_grid.get(key)\n                            if bucket is None:\n                                self._obs_grid[key] = [obs]\n                            else:\n                                bucket.append(obs)\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                x2, y2 = x + w, y + h\n                ix0 = int(x // self._obs_cell)\n                iy0 = int(y // self._obs_cell)\n                ix1 = int(x2 // self._obs_cell)\n                iy1 = int(y2 // self._obs_cell)\n                for ix in range(ix0, ix1 + 1):\n                    for iy in range(iy0, iy1 + 1):\n                        key = (ix, iy)\n                        bucket = self._obs_grid.get(key)\n                        if bucket is None:\n                            self._obs_grid[key] = [obs]\n                        else:\n                            bucket.append(obs)\n\n    def _is_in_obstacle(self, pos):\n        if self.is_3d:\n            px, py, pz = pos\n            key = self._obs_key(pos)\n            bucket = self._obs_grid.get(key)\n            if not bucket:\n                return False\n            for obs in bucket:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            key = self._obs_key(pos)\n            bucket = self._obs_grid.get(key)\n            if not bucket:\n                return False\n            for obs in bucket:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_hits(self, a, b):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p):\n                return True\n        return False\n\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked(self, a, b):\n        k = self._edge_key(a, b)\n        cached = self._edge_cache.get(k)\n        if cached is not None:\n            return cached\n        blocked = self._segment_hits(a, b)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    # Node spatial hash (for NN and duplicate suppression)\n    def _grid_key(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.nn_cell), int(pos[1] // self.nn_cell), int(pos[2] // self.nn_cell))\n        else:\n            return (int(pos[0] // self.nn_cell), int(pos[1] // self.nn_cell))\n\n    def _grid_add(self, grid, counts, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n\n    def _grid_ring_cells(self, key, r):\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        yield (key[0] + dx, key[1] + dy, key[2] + dz)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    yield (key[0] + dx, key[1] + dy)\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        seen = set()\n        total = 0\n        for r in range(0, self.ring_max + 1):\n            for cell in self._grid_ring_cells(key, r):\n                bucket = grid.get(cell)\n                if not bucket:\n                    continue\n                for n in bucket:\n                    if id(n) in seen:\n                        continue\n                    seen.add(id(n))\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                    total += 1\n            if total >= self.min_nn_candidates and best is not None:\n                break\n        if best is not None:\n            return best\n        # Fallback random subset if grid empty\n        if not tree:\n            return None\n        trials = min(48, len(tree))\n        for _ in range(trials):\n            idx = int(self._uniform(0, len(tree)))\n            n = tree[idx]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r = max(1, int(radius // self.nn_cell) + 1)\n        rr = radius\n        for rad in range(0, r + 1):\n            for cell in self._grid_ring_cells(key, rad):\n                bucket = grid.get(cell)\n                if not bucket:\n                    continue\n                for n in bucket:\n                    if self._dist(n.position, pos) <= rr:\n                        return True\n        return False\n\n    # Sampling\n    def _sample_free(self):\n        while True:\n            if self.is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p):\n                return p\n\n    def _guided_sample(self, attractor):\n        if self._rand() < self.goal_bias:\n            if not self._is_in_obstacle(attractor):\n                return attractor\n        # Blend toward attractor\n        alpha = 0.25\n        if self.is_3d:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]),\n                   self._uniform(0.0, self.bounds[2]))\n            p = tuple(alpha * attractor[i] + (1.0 - alpha) * rnd[i] for i in range(3))\n        else:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]))\n            p = tuple(alpha * attractor[i] + (1.0 - alpha) * rnd[i] for i in range(2))\n        if self._in_bounds(p) and not self._is_in_obstacle(p):\n            return p\n        return self._sample_free()\n\n    # Greedy extend for active tree (multi-step)\n    def _extend_greedy(self, tree, grid, counts, nodes_all, edges_all, target):\n        nearest = self._nearest_hashed(grid, tree, target)\n        if nearest is None:\n            return None\n        cur = nearest\n        last_added = None\n        for _ in range(self.connect_max_steps):\n            new_pos = self._steer_step(cur.position, target)\n            if not self._in_bounds(new_pos):\n                break\n            if self._is_in_obstacle(new_pos):\n                break\n            if self._edge_blocked(cur.position, new_pos):\n                break\n            # Per-cell capacity and near-duplicate suppression\n            key = self._grid_key(new_pos)\n            if counts.get(key, 0) >= self.max_per_cell:\n                # Try to step further without adding\n                if self._dist(new_pos, target) <= 1e-6:\n                    break\n                # advance origin for next attempt to same cur to see if farther step is viable\n                # but keep cur to avoid skipping collision guarantee; attempt another step\n                # however, to prevent infinite loops if target within step, break\n                cur_to_target = self._dist(cur.position, target)\n                if cur_to_target <= self.step_size + 1e-9:\n                    break\n                # Try to leap one more step ahead\n                leap_pos = self._steer_step(new_pos, target)\n                if not self._in_bounds(leap_pos) or self._is_in_obstacle(leap_pos) or self._edge_blocked(cur.position, leap_pos):\n                    break\n                new_pos = leap_pos  # accept leap if valid\n                key = self._grid_key(new_pos)\n                if counts.get(key, 0) >= self.max_per_cell:\n                    # still crowded; skip insertion this round\n                    if self._dist(new_pos, target) <= self.step_size:\n                        break\n                    continue\n            if self._near_duplicate(grid, new_pos, self.min_sep):\n                if self._dist(new_pos, target) <= self.step_size:\n                    break\n                # continue stepping without adding\n                cur_to_target = self._dist(cur.position, target)\n                if cur_to_target <= self.step_size + 1e-9:\n                    break\n                continue\n\n            # Insert node\n            new_cost = cur.cost + self._dist(cur.position, new_pos)\n            new_node = Node(new_pos, parent=cur, cost=new_cost)\n            cur.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_all.append((cur, new_node))\n            self._grid_add(grid, counts, new_node)\n            last_added = new_node\n            cur = new_node\n\n            # Stop if we got close enough to target\n            if self._dist(new_pos, target) <= self.step_size * 0.5:\n                break\n        return last_added\n\n    # Greedy connect from the opposite tree toward a target point; return last added if progressed\n    def _connect_greedy(self, tree, grid, counts, nodes_all, edges_all, target):\n        nearest = self._nearest_hashed(grid, tree, target)\n        if nearest is None:\n            return None\n        cur = nearest\n        last_added = None\n        for _ in range(self.connect_max_steps):\n            new_pos = self._steer_step(cur.position, target)\n            if not self._in_bounds(new_pos):\n                break\n            if self._is_in_obstacle(new_pos):\n                break\n            if self._edge_blocked(cur.position, new_pos):\n                break\n            key = self._grid_key(new_pos)\n            if counts.get(key, 0) >= self.max_per_cell:\n                cur_to_target = self._dist(cur.position, target)\n                if cur_to_target <= self.step_size + 1e-9:\n                    break\n                # attempt to continue without adding\n                continue\n            if self._near_duplicate(grid, new_pos, self.min_sep):\n                cur_to_target = self._dist(cur.position, target)\n                if cur_to_target <= self.step_size + 1e-9:\n                    break\n                continue\n            # Insert node\n            new_cost = cur.cost + self._dist(cur.position, new_pos)\n            new_node = Node(new_pos, parent=cur, cost=new_cost)\n            cur.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_all.append((cur, new_node))\n            self._grid_add(grid, counts, new_node)\n            last_added = new_node\n            cur = new_node\n\n            # If close enough to target, stop\n            if self._dist(new_pos, target) <= self.step_size * 0.5:\n                break\n        return last_added\n\n    # Path extraction and post-processing\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j]):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -37.29529,
          "time_improvement": 53.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 2507.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015715956687927246,
                    "num_nodes_avg": 50.0,
                    "path_length_avg": 159.74438521735743,
                    "smoothness_avg": 0.04853181796198822,
                    "success_improvement": 0.0,
                    "time_improvement": 36.29860773549004,
                    "node_improvement": 87.40871317048602,
                    "length_improvement": 12.441571150596545,
                    "smoothness_improvement": 659.628339634622,
                    "objective_score": 21.65266670917805
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07348463535308838,
                    "num_nodes_avg": 114.0,
                    "path_length_avg": 256.59359164084896,
                    "smoothness_avg": 0.19309266417859872,
                    "success_improvement": 0.0,
                    "time_improvement": 56.06341517653498,
                    "node_improvement": 92.34025398105221,
                    "length_improvement": 14.341673473257,
                    "smoothness_improvement": 4868.413328339737,
                    "objective_score": 49.76609527861338
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016176486015319826,
                    "num_nodes_avg": 81.0,
                    "path_length_avg": 125.19551263187705,
                    "smoothness_avg": 0.1646340240175897,
                    "success_improvement": 0.0,
                    "time_improvement": 67.95257957997248,
                    "node_improvement": 89.70120788302607,
                    "length_improvement": 16.851101679581618,
                    "smoothness_improvement": 1994.132633484155,
                    "objective_score": 40.467098049161486
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "ARC-Bridge*: Adaptive Rewire-and-Connect Informed BiRRT with cost-ordered cross bridging, grid-accelerated proximity, ancestor jump compression, and lightweight post-refinement. It fuses informed/corridor/goal sampling, variable-length LOS steering with strict validation, per-cell admission with best-cost memory, neighbor rewiring, and opportunistic cross-tree bridges to reduce time and path suboptimality while preserving robustness.",
          "planning_mechanism": "Mechanism: Grow two trees alternately. Each step: sample (informed/goal/corridor/uniform), find nearest via a node grid, steer with LOS jump or fixed step, validate node and edge, reject duplicates, and choose a best-cost parent among near neighbors. Insert, optionally jump to a farther visible ancestor, and rewire local neighbors cost-ordered. Then seek a cost-optimal visible bridge in the opposite tree; if none, greedily connect the other tree toward the new node. On a valid cross-bridge, assemble and refine the path (visibility prune, bounded shortcutting, elastic smoothing) for early return; otherwise maintain an incumbent for informed sampling and fallback.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        return pts[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=7000,\n        step=5.0,\n        long_step_factor=2.5,\n        goal_bias=0.15,\n        corridor_bias=0.30,\n        informed_bias=0.45,\n        node_grid_factor=1.5,\n        dup_factor=0.45,\n        cell_cap=12,\n        neighbor_radius_factor=3.5,\n        rewire_cap=24,\n        connect_cap=96,\n        shortcut_attempts=64,\n        smooth_passes=4\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step)\n        self.long_step = float(step * long_step_factor)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.node_grid_factor = float(node_grid_factor)\n        self.dup_factor = float(dup_factor)\n        self.cell_cap = int(cell_cap)\n        self.neighbor_radius_factor = float(neighbor_radius_factor)\n        self.rewire_cap = int(rewire_cap)\n        self.connect_cap = int(connect_cap)\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.smooth_passes = int(max(0, smooth_passes))\n        self._rng = 1234567\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if getattr(map, \"obstacles\", None) else []\n\n        nodes = []\n        edges = []\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self._build_obstacle_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            s = Node(self.start, None, 0.0)\n            g = Node(self.goal, s, self._dist(self.start, self.goal))\n            s.add_child(g)\n            nodes.extend([s, g])\n            edges.append((s, g))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        sg = self._dist(self.start, self.goal)\n        self.node_cell = max(1.0, self.step * self.node_grid_factor)\n        self.dup_radius = max(0.3, self.step * self.dup_factor)\n        self.corridor_w = max(self.step, 0.25 * sg)\n\n        ra = Node(self.start, None, 0.0)\n        rb = Node(self.goal, None, 0.0)\n        Ta, Tb = [ra], [rb]\n        Ga, Gb = {}, {}\n        Ca, Cb = {}, {}\n        Ba, Bb = {}, {}\n        self._grid_add(Ga, Ca, Ba, ra)\n        self._grid_add(Gb, Cb, Bb, rb)\n        nodes.extend([ra, rb])\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            grow_a = (it & 1) == 0\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            C = Ca if grow_a else Cb\n            B = Ba if grow_a else Bb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            Copp = Cb if grow_a else Ca\n            Bopp = Bb if grow_a else Ba\n            attractor = self.goal if grow_a else self.start\n\n            target = self._sample_target(attractor, best_len)\n            if target is None:\n                continue\n\n            base = self._nearest(G, target, T)\n            if base is None:\n                continue\n\n            newp = self._steer(base.position, target)\n            if not self._valid_new_edge(base.position, newp):\n                continue\n\n            if self._has_duplicate(G, newp, self.dup_radius):\n                # Try opportunistic incumbent update via visible nearest in other tree\n                other = self._nearest(Gopp, newp, Topp)\n                if other is not None and self._edge_free(newp, other.position):\n                    cand = self._assemble_temp(newp, base, other, grow_a)\n                    L = self._path_len(cand)\n                    if L < best_len:\n                        best_len = L\n                        best_path = cand\n                continue\n\n            radius = self._neighbor_radius(len(T))\n            parent = self._choose_parent(G, newp, base, radius)\n            if parent is None:\n                continue\n            # Both checks before adding edge\n            if not self._valid_new_edge(parent.position, newp):\n                continue\n\n            new_cost = parent.cost + self._dist(parent.position, newp)\n            k = self._cell_key(newp)\n            cc = C.get(k, 0)\n            bc = B.get(k, float('inf'))\n            if cc >= self.cell_cap and not (new_cost + 1e-9 < bc):\n                # Update incumbent if the opposite tree can see this point\n                other = self._nearest(Gopp, newp, Topp)\n                if other is not None and self._edge_free(newp, other.position):\n                    cand = self._assemble_temp(newp, parent, other, grow_a)\n                    L = self._path_len(cand)\n                    if L < best_len:\n                        best_len = L\n                        best_path = cand\n                continue\n\n            q = Node(newp, parent, new_cost)\n            parent.add_child(q)\n            T.append(q)\n            nodes.append(q)\n            edges.append((parent, q))\n            self._grid_add(G, C, B, q)\n\n            self._jump_to_visible_ancestor(q, edges, 4)\n\n            self._rewire_local(G, q, self._neighbor_radius(len(T)), edges)\n\n            bridge = self._best_visible_bridge(Gopp, q)\n            if bridge is not None:\n                raw = self._assemble(q, bridge, grow_a)\n                L = self._path_len(raw)\n                if L < best_len:\n                    best_len = L\n                    best_path = raw\n                path = self._refine(raw)\n                return PlannerResult(True, path, Ta + Tb, edges)\n\n            meet = self._greedy_connect(Topp, Gopp, q.position)\n            if meet is not None and self._edge_free(q.position, meet.position):\n                raw = self._assemble(q, meet, grow_a)\n                L = self._path_len(raw)\n                if L < best_len:\n                    best_len = L\n                    best_path = raw\n                path = self._refine(raw)\n                return PlannerResult(True, path, Ta + Tb, edges)\n\n            # Opportunistic incumbent update\n            other = self._nearest(Gopp, q.position, Topp)\n            if other is not None and self._edge_free(q.position, other.position):\n                cand = self._assemble(q, other, grow_a)\n                L = self._path_len(cand)\n                if L < best_len:\n                    best_len = L\n                    best_path = cand\n\n        if best_path is not None and best_len < float('inf'):\n            path = self._refine(best_path)\n            return PlannerResult(True, path, Ta + Tb, edges)\n\n        return PlannerResult(False, [], Ta + Tb, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0xA5A5A5A5\n        for v in self.start + self.goal:\n            s ^= (int((v + 0.5) * 10007) + 137) & 0xffffffff\n            s = (s * 1103515245 + 12345) & 0xffffffff\n        s ^= ((len(self.obstacles) + 23) * 2654435761) & 0xffffffff\n        self._rng = s if s != 0 else 1\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry and helpers\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if self._edge_free(a, b):\n            if d <= self.long_step:\n                return self._clamp(b)\n            r = self.long_step / d\n            return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n        # fallback fixed step\n        if d <= self.step:\n            return self._clamp(b)\n        r = self.step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _neighbor_radius(self, ncount):\n        r_min = 1.25 * self.step\n        r_max = self.neighbor_radius_factor * self.step\n        t = ncount / (ncount + 250.0)\n        return r_max * (1.0 - t) + r_min * t\n\n    # Node grid\n    def _cell_key(self, p):\n        return tuple(int(p[i] // self.node_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, bestcost, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n        if counts is not None:\n            counts[k] = counts.get(k, 0) + 1\n        if bestcost is not None:\n            bc = bestcost.get(k)\n            if bc is None or node.cost < bc:\n                bestcost[k] = node.cost\n\n    def _grid_query_radius(self, grid, pos, radius, cap):\n        key = self._cell_key(pos)\n        span = int(radius // self.node_cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.dim == 3:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n                                if len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n                            if len(out) >= cap:\n                                return out\n        return out\n\n    def _nearest(self, grid, pos, tree):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        r = 0\n        found = False\n        while r <= 4:\n            if self.dim == 3:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                            if not lst:\n                                continue\n                            for n in lst:\n                                d2 = self._dist2(n.position, pos)\n                                if d2 < bestd:\n                                    bestd = d2\n                                    best = n\n                                    found = True\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            d2 = self._dist2(n.position, pos)\n                            if d2 < bestd:\n                                bestd = d2\n                                best = n\n                                found = True\n            if found:\n                return best\n            r += 1\n        # fallback exact scan if grid ring empty\n        best = None\n        bestd = 1e100\n        for n in tree:\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        return best\n\n    def _has_duplicate(self, grid, pos, radius):\n        res = self._grid_query_radius(grid, pos, radius, 1)\n        return len(res) > 0\n\n    # Obstacles and collision\n    def _build_obstacle_bins(self):\n        self.obs_cell = max(4.0, self.step * 2.0)\n        self.obin = {}\n        if self.dim == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            self._obin_add((i, j, k), idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        self._obin_add((i, j), idx)\n\n    def _obin_add(self, key, idx):\n        lst = self.obin.get(key)\n        if lst is None:\n            self.obin[key] = [idx]\n        else:\n            lst.append(idx)\n\n    def _bucket_candidates(self, a, b):\n        if self.dim == 3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self.obin.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            return cand\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self.obin.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            return cand\n\n    def _point_blocked(self, p):\n        if self.dim == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            lst = self.obin.get((ix, iy, iz))\n            if not lst:\n                return False\n            x, y, z = p\n            for idx in lst:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            lst = self.obin.get((ix, iy))\n            if not lst:\n                return False\n            x, y = p\n            for idx in lst:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    def _edge_free(self, a, b):\n        cand = self._bucket_candidates(a, b)\n        if not cand:\n            return True\n        if self.dim == 3:\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    def _valid_new_edge(self, a, b):\n        if not self._in_bounds(b):\n            return False\n        if self._point_blocked(b):\n            return False\n        if not self._edge_free(a, b):\n            return False\n        return True\n\n    # Parent choice, compression, rewiring\n    def _choose_parent(self, grid, new_pos, fallback, radius):\n        cand = self._grid_query_radius(grid, new_pos, radius, 96)\n        if fallback not in cand:\n            cand.append(fallback)\n        best = None\n        bestc = 1e100\n        for n in cand:\n            if not self._edge_free(n.position, new_pos):\n                continue\n            c = n.cost + self._dist(n.position, new_pos)\n            if c < bestc:\n                bestc = c\n                best = n\n        return best\n\n    def _jump_to_visible_ancestor(self, node, edges, max_hops):\n        hops = 0\n        cur = node\n        while hops < max_hops and cur.parent is not None and cur.parent.parent is not None:\n            anc = cur.parent.parent\n            if self._edge_free(anc.position, cur.position):\n                newc = anc.cost + self._dist(anc.position, cur.position)\n                if newc + 1e-9 < cur.cost:\n                    self._reparent(cur, anc, edges)\n                    hops += 1\n                    continue\n            break\n\n    def _rewire_local(self, grid, pivot, radius, edges):\n        neigh = self._grid_query_radius(grid, pivot.position, radius, 120)\n        order = []\n        for nb in neigh:\n            if nb is pivot:\n                continue\n            tc = pivot.cost + self._dist(pivot.position, nb.position)\n            order.append((tc, nb))\n        order.sort(key=lambda x: x[0])\n        changes = 0\n        for tc, nb in order:\n            if nb is pivot or nb.parent is pivot:\n                continue\n            if self._is_ancestor(nb, pivot):\n                continue\n            if not self._edge_free(pivot.position, nb.position):\n                continue\n            newc = pivot.cost + self._dist(pivot.position, nb.position)\n            if newc + 1e-9 < nb.cost:\n                self._reparent(nb, pivot, edges)\n                changes += 1\n                if changes >= self.rewire_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        old = child.parent\n        if old is new_parent:\n            return\n        if old is not None:\n            old.remove_child(child)\n            self._remove_edge(edges, old, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        stack = [child]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if abs(newc - ch.cost) > 1e-12:\n                    ch.cost = newc\n                    stack.append(ch)\n\n    def _remove_edge(self, edges, parent, child):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is parent and e[1] is child:\n                edges.pop(i)\n                return\n\n    # Cross-bridging and connect\n    def _best_visible_bridge(self, other_grid, node):\n        radius = 1.75 * self._neighbor_radius(1) + 0.5 * self._neighbor_radius(1 + 1000)\n        radius = max(radius, 2.0 * self.step)\n        neigh = self._grid_query_radius(other_grid, node.position, radius, 128)\n        best = None\n        best_total = 1e100\n        for nb in neigh:\n            if not self._edge_free(node.position, nb.position):\n                continue\n            total = node.cost + self._dist(node.position, nb.position) + nb.cost\n            if total < best_total:\n                best_total = total\n                best = nb\n        return best\n\n    def _greedy_connect(self, tree, grid, target_point):\n        base = self._nearest(grid, target_point, tree)\n        if base is None:\n            return None\n        last = None\n        cap = self.connect_cap\n        while cap > 0:\n            cap -= 1\n            d = self._dist(base.position, target_point)\n            if d <= self.step:\n                nxtp = target_point\n            else:\n                r = self.step / d\n                nxtp = tuple(base.position[i] + (target_point[i] - base.position[i]) * r for i in range(self.dim))\n            nxtp = self._clamp(nxtp)\n            if not self._valid_new_edge(base.position, nxtp):\n                break\n            if self._has_duplicate(grid, nxtp, self.dup_radius):\n                break\n            nn = Node(nxtp, base, base.cost + self._dist(base.position, nxtp))\n            base.add_child(nn)\n            tree.append(nn)\n            self._grid_add(grid, None, None, nn)\n            last = nn\n            base = nn\n            if nxtp == target_point:\n                return nn\n        return last\n\n    # Sampling\n    def _sample_target(self, attractor, best_len):\n        tries = 24\n        while tries > 0:\n            tries -= 1\n            r = self._rand()\n            p = None\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._sample_informed(best_len * 1.02)\n            if p is None:\n                r2 = self._rand()\n                if r2 < self.goal_bias:\n                    p = attractor\n                elif r2 < self.goal_bias + self.corridor_bias:\n                    t = self._rand()\n                    base = self._lerp(self.start, self.goal, t)\n                    if self.dim == 3:\n                        p = (self._rand_range(base[0] - self.corridor_w, base[0] + self.corridor_w),\n                             self._rand_range(base[1] - self.corridor_w, base[1] + self.corridor_w),\n                             self._rand_range(base[2] - self.corridor_w, base[2] + self.corridor_w))\n                    else:\n                        p = (self._rand_range(base[0] - self.corridor_w, base[0] + self.corridor_w),\n                             self._rand_range(base[1] - self.corridor_w, base[1] + self.corridor_w))\n                else:\n                    if self.dim == 3:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]),\n                             self._rand_range(0.0, self.bounds[2]))\n                    else:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]))\n            if p is None:\n                continue\n            p = self._clamp(p)\n            if not self._point_blocked(p):\n                return p\n        return None\n\n    def _sample_informed(self, max_sum):\n        c = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        for _ in range(28):\n            if self.dim == 3:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half),\n                     self._rand_range(c[2] - half, c[2] + half))\n            else:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half))\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= max_sum + 1e-9:\n                return p\n        return None\n\n    # Path assembly and refinement\n    def _trace(self, node):\n        return node.path_to_root()\n\n    def _assemble(self, u, v, u_from_start):\n        pu = self._trace(u)\n        pv = self._trace(v)\n        if u_from_start:\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _assemble_temp(self, newp, base_in_tree, other_node, u_from_start):\n        # Assemble a temporary path using a hypothetical point newp attached to base_in_tree\n        pu = base_in_tree.path_to_root() + [newp]\n        pv = self._trace(other_node)\n        if u_from_start:\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _vis_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        anchor = 0\n        n = len(pts)\n        while anchor < n - 1:\n            j = n - 1\n            hopped = False\n            while j > anchor + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    anchor = j\n                    hopped = True\n                    break\n                j -= 1\n            if not hopped:\n                out.append(pts[anchor + 1])\n                anchor += 1\n        out[0] = pts[0]\n        out[-1] = pts[-1]\n        return out\n\n    def _shortcuts(self, pts, attempts):\n        if len(pts) < 3 or attempts <= 0:\n            return pts[:]\n        cur = list(pts)\n        best = self._path_len(cur)\n        stall = 0\n        for _ in range(attempts):\n            if len(cur) < 3:\n                break\n            i = int(self._rand_range(0, len(cur) - 2))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                continue\n            a, b = cur[i], cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    cur = cand\n                    best = L\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            if stall > 64:\n                break\n        return cur\n\n    def _elastic_smooth(self, pts, passes):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = list(pts)\n        base_len = self._path_len(cur)\n        for _ in range(passes):\n            improved = False\n            for k in range(1, len(cur) - 1):\n                a = cur[k - 1]\n                c = cur[k + 1]\n                mid = tuple(0.5 * (a[i] + c[i]) for i in range(self.dim))\n                if self._point_blocked(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    old = cur[k]\n                    cand = cur[:]\n                    cand[k] = mid\n                    L = self._path_len(cand)\n                    if L <= base_len + 1e-9:\n                        cur = cand\n                        base_len = L\n                        improved = True\n                    else:\n                        newp = tuple(0.25 * a[i] + 0.5 * old[i] + 0.25 * c[i] for i in range(self.dim))\n                        if (not self._point_blocked(newp)) and self._edge_free(a, newp) and self._edge_free(newp, c):\n                            cand2 = cur[:]\n                            cand2[k] = newp\n                            L2 = self._path_len(cand2)\n                            if L2 <= base_len + 1e-9:\n                                cur = cand2\n                                base_len = L2\n                                improved = True\n            if not improved:\n                break\n        cur[0] = pts[0]\n        cur[-1] = pts[-1]\n        return cur\n\n    def _refine(self, path):\n        if len(path) < 2:\n            return path[:]\n        p0 = self._vis_prune(path)\n        p1 = self._shortcuts(p0, self.shortcut_attempts)\n        p2 = self._elastic_smooth(p1, self.smooth_passes)\n        return p2",
          "objective": -37.21824,
          "time_improvement": 70.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1613.0,
          "node_improvement": 91.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010649538040161133,
                    "num_nodes_avg": 45.0,
                    "path_length_avg": 172.9719263171981,
                    "smoothness_avg": 0.04128092602812851,
                    "success_improvement": 0.0,
                    "time_improvement": 56.975366554226525,
                    "node_improvement": 88.66784185343742,
                    "length_improvement": 5.1913462699719854,
                    "smoothness_improvement": 546.1361353058666,
                    "objective_score": 22.93809840478048
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02203972339630127,
                    "num_nodes_avg": 80.0,
                    "path_length_avg": 238.353808351295,
                    "smoothness_avg": 0.12042250126598031,
                    "success_improvement": 0.0,
                    "time_improvement": 86.59603535905705,
                    "node_improvement": 94.6247396358261,
                    "length_improvement": 20.430638138362518,
                    "smoothness_improvement": 2998.5576943954065,
                    "objective_score": 53.22998196271166
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01762080192565918,
                    "num_nodes_avg": 77.0,
                    "path_length_avg": 127.03166360883196,
                    "smoothness_avg": 0.10967660825903078,
                    "success_improvement": 0.0,
                    "time_improvement": 65.4409093183339,
                    "node_improvement": 90.20979020979021,
                    "length_improvement": 15.63161762880193,
                    "smoothness_improvement": 1295.0783615697515,
                    "objective_score": 35.48663518063008
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "FLASH-Bridge BiRRT-Lite: An efficiency-first bidirectional planner that uses hash-grid approximate nearest neighbors without global scans, single-pass best-parent selection, and direct bridging with bounded micro-extensions. It returns early on the first valid connection and applies minimal, constraint-aware smoothing to keep planning time low while producing short, smooth paths.",
          "planning_mechanism": "Mechanism: Grow two trees from start and goal. For each informed/biased random sample, pick the nearest by grid-ring search, steer one step, and select the lowest-cost visible parent from a small local set. Insert only after passing both node and edge collision checks. Immediately attempt to bridge to the opposite tree via direct line-of-sight to its nearest node; otherwise make a few safe steps toward the target. On success, trace and stitch paths, run fast visibility pruning plus limited shortcutting and light relaxation, and return. No global rewiring and no all-node scans.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=6.0,\n                 goal_bias=0.2,\n                 connect_steps=10,\n                 neighbor_radius_factor=2.0,\n                 neighbor_cap=8,\n                 dup_radius_factor=0.4,\n                 shortcut_attempts=40,\n                 relax_passes=4):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.connect_steps = int(max(1, connect_steps))\n        self.nei_fac = float(neighbor_radius_factor)\n        self.nb_cap = int(max(2, neighbor_cap))\n        self.dup_fac = float(dup_radius_factor)\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.relax_passes = int(max(0, relax_passes))\n        self._rng = 1\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", [])) if getattr(map, \"obstacles\", None) is not None else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed()\n        self._build_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        diag = 0.0\n        for i in range(self.dim):\n            diag += (self.goal[i] - self.start[i]) * (self.goal[i] - self.start[i])\n        diag = diag ** 0.5\n        if self.step <= 0.0:\n            self.step = max(2.0, 0.02 * sum(self.bounds) / max(1, self.dim))\n        self.grid_cell = max(1.0, 0.9 * self.step)\n        self.dupe_radius = max(0.25 * self.step, self.dup_fac * self.step)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        GA, GB = {}, {}\n        Ta, Tb = [], []\n        ra = Node(self.start, None, 0.0)\n        rb = Node(self.goal, None, 0.0)\n        Ta.append(ra)\n        Tb.append(rb)\n        nodes.extend([ra, rb])\n        self._grid_add(GA, ra)\n        self._grid_add(GB, rb)\n\n        best_len = None\n\n        lastA, lastB = ra, rb\n\n        for it in range(self.max_iter):\n            growA = (len(Ta) <= len(Tb))\n            T = Ta if growA else Tb\n            O = Tb if growA else Ta\n            G = GA if growA else GB\n            GO = GB if growA else GA\n            attract = self.goal if growA else self.start\n            fallback = lastA if growA else lastB\n\n            qrand = self._sample(attractor=attract, c_best=best_len)\n            if qrand is None:\n                continue\n\n            qnear = self._nearest(G, qrand)\n            if qnear is None:\n                qnear = fallback\n\n            qnew_pos = self._steer(qnear.position, qrand, self.step)\n            if (not self._in_bounds(qnew_pos)) or self._point_blocked(qnew_pos):\n                continue\n            if self._exists_close(G, qnew_pos, self.dupe_radius):\n                continue\n\n            parent, bestc = self._choose_parent(G, qnew_pos, qnear)\n            if parent is None:\n                continue\n            if self._point_blocked(qnew_pos):\n                continue\n            if not self._edge_free(parent.position, qnew_pos):\n                continue\n\n            nn = Node(qnew_pos, parent, bestc)\n            nodes.append(nn)\n            T.append(nn)\n            self._grid_add(G, nn)\n            edges.append((parent, nn))\n            if growA:\n                lastA = nn\n            else:\n                lastB = nn\n\n            meet, bridged = self._bridge(O, GO, nn, nodes, edges)\n            if bridged:\n                pa = self._trace(nn)\n                pb = self._trace(meet)\n                if growA:\n                    full = pa + pb[-2::-1]\n                else:\n                    full = pb + pa[-2::-1]\n                full = self._dedup(full)\n                L = self._path_len(full)\n                if best_len is None or L < best_len - 1e-9:\n                    best_len = L\n                path = self._finalize(full)\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _seed(self):\n        s = 0xC0FFEE\n        vals = list(self.start) + list(self.goal) + [len(self.obstacles), sum(int(b) for b in self.bounds)]\n        for v in vals:\n            s ^= (int(v * 2654435761) + (s << 6) + (s >> 2)) & 0xffffffff\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            t = b\n        else:\n            d = d2 ** 0.5\n            r = step / d\n            t = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n        return tuple(min(max(t[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _gkey(self, p):\n        if self.is3:\n            return (int(p[0] // self.grid_cell), int(p[1] // self.grid_cell), int(p[2] // self.grid_cell))\n        else:\n            return (int(p[0] // self.grid_cell), int(p[1] // self.grid_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._gkey(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        kk = self._gkey(pos)\n        best = None\n        bd = 1e100\n        for r in range(0, 3):\n            cand = self._collect_ring(grid, kk, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bd:\n                    bd = d2\n                    best = n\n            if best is not None:\n                return best\n        # no global scan; caller will fallback to a recent node\n        return None\n\n    def _neighbors(self, grid, pos, radius, cap):\n        kk = self._gkey(pos)\n        rc = int(max(1, radius // self.grid_cell))\n        r2 = radius * radius\n        out = []\n        cand = self._collect_ring(grid, kk, rc)\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        if not out and cand:\n            # pick closest few from cand if within same ring but radius missed\n            cand2 = sorted(cand, key=lambda n: self._dist2(n.position, pos))[:cap]\n            out.extend(cand2)\n        return out\n\n    def _exists_close(self, grid, pos, radius):\n        kk = self._gkey(pos)\n        rc = int(max(1, radius // self.grid_cell))\n        cand = self._collect_ring(grid, kk, rc)\n        r2 = radius * radius\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                return True\n        return False\n\n    def _build_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self._obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self._obin.get(key)\n                            if lst is None:\n                                self._obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self._obin.get(key)\n                        if lst is None:\n                            self._obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_bucket(self, p):\n        if self.is3:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell),\n                                   int(p[2] // self.obs_cell)))\n        else:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell)))\n\n    def _point_blocked(self, p):\n        bucket = self._point_bucket(p)\n        if not bucket:\n            return False\n        if self.is3:\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        if self.is3:\n            mn = (a[0] if a[0] < b[0] else b[0],\n                  a[1] if a[1] < b[1] else b[1],\n                  a[2] if a[2] < b[2] else b[2])\n            mx = (a[0] if a[0] > b[0] else b[0],\n                  a[1] if a[1] > b[1] else b[1],\n                  a[2] if a[2] > b[2] else b[2])\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            iz0 = int(max(0.0, mn[2]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mx[2]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self._obin.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            if not cand:\n                return True\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            mn = (a[0] if a[0] < b[0] else b[0],\n                  a[1] if a[1] < b[1] else b[1])\n            mx = (a[0] if a[0] > b[0] else b[0],\n                  a[1] if a[1] > b[1] else b[1])\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self._obin.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            if not cand:\n                return True\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    def _choose_parent(self, grid, new_pos, fallback):\n        rad = max(self.step * self.nei_fac, self.step * 1.25)\n        cand = self._neighbors(grid, new_pos, rad, cap=self.nb_cap)\n        if fallback not in cand:\n            cand.append(fallback)\n        best = None\n        best_cost = 1e100\n        for p in cand:\n            if not self._edge_free(p.position, new_pos):\n                continue\n            c = p.cost + self._dist(p.position, new_pos)\n            if c < best_cost:\n                best_cost = c\n                best = p\n        if best is None:\n            return None, None\n        return best, best_cost\n\n    def _bridge(self, tree, grid, new_node, nodes, edges):\n        target = new_node.position\n        near = self._nearest(grid, target)\n        if near is None:\n            near = tree[-1]\n        if self._edge_free(near.position, target):\n            edges.append((near, new_node))\n            return near, True\n        cur = near\n        steps = 0\n        while steps < self.connect_steps:\n            nxt_pos = self._steer(cur.position, target, self.step * 1.5)\n            if (not self._in_bounds(nxt_pos)) or self._point_blocked(nxt_pos):\n                break\n            if self._exists_close(grid, nxt_pos, self.dupe_radius * 0.75):\n                break\n            if not self._edge_free(cur.position, nxt_pos):\n                break\n            new_cost = cur.cost + self._dist(cur.position, nxt_pos)\n            nn = Node(nxt_pos, cur, new_cost)\n            if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                break\n            nodes.append(nn)\n            tree.append(nn)\n            self._grid_add(grid, nn)\n            edges.append((cur, nn))\n            cur = nn\n            if self._edge_free(cur.position, target):\n                edges.append((cur, new_node))\n                return cur, True\n            steps += 1\n        return cur, False\n\n    def _sample(self, attractor, c_best):\n        r = self._rand()\n        if c_best is not None and r < 0.6:\n            p = self._sample_informed(c_best * 1.01)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            if (not self._point_blocked(attractor)) and self._in_bounds(attractor):\n                return attractor\n        tries = 16\n        while tries > 0:\n            tries -= 1\n            if self.is3:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n            else:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        return None\n\n    def _sample_informed(self, max_sum):\n        c = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half) for _ in range(self.dim)]\n        tries = 24\n        while tries > 0:\n            tries -= 1\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= max_sum + 1e-9:\n                return p\n        return None\n\n    def _trace(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        if len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = i + 1\n            far = j\n            while j < n and self._edge_free(out[-1], pts[j]):\n                far = j\n                j += 1\n            out.append(pts[far])\n            i = far\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            n = len(cur)\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            a, b = cur[i], cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L <= bestL + 1e-12:\n                    cur = cand\n                    bestL = L\n            tries += 1\n        return cur\n\n    def _relax(self, pts, passes):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        alpha = 0.5\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                c = cur[i + 1]\n                t = tuple((1.0 - alpha) * cur[i][k] + alpha * 0.5 * (a[k] + c[k]) for k in range(self.dim))\n                if (not self._in_bounds(t)) or self._point_blocked(t):\n                    continue\n                if self._edge_free(a, t) and self._edge_free(t, c):\n                    if t != cur[i]:\n                        cur[i] = t\n                        moved = True\n            if not moved:\n                break\n        return cur\n\n    def _finalize(self, path):\n        p = self._prune(path)\n        p = self._shortcut(p, self.shortcut_attempts)\n        p = self._relax(p, self.relax_passes)\n        p = self._prune(p)\n        return self._dedup(p)",
          "objective": -37.20947,
          "time_improvement": 73.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1368.0,
          "node_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.005640697479248047,
                    "num_nodes_avg": 61.0,
                    "path_length_avg": 171.97142853307741,
                    "smoothness_avg": 0.04638849463441365,
                    "success_improvement": 0.0,
                    "time_improvement": 77.21131747612652,
                    "node_improvement": 84.63863006799295,
                    "length_improvement": 5.739734959350459,
                    "smoothness_improvement": 626.0806752569794,
                    "objective_score": 29.73763959473313
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01880669593811035,
                    "num_nodes_avg": 243.0,
                    "path_length_avg": 235.9053856958496,
                    "smoothness_avg": 0.08848357754673088,
                    "success_improvement": 0.0,
                    "time_improvement": 88.56227535914985,
                    "node_improvement": 83.6726466438218,
                    "length_improvement": 21.247992094688797,
                    "smoothness_improvement": 2176.7461824222196,
                    "objective_score": 50.201208776669326
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0242264986038208,
                    "num_nodes_avg": 239.0,
                    "path_length_avg": 126.88165706959765,
                    "smoothness_avg": 0.11014543996879947,
                    "success_improvement": 0.0,
                    "time_improvement": 52.485376903901624,
                    "node_improvement": 69.61220597584233,
                    "length_improvement": 15.73124482961756,
                    "smoothness_improvement": 1301.0418663124522,
                    "objective_score": 31.689569300503287
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "AERO-Connect-R*: Adaptive Elliptic Rewired Connect BiRRT with Hash-Grids. It couples bidirectional RRT-Connect growth (greedy multi-step connect) with lightweight RRT* local optimization (best-parent selection and bounded rewiring), uses adaptive informed sampling (goal/corridor \u2192 ellipse after first incumbent), and fast slab-based collision via obstacle bins. A two-stage path refiner (visibility + shortcut + corner-round) improves length and smoothness at negligible cost.",
          "planning_mechanism": "Mechanism: Alternate expanding start/goal trees. Each iteration: draw a guided sample (goal/corridor/uniform; switch to ellipse once a path is known), pick an anchor via multi-ring hash-grid nearest, steer one step, validate node/edge, choose cheapest parent among nearby anchors, insert and locally rewire. Then greedily connect the opposite tree toward the new node with multiple validated steps; on meeting, extract the path and run refinements, then return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.25,\n                 corridor_bias=0.35,\n                 ellipse_bias=0.55,\n                 grid_cell_factor=1.7,\n                 neighbor_radius_factor=2.4,\n                 min_sep_ratio=0.4,\n                 k_parent=6,\n                 k_rewire=6,\n                 connect_mult=1.8,\n                 smoothing_attempts=120):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.ellipse_bias = float(ellipse_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neigh_factor = float(neighbor_radius_factor)\n        self.min_sep_ratio = float(min_sep_ratio)\n        self.k_parent = int(max(1, k_parent))\n        self.k_rewire = int(max(0, k_rewire))\n        self.connect_mult = float(connect_mult)\n        self.smoothing_attempts = int(max(0, smoothing_attempts))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self._is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Spatial parameters\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.neigh_radius = max(self.step * 1.2, self.step * self.neigh_factor)\n        self.min_sep = max(0.5, self.step * self.min_sep_ratio)\n        self.connect_step = max(self.step, self.step * self.connect_mult)\n\n        # Initialize RNG seed\n        self._seed()\n\n        # Build obstacle bins before any collision checks\n        self._build_obs_bins()\n\n        # Validate start/goal\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Trivial straight-line solution\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._smooth_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize two trees and their grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = self.goal if active_start else self.start\n\n            # Guided sampling with informed ellipse once best path exists\n            sp = self._guided_sample(root_other, best_len)\n            if sp is None:\n                continue\n\n            # Nearest anchor in active tree\n            anchor = self._nearest_grid(grid_a, sp)\n            if anchor is None:\n                anchor = tree_a[-1]\n\n            # Steer one step toward sample\n            newp = self._steer(anchor.position, sp, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(grid_a, newp, self.min_sep):\n                continue\n            if not self._edge_free(anchor.position, newp):\n                continue\n\n            # Best-parent selection (local RRT*)\n            neigh = self._neighbors(grid_a, newp, self.neigh_radius)\n            if not neigh:\n                neigh = [anchor]\n            # Sort few closest anchors\n            neigh = sorted(neigh, key=lambda n: self._dist2(n.position, newp))[:self.k_parent]\n            parent = anchor\n            bestc = anchor.cost + self._dist(anchor.position, newp)\n            for nb in neigh:\n                gc = nb.cost + self._dist(nb.position, newp)\n                if gc + 1e-12 < bestc and self._edge_free(nb.position, newp):\n                    parent = nb\n                    bestc = gc\n\n            # Final checks before adding node/edge\n            if self._point_in_obstacles(newp) or (not self._edge_free(parent.position, newp)):\n                continue\n\n            nn = Node(newp, parent, bestc)\n            parent.add_child(nn)\n            tree_a.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(grid_a, nn)\n\n            # Bounded local rewiring\n            if self.k_rewire > 0:\n                self._rewire_lite(nn, grid_a, edges)\n\n            # Greedy multi-step connect from the opposite tree toward nn\n            other_near = self._nearest_grid(grid_b, nn.position)\n            meet_b = other_near\n            connected = False\n            cur = other_near\n            if cur is not None:\n                while True:\n                    # If we are close and direct edge is free, consider connected\n                    if self._dist(cur.position, nn.position) <= self.connect_step and self._edge_free(cur.position, nn.position):\n                        connected = True\n                        meet_b = cur\n                        break\n                    # Otherwise extend the other tree by a connect step\n                    nxtp = self._steer(cur.position, nn.position, self.connect_step)\n                    if (not self._in_bounds(nxtp)) or self._point_in_obstacles(nxtp):\n                        break\n                    if not self._edge_free(cur.position, nxtp):\n                        break\n                    # Add the node to the opposite tree (both checks already passed)\n                    cn = Node(nxtp, cur, cur.cost + self._dist(cur.position, nxtp))\n                    cur.add_child(cn)\n                    tree_b.append(cn)\n                    nodes.append(cn)\n                    edges.append((cur, cn))\n                    self._grid_add(grid_b, cn)\n                    cur = cn\n                    meet_b = cur\n                    # Loop continues until blocked or within direct reach\n\n            if connected:\n                # Extract full path (do not insert a cross-edge to preserve tree structures)\n                path = self._extract_path(nn, meet_b)\n                L = self._path_len(path)\n                if best_len is None or L + 1e-9 < best_len:\n                    best_len = L\n                path = self._smooth_path(path)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- RNG ----------\n    def _seed(self):\n        s = 0x9E3779B97F4A7C15 & 0xffffffff\n        for v in self.start + self.goal:\n            zv = int(v * 1315423911) & 0xffffffff\n            s ^= ((zv ^ (zv << 13) ^ (zv >> 17)) & 0xffffffff)\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # ---------- Spatial hash for nodes ----------\n    def _cell_key(self, p):\n        if self._is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self._is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            cand.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        cand.extend(lst)\n        return cand\n\n    def _nearest_grid(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback scan\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self._is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors(grid, pos, radius)) > 0\n\n    # ---------- Obstacles: binning and collision ----------\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self._is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obin.get(key)\n                            if b is None:\n                                self.obin[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obin.get(key)\n                        if b is None:\n                            self.obin[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self._is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self._is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # ---------- Rewiring ----------\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _erase_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                del edges[i]\n                break\n\n    def _propagate_cost(self, node, delta):\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    def _rewire_lite(self, new_node, grid, edges):\n        neigh = self._neighbors(grid, new_node.position, self.neigh_radius)\n        if not neigh:\n            return\n        neigh = sorted(neigh, key=lambda n: self._dist2(n.position, new_node.position))[:self.k_rewire]\n        for nb in neigh:\n            if nb is new_node or nb is new_node.parent:\n                continue\n            if self._is_ancestor(nb, new_node):\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            cand = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand + 1e-9 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._erase_edge(edges, oldp, nb)\n                new_node.add_child(nb)\n                edges.append((new_node, nb))\n                delta = cand - nb.cost\n                nb.cost = cand\n                self._propagate_cost(nb, delta)\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, target_root, incumbent_len):\n        tries = 20\n        while tries > 0:\n            tries -= 1\n            r = self._rand()\n            if incumbent_len is not None and r < self.ellipse_bias:\n                p = self._sample_in_ellipse(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                r2 = self._rand()\n                if r2 < self.goal_bias:\n                    p = target_root\n                elif r2 < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_point()\n                else:\n                    if self._is3:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]),\n                             self._rand_range(0.0, self.bounds[2]))\n                    else:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _corridor_point(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step, 0.07 * sg)\n        if self._is3:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            oz = self._rand_range(-w, w)\n            return self._clamp((base[0] + ox, base[1] + oy, base[2] + oz))\n        else:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            return self._clamp((base[0] + ox, base[1] + oy))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(16):\n            if self._is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if not self._in_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # ---------- Paths and smoothing ----------\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, meet_a, meet_b):\n        # meet_a is in active tree; meet_b is in the opposite tree\n        path_a = self._trace_to_root(meet_a)\n        # path_b: from meet_b up to its root\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # Concatenate without adding a cross edge to preserve structures\n        return path_a + path_b\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _prune_collinear(self, pts, cos_eps=0.999):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        for i in range(1, len(pts) - 1):\n            a = out[-1]\n            b = pts[i]\n            c = pts[i + 1]\n            v1 = tuple(b[j] - a[j] for j in range(self.dim))\n            v2 = tuple(c[j] - b[j] for j in range(self.dim))\n            n1 = sum(v1[j] * v1[j] for j in range(self.dim)) ** 0.5\n            n2 = sum(v2[j] * v2[j] for j in range(self.dim)) ** 0.5\n            if n1 < 1e-9 or n2 < 1e-9:\n                continue\n            cosang = sum(v1[j] * v2[j] for j in range(self.dim)) / (n1 * n2)\n            if cosang < cos_eps:\n                out.append(b)\n        out.append(pts[-1])\n        return out\n\n    def _vis_collapse(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = pts[:]\n        i = 0\n        while i < len(out) - 2:\n            j = len(out) - 1\n            collapsed = False\n            while j > i + 1:\n                if self._edge_free(out[i], out[j]):\n                    del out[i + 1:j]\n                    collapsed = True\n                    break\n                j -= 1\n            if not collapsed:\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        stall = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 1, len(cur) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-9 <= bestL:\n                    cur = cand\n                    bestL = L\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            tries += 1\n            if stall > 24:\n                break\n        return cur\n\n    def _round_corners(self, pts, passes=2):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            i = 1\n            while i < len(cur) - 1:\n                a = cur[i - 1]\n                c = cur[i + 1]\n                # propose midpoint between a and c\n                mid = tuple(0.5 * (a[j] + c[j]) for j in range(self.dim))\n                if self._in_bounds(mid) and (not self._point_in_obstacles(mid)):\n                    if self._edge_free(a, mid) and self._edge_free(mid, c):\n                        cur[i] = mid\n                i += 1\n        return cur\n\n    def _smooth_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._prune_collinear(path)\n        p1 = self._vis_collapse(p0)\n        p2 = self._shortcut(p1, self.smoothing_attempts)\n        p3 = self._round_corners(p2, passes=2)\n        return p3",
          "objective": -37.18079,
          "time_improvement": 73.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1385.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009148359298706055,
                    "num_nodes_avg": 41.0,
                    "path_length_avg": 160.05130696013703,
                    "smoothness_avg": 0.047923416631070685,
                    "success_improvement": 0.0,
                    "time_improvement": 62.919010542245815,
                    "node_improvement": 89.67514479979855,
                    "length_improvement": 12.273342479892806,
                    "smoothness_improvement": 650.1055376411265,
                    "objective_score": 29.490236338815063
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.039803075790405276,
                    "num_nodes_avg": 172.0,
                    "path_length_avg": 240.87765654308606,
                    "smoothness_avg": 0.0896202009366,
                    "success_improvement": 0.0,
                    "time_improvement": 76.20167525773196,
                    "node_improvement": 88.44319021702614,
                    "length_improvement": 19.588104967000366,
                    "smoothness_improvement": 2205.992320920289,
                    "objective_score": 45.64332716212125
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.00955343246459961,
                    "num_nodes_avg": 74.0,
                    "path_length_avg": 136.5410158564313,
                    "smoothness_avg": 0.11001885368701667,
                    "success_improvement": 0.0,
                    "time_improvement": 81.07358629325219,
                    "node_improvement": 90.59122695486332,
                    "length_improvement": 9.315958652640234,
                    "smoothness_improvement": 1299.4316981518023,
                    "objective_score": 36.40880957031881
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "FLASH-CacheBiRRTc*: Fast Lightweight And Sparse Heuristic bi-directional RRT with global collision-cache, per-cell admission, and direct LOS-bridging. It unifies ellipse-informed sampling once an incumbent exists, wide-ring grid nearest queries, capped local growth by cost-aware admission, cached collision tests reused across expansion and smoothing, and minimal local rewiring. Opposite-tree connections prefer direct visibility seams to cut iterations. Post-processing is cache-aware visibility collapse, few shortcuts, and a light elastic pass for smoothness.",
          "planning_mechanism": "Alternate expanding the smaller tree. Each iteration: draw a sample from a hybrid of goal/corridor/uniform with ellipse focus if an incumbent path exists; find nearest via a multi-ring spatial grid; take one steered step and insert only if both node and edge checks pass and the cell admits growth; optionally rewire a few neighbors if it shortens their cost while respecting both checks; then query k nearest nodes of the opposite tree within a meet radius and attempt a direct LOS seam using cached collisions. Maintain the best path length to tighten ellipse sampling. On success, stitch the two trees and run cache-aware visibility collapse, bounded shortcutting, and one elastic pass, then return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children) - 1, - 1, -1):\n            if self.children[i] is child:\n                del self.children[i]\n                break\nclass Planner:\n    def __init__(self,\n                 max_iter=3500,\n                 step_size=7.0,\n                 grid_cell_factor=1.6,\n                 grid_rings=3,\n                 goal_bias=0.18,\n                 corridor_bias=0.22,\n                 ellipse_bias=0.48,\n                 meet_k=6,\n                 meet_radius_factor=3.2,\n                 per_cell_cap=7,\n                 rewire_k=5,\n                 neighbor_radius_factor=2.0,\n                 min_sep_ratio=0.22,\n                 shortcut_attempts=28,\n                 elastic_iters=14):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.grid_rings = int(max(1, grid_rings))\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.ellipse_bias = float(ellipse_bias)\n        self.meet_k = int(max(1, meet_k))\n        self.meet_factor = float(meet_radius_factor)\n        self.per_cell_cap = int(max(1, per_cell_cap))\n        self.rewire_k = int(max(0, rewire_k))\n        self.neigh_factor = float(neighbor_radius_factor)\n        self.min_sep_ratio = float(min_sep_ratio)\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.elastic_iters = int(max(0, elastic_iters))\n        self._rng = 2463534242\n        self._hidx = 1\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self._is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if hasattr(map, \"obstacles\") and map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        # basic checks\n        if not (self._in_bounds(self.start) and self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self.q = 1000.0\n\n        # spatial params\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.neigh_radius = max(self.step * 1.1, self.step * self.neigh_factor)\n        self.meet_radius = max(self.step * 1.2, self.step * self.meet_factor)\n        self.min_sep_base = max(0.25, self.step * self.min_sep_ratio)\n\n        # caches\n        self._pblock_cache = {}\n        self._edge_cache = {}\n\n        # bins\n        self._build_obs_bins()\n\n        # validate endpoints\n        if self._point_blocked_cached(self.start) or self._point_blocked_cached(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # early direct path\n        if self._edge_free_cached(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # initialize trees and grids\n        Aroot = Node(self.start, None, 0.0)\n        Broot = Node(self.goal, None, 0.0)\n        Ta, Tb = [Aroot], [Broot]\n        nodes.extend([Aroot, Broot])\n\n        GA, GB = {}, {}\n        GA_best = {}\n        GB_best = {}\n        self._grid_add(GA, GA_best, Aroot)\n        self._grid_add(GB, GB_best, Broot)\n\n        # incumbent length for informed sampling\n        best_len = None\n\n        # iterate\n        for it in range(self.max_iter):\n            # pick smaller tree to expand\n            if len(Ta) <= len(Tb):\n                T_src, T_dst = Ta, Tb\n                G_src, G_dst = GA, GB\n                Gbest_src, Gbest_dst = GA_best, GB_best\n                from_start = True\n                root_dst = self.goal\n            else:\n                T_src, T_dst = Tb, Ta\n                G_src, G_dst = GB, GA\n                Gbest_src, Gbest_dst = GB_best, GA_best\n                from_start = False\n                root_dst = self.start\n\n            # sample\n            sp = self._sample(self.start if from_start else self.goal, root_dst, best_len)\n            if sp is None:\n                continue\n\n            # nearest\n            anchor = self._nearest(G_src, sp, T_src)\n            if anchor is None:\n                continue\n\n            # one steered step\n            newp = self._steer(anchor.position, sp, self.step)\n            if newp == anchor.position:\n                continue\n\n            # admission checks: bounds, node, spacing, cell cap, edge\n            if (not self._in_bounds(newp)) or self._point_blocked_cached(newp):\n                pass\n            else:\n                if not self._too_close(G_src, newp, self._local_min_sep(newp)):\n                    if self._grid_can_admit(G_src, Gbest_src, newp, anchor.cost + self._dist(anchor.position, newp)):\n                        if self._edge_free_cached(anchor.position, newp):\n                            # insert node\n                            new_cost = anchor.cost + self._dist(anchor.position, newp)\n                            nn = Node(newp, anchor, new_cost)\n                            anchor.add_child(nn)\n                            T_src.append(nn)\n                            nodes.append(nn)\n                            edges.append((anchor, nn))\n                            self._grid_add(G_src, Gbest_src, nn)\n\n                            # light local rewiring\n                            if self.rewire_k > 0:\n                                self._rewire_local(nn, G_src, edges)\n\n                            # attempt meet with opposite tree by LOS seam\n                            meet = self._meet_candidate(nn, G_dst, T_dst)\n                            if meet is not None and self._edge_free_cached(nn.position, meet.position):\n                                # stitch path\n                                path = self._stitch(nn, meet, from_start)\n                                Lraw = self._path_len(path)\n                                if best_len is None or Lraw < best_len:\n                                    best_len = Lraw\n                                path = self._finalize_path(path)\n                                return PlannerResult(True, path, Ta + Tb, edges)\n\n        return PlannerResult(False, [], Ta + Tb, edges)\n\n    # RNG and Halton\n    def _seed_rng(self):\n        x = 0x9E3779B9 ^ (len(self.obstacles) + 1) * 2654435761\n        for v in self.start + self.goal:\n            y = int((v + 1.0) * 1000003) & 0xffffffff\n            x ^= (y + 0x9E3779B9 + ((x << 6) & 0xffffffff) + (x >> 2)) & 0xffffffff\n        self._rng = (x if x != 0 else 2463534242) & 0xffffffff\n        self._hidx = 1\n\n    def _randu(self):\n        x = self._rng\n        x ^= (x << 13) & 0xffffffff\n        x ^= (x >> 17) & 0xffffffff\n        x ^= (x << 5) & 0xffffffff\n        self._rng = x & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._randu()\n\n    def _radical_inverse(self, base, i):\n        inv = 1.0 / base\n        f = inv\n        x = 0.0\n        n = i\n        while n > 0:\n            x += (n % base) * f\n            n //= base\n            f *= inv\n        return x\n\n    def _halton_point(self, idx):\n        if self._is3:\n            return (self._radical_inverse(2, idx) * self.bounds[0],\n                    self._radical_inverse(3, idx) * self.bounds[1],\n                    self._radical_inverse(5, idx) * self.bounds[2])\n        else:\n            return (self._radical_inverse(2, idx) * self.bounds[0],\n                    self._radical_inverse(3, idx) * self.bounds[1])\n\n    def _halton_next(self):\n        p = self._halton_point(self._hidx)\n        self._hidx += 1\n        return p\n\n    # geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # spatial hashing and admission\n    def _cell_key(self, p):\n        if self._is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        else:\n            return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, best_cost, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n        bc = best_cost.get(k)\n        if bc is None or node.cost < bc:\n            best_cost[k] = node.cost\n\n    def _grid_can_admit(self, grid, best_cost, pos, cand_cost):\n        k = self._cell_key(pos)\n        lst = grid.get(k)\n        if lst is None or len(lst) < self.per_cell_cap:\n            return True\n        bc = best_cost.get(k)\n        if bc is None:\n            return True\n        # admit only if substantially better than current best in the cell\n        return cand_cost + 0.5 * self.step < bc\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self._is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos, T_list):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(self.grid_rings + 1):\n            cands = self._collect_ring(grid, key, r)\n            if not cands:\n                continue\n            for n in cands:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n            if best is not None:\n                return best\n        # fallback: sample random subset\n        if not T_list:\n            return None\n        m = min(32, len(T_list))\n        for _ in range(m):\n            j = int(self._rand_range(0, len(T_list)))\n            if j >= len(T_list):\n                j = len(T_list) - 1\n            n = T_list[j]\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        span = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self._is3:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _k_nearest(self, nodes, pos, k):\n        if not nodes:\n            return []\n        buf = []\n        for nd in nodes:\n            buf.append((self._dist2(nd.position, pos), nd))\n        buf.sort(key=lambda t: t[0])\n        return [buf[i][1] for i in range(min(k, len(buf)))]\n\n    def _too_close(self, grid, pos, radius):\n        if radius <= 0.0:\n            return False\n        neigh = self._neighbors_in_radius(grid, pos, radius)\n        return len(neigh) > 0\n\n    def _local_min_sep(self, pos):\n        # allow denser points near obstacles\n        if self._is3:\n            key = (int(pos[0] // self.obs_cell), int(pos[1] // self.obs_cell), int(pos[2] // self.obs_cell))\n        else:\n            key = (int(pos[0] // self.obs_cell), int(pos[1] // self.obs_cell))\n        near_obs = key in self.obin\n        return self.min_sep_base * (0.6 if near_obs else 1.0)\n\n    # obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.6)\n        self.obin = {}\n        if self._is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            lst = self.obin.get((i, j, k))\n                            if lst is None:\n                                self.obin[(i, j, k)] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        lst = self.obin.get((i, j))\n                        if lst is None:\n                            self.obin[(i, j)] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _bucket_candidates(self, a, b):\n        if self._is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self.obin.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            return cand\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self.obin.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            return cand\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            q = p1[i]\n            d = q - p\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _pkey(self, p):\n        if self._is3:\n            return (int(p[0] * self.q), int(p[1] * self.q), int(p[2] * self.q))\n        else:\n            return (int(p[0] * self.q), int(p[1] * self.q))\n\n    def _ekey(self, a, b):\n        ak = self._pkey(a)\n        bk = self._pkey(b)\n        return (ak, bk) if ak < bk else (bk, ak)\n\n    def _point_blocked_cached(self, p):\n        k = self._pkey(p)\n        v = self._pblock_cache.get(k)\n        if v is not None:\n            return v\n        res = self._point_blocked_raw(p)\n        self._pblock_cache[k] = res\n        return res\n\n    def _edge_free_cached(self, a, b):\n        k = self._ekey(a, b)\n        v = self._edge_cache.get(k)\n        if v is not None:\n            return v\n        res = self._edge_free_raw(a, b)\n        self._edge_cache[k] = res\n        return res\n\n    def _point_blocked_raw(self, p):\n        if self._is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            lst = self.obin.get((ix, iy, iz))\n            if not lst:\n                return False\n            x, y, z = p\n            for idx in lst:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            lst = self.obin.get((ix, iy))\n            if not lst:\n                return False\n            x, y = p\n            for idx in lst:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free_raw(self, a, b):\n        cand = self._bucket_candidates(a, b)\n        if not cand:\n            return True\n        if self._is3:\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    # sampling\n    def _sample(self, root_src, root_dst, incumbent_len):\n        tries = 0\n        while tries < 18:\n            tries += 1\n            r = self._randu()\n            if incumbent_len is not None and r < self.ellipse_bias:\n                p = self._sample_in_ellipse(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                r2 = self._randu()\n                if r2 < self.goal_bias:\n                    p = root_dst\n                elif r2 < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_point()\n                else:\n                    if (tries & 1) == 0:\n                        p = self._halton_next()\n                    else:\n                        if self._is3:\n                            p = (self._rand_range(0.0, self.bounds[0]),\n                                 self._rand_range(0.0, self.bounds[1]),\n                                 self._rand_range(0.0, self.bounds[2]))\n                        else:\n                            p = (self._rand_range(0.0, self.bounds[0]),\n                                 self._rand_range(0.0, self.bounds[1]))\n            if (not self._in_bounds(p)) or self._point_blocked_cached(p):\n                continue\n            return p\n        return None\n\n    def _corridor_point(self):\n        t = self._randu()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        span = max(self.step, 0.06 * self._dist(self.start, self.goal))\n        if self._is3:\n            return self._clamp((base[0] + self._rand_range(-span, span),\n                                base[1] + self._rand_range(-span, span),\n                                base[2] + self._rand_range(-span, span)))\n        else:\n            return self._clamp((base[0] + self._rand_range(-span, span),\n                                base[1] + self._rand_range(-span, span)))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(16):\n            if self._is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_blocked_cached(p):\n                continue\n            if self._dist(p, f1) + self._dist(p, f2) <= max_sum + 1e-9:\n                return p\n        return None\n\n    # meeting\n    def _meet_candidate(self, last_node, G_dst, T_dst):\n        near = self._neighbors_in_radius(G_dst, last_node.position, self.meet_radius)\n        if not near and T_dst:\n            # fallback to nearest single node\n            near = [self._nearest(G_dst, last_node.position, T_dst)]\n        if not near:\n            return None\n        cands = self._k_nearest(near, last_node.position, min(self.meet_k, len(near)))\n        best = None\n        bestL = 1e100\n        for nd in cands:\n            if nd is None:\n                continue\n            if self._edge_free_cached(last_node.position, nd.position):\n                L = last_node.cost + nd.cost + self._dist(last_node.position, nd.position)\n                if L < bestL:\n                    bestL = L\n                    best = nd\n        return best\n\n    # rewiring\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                del edges[i]\n                break\n\n    def _propagate_cost(self, node, delta):\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    def _rewire_local(self, new_node, grid, edges):\n        neigh = self._neighbors_in_radius(grid, new_node.position, self.neigh_radius)\n        if not neigh:\n            return\n        cands = self._k_nearest(neigh, new_node.position, self.rewire_k)\n        for nb in cands:\n            if nb is new_node or nb is new_node.parent:\n                continue\n            # cycle check\n            cur = new_node\n            cyc = False\n            while cur is not None:\n                if cur is nb:\n                    cyc = True\n                    break\n                cur = cur.parent\n            if cyc:\n                continue\n            # both checks before adding edge\n            if self._point_blocked_cached(nb.position) or self._point_blocked_cached(new_node.position):\n                continue\n            if not self._edge_free_cached(new_node.position, nb.position):\n                continue\n            cand_cost = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand_cost + 1e-9 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, oldp, nb)\n                new_node.add_child(nb)\n                edges.append((new_node, nb))\n                delta = cand_cost - nb.cost\n                nb.cost = cand_cost\n                self._propagate_cost(nb, delta)\n\n    # path utilities\n    def _trace(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        return out[::-1]\n\n    def _stitch(self, a_node, b_node, a_from_start):\n        pa = self._trace(a_node)  # rootA->a\n        pb = self._trace(b_node)  # rootB->b\n        if a_from_start:\n            # start->...->a, goal->...->b\n            return pa + list(reversed(pb))\n        else:\n            # goal->...->a, start->...->b\n            return pb + list(reversed(pa))\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_collapse(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            progressed = False\n            while j > i + 1:\n                if self._edge_free_cached(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    progressed = True\n                    break\n                j -= 1\n            if not progressed:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _corner_cost(self, a, b, c):\n        v1 = tuple(b[i] - a[i] for i in range(self.dim))\n        v2 = tuple(c[i] - b[i] for i in range(self.dim))\n        n1 = (sum(v1[i] * v1[i] for i in range(self.dim))) ** 0.5\n        n2 = (sum(v2[i] * v2[i] for i in range(self.dim))) ** 0.5\n        if n1 < 1e-12 or n2 < 1e-12:\n            return 0.0\n        dot = sum(v1[i] * v2[i] for i in range(self.dim)) / (n1 * n2)\n        if dot > 1.0:\n            dot = 1.0\n        if dot < -1.0:\n            dot = -1.0\n        return 1.0 - dot\n\n    def _elastic_smooth(self, pts, iters=14, w=0.55, max_len_inc=0.006):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(iters):\n            changed = False\n            for k in range(1, len(cur) - 1):\n                a = cur[k - 1]\n                b = cur[k]\n                c = cur[k + 1]\n                mid = tuple(0.5 * (a[i] + c[i]) for i in range(self.dim))\n                q = tuple((1.0 - w) * b[i] + w * mid[i] for i in range(self.dim))\n                if (not self._in_bounds(q)) or self._point_blocked_cached(q):\n                    continue\n                if not (self._edge_free_cached(a, q) and self._edge_free_cached(q, c)):\n                    continue\n                oldL = self._dist(a, b) + self._dist(b, c)\n                newL = self._dist(a, q) + self._dist(q, c)\n                len_ok = newL <= oldL * (1.0 + max_len_inc) + 1e-12\n                curv_old = self._corner_cost(a, b, c)\n                curv_new = self._corner_cost(a, q, c)\n                if len_ok and (newL <= oldL + 1e-12 or curv_new + 1e-12 < 0.85 * curv_old):\n                    cur[k] = q\n                    changed = True\n            if not changed:\n                break\n        return cur\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a, b = cur[i], cur[j]\n            if self._edge_free_cached(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-9 <= bestL:\n                    cur = cand\n                    bestL = L\n            tries += 1\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path[:]\n        p1 = self._visibility_collapse(path)\n        p2 = self._shortcut(p1, self.shortcut_attempts)\n        p3 = self._elastic_smooth(p2, iters=self.elastic_iters, w=0.55, max_len_inc=0.006)\n        # dedup\n        out = []\n        last = None\n        for p in p3:\n            if (last is None) or (p != last):\n                out.append(p)\n                last = p\n        return out",
          "objective": -37.12336,
          "time_improvement": 72.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1669.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010129237174987793,
                    "num_nodes_avg": 54.0,
                    "path_length_avg": 180.63292746527787,
                    "smoothness_avg": 0.05068207036826415,
                    "success_improvement": 0.0,
                    "time_improvement": 59.07740646630359,
                    "node_improvement": 86.4014102241249,
                    "length_improvement": 0.9922301443777611,
                    "smoothness_improvement": 693.2844591406761,
                    "objective_score": 21.784982322221115
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03082451820373535,
                    "num_nodes_avg": 151.0,
                    "path_length_avg": 258.3210229330181,
                    "smoothness_avg": 0.1215667527531317,
                    "success_improvement": 0.0,
                    "time_improvement": 81.25336036901855,
                    "node_improvement": 89.85419606262178,
                    "length_improvement": 13.76500718657806,
                    "smoothness_improvement": 3028.0001093308447,
                    "objective_score": 47.77501296930662
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01240077018737793,
                    "num_nodes_avg": 81.0,
                    "path_length_avg": 118.7369053051491,
                    "smoothness_avg": 0.10883863327804452,
                    "success_improvement": 0.0,
                    "time_improvement": 75.6787833359597,
                    "node_improvement": 89.70120788302607,
                    "length_improvement": 21.140601140162726,
                    "smoothness_improvement": 1284.4193816644854,
                    "objective_score": 41.81009259320797
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SIBiRRT-Connect-Lite: A streamlined balanced informed BiRRT-Connect with light neighbor parent selection, grid-accelerated proximity/collision, and two-phase shortcut refinement for faster search, shorter paths, and improved smoothness.",
          "planning_mechanism": "Per iteration, expand the smaller tree: sample from a mixed distribution (uniform/corridor/goal; ellipse after a first solution), steer one bounded step, validate node and edge, pick the cheapest feasible parent among the nearest few neighbors, insert, then greedily connect the opposite tree toward it until blocked. On connection, extract and shortcut the path and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=6.0,\n        goal_bias=0.25,\n        corridor_bias=0.35,\n        grid_cell_factor=1.0,\n        min_sep_ratio=0.3,\n        neighbor_radius_factor=2.0,\n        neighbor_cap=6,\n        connect_steps=32,\n        shortcut_attempts=80\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.min_sep_ratio = min_sep_ratio\n        self.neighbor_radius_factor = neighbor_radius_factor\n        self.neighbor_cap = neighbor_cap\n        self.connect_steps = connect_steps\n        self.shortcut_attempts = shortcut_attempts\n        self._rnd_state = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step_size * self.min_sep_ratio)\n        self.neighbor_radius = max(self.step_size * 1.2, self.step_size * self.neighbor_radius_factor)\n\n        self._seed_from_scene()\n\n        nodes = []\n        edges = []\n\n        if (not self._within_bounds(self.start)) or (not self._within_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._build_obstacle_grid()\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        incumbent_len = None\n\n        for _ in range(self.max_iter):\n            if len(tree_a) <= len(tree_b):\n                active_tree, active_grid = tree_a, grid_a\n                passive_tree, passive_grid = tree_b, grid_b\n                attractor = self.goal\n            else:\n                active_tree, active_grid = tree_b, grid_b\n                passive_tree, passive_grid = tree_a, grid_a\n                attractor = self.start\n\n            s = self._sample(attractor, incumbent_len)\n            if s is None:\n                continue\n\n            nearest = self._nearest_in_grid(active_grid, s)\n            if nearest is None:\n                continue\n\n            new_pos = self._steer(nearest.position, s, self.step_size)\n            if not self._within_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if self._has_nearby(active_grid, new_pos, self.min_sep):\n                continue\n\n            parent, new_cost = self._choose_parent_light(active_grid, nearest, new_pos)\n            if parent is None:\n                continue\n\n            if self._point_in_obstacles(new_pos):\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(active_grid, new_node)\n\n            meet = self._connect_toward(passive_tree, passive_grid, new_node.position, nodes, edges)\n            if meet is not None and self._edge_free(meet.position, new_node.position):\n                path = self._extract_path(new_node, meet)\n                incumbent_len = self._path_len(path)\n                path = self._shortcut(path)\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0x7fffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0x7fffffff\n        self._rnd_state = (s ^ 0x9E3779B9) & 0x7fffffff\n        if self._rnd_state == 0:\n            self._rnd_state = 123456789\n\n    def _rand(self):\n        self._rnd_state = (1103515245 * self._rnd_state + 12345) & 0x7fffffff\n        return self._rnd_state / 2147483647.0\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            q = []\n            for i in range(self.dims):\n                q.append(self._clamp_val(b[i], 0.0, self.bounds[i]))\n            return tuple(q)\n        d = d2 ** 0.5\n        r = step / d\n        q = []\n        for i in range(self.dims):\n            v = a[i] + (b[i] - a[i]) * r\n            q.append(self._clamp_val(v, 0.0, self.bounds[i]))\n        return tuple(q)\n\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_in_grid(self, grid, pos, max_ring=4):\n        key = self._cell_of(pos)\n        best = None\n        bestd2 = 1e100\n        for r in range(0, max_ring + 1):\n            cand = self._ring_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            if best is not None:\n                return best\n        buckets = list(grid.values())\n        if not buckets:\n            return None\n        trials = 0\n        while trials < 24:\n            b = buckets[int(self._rand() * len(buckets)) % max(1, len(buckets))]\n            if b:\n                n = b[int(self._rand() * len(b)) % max(1, len(b))]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            trials += 1\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        rc = int(radius // self.cell_size) + 1\n        r2 = radius * radius\n        for n in self._ring_collect(grid, key, rc):\n            if self._dist2(n.position, pos) <= r2:\n                return True\n        return False\n\n    def _nearby_nodes(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        rc = int(radius // self.cell_size) + 1\n        r2 = radius * radius\n        out = []\n        for n in self._ring_collect(grid, key, rc):\n            if self._dist2(n.position, pos) <= r2:\n                out.append(n)\n        return out\n\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            b = self.obs_grid.get((cx, cy, cz))\n            if not b:\n                return False\n            px, py, pz = p\n            for idx in b:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            b = self.obs_grid.get((cx, cy))\n            if not b:\n                return False\n            px, py = p\n            for idx in b:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _choose_parent_light(self, grid, nearest, new_pos):\n        neigh = self._nearby_nodes(grid, new_pos, self.neighbor_radius)\n        if nearest not in neigh:\n            neigh.append(nearest)\n        neigh.sort(key=lambda n: self._dist2(n.position, new_pos))\n        cand = neigh[:max(1, self.neighbor_cap)]\n        best_parent = None\n        best_cost = 1e100\n        for n in cand:\n            if not self._edge_free(n.position, new_pos):\n                continue\n            c = n.cost + self._dist(n.position, new_pos)\n            if c + 1e-9 < best_cost:\n                best_cost = c\n                best_parent = n\n        if best_parent is None:\n            return None, None\n        return best_parent, best_cost\n\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        near = self._nearest_in_grid(grid, target_pos)\n        if near is None:\n            return None\n        cur = near\n        steps = 0\n        while steps < self.connect_steps:\n            nxt = self._steer(cur.position, target_pos, self.step_size)\n            if self._dist2(cur.position, nxt) < (self.min_sep * self.min_sep * 0.25):\n                break\n            if not self._within_bounds(nxt):\n                break\n            if self._point_in_obstacles(nxt):\n                break\n            if self._has_nearby(grid, nxt, self.min_sep):\n                break\n            if not self._edge_free(cur.position, nxt):\n                break\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            q = Node(nxt, cur, new_cost)\n            cur.add_child(q)\n            tree.append(q)\n            nodes.append(q)\n            edges.append((cur, q))\n            self._grid_insert(grid, q)\n            cur = q\n            steps += 1\n            if self._dist2(cur.position, target_pos) <= (self.step_size * self.step_size) and self._edge_free(cur.position, target_pos):\n                return cur\n        return None\n\n    def _sample(self, attractor, incumbent_len):\n        for _ in range(20):\n            r = self._rand()\n            if incumbent_len is not None and r < 0.55:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                elif r < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_sample()\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            if p is not None and self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        if self._within_bounds(attractor) and not self._point_in_obstacles(attractor):\n            return attractor\n        return None\n\n    def _corridor_sample(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n        dsg = self._dist(self.start, self.goal)\n        width = max(self.step_size, 0.08 * dsg)\n        if self.is_3d:\n            return (\n                self._clamp_val(base[0] + self._rand_range(-width, width), 0.0, self.bounds[0]),\n                self._clamp_val(base[1] + self._rand_range(-width, width), 0.0, self.bounds[1]),\n                self._clamp_val(base[2] + self._rand_range(-width, width), 0.0, self.bounds[2]),\n            )\n        else:\n            return (\n                self._clamp_val(base[0] + self._rand_range(-width, width), 0.0, self.bounds[0]),\n                self._clamp_val(base[1] + self._rand_range(-width, width), 0.0, self.bounds[1]),\n            )\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum_dist\n        ext = [max(self.step_size, half)] * self.dims\n        for _ in range(18):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._within_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum_dist and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        pb.reverse()\n        if pa and pb and pa[-1] == pb[0]:\n            pb = pb[1:]\n        return pa + pb\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        i = 0\n        while i < len(pts) - 2:\n            j = len(pts) - 1\n            improved = False\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    del pts[i + 1:j]\n                    improved = True\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n        attempts = 0\n        while attempts < self.shortcut_attempts and len(pts) > 2:\n            i = int(self._rand_range(0, len(pts) - 2))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                attempts += 1\n                continue\n            if self._edge_free(pts[i], pts[j]):\n                pts = pts[:i + 1] + pts[j:]\n            attempts += 1\n        return pts",
          "objective": -37.09124,
          "time_improvement": 61.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1377.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011144709587097169,
                    "num_nodes_avg": 49.0,
                    "path_length_avg": 150.61019244127573,
                    "smoothness_avg": 0.04827733550563596,
                    "success_improvement": 0.0,
                    "time_improvement": 54.82721598316178,
                    "node_improvement": 87.6605389070763,
                    "length_improvement": 17.448166951713837,
                    "smoothness_improvement": 655.6451365752101,
                    "objective_score": 30.195290648852886
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04703662395477295,
                    "num_nodes_avg": 160.0,
                    "path_length_avg": 222.69131300634007,
                    "smoothness_avg": 0.08728289130799861,
                    "success_improvement": 0.0,
                    "time_improvement": 71.87672486543198,
                    "node_improvement": 89.24947927165222,
                    "length_improvement": 25.65922990444059,
                    "smoothness_improvement": 2145.851660680297,
                    "objective_score": 47.68781370569543
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02253601551055908,
                    "num_nodes_avg": 116.0,
                    "path_length_avg": 125.1119046359757,
                    "smoothness_avg": 0.11227318427452833,
                    "success_improvement": 0.0,
                    "time_improvement": 55.35364337006359,
                    "node_improvement": 85.2511125238398,
                    "length_improvement": 16.906630129474358,
                    "smoothness_improvement": 1328.1066168275754,
                    "objective_score": 33.39060417284157
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "FLASH-IBiRRT: A fast, informed bidirectional RRT-Connect with bounded parenting and zero-cost rewiring. It grows two trees with large-step greedy connections, uses a compact spatial hash and obstacle bins for O(1)-like queries, schedules goal/segment-biased sampling, and returns on the first valid connection. Post-processing applies a single shortcut pass and visibility pruning for quick, smooth paths.",
          "planning_mechanism": "Alternate expansions from start/goal: sample (goal/line/uniform), steer one step from the active tree, insert only if node- and edge-free, then greedily connect the opposite tree with larger steps, inserting the exact meeting point when visible. No global rewiring; a small, local best-parent choice near the extension reduces cost at negligible overhead. Early exit upon connection, followed by fast shortcut and visibility prune.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=7.5,\n        connect_factor=2.6,\n        goal_bias=0.18,\n        line_bias=0.22,\n        grid_cell_factor=2.0,\n        k_parent=6,\n        smooth_attempts=60\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_step = self.step * float(connect_factor)\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.k_parent = int(max(1, k_parent))\n        self.smooth_attempts = int(max(0, smooth_attempts))\n        self._rng = 246813579\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_radius = max(0.4, 0.35 * self.step)\n\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            final = self._finalize_path(path)\n            return PlannerResult(True, final, nodes, edges)\n\n        # Initialize trees\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        Ta, Tb = [start_root], [goal_root]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, start_root)\n        self._grid_add(Gb, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        for it in range(self.max_iter):\n            # Two fast passes per iteration: grow both sides toward a single sample\n            attract_a = self.goal\n            attract_b = self.start\n            sample = self._sample(attract_a, attract_b)\n            if sample is None:\n                continue\n\n            # pass 1: start tree\n            res = self._expand_and_connect(Ta, Ga, Tb, Gb, sample, nodes, edges, active_is_start=True)\n            if res is not None:\n                path = res\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n            # pass 2: goal tree\n            res = self._expand_and_connect(Tb, Gb, Ta, Ga, sample, nodes, edges, active_is_start=False)\n            if res is not None:\n                path = res\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # Core expansion + connection\n    def _expand_and_connect(self, Ta, Ga, Tb, Gb, sample, nodes, edges, active_is_start):\n        na = self._nearest(Ga, sample)\n        if na is None:\n            return None\n\n        # Choose a lightweight best parent among k nearest in the grid ring\n        target = self._steer(na.position, sample, self.step)\n        if (not self._in_bounds(target)) or self._point_in_obstacles(target):\n            return None\n\n        parent = self._best_parent(Ga, target, na, self.k_parent)\n        if parent is None:\n            return None\n\n        if (not self._edge_free(parent.position, target)):\n            return None\n\n        if self._too_close(Ga, target, self.dup_radius):\n            return None\n\n        new_cost = parent.cost + self._dist(parent.position, target)\n        nn = Node(target, parent, new_cost)\n        parent.add_child(nn)\n        Ta.append(nn)\n        nodes.append(nn)\n        edges.append((parent, nn))\n        self._grid_add(Ga, nn)\n\n        meet_node, reached = self._connect_toward(Tb, Gb, nn.position, nodes, edges)\n        if reached:\n            pa = self._trace_to_root(nn)\n            pb = self._trace_to_root(meet_node)\n            if active_is_start:\n                # pa goes start->...->nn, pb goes goal->...->meet\n                # Join paths; include meet if different from nn\n                if pa[-1] != pb[-1]:\n                    path = pa + [pb[-1]] + pb[-2::-1]\n                else:\n                    path = pa + pb[-2::-1]\n            else:\n                # pa goes goal->...->nn, pb goes start->...->meet\n                if pa[-1] != pb[-1]:\n                    path = pb + [pa[-1]] + pa[-2::-1]\n                else:\n                    path = pb + pa[-2::-1]\n            return self._dedup(path)\n        return None\n\n    # RNG and sampling\n    def _seed_from_scene(self):\n        s = 0xA341316C & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 11400714819323198485 & 0xffffffff)\n            s ^= (q ^ (q >> 15) ^ ((q << 9) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 29) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 246813579\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _sample(self, attract_a, attract_b):\n        r = self._rand()\n        # Goal bias\n        if r < self.goal_bias:\n            return attract_a\n        # Segment (start-goal) bias\n        if r < self.goal_bias + self.line_bias:\n            t = self._rand()\n            if self.is3:\n                return (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                        self.start[1] + (self.goal[1] - self.start[1]) * t,\n                        self.start[2] + (self.goal[2] - self.start[2]) * t)\n            else:\n                return (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                        self.start[1] + (self.goal[1] - self.start[1]) * t)\n        # Uniform\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial hash for nodes\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        for r in range(0, 3):\n            cand = self._grid_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found = True\n            if found:\n                return best\n        # fallback scan\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _k_nearest(self, grid, pos, kmax):\n        key = self._cell_key(pos)\n        heap = []\n        # simple partial selection without imports\n        cand = []\n        for r in range(0, 2):\n            cand.extend(self._grid_collect(grid, key, r))\n        if not cand:\n            for lst in grid.values():\n                cand.extend(lst)\n        # unique nodes (avoid tiny overhead of set by ID)\n        seen = {}\n        out = []\n        for n in cand:\n            if id(n) in seen:\n                continue\n            seen[id(n)] = True\n            out.append((self._dist2(n.position, pos), n))\n        out.sort(key=lambda x: x[0])\n        return [n for (_, n) in out[:kmax]]\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Local best parent (bounded k-NN)\n    def _best_parent(self, grid, newp, fallback, kmax):\n        best = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        kn = self._k_nearest(grid, newp, kmax)\n        for n in kn:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                best = n\n                best_cost = c\n        return best\n\n    # Greedy connect from the other tree toward a target position\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < 48:\n            if self._edge_free(cur.position, target_pos):\n                # Insert exact meeting point if sufficiently far/unique\n                if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                    if not self._too_close(grid, target_pos, 0.75 * self.dup_radius):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        cur.add_child(nn)\n                        tree.append(nn)\n                        nodes.append(nn)\n                        edges.append((cur, nn))\n                        self._grid_add(grid, nn)\n                        return nn, True\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            if self._too_close(grid, nxt, 0.75 * self.dup_radius):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n        # Last visibility try\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                if not self._too_close(grid, target_pos, 0.75 * self.dup_radius):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    cur.add_child(nn)\n                    tree.append(nn)\n                    nodes.append(nn)\n                    edges.append((cur, nn))\n                    self._grid_add(grid, nn)\n                    return nn, True\n            return cur, True\n        return cur, False\n\n    # Utilities\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        nbr = self._neighbors_in_radius(grid, pos, radius)\n        return len(nbr) > 0\n\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    # Fast, light smoothing\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._shortcut(path, self.smooth_attempts)\n        p2 = self._visibility_prune(p1)\n        return self._dedup(p2)",
          "objective": -37.07801,
          "time_improvement": 75.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1629.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014019584655761719,
                    "num_nodes_avg": 83.0,
                    "path_length_avg": 188.21860119077922,
                    "smoothness_avg": 0.04147767672480912,
                    "success_improvement": 0.0,
                    "time_improvement": 43.17450224151976,
                    "node_improvement": 79.0984638630068,
                    "length_improvement": -3.1655978272618333,
                    "smoothness_improvement": 549.2157109598944,
                    "objective_score": 13.799070530898302
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009280896186828614,
                    "num_nodes_avg": 72.0,
                    "path_length_avg": 247.55425918283944,
                    "smoothness_avg": 0.12140082327282926,
                    "success_improvement": 0.0,
                    "time_improvement": 94.45093684426602,
                    "node_improvement": 95.16226567224349,
                    "length_improvement": 17.35926283049915,
                    "smoothness_improvement": 3023.7306242884893,
                    "objective_score": 53.869491873021744
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.005894255638122558,
                    "num_nodes_avg": 52.0,
                    "path_length_avg": 124.23642750462632,
                    "smoothness_avg": 0.11125496209005074,
                    "success_improvement": 0.0,
                    "time_improvement": 88.32282311998175,
                    "node_improvement": 93.38842975206612,
                    "length_improvement": 17.48808035437552,
                    "smoothness_improvement": 1315.154905798364,
                    "objective_score": 43.56546967761165
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "INSTAR-BiRRT*: Informed-Indexed Star-Rewire Bidirectional Planner. A bidirectional, obstacle-indexed RRT with local best-parent selection, limited RRT*-style rewiring, cached edge checks, and informed corridor sampling that tightens after the first solution. It enforces strict node and edge collision checks before any insertion, caps connect steps, and maintains coherent trees/edges. On connection, it performs visibility compression, endpoint-inclusive shortcutting, and elastic smoothing for shorter, smoother paths while keeping runtime low.",
          "planning_mechanism": "Mechanism: Build start/goal trees with a spatial node grid and an obstacle cell index. Each iteration alternates trees, samples goal/corridor/informed/uniform targets using LCG RNG, gathers near candidates from grid rings, selects the cheapest collision-free parent, and inserts a single node after both node and edge checks. It then locally rewires cheaper neighbors (edge-checked) and attempts a bounded greedy connect on the opposite tree with commit-per-step checks. A cached, AABB-prefiltered edge tester accelerates validation. Upon bridge closure, it assembles the path and applies visibility compression, endpoint-inclusive random shortcuts, and elastic smoothing.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=7000,\n        step_size=6.0,\n        goal_bias=0.22,\n        corridor_bias=0.40,\n        grid_cell_factor=1.3,\n        neighbor_radius_ratio=1.5,\n        rewire_radius_ratio=1.8,\n        dupe_radius_ratio=0.30,\n        connect_hops=6,\n        edge_resolution=0.9,\n        shortcut_attempts=120,\n        elastic_iters=8\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neighbor_radius_ratio = float(neighbor_radius_ratio)\n        self.rewire_radius_ratio = float(rewire_radius_ratio)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.connect_hops = int(connect_hops)\n        self.edge_resolution = float(edge_resolution)\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.elastic_iters = int(max(0, elastic_iters))\n        # runtime fields\n        self.bounds = None\n        self.dim = 2\n        self.is_3d = False\n        self.start = None\n        self.goal = None\n        self.obstacles = None\n        self.grid_cell = 1.0\n        self.obs_cell = 4.0\n        self.edge_res = 1.0\n        self.cache_bin = 1.0\n        self._free_edge_cache = None\n        self._blocked_edge_cache = None\n        self.obs_index = None\n\n    # ---- Public API ----\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles)\n\n        # Parameterize\n        self.grid_cell = max(1.0, self.grid_cell_factor * self.step_size)\n        self.obs_cell = max(4.0, 1.2 * self.step_size)\n        self.edge_res = max(0.5, min(self.edge_resolution, self.step_size))\n        self.cache_bin = max(1.0, self.edge_res)\n\n        # Validate start/goal\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._build_obstacle_index()\n        if self._is_point_blocked_indexed(self.start) or self._is_point_blocked_indexed(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct LOS\n        self._free_edge_cache, self._blocked_edge_cache = set(), set()\n        if not self._is_edge_blocked_cached(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._distance(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Initialize trees, grids, edges\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree, goal_tree = [start_root], [goal_root]\n        grid_start, grid_goal = {}, {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n        edges = []\n\n        # RNG init\n        self._lcg_state = 2463534242\n\n        # Sampling parameters\n        dsg = self._distance(self.start, self.goal)\n        corridor_w = max(self.step_size, 0.2 * dsg)\n        dupe_radius = max(0.5, self.dupe_radius_ratio * self.step_size)\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            # Alternate sides\n            if it % 2 == 0:\n                grow_tree, grow_grid, grow_root_pos = start_tree, grid_start, self.start\n                other_tree, other_grid, other_root_pos = goal_tree, grid_goal, self.goal\n                start_side_active = True\n            else:\n                grow_tree, grow_grid, grow_root_pos = goal_tree, grid_goal, self.goal\n                other_tree, other_grid, other_root_pos = start_tree, grid_start, self.start\n                start_side_active = False\n\n            # Dynamic radii (light dependence on current tree size)\n            nA = max(1, len(grow_tree))\n            neighbor_radius = max(self.step_size, self.neighbor_radius_ratio * self.step_size * (1.0 + 0.15 * (1.0 / (1.0 + nA / 300.0))))\n            rewire_radius = max(self.step_size, self.rewire_radius_ratio * self.step_size * (1.0 + 0.10 * (1.0 / (1.0 + nA / 300.0))))\n\n            # Target sampling (goal / informed corridor / uniform)\n            r = self._rand()\n            if r < self.goal_bias:\n                target = other_root_pos\n            else:\n                # informed corridor tightens once a path exists\n                use_informed = best_len < float('inf') and self._rand() < self.corridor_bias\n                if use_informed:\n                    width = max(self.step_size, 0.25 * (best_len - dsg) + 0.15 * dsg)\n                    target = self._sample_corridor(self.start, self.goal, width)\n                elif self._rand() < self.corridor_bias:\n                    target = self._sample_corridor(self.start, self.goal, corridor_w)\n                else:\n                    target = self._sample_free()\n\n            # Choose near set and best parent\n            near_candidates = self._nearest_candidates(grow_tree, grow_grid, target, min_k=16, max_rings=4)\n            if not near_candidates:\n                near_candidates = [self._nearest_linear(grow_tree, target)]\n            base_parent = self._best_near(near_candidates, target)\n            proposed = self._steer(base_parent.position, target, self.step_size)\n            if not self._within_bounds(proposed):\n                continue\n            if self._is_point_blocked_indexed(proposed):\n                continue\n            if self._exists_close(grow_grid, proposed, dupe_radius):\n                continue\n\n            # Best-parent selection within neighbor radius (strict node+edge checks)\n            neighbors = self._neighbors_within_radius(grow_grid, proposed, neighbor_radius)\n            if base_parent not in neighbors:\n                neighbors.append(base_parent)\n            best_parent = None\n            best_cost = float('inf')\n            for cand in neighbors:\n                dcp = self._distance(cand.position, proposed)\n                if dcp > self.step_size + 1e-9:\n                    continue\n                if self._is_edge_blocked_cached(cand.position, proposed):\n                    continue\n                cost = cand.cost + dcp\n                if cost < best_cost:\n                    best_cost = cost\n                    best_parent = cand\n            if best_parent is None:\n                continue\n\n            # Commit new node (both checks enforced)\n            new_node = self._commit_node(grow_tree, grow_grid, edges, best_parent, proposed, best_cost)\n            if new_node is None:\n                continue\n\n            # Local rewiring (limited) with strict edge checks\n            self._local_rewire(new_node, grow_grid, edges, rewire_radius, max_rewires=16)\n\n            # Attempt immediate direct bridge to nearest of other tree\n            other_near = self._nearest_from_grid(other_tree, other_grid, new_node.position, max_rings=3)\n            if other_near is not None and not self._is_edge_blocked_cached(new_node.position, other_near.position):\n                # Bridge and finish\n                edges.append((other_near, new_node))\n                raw_path = self._assemble_path(start_root, goal_root, new_node, other_near, start_side_active)\n                best_len = self._path_length(raw_path)\n                path = self._postprocess(raw_path)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Greedy bounded connect on the other tree toward new_node\n            if other_near is None:\n                other_near = self._nearest_linear(other_tree, new_node.position)\n            last_b = self._bounded_connect(other_tree, other_grid, other_near, new_node.position, edges, self.connect_hops)\n            if last_b is not None:\n                # Try final bridge\n                if not self._is_edge_blocked_cached(last_b.position, new_node.position):\n                    edges.append((last_b, new_node))\n                    raw_path = self._assemble_path(start_root, goal_root, new_node, last_b, start_side_active)\n                    best_len = self._path_length(raw_path)\n                    path = self._postprocess(raw_path)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---- RNG ----\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---- Geometry ----\n    def _distance(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_pos(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._distance(from_pos, to_pos)\n        if d <= step:\n            return self._clamp_pos(to_pos)\n        r = step / (d + 1e-12)\n        return self._clamp_pos(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---- Obstacle index and collision ----\n    def _build_obstacle_index(self):\n        self.obs_index = {}\n        if self.is_3d:\n            for oi, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                minx = int(x // self.obs_cell)\n                maxx = int((x + w) // self.obs_cell)\n                miny = int(y // self.obs_cell)\n                maxy = int((y + h) // self.obs_cell)\n                minz = int(z // self.obs_cell)\n                maxz = int((z + d) // self.obs_cell)\n                for cx in range(minx, maxx + 1):\n                    for cy in range(miny, maxy + 1):\n                        for cz in range(minz, maxz + 1):\n                            key = (cx, cy, cz)\n                            bucket = self.obs_index.get(key)\n                            if bucket is None:\n                                self.obs_index[key] = [oi]\n                            else:\n                                bucket.append(oi)\n        else:\n            for oi, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                minx = int(x // self.obs_cell)\n                maxx = int((x + w) // self.obs_cell)\n                miny = int(y // self.obs_cell)\n                maxy = int((y + h) // self.obs_cell)\n                for cx in range(minx, maxx + 1):\n                    for cy in range(miny, maxy + 1):\n                        key = (cx, cy)\n                        bucket = self.obs_index.get(key)\n                        if bucket is None:\n                            self.obs_index[key] = [oi]\n                        else:\n                            bucket.append(oi)\n\n    def _obs_cell_key(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.obs_cell), int(pos[1] // self.obs_cell), int(pos[2] // self.obs_cell))\n        else:\n            return (int(pos[0] // self.obs_cell), int(pos[1] // self.obs_cell))\n\n    def _obs_candidates_for_segment(self, a, b, pad):\n        if self.is_3d:\n            mins = (min(a[0], b[0]) - pad, min(a[1], b[1]) - pad, min(a[2], b[2]) - pad)\n            maxs = (max(a[0], b[0]) + pad, max(a[1], b[1]) + pad, max(a[2], b[2]) + pad)\n            minc = (int(mins[0] // self.obs_cell), int(mins[1] // self.obs_cell), int(mins[2] // self.obs_cell))\n            maxc = (int(maxs[0] // self.obs_cell), int(maxs[1] // self.obs_cell), int(maxs[2] // self.obs_cell))\n            seen = set()\n            cand = []\n            for cx in range(minc[0], maxc[0] + 1):\n                for cy in range(minc[1], maxc[1] + 1):\n                    for cz in range(minc[2], maxc[2] + 1):\n                        bucket = self.obs_index.get((cx, cy, cz))\n                        if bucket:\n                            for oi in bucket:\n                                if oi not in seen:\n                                    seen.add(oi)\n                                    cand.append(oi)\n            return cand\n        else:\n            mins = (min(a[0], b[0]) - pad, min(a[1], b[1]) - pad)\n            maxs = (max(a[0], b[0]) + pad, max(a[1], b[1]) + pad)\n            minc = (int(mins[0] // self.obs_cell), int(mins[1] // self.obs_cell))\n            maxc = (int(maxs[0] // self.obs_cell), int(maxs[1] // self.obs_cell))\n            seen = set()\n            cand = []\n            for cx in range(minc[0], maxc[0] + 1):\n                for cy in range(minc[1], maxc[1] + 1):\n                    bucket = self.obs_index.get((cx, cy))\n                    if bucket:\n                        for oi in bucket:\n                            if oi not in seen:\n                                seen.add(oi)\n                                cand.append(oi)\n            return cand\n\n    def _is_point_blocked_indexed(self, pos):\n        key = self._obs_cell_key(pos)\n        bucket = self.obs_index.get(key)\n        if not bucket:\n            return False\n        if self.is_3d:\n            px, py, pz = pos\n            for oi in bucket:\n                x, y, z, w, h, d = self.obstacles[oi]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for oi in bucket:\n                x, y, w, h = self.obstacles[oi]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_blocked_cached(self, a, b):\n        key = self._edge_key_q(a, b)\n        if key in self._blocked_edge_cache:\n            return True\n        if key in self._free_edge_cache:\n            return False\n        blocked = self._is_edge_blocked_filtered(a, b)\n        if blocked:\n            self._blocked_edge_cache.add(key)\n            return True\n        else:\n            self._free_edge_cache.add(key)\n            return False\n\n    def _is_edge_blocked_filtered(self, a, b):\n        d = self._distance(a, b)\n        steps = int(max(1, d / max(1e-9, self.edge_res)))\n        cand = self._obs_candidates_for_segment(a, b, pad=self.edge_res)\n        if not cand:\n            return False\n        if steps <= 1:\n            mid = tuple((a[i] + b[i]) * 0.5 for i in range(self.dim))\n            return self._is_point_blocked_in_list(mid, cand) or self._is_point_blocked_in_list(a, cand) or self._is_point_blocked_in_list(b, cand)\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_point_blocked_in_list(p, cand):\n                return True\n        return False\n\n    def _is_point_blocked_in_list(self, pos, cand_idx):\n        if not cand_idx:\n            return False\n        if self.is_3d:\n            px, py, pz = pos\n            for oi in cand_idx:\n                x, y, z, w, h, d = self.obstacles[oi]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for oi in cand_idx:\n                x, y, w, h = self.obstacles[oi]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    # ---- Sampling ----\n    def _sample_free(self):\n        for _ in range(64):\n            if self.is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_point_blocked_indexed(p):\n                return p\n        # fallback within bounds (may be blocked; extension will reject)\n        if self.is_3d:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]),\n                    self._uniform(0.0, self.bounds[2]))\n        else:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]))\n\n    def _sample_corridor(self, a, b, width):\n        t = self._rand()\n        base = tuple(a[i] + t * (b[i] - a[i]) for i in range(self.dim))\n        if self.is_3d:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_point_blocked_indexed(p):\n            return p\n        return self._sample_free()\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # ---- Node grid and nearest ----\n    def _grid_key(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell), int(pos[2] // self.grid_cell))\n        else:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _nearest_from_grid(self, tree, grid, point, max_rings=4):\n        # ring search with early exit only if enough candidates seen; else fallback\n        cand = self._collect_ring(grid, point, max_rings)\n        if cand:\n            best = cand[0]\n            bestd = self._distance(best.position, point)\n            for n in cand:\n                d = self._distance(n.position, point)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            return best\n        return self._nearest_linear(tree, point)\n\n    def _nearest_linear(self, tree, point):\n        best = tree[0]\n        bestd = self._distance(best.position, point)\n        for n in tree:\n            d = self._distance(n.position, point)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _collect_ring(self, grid, point, max_rings):\n        center = self._grid_key(point)\n        out = []\n        # grow rings\n        for r in range(0, max_rings + 1):\n            if self.is_3d:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            k = (center[0] + dx, center[1] + dy, center[2] + dz)\n                            if k in grid:\n                                out.extend(grid[k])\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        k = (center[0] + dx, center[1] + dy)\n                        if k in grid:\n                            out.extend(grid[k])\n        return out\n\n    def _nearest_candidates(self, tree, grid, point, min_k=16, max_rings=4):\n        cand = []\n        center = self._grid_key(point)\n        for r in range(0, max_rings + 1):\n            if self.is_3d:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            k = (center[0] + dx, center[1] + dy, center[2] + dz)\n                            if k in grid:\n                                cand.extend(grid[k])\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        k = (center[0] + dx, center[1] + dy)\n                        if k in grid:\n                            cand.extend(grid[k])\n            if len(cand) >= min_k:\n                break\n        if not cand and tree:\n            cand = tree[:min(min_k, len(tree))]\n        return cand\n\n    def _neighbors_within_radius(self, grid, point, radius):\n        cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        center = self._grid_key(point)\n        out = []\n        if self.is_3d:\n            for dx in range(-cells, cells + 1):\n                for dy in range(-cells, cells + 1):\n                    for dz in range(-cells, cells + 1):\n                        k = (center[0] + dx, center[1] + dy, center[2] + dz)\n                        if k in grid:\n                            out.extend(grid[k])\n        else:\n            for dx in range(-cells, cells + 1):\n                for dy in range(-cells, cells + 1):\n                    k = (center[0] + dx, center[1] + dy)\n                    if k in grid:\n                        out.extend(grid[k])\n        # distance filter\n        rr = radius * radius\n        fil = []\n        for n in out:\n            s = 0.0\n            p = n.position\n            for i in range(self.dim):\n                d = p[i] - point[i]\n                s += d * d\n            if s <= rr:\n                fil.append(n)\n        return fil\n\n    def _exists_close(self, grid, pos, radius):\n        return len(self._neighbors_within_radius(grid, pos, radius)) > 0\n\n    def _best_near(self, nodes, target):\n        best = nodes[0]\n        bestd = self._distance(best.position, target)\n        for n in nodes:\n            d = self._distance(n.position, target)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    # ---- Commit/rewire/connect ----\n    def _commit_node(self, tree, grid, edges, parent, pos, cost):\n        if not self._within_bounds(pos):\n            return None\n        if self._is_point_blocked_indexed(pos):\n            return None\n        if self._is_edge_blocked_cached(parent.position, pos):\n            return None\n        new_node = Node(pos, parent, cost)\n        parent.add_child(new_node)\n        tree.append(new_node)\n        self._grid_add(grid, new_node)\n        edges.append((parent, new_node))\n        return new_node\n\n    def _local_rewire(self, new_node, grid, edges, radius, max_rewires=16):\n        # try to improve nearby neighbors' costs via new_node\n        neigh = self._neighbors_within_radius(grid, new_node.position, radius)\n        count = 0\n        for nb in neigh:\n            if nb is new_node or nb is new_node.parent:\n                continue\n            d = self._distance(new_node.position, nb.position)\n            if d <= 1e-9 or d > radius + 1e-9:\n                continue\n            new_cost = new_node.cost + d\n            if new_cost + 1e-9 < nb.cost:\n                # enforce both checks\n                if self._is_edge_blocked_cached(new_node.position, nb.position):\n                    continue\n                if self._is_point_blocked_indexed(nb.position):  # redundant but explicit\n                    continue\n                old_parent = nb.parent\n                if old_parent is None:\n                    continue\n                # apply rewire\n                self._remove_child(old_parent, nb)\n                self._remove_edge(edges, old_parent, nb)\n                new_node.add_child(nb)\n                nb.parent = new_node\n                delta = new_cost - nb.cost\n                nb.cost = new_cost\n                self._propagate_cost(nb, delta)\n                edges.append((new_node, nb))\n                count += 1\n                if count >= max_rewires:\n                    break\n\n    def _remove_child(self, parent, child):\n        if child in parent.children:\n            parent.children.remove(child)\n\n    def _remove_edge(self, edges, parent, child):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is parent and e[1] is child:\n                del edges[i]\n                return\n\n    def _propagate_cost(self, node, delta):\n        # BFS propagate cost changes to subtree\n        q = [node]\n        while q:\n            cur = q.pop()\n            for ch in cur.children:\n                ch.cost += delta\n                q.append(ch)\n\n    def _bounded_connect(self, tree, grid, from_node, target_pos, edges, max_hops):\n        current = from_node\n        last_new = None\n        hops = 0\n        while hops < max_hops:\n            step_pos = self._steer(current.position, target_pos, self.step_size)\n            if not self._within_bounds(step_pos):\n                break\n            if self._is_point_blocked_indexed(step_pos):\n                break\n            if self._is_edge_blocked_cached(current.position, step_pos):\n                break\n            # commit (strict checks already done)\n            new_cost = current.cost + self._distance(current.position, step_pos)\n            nxt = Node(step_pos, current, new_cost)\n            current.add_child(nxt)\n            tree.append(nxt)\n            self._grid_add(grid, nxt)\n            edges.append((current, nxt))\n            last_new = nxt\n            current = nxt\n            hops += 1\n            if self._distance(current.position, target_pos) <= self.step_size:\n                break\n        return last_new\n\n    # ---- Path assembly and post-processing ----\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _assemble_path(self, start_root, goal_root, a_node, b_node, a_is_start_side):\n        if a_is_start_side:\n            pa = self._path_to_root(a_node)  # start -> a_node\n            pb = self._path_to_root(b_node)  # goal -> b_node\n            return pa + pb[::-1]\n        else:\n            pa = self._path_to_root(a_node)  # goal-side growth\n            pb = self._path_to_root(b_node)\n            return pb + pa[::-1]\n\n    def _path_length(self, path):\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._distance(path[i - 1], path[i])\n        return total\n\n    def _visibility_compress(self, path):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            jumped = False\n            while j > i + 1:\n                if not self._is_edge_blocked_cached(path[i], path[j]):\n                    out.append(path[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(path[i + 1])\n                i += 1\n        if out[-1] != path[-1]:\n            out.append(path[-1])\n        # de-dup\n        ded = [out[0]]\n        for k in range(1, len(out)):\n            if self._distance(ded[-1], out[k]) > 1e-9:\n                ded.append(out[k])\n        return ded\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return list(path)\n        pts = list(path)\n        for _ in range(attempts):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_blocked_cached(a, b):\n                pts = pts[:i + 1] + pts[j:]\n        return pts\n\n    def _elastic(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return list(path)\n        pts = list(path)\n        for _ in range(iters):\n            changed = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                if self._is_point_blocked_indexed(mid):\n                    continue\n                if self._is_edge_blocked_cached(a, mid):\n                    continue\n                if self._is_edge_blocked_cached(mid, c):\n                    continue\n                if self._distance(pts[i], mid) > 1e-9:\n                    pts[i] = mid\n                    changed = True\n            if not changed:\n                break\n        return pts\n\n    def _postprocess(self, raw_path):\n        p = self._visibility_compress(raw_path)\n        p = self._shortcut(p, self.shortcut_attempts)\n        p = self._elastic(p, self.elastic_iters)\n        return p",
          "objective": -36.94679,
          "time_improvement": 62.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1876.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01455528736114502,
                    "num_nodes_avg": 56.0,
                    "path_length_avg": 153.05488117915178,
                    "smoothness_avg": 0.04323917072604063,
                    "success_improvement": 0.0,
                    "time_improvement": 41.00314170328443,
                    "node_improvement": 85.89775875094435,
                    "length_improvement": 16.108194315911927,
                    "smoothness_improvement": 576.7869172246149,
                    "objective_score": 24.84979368665556
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04361860752105713,
                    "num_nodes_avg": 170.0,
                    "path_length_avg": 244.2123677023688,
                    "smoothness_avg": 0.12207511882177972,
                    "success_improvement": 0.0,
                    "time_improvement": 73.92036253535261,
                    "node_improvement": 88.57757172613049,
                    "length_improvement": 18.474882397693065,
                    "smoothness_improvement": 3041.0807344384375,
                    "objective_score": 48.466441871413814
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014497733116149903,
                    "num_nodes_avg": 74.0,
                    "path_length_avg": 135.28177456457792,
                    "smoothness_avg": 0.16586943691668363,
                    "success_improvement": 0.0,
                    "time_improvement": 71.27837604096456,
                    "node_improvement": 90.59122695486332,
                    "length_improvement": 10.15228676006259,
                    "smoothness_improvement": 2009.8469943719351,
                    "objective_score": 37.5241198401866
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SAGE-BRRT: Simple Adaptive Grid-Enhanced BiRRT with Local Rewire and On-the-fly Visibility. Two trees grow toward each other using grid-accelerated nearest search and informed/corridor-biased sampling. Each insertion selects the least-cost feasible parent among nearby nodes, performs ancestor visibility compression, and locally rewires neighbors. A probe-then-commit connect adds at most one node on the opposite tree per iteration and bridges if a short direct link is free. Obstacle checks use a spatial hash for fast node and edge validation. On success, a lightweight visibility pass, shortcutting, and elastic smoothing return a short, smooth path quickly.",
          "planning_mechanism": "Initialize bidirectional trees, node-grid, and obstacle-grid. Iterate: sample a target (goal/corridor/informed/uniform), find a near node via grid rings, steer by a fixed step, and validate node (inside-bounds, not in obstacles) and edge (segment-obstacle free). Choose the best feasible parent within a local radius; insert the node, then optionally compress to a visible ancestor and rewire nearby nodes if cheaper. Probe the other tree: try a direct bridge; else simulate one feasible step toward the new node and commit at most one opposite-node; if the short bridge becomes free, assemble the path. Maintain an incumbent path for informed sampling. After connection, run visibility compression, shortcutting, and elastic smoothing, then return the result.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=7.0,\n        goal_bias=0.18,\n        corridor_bias=0.35,\n        informed_bias=0.55,\n        cell_size_factor=1.6,\n        dupe_radius_ratio=0.45,\n        rewire_radius_factor=2.0,\n        neighbor_cap=24,\n        connect_steps=1,\n        smooth_shortcuts=80,\n        rubber_iters=8\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.cell_size_factor = float(cell_size_factor)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.rewire_radius_factor = float(rewire_radius_factor)\n        self.neighbor_cap = int(neighbor_cap)\n        self.connect_steps = int(connect_steps)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self.rubber_iters = int(max(0, rubber_iters))\n\n        self._rnd = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_from_scene()\n\n        # Build obstacle spatial hash\n        self._build_obstacle_grid()\n\n        # Validate endpoints\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Setup structures\n        self.cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.rewire_radius = max(self.step_size * 1.25, self.rewire_radius_factor * self.step_size)\n\n        nodes = []\n        edges = []\n\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        tree_a, tree_b = [a_root], [b_root]\n        grid_a, grid_b = {}, {}\n        anchors_a, anchors_b = [a_root], [b_root]\n        self._grid_insert(grid_a, a_root)\n        self._grid_insert(grid_b, b_root)\n\n        best_path = None\n        best_len = float('inf')\n\n        # Corridor width for biased sampling\n        sg = self._dist(self.start, self.goal)\n        corridor_w = max(self.step_size, 0.2 * sg)\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            tree1 = tree_a if side_a else tree_b\n            grid1 = grid_a if side_a else grid_b\n            anchors1 = anchors_a if side_a else anchors_b\n\n            tree2 = tree_b if side_a else tree_a\n            grid2 = grid_b if side_a else grid_a\n            anchors2 = anchors_b if side_a else anchors_a\n\n            attractor = self.goal if side_a else self.start\n\n            # Sample a target\n            target = self._sample_target(attractor, best_len, corridor_w)\n            if target is None:\n                continue\n\n            # Find near node and steer\n            near = self._nearest_hashed(grid1, anchors1, target, 3)\n            if near is None:\n                continue\n            new_pos = self._steer(near.position, target)\n\n            # Validity checks for node and edge\n            if not self._within_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if self._has_nearby(grid1, new_pos, self.dupe_radius):\n                continue\n\n            # Select best parent among local candidates\n            parent, new_cost = self._choose_parent(grid1, anchors1, tree1, new_pos)\n            if parent is None:\n                continue\n\n            # Node collision already checked; ensure edge is free\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            # Insert node\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(grid1, new_node)\n            if (len(tree1) % 24) == 0:\n                anchors1.append(new_node)\n\n            # Optional: compress to visible ancestor (one hop)\n            gp = parent.parent\n            if gp is not None:\n                if self._edge_free(gp.position, new_node.position):\n                    self._reparent(new_node, gp, edges)\n\n            # Local rewiring\n            self._rewire_neighbors(grid1, new_node, self.rewire_radius, edges)\n\n            # Try to connect the other tree\n            other_near = self._nearest_hashed(grid2, anchors2, new_node.position, 3)\n            if other_near is not None:\n                # Direct bridge\n                if self._edge_free(new_node.position, other_near.position):\n                    path = self._assemble_path(new_node, other_near, side_a)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # Probe-then-commit: at most one step on the other tree\n                committed = None\n                steps = 0\n                probe_from = other_near\n                while steps < self.connect_steps:\n                    step_p = self._steer(probe_from.position, new_node.position)\n                    if not self._within_bounds(step_p):\n                        break\n                    if self._point_in_obstacles(step_p):\n                        break\n                    if self._has_nearby(grid2, step_p, self.dupe_radius):\n                        break\n                    if not self._edge_free(probe_from.position, step_p):\n                        break\n                    # Commit this single step\n                    q = Node(step_p, probe_from, probe_from.cost + self._dist(probe_from.position, step_p))\n                    probe_from.add_child(q)\n                    tree2.append(q)\n                    nodes.append(q)\n                    edges.append((probe_from, q))\n                    self._grid_insert(grid2, q)\n                    if (len(tree2) % 24) == 0:\n                        anchors2.append(q)\n                    # Light local optimize\n                    self._compress_one(q, edges)\n                    self._rewire_neighbors(grid2, q, self.rewire_radius, edges)\n                    committed = q\n                    break\n                # If committed, try short bridge\n                if committed is not None:\n                    if self._edge_free(new_node.position, committed.position):\n                        path = self._assemble_path(new_node, committed, side_a)\n                        path = self._postprocess(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n            # Maintain best incumbent (for informed sampling)\n            if best_path is None:\n                # Try a temporary connection via NN if possible (no commit)\n                if other_near is not None:\n                    if self._edge_free(new_node.position, other_near.position):\n                        tmp = self._assemble_path(new_node, other_near, side_a)\n                        L = self._path_len(tmp)\n                        if L < best_len:\n                            best_len = L\n                            best_path = tmp\n\n        if best_path is not None:\n            best_path = self._postprocess(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG utilities\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 1) * 2654435761\n        self._rnd = (s ^ 0x9E3779B9) & 0xffffffff\n        if self._rnd == 0:\n            self._rnd = 2463534242\n\n    def _rand(self):\n        self._rnd = (1664525 * self._rnd + 1013904223) & 0xffffffff\n        return self._rnd / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= self.step_size:\n            return self._clamp(b)\n        r = self.step_size / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Sampling\n    def _sample_target(self, attractor, best_len, corridor_w):\n        for _ in range(24):\n            if best_len < float('inf') and self._rand() < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p is not None and not self._point_in_obstacles(p):\n                    return p\n            else:\n                r = self._rand()\n                if r < self.goal_bias:\n                    p = attractor\n                elif r < self.goal_bias + self.corridor_bias:\n                    t = self._rand()\n                    base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n                    if self.is_3d:\n                        p = (\n                            self._clamp((base[0] + self._rand_range(-corridor_w, corridor_w),\n                                         base[1] + self._rand_range(-corridor_w, corridor_w),\n                                         base[2] + self._rand_range(-corridor_w, corridor_w)))[0],\n                            self._clamp((base[0] + self._rand_range(-corridor_w, corridor_w),\n                                         base[1] + self._rand_range(-corridor_w, corridor_w),\n                                         base[2] + self._rand_range(-corridor_w, corridor_w)))[1],\n                            self._clamp((base[0] + self._rand_range(-corridor_w, corridor_w),\n                                         base[1] + self._rand_range(-corridor_w, corridor_w),\n                                         base[2] + self._rand_range(-corridor_w, corridor_w)))[2]\n                        )\n                        p = (min(max(base[0] + self._rand_range(-corridor_w, corridor_w), 0.0), self.bounds[0]),\n                             min(max(base[1] + self._rand_range(-corridor_w, corridor_w), 0.0), self.bounds[1]),\n                             min(max(base[2] + self._rand_range(-corridor_w, corridor_w), 0.0), self.bounds[2]))\n                    else:\n                        p = (min(max(base[0] + self._rand_range(-corridor_w, corridor_w), 0.0), self.bounds[0]),\n                             min(max(base[1] + self._rand_range(-corridor_w, corridor_w), 0.0), self.bounds[1]))\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n                if self._within_bounds(p) and not self._point_in_obstacles(p):\n                    return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._within_bounds(p):\n                return p\n        return None\n\n    # Node grid\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, anchors, pos, max_rings=3):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # Fallback: scan grid buckets\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors_within_radius(self, grid, pos, radius, cap):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        # Filter and cap\n        out = []\n        rr = radius * radius\n        for n in cand:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= rr:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _has_nearby(self, grid, pos, radius):\n        neigh = self._neighbors_within_radius(grid, pos, radius, self.neighbor_cap)\n        return len(neigh) > 0\n\n    # Parent selection\n    def _choose_parent(self, grid, anchors, tree, new_pos):\n        neigh = self._neighbors_within_radius(grid, new_pos, self.rewire_radius, self.neighbor_cap)\n        if not neigh:\n            # include a nearest fallback\n            near = None\n            bestd = 1e100\n            for n in tree:\n                d = self._dist(n.position, new_pos)\n                if d < bestd:\n                    bestd = d\n                    near = n\n            if near is None:\n                return None, None\n            neigh = [near]\n        best_parent = None\n        best_cost = 1e100\n        for p in neigh:\n            d = self._dist(p.position, new_pos)\n            if d > self.step_size + 1e-9:\n                continue\n            if not self._edge_free(p.position, new_pos):\n                continue\n            gc = p.cost + d\n            if gc < best_cost:\n                best_cost = gc\n                best_parent = p\n        if best_parent is None:\n            return None, None\n        return best_parent, best_cost\n\n    # Obstacle spatial hash\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Local optimization helpers\n    def _compress_one(self, node, edges):\n        p = node.parent\n        if p is None or p.parent is None:\n            return\n        gp = p.parent\n        if self._edge_free(gp.position, node.position):\n            self._reparent(node, gp, edges)\n\n    def _rewire_neighbors(self, grid, node, radius, edges):\n        neigh = self._neighbors_within_radius(grid, node.position, radius, self.neighbor_cap)\n        count = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            new_cost = node.cost + d\n            if new_cost + 1e-9 < nb.cost and self._edge_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n                count += 1\n                if count >= self.neighbor_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        old_parent = child.parent\n        if old_parent is new_parent:\n            return\n        if old_parent is not None:\n            old_parent.remove_child(child)\n            self._edges_remove(edges, old_parent, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        self._propagate_costs(child)\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                old = ch.cost\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                if abs(ch.cost - old) > 1e-12:\n                    stack.append(ch)\n\n    # Path assembly and post-processing\n    def _assemble_path(self, new_node, other_node, side_a):\n        if side_a:\n            pa = new_node.path_from_root()\n            pb = other_node.path_from_root()\n            if pa and pb and pa[0] == pb[-1]:\n                pb = pb[:-1]\n            return pa + pb[::-1]\n        else:\n            pa = new_node.path_from_root()\n            pb = other_node.path_from_root()\n            if pa and pb and pb[0] == pa[-1]:\n                pa = pa[:-1]\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _postprocess(self, path):\n        if len(path) < 3:\n            return path[:]\n        p = self._visibility_compress(path)\n        p = self._shortcut(p, self.smooth_shortcuts)\n        p = self._rubber_band(p, self.rubber_iters)\n        return p\n\n    def _visibility_compress(self, path):\n        out = [path[0]]\n        last = path[0]\n        i = 1\n        while i < len(path):\n            far = i\n            j = i\n            while j < len(path):\n                if self._edge_free(last, path[j]):\n                    far = j\n                    j += 1\n                else:\n                    break\n            out.append(path[far])\n            last = path[far]\n            i = far + 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = path[:]\n        best_len = self._path_len(pts)\n        n = len(pts)\n        tries = 0\n        noimp = 0\n        stop = 12\n        while tries < attempts and n >= 3:\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j > n:\n                tries += 1\n                continue\n            a, b = pts[i], pts[j - 1]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j - 1:]\n                L = self._path_len(new_pts)\n                if L <= best_len + 1e-12:\n                    pts = new_pts\n                    best_len = L\n                    n = len(pts)\n                    noimp = 0\n                else:\n                    noimp += 1\n            else:\n                noimp += 1\n            tries += 1\n            if noimp >= stop:\n                break\n        return pts\n\n    def _rubber_band(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return path[:]\n        pts = list(path)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dims))\n                if self._point_in_obstacles(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if mid != pts[i]:\n                        pts[i] = mid\n                        moved = True\n            if not moved:\n                break\n        return pts",
          "objective": -36.91755,
          "time_improvement": 60.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 2316.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016495347023010254,
                    "num_nodes_avg": 71.0,
                    "path_length_avg": 170.6218692301367,
                    "smoothness_avg": 0.05965294648609013,
                    "success_improvement": 0.0,
                    "time_improvement": 33.13950960050793,
                    "node_improvement": 82.12037270209015,
                    "length_improvement": 6.479449798427921,
                    "smoothness_improvement": 833.6981509539397,
                    "objective_score": 17.99801351397883
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03120548725128174,
                    "num_nodes_avg": 138.0,
                    "path_length_avg": 245.4887822432574,
                    "smoothness_avg": 0.18956585497977163,
                    "success_improvement": 0.0,
                    "time_improvement": 81.34218764255085,
                    "node_improvement": 90.72767587180005,
                    "length_improvement": 18.048778484388976,
                    "smoothness_improvement": 4777.665987395928,
                    "objective_score": 59.12025332037828
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01702072620391846,
                    "num_nodes_avg": 92.0,
                    "path_length_avg": 132.8506469498789,
                    "smoothness_avg": 0.1130542551758292,
                    "success_improvement": 0.0,
                    "time_improvement": 66.28004574080119,
                    "node_improvement": 88.30260648442466,
                    "length_improvement": 11.766925963888978,
                    "smoothness_improvement": 1338.0417810394658,
                    "objective_score": 33.63437820577107
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Mini-BiRRT Connect-Lite: a simplified, robust bi-directional RRT-Connect with strict node/edge collision checks, lightweight grid-accelerated nearest/duplicate queries, and fast post-processing (visibility prune + random shortcut). It favors generalization by avoiding heavy rewiring or complex heuristics while delivering short, smooth paths quickly.",
          "planning_mechanism": "Alternate expansions from start and goal: sample with modest goal bias, steer a fixed step to a collision-free node, add only if unique, then attempt a greedy, strictly-validated connect to the opposite tree (no partial commits on failure). On success, merge roots-to-meet path, prune by line-of-sight, and shortcut to reduce length and kinks.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=3500,\n                 step_size=6.0,\n                 goal_bias=0.2,\n                 grid_scale=1.0,\n                 dupe_radius_ratio=0.5,\n                 connect_steps=14,\n                 shortcut_attempts=64):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_scale = float(grid_scale)\n        self.dupe_ratio = float(dupe_radius_ratio)\n        self.connect_steps = int(max(1, connect_steps))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self._rng = 1469598103934665603  # 64-bit state\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if getattr(map, 'obstacles', None) else []\n\n        nodes, edges = [], []\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._build_obs_grid()\n\n        if self._point_in_obs(self.start) or self._point_in_obs(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        self.node_cell = max(1.0, self.step * self.grid_scale)\n        self.dupe_radius = max(0.4 * self.step, self.step * self.dupe_ratio)\n\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        tree_a, tree_b = [a_root], [b_root]\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, a_root)\n        self._grid_add(grid_b, b_root)\n        nodes.extend([a_root, b_root])\n\n        for it in range(self.max_iter):\n            expand_a = (it % 2 == 0)\n            tree = tree_a if expand_a else tree_b\n            other_tree = tree_b if expand_a else tree_a\n            grid = grid_a if expand_a else grid_b\n            other_grid = grid_b if expand_a else grid_a\n            attractor = self.goal if expand_a else self.start\n\n            q_rand = self._sample(attractor)\n            if q_rand is None:\n                continue\n\n            parent = self._nearest(grid, q_rand, tree)\n            if parent is None:\n                continue\n\n            q_new = self._steer(parent.position, q_rand, self.step)\n            if (not self._in_bounds(q_new)) or self._point_in_obs(q_new):\n                continue\n            if self._exists_close(grid, q_new, self.dupe_radius):\n                continue\n            if not self._edge_free(parent.position, q_new):\n                continue\n\n            new_node = Node(q_new, parent, parent.cost + self._dist(parent.position, q_new))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(grid, new_node)\n\n            other_near = self._nearest(other_grid, new_node.position, other_tree)\n\n            if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                path = self._merge_path(new_node, other_near, expand_a)\n                path = self._finalize_path(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            if other_near is not None:\n                ok, commit_pts, last = self._simulate_connect(other_near.position, new_node.position, self.connect_steps)\n                if ok:\n                    prev = other_near\n                    commit_ok = True\n                    for p in commit_pts:\n                        if (not self._in_bounds(p)) or self._point_in_obs(p):\n                            commit_ok = False\n                            break\n                        if not self._edge_free(prev.position, p):\n                            commit_ok = False\n                            break\n                        n2 = Node(p, prev, prev.cost + self._dist(prev.position, p))\n                        prev.add_child(n2)\n                        other_tree.append(n2)\n                        nodes.append(n2)\n                        edges.append((prev, n2))\n                        self._grid_add(other_grid, n2)\n                        prev = n2\n                    if commit_ok and self._edge_free(prev.position, new_node.position):\n                        path = self._merge_path(new_node, prev, expand_a)\n                        path = self._finalize_path(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._rng ^= (self._rng << 13) & ((1 << 64) - 1)\n        self._rng ^= (self._rng >> 7)\n        self._rng ^= (self._rng << 17) & ((1 << 64) - 1)\n        return ((self._rng & ((1 << 53) - 1)) / float(1 << 53))\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-16:\n            return tuple(a)\n        if d2 <= step * step:\n            tgt = b\n        else:\n            d = d2 ** 0.5\n            r = step / d\n            tgt = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n        return tuple(min(max(tgt[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # Node grid\n    def _grid_key(self, pos):\n        if self.is3:\n            return (int(pos[0] // self.node_cell), int(pos[1] // self.node_cell), int(pos[2] // self.node_cell))\n        else:\n            return (int(pos[0] // self.node_cell), int(pos[1] // self.node_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos, fallback_list):\n        key = self._grid_key(pos)\n        best, bestd = None, 1e100\n        for r in range(0, 3):\n            cand = self._ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd, best = d2, n\n                if best is not None:\n                    return best\n        for n in fallback_list:\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd, best = d2, n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius // self.node_cell) + 1\n        r2 = radius * radius\n        cand = self._ring_collect(grid, key, r_cells)\n        out = []\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                out.append(n)\n        return out\n\n    def _exists_close(self, grid, pos, radius):\n        return len(self._neighbors_in_radius(grid, pos, radius)) > 0\n\n    # Obstacles\n    def _build_obs_grid(self):\n        self.og_cell = max(3.0, self.step * 1.5)\n        self.ogrid = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.og_cell)\n                cy0 = int(max(0.0, y) // self.og_cell)\n                cz0 = int(max(0.0, z) // self.og_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.og_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.og_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.og_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.ogrid.get(k)\n                            if b is None:\n                                self.ogrid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.og_cell)\n                cy0 = int(max(0.0, y) // self.og_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.og_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.og_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.ogrid.get(k)\n                        if b is None:\n                            self.ogrid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _bucket_candidates(self, a, b):\n        if self.is3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.og_cell)\n            cy0 = int(max(0.0, miny) // self.og_cell)\n            cz0 = int(max(0.0, minz) // self.og_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.og_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.og_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.og_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.ogrid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            return cand\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.og_cell)\n            cy0 = int(max(0.0, miny) // self.og_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.og_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.og_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.ogrid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            return cand\n\n    def _point_in_obs(self, p):\n        if self.is3:\n            cx = int(p[0] // self.og_cell)\n            cy = int(p[1] // self.og_cell)\n            cz = int(p[2] // self.og_cell)\n            bucket = self.ogrid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if (ox <= x <= ox + w) and (oy <= y <= oy + h) and (oz <= z <= oz + d):\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.og_cell)\n            cy = int(p[1] // self.og_cell)\n            bucket = self.ogrid.get((cx, cy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if (ox <= x <= ox + w) and (oy <= y <= oy + h):\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        cand = self._bucket_candidates(a, b)\n        if not cand:\n            return False\n        if self.is3:\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(self.dim):\n            d = p1[i] - p0[i]\n            if abs(d) < 1e-12:\n                if p0[i] < bmin[i] or p0[i] > bmax[i]:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (bmin[i] - p0[i]) * inv\n                tB = (bmax[i] - p0[i]) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Sampling\n    def _sample(self, attractor):\n        for _ in range(12):\n            if self._rand() < self.goal_bias:\n                p = attractor\n            else:\n                if self.is3:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(p) and (not self._point_in_obs(p)):\n                return p\n        return None\n\n    # Connect and path utilities\n    def _simulate_connect(self, start_pos, target_pos, steps):\n        pts = []\n        cur = start_pos\n        for _ in range(steps):\n            nxt = self._steer(cur, target_pos, self.step)\n            if (not self._in_bounds(nxt)) or self._point_in_obs(nxt):\n                return False, [], cur\n            if not self._edge_free(cur, nxt):\n                return False, [], cur\n            pts.append(nxt)\n            cur = nxt\n            if self._edge_free(cur, target_pos):\n                return True, pts, cur\n        if self._edge_free(cur, target_pos):\n            return True, pts, cur\n        return False, pts, cur\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_path(self, a_end, b_end, a_forward):\n        pa = self._path_to_root(a_end)\n        pb = self._path_to_root(b_end)\n        if a_forward:\n            return pa + pb[::-1]\n        else:\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _vis_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-12 <= bestL:\n                    cur = cand\n                    bestL = L\n            tries += 1\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._vis_prune(path)\n        p1 = self._shortcut(p0, self.shortcut_attempts)\n        p2 = self._vis_prune(p1)\n        return p2",
          "objective": -36.76802,
          "time_improvement": 65.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1882.0,
          "node_improvement": 83.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013627099990844726,
                    "num_nodes_avg": 84.7,
                    "path_length_avg": 174.56569007096033,
                    "smoothness_avg": 0.048326840248883916,
                    "success_improvement": 0.0,
                    "time_improvement": 44.76535796186469,
                    "node_improvement": 78.67036011080333,
                    "length_improvement": 4.317779101732099,
                    "smoothness_improvement": 656.4199933083113,
                    "objective_score": 19.302374816140222
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0202009916305542,
                    "num_nodes_avg": 136.8,
                    "path_length_avg": 237.0938391096177,
                    "smoothness_avg": 0.1283977633324745,
                    "success_improvement": 0.0,
                    "time_improvement": 87.92179374600857,
                    "node_improvement": 90.80830477726265,
                    "length_improvement": 20.851252137438184,
                    "smoothness_improvement": 3203.76693171538,
                    "objective_score": 54.90612406484238
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018436336517333986,
                    "num_nodes_avg": 164.0,
                    "path_length_avg": 130.18358877739544,
                    "smoothness_avg": 0.1482704890864588,
                    "success_improvement": 0.0,
                    "time_improvement": 63.47556404916617,
                    "node_improvement": 79.14812460267005,
                    "length_improvement": 13.538259010389897,
                    "smoothness_improvement": 1785.9896769906786,
                    "objective_score": 36.09557300593718
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "AURORA-IBiRRT* (Adaptive Unified Rewire-Connect Optimal Bi-directional RRT with Elastic Smoothing): A bidirectional, informed, grid-accelerated RRT* variant that symmetrically guides samples toward the opposite root, selects best parents by accumulated cost with ancestor compression, performs bounded local rewiring, and attempts multi-neighbor lazy connects with short validated chains. It uses obstacle-binned collision checks and maintains coherent trees. The resulting path is refined by visibility collapse and an elastic-band smoother that can accept tiny length increases for large curvature reductions, followed by opportunistic shortcutting.",
          "planning_mechanism": "Alternate expanding start and goal trees. Each iteration: draw a guided sample (goal/corridor/uniform, switch to informed ellipse after an incumbent), gated by a symmetric cone using the active root-to-target direction; steer; pick a best-cost parent from k-near via spatial hash, compress to a visible ancestor, validate node and edge, insert, then locally rewire neighbors. Try to connect to k near nodes in the opposite tree by direct line-of-sight or a short, validated step chain; on success, extract a bi-tree path, visibility-collapse, apply elastic smoothing with curvature-aware acceptance, shortcut, re-smooth, and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children) - 1, -1, -1):\n            if self.children[i] is child:\n                del self.children[i]\n                break\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=6.5,\n                 goal_bias=0.22,\n                 corridor_bias=0.28,\n                 ellipse_bias=0.55,\n                 grid_cell_factor=1.6,\n                 neighbor_radius_factor=2.2,\n                 k_parent=8,\n                 k_rewire=8,\n                 connect_radius_factor=2.8,\n                 connect_steps=4,\n                 smoothing_attempts=80,\n                 elastic_iters=24,\n                 min_sep_ratio=0.22):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.ellipse_bias = float(ellipse_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neigh_factor = float(neighbor_radius_factor)\n        self.k_parent = int(max(1, k_parent))\n        self.k_rewire = int(max(0, k_rewire))\n        self.connect_radius_factor = float(connect_radius_factor)\n        self.connect_steps = int(max(1, connect_steps))\n        self.smoothing_attempts = int(max(0, smoothing_attempts))\n        self.elastic_iters = int(max(0, elastic_iters))\n        self.min_sep_ratio = float(min_sep_ratio)\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self._is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if hasattr(map, \"obstacles\") and map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n\n        # Spatial parameters\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.neigh_radius = max(self.step * 1.2, self.step * self.neigh_factor)\n        self.min_sep = max(0.25, self.step * self.min_sep_ratio)\n        self.cstep = max(self.step, 1.5 * self.step)\n        self.connect_radius = max(self.step, self.connect_radius_factor * self.step)\n\n        # Build obstacle bins for fast collision lookups\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early trivial solution\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize trees and spatial grids\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        Ta, Tb = [a_root], [b_root]\n        nodes.extend([a_root, b_root])\n        GA, GB = {}, {}\n\n        self._grid_add(GA, a_root)\n        self._grid_add(GB, b_root)\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            # Choose active/other trees\n            if (it & 1) == 0:\n                A, B = Ta, Tb\n                GAct, GOth = GA, GB\n                root_act, root_oth = self.start, self.goal\n            else:\n                A, B = Tb, Ta\n                GAct, GOth = GB, GA\n                root_act, root_oth = self.goal, self.start\n\n            # Sample with symmetric cone gating\n            sp = self._guided_sample(root_act, root_oth, best_len)\n            if sp is None:\n                continue\n\n            # Nearest and steering\n            anchor = self._nearest(GAct, sp)\n            newp = self._steer(anchor.position, sp, self.step)\n\n            # Prechecks\n            if (not self._in_bounds(newp)) or self._point_blocked(newp):\n                continue\n            if self._too_close(GAct, newp, self.min_sep):\n                continue\n\n            # Best parent among k nearest\n            neigh = self._neighbors(GAct, newp, self.neigh_radius)\n            cands = self._k_nearest(neigh if neigh else [anchor], newp, self.k_parent)\n            parent, gbest = None, 1e100\n            for nb in cands:\n                if not self._edge_free(nb.position, newp):\n                    continue\n                gc = nb.cost + self._dist(nb.position, newp)\n                if gc < gbest:\n                    parent, gbest = nb, gc\n\n            if parent is None:\n                continue\n\n            # Ancestor compression (up to 4 hops) if visible and cheaper\n            hops = 0\n            anc = parent\n            while anc is not None and anc.parent is not None and hops < 4:\n                up = anc.parent\n                if self._edge_free(up.position, newp):\n                    gc = up.cost + self._dist(up.position, newp)\n                    if gc + 1e-12 < gbest:\n                        parent, gbest = up, gc\n                anc = up\n                hops += 1\n\n            # Both checks before adding\n            if self._point_blocked(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, gbest)\n            parent.add_child(nn)\n            A.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(GAct, nn)\n\n            # Lite local rewiring\n            if self.k_rewire > 0:\n                self._rewire_local(nn, GAct, edges)\n\n            # Multi-neighbor lazy connect to other tree\n            meet_node = None\n            near_o = self._neighbors(GOth, nn.position, self.connect_radius)\n            if not near_o:\n                near_o = [self._nearest(GOth, nn.position)]\n\n            # Evaluate multiple meet candidates and pick the best path length\n            best_meet = None\n            best_meet_len = 1e100\n            best_chain = None\n\n            for cand in self._k_nearest(near_o, nn.position, min(6, max(1, len(near_o)))):\n                if cand is None:\n                    continue\n                # Direct line of sight\n                if self._edge_free(cand.position, nn.position):\n                    # estimate length\n                    L = self._estimate_bipath_len(nn, cand)\n                    if L < best_meet_len:\n                        best_meet_len = L\n                        best_meet = cand\n                        best_chain = None\n                    continue\n                # Short validated chain from cand towards nn (do not bloat if fails)\n                ok, chain_positions = self._ghost_chain_positions(cand.position, nn.position, self.connect_steps, self.cstep)\n                if ok:\n                    # If last in chain connects to nn, this is a candidate; we will later commit it\n                    lastp = chain_positions[-1] if chain_positions else cand.position\n                    if self._edge_free(lastp, nn.position):\n                        # Estimate using chain\n                        L = self._estimate_bipath_len(nn, cand)  # rough estimate; acceptable\n                        if L < best_meet_len:\n                            best_meet_len = L\n                            best_meet = cand\n                            best_chain = chain_positions\n\n            if best_meet is not None:\n                # If a chain was proposed, commit it with both checks at each step\n                commit_target = best_meet\n                if best_chain:\n                    prev = best_meet\n                    okc = True\n                    for p in best_chain:\n                        if (not self._in_bounds(p)) or self._point_blocked(p):\n                            okc = False\n                            break\n                        if not self._edge_free(prev.position, p):\n                            okc = False\n                            break\n                        # Add node into B\n                        nb = Node(p, prev, prev.cost + self._dist(prev.position, p))\n                        prev.add_child(nb)\n                        B.append(nb)\n                        nodes.append(nb)\n                        edges.append((prev, nb))\n                        self._grid_add(GOth, nb)\n                        prev = nb\n                    if okc:\n                        commit_target = prev\n                    else:\n                        commit_target = best_meet\n\n                # Final snap check (do not add cross-edge; we only use it for path extraction)\n                if self._edge_free(commit_target.position, nn.position):\n                    path = self._extract_path(nn, commit_target, forward_from_a=(root_act == self.start))\n                    rawL = self._path_len(path)\n                    if best_len is None or rawL < best_len:\n                        best_len = rawL\n                    path = self._finalize_path(path)\n                    return PlannerResult(True, path, Ta + Tb, edges)\n\n        return PlannerResult(False, [], Ta + Tb, edges)\n\n    # ---------- RNG ----------\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            iv = int((v + 0.5) * 1103515245) & 0xffffffff\n            s ^= (iv + 0x9E3779B9 + ((s << 6) & 0xffffffff) + (s >> 2))\n            s &= 0xffffffff\n        s ^= (len(self.obstacles) + 1) * 2654435761 & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _randu(self):\n        # xorshift32\n        x = self._rng\n        x ^= (x << 13) & 0xffffffff\n        x ^= (x >> 17) & 0xffffffff\n        x ^= (x << 5) & 0xffffffff\n        self._rng = x & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._randu()\n\n    # ---------- Geometry ----------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # ---------- Spatial hashing ----------\n    def _cell_key(self, p):\n        if self._is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _neighbors(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        span = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self._is3:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        # expanding rings up to 3; fallback scan\n        for r in range(0, 4):\n            cand = []\n            if self._is3:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                            if lst:\n                                cand += lst\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy))\n                        if lst:\n                            cand += lst\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                if best is not None:\n                    return best\n        # fallback\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _k_nearest(self, nodes, pos, k):\n        # Partial selection by squared distance\n        if not nodes:\n            return []\n        buf = []\n        for nd in nodes:\n            buf.append((self._dist2(nd.position, pos), nd))\n        buf.sort(key=lambda t: t[0])\n        out = []\n        m = min(k, len(buf))\n        for i in range(m):\n            out.append(buf[i][1])\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        neigh = self._neighbors(grid, pos, radius)\n        return len(neigh) > 0\n\n    # ---------- Obstacles & collision ----------\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.6)\n        self.obin = {}\n        if self._is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            self._obin_add((i, j, k), idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        self._obin_add((i, j), idx)\n\n    def _obin_add(self, key, idx):\n        lst = self.obin.get(key)\n        if lst is None:\n            self.obin[key] = [idx]\n        else:\n            lst.append(idx)\n\n    def _bucket_candidates(self, a, b):\n        if self._is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self.obin.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            return cand\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self.obin.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            return cand\n\n    def _point_blocked(self, p):\n        if self._is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            lst = self.obin.get((ix, iy, iz))\n            if not lst:\n                return False\n            x, y, z = p\n            for idx in lst:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            lst = self.obin.get((ix, iy))\n            if not lst:\n                return False\n            x, y = p\n            for idx in lst:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        cand = self._bucket_candidates(a, b)\n        if not cand:\n            return True\n        if self._is3:\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            q = p1[i]\n            d = q - p\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # ---------- Rewiring ----------\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                del edges[i]\n                break\n\n    def _propagate_cost(self, node, delta):\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    def _rewire_local(self, new_node, grid, edges):\n        neigh = self._neighbors(grid, new_node.position, self.neigh_radius)\n        if not neigh:\n            return\n        cands = self._k_nearest(neigh, new_node.position, self.k_rewire)\n        for nb in cands:\n            if nb is new_node or nb is new_node.parent:\n                continue\n            # avoid cycles\n            cur = new_node\n            cyc = False\n            while cur is not None:\n                if cur is nb:\n                    cyc = True\n                    break\n                cur = cur.parent\n            if cyc:\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            cand_cost = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand_cost + 1e-9 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, oldp, nb)\n                new_node.add_child(nb)\n                edges.append((new_node, nb))\n                delta = cand_cost - nb.cost\n                nb.cost = cand_cost\n                self._propagate_cost(nb, delta)\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, root_act, root_oth, incumbent_len):\n        tries = 20\n        while tries > 0:\n            tries -= 1\n            r = self._randu()\n            if incumbent_len is not None and r < self.ellipse_bias:\n                p = self._sample_in_ellipse(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                r2 = self._randu()\n                if r2 < self.goal_bias:\n                    p = root_oth\n                elif r2 < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_point()\n                else:\n                    if self._is3:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]),\n                             self._rand_range(0.0, self.bounds[2]))\n                    else:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]))\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            # Symmetric cone gating: gate by direction from active root toward opposite root\n            v_to_p = tuple(p[i] - root_act[i] for i in range(self.dim))\n            v_to_oth = tuple(root_oth[i] - root_act[i] for i in range(self.dim))\n            if self._cos_align(v_to_p, v_to_oth) < -0.1 and self._randu() < 0.5:\n                continue\n            return p\n        return None\n\n    def _cos_align(self, a, b):\n        na, nb, dp = 0.0, 0.0, 0.0\n        for i in range(self.dim):\n            na += a[i] * a[i]\n            nb += b[i] * b[i]\n            dp += a[i] * b[i]\n        if na <= 1e-18 or nb <= 1e-18:\n            return 1.0\n        return dp / ((na ** 0.5) * (nb ** 0.5))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(20):\n            if self._is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            if self._dist(p, f1) + self._dist(p, f2) <= max_sum + 1e-9:\n                return p\n        return None\n\n    def _corridor_point(self):\n        t = self._randu()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step, 0.06 * sg)\n        if self._is3:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            oz = self._rand_range(-w, w)\n            p = (base[0] + ox, base[1] + oy, base[2] + oz)\n        else:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            p = (base[0] + ox, base[1] + oy)\n        return self._clamp(p)\n\n    # ---------- Connect helpers ----------\n    def _ghost_chain_positions(self, from_pos, to_pos, steps, step_len):\n        chain = []\n        cur = from_pos\n        for _ in range(steps):\n            nxt = self._steer(cur, to_pos, step_len)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                return False, None\n            if not self._edge_free(cur, nxt):\n                return False, None\n            chain.append(nxt)\n            cur = nxt\n            if self._edge_free(cur, to_pos):\n                break\n        if not chain:\n            return False, None\n        return True, chain\n\n    def _estimate_bipath_len(self, a_node, b_node):\n        # rough: cost to a_node + cost from b_node to its root + distance between\n        L = a_node.cost + b_node.cost + self._dist(a_node.position, b_node.position)\n        return L\n\n    # ---------- Paths and smoothing ----------\n    def _trace(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, a_node, b_node, forward_from_a=True):\n        pa = self._trace(a_node)\n        # b_node toward its root\n        pb = []\n        cur = b_node\n        while cur is not None:\n            pb.append(cur.position)\n            cur = cur.parent\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return (pa + pb) if forward_from_a else (pb[::-1] + pa[::-1])\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_collapse(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            progressed = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    progressed = True\n                    break\n                j -= 1\n            if not progressed:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _elastic_smooth(self, pts, iters=24, w=0.5, max_len_increase=0.005):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(iters):\n            changed = False\n            for k in range(1, len(cur) - 1):\n                a = cur[k - 1]\n                b = cur[k]\n                c = cur[k + 1]\n                mid = tuple(0.5 * (a[i] + c[i]) for i in range(self.dim))\n                q = tuple((1.0 - w) * b[i] + w * mid[i] for i in range(self.dim))\n                if (not self._in_bounds(q)) or self._point_blocked(q):\n                    continue\n                # Check edges\n                if not (self._edge_free(a, q) and self._edge_free(q, c)):\n                    continue\n                # Length and curvature criteria\n                oldL = self._dist(a, b) + self._dist(b, c)\n                newL = self._dist(a, q) + self._dist(q, c)\n                len_ok = (newL <= oldL * (1.0 + max_len_increase) + 1e-12)\n\n                curv_old = self._corner_cost(a, b, c)\n                curv_new = self._corner_cost(a, q, c)\n                # Accept if not longer, or tiny increase buys meaningful curvature reduction\n                if len_ok and (newL <= oldL + 1e-12 or curv_new + 1e-12 < 0.85 * curv_old):\n                    cur[k] = q\n                    changed = True\n            if not changed:\n                break\n        return cur\n\n    def _corner_cost(self, a, b, c):\n        # 1 - cosine of angle at b, scaled by segment lengths to de-emphasize tiny edges\n        v1 = tuple(b[i] - a[i] for i in range(self.dim))\n        v2 = tuple(c[i] - b[i] for i in range(self.dim))\n        n1 = (sum(v1[i] * v1[i] for i in range(self.dim))) ** 0.5\n        n2 = (sum(v2[i] * v2[i] for i in range(self.dim))) ** 0.5\n        if n1 < 1e-9 or n2 < 1e-9:\n            return 0.0\n        cosang = sum(v1[i] * v2[i] for i in range(self.dim)) / (n1 * n2)\n        if cosang > 1.0:\n            cosang = 1.0\n        if cosang < -1.0:\n            cosang = -1.0\n        return 1.0 - cosang\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a, b = cur[i], cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-9 <= bestL:\n                    cur = cand\n                    bestL = L\n            tries += 1\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path[:]\n        p1 = self._visibility_collapse(path)\n        p2 = self._elastic_smooth(p1, iters=self.elastic_iters, w=0.55, max_len_increase=0.006)\n        p3 = self._shortcut(p2, self.smoothing_attempts)\n        p4 = self._elastic_smooth(p3, iters=max(8, self.elastic_iters // 2), w=0.5, max_len_increase=0.004)\n        return p4",
          "objective": -36.64471,
          "time_improvement": 59.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1360.0,
          "node_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011651158332824707,
                    "num_nodes_avg": 58.0,
                    "path_length_avg": 156.0637914065294,
                    "smoothness_avg": 0.04615392285067924,
                    "success_improvement": 0.0,
                    "time_improvement": 52.77443034280418,
                    "node_improvement": 85.39410727776378,
                    "length_improvement": 14.458962941052569,
                    "smoothness_improvement": 622.4091174607547,
                    "objective_score": 27.619752454776567
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022267484664916994,
                    "num_nodes_avg": 102.0,
                    "path_length_avg": 225.72102057026777,
                    "smoothness_avg": 0.08695574697277104,
                    "success_improvement": 0.0,
                    "time_improvement": 86.68623414834413,
                    "node_improvement": 93.14654303567829,
                    "length_improvement": 24.64782631430452,
                    "smoothness_improvement": 2137.434001302351,
                    "objective_score": 51.481736039597706
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03081855773925781,
                    "num_nodes_avg": 127.0,
                    "path_length_avg": 119.0787979417283,
                    "smoothness_avg": 0.11165176730825668,
                    "success_improvement": 0.0,
                    "time_improvement": 38.94500476348596,
                    "node_improvement": 83.8525111252384,
                    "length_improvement": 20.913532330124678,
                    "smoothness_improvement": 1320.2022388848293,
                    "objective_score": 30.83263202154474
               }
          ],
          "success_rate": 1.0
     }
]