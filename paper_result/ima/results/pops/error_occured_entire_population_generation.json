{
    "operator": "e2",
    "algorithm_description": "This algorithm is a hybrid bidirectional RRT* with adaptive rewiring, incremental connection, informed sampling, and path smoothing. It grows two trees from start and goal, alternately extending and rewiring them with adaptive neighbor radius and goal bias. The trees attempt incremental connections with rewiring to optimize path cost. After solution discovery or timeout, randomized shortcut smoothing is applied to improve path smoothness and length. Collision checks and map bounds are strictly enforced throughout. This efficient, robust planner improves convergence speed, path quality, and smoothness while respecting a hard 30-second runtime limit.",
    "planning_mechanism": "The planner alternates growing two RRT* trees with adaptive rewiring and informed sampling to efficiently explore and optimize paths. Incremental, cost-aware connections between trees increase success and path quality. Early best-path extraction and randomized shortcut smoothing improve smoothness and reduce path length. Strict collision and boundary checks ensure safe feasible paths at every step. Runtime is bounded by wall-clock time for practical responsiveness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float, ...]\n        self.parent = parent      # Node or None\n        self.cost = cost          # Cost-to-come\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update children's costs\n        self._update_children_costs()\n\n    def _update_children_costs(self):\n        for c in self.children:\n            old_cost = c.cost\n            c.cost = self.cost + distance(self.position, c.position)\n            if abs(c.cost - old_cost) > 1e-6:\n                c._update_children_costs()\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=10000, step_size: float=5.0, goal_sample_rate: float=0.1,\n                 min_neighbor_radius: float=10.0, max_neighbor_radius: float=30.0, smoothing_iters: int=100,\n                 time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.smoothing_iters = smoothing_iters\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math, time\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialization\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = tree_start + tree_goal\n        edges = []\n        success = False\n        best_path = []\n        best_cost = float('inf')\n\n        # For informed sampling ellipsoid parameters\n        def heuristic_cost(p1, p2):\n            return distance(p1, p2)\n\n        # Adaptive neighbor radius based on number of nodes\n        def neighbor_radius(n_nodes):\n            r = max(self.min_neighbor_radius,\n                    min(self.max_neighbor_radius,\n                        self.step_size * (math.log(n_nodes+1)/(n_nodes+1))**(1/dim)))\n            return r\n\n        # Collision & Bound Checks\n        def in_bounds(p):\n            for d in range(dim):\n                if not (0 <= p[d] <= bounds[d]):\n                    return False\n            return True\n\n        def is_valid_node(p):\n            return in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def is_valid_edge(p1, p2):\n            return (in_bounds(p1) and in_bounds(p2) and\n                    (not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=max(self.step_size/2,0.5))))\n\n        def steer(from_p, to_p):\n            d = distance(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        # Select parent with minimal cost to new_node among neighbors\n        def choose_best_parent(new_pos, neighbors):\n            min_cost = float('inf')\n            best_parent = None\n            for node in neighbors:\n                if is_valid_edge(node.position, new_pos):\n                    c = node.cost + distance(node.position, new_pos)\n                    if c < min_cost:\n                        min_cost = c\n                        best_parent = node\n            return best_parent, min_cost\n\n        # Rewire neighbors if beneficial\n        def rewire_neighbors(new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                new_cost = new_node.cost + distance(new_node.position, neighbor.position)\n                if new_cost + 1e-9 < neighbor.cost and is_valid_edge(new_node.position, neighbor.position):\n                    # Update parent\n                    edges_remove = [(neighbor.parent, neighbor)] if neighbor.parent else []\n                    for e in edges_remove:\n                        if e in edges:\n                            edges.remove(e)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        # Get neighbors within radius\n        def get_neighbors(tree, p, radius):\n            return [node for node in tree if distance(node.position, p) <= radius]\n\n        # Incremental extend and rewire a single tree toward a sample point\n        def extend_and_rewire(tree, other_tree, sample):\n            nearest = min(tree, key=lambda n: distance(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not is_valid_node(new_pos):\n                return None\n            if not is_valid_edge(nearest.position, new_pos):\n                return None\n            radius = neighbor_radius(len(tree))\n            neighbors = get_neighbors(tree, new_pos, radius)\n            best_parent, best_cost = choose_best_parent(new_pos, neighbors)\n            if best_parent is None:\n                best_parent = nearest\n                best_cost = nearest.cost + distance(nearest.position, new_pos)\n                if not is_valid_edge(nearest.position, new_pos):\n                    return None\n            new_node = Node(new_pos)\n            new_node.parent = None\n            new_node.cost = 0.0\n            new_node.update_parent(best_parent, best_cost)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            # Rewire neighbors\n            rewire_neighbors(new_node, neighbors)\n\n            # Attempt incremental connection to other tree\n            connect_node = connect_and_rewire(other_tree, new_node)\n            if connect_node:\n                # Build path from start root and goal root\n                path_start = new_node.path_from_root()\n                path_goal = connect_node.path_from_root()\n                full_path = path_start + path_goal[::-1]\n                path_cost = full_path_cost(full_path)\n                nonlocal best_cost, best_path, success\n                if path_cost < best_cost:\n                    best_cost = path_cost\n                    best_path = full_path\n                    success = True\n                return True\n            return False\n\n        # Incrementally connect other_tree toward new_node with rewiring\n        def connect_and_rewire(tree, target_node):\n            nearest = min(tree, key=lambda n: distance(n.position, target_node.position))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_node.position)\n                if not is_valid_node(new_pos) or not is_valid_edge(current.position, new_pos):\n                    return None\n                radius = neighbor_radius(len(tree))\n                neighbors = get_neighbors(tree, new_pos, radius)\n                best_parent, best_cost = choose_best_parent(new_pos, neighbors)\n                if best_parent is None:\n                    best_parent = current\n                    best_cost = current.cost + distance(current.position, new_pos)\n                    if not is_valid_edge(current.position, new_pos):\n                        return None\n                new_node = Node(new_pos)\n                new_node.parent = None\n                new_node.cost = 0.0\n                new_node.update_parent(best_parent, best_cost)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                rewire_neighbors(new_node, neighbors)\n                if distance(new_pos, target_node.position) <= self.step_size:\n                    # Final edge to target_node if collision free\n                    if is_valid_edge(new_pos, target_node.position):\n                        if target_node.parent is None:\n                            # Connect target_node to new_node as parent if better\n                            edge_cost = new_node.cost + distance(new_pos, target_node.position)\n                            if (target_node.cost == 0.0) or (edge_cost < target_node.cost):\n                                target_node.update_parent(new_node, edge_cost)\n                                edges.append((new_node, target_node))\n                                if target_node not in tree:\n                                    tree.append(target_node)\n                                if target_node not in nodes:\n                                    nodes.append(target_node)\n                        return target_node\n                    else:\n                        return None\n                current = new_node\n                if time.monotonic()-start_time > self.time_limit_sec:\n                    return None\n\n        def full_path_cost(path):\n            c = 0.0\n            for i in range(1, len(path)):\n                c += distance(path[i-1], path[i])\n            return c\n\n        # Informed sampling ellipsoid between start and goal\n        def informed_sample():\n            if not success:\n                # Uniform random\n                while True:\n                    p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if is_valid_node(p):\n                        return p\n            c_best = best_cost if success else float('inf')\n            c_min = distance(start_pos, goal_pos)\n            if c_best == float('inf') or c_best <= c_min:\n                # No improvement, uniform sampling until solution found\n                while True:\n                    p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if is_valid_node(p):\n                        return p\n            # Ellipsoidal sampling between start and goal\n            import math\n            import random\n            import numpy as np\n\n            a1 = np.array(start_pos)\n            a2 = np.array(goal_pos)\n            c = (a1 + a2) / 2.0\n            if dim == 3:\n                unit_vec = (a2 - a1)/np.linalg.norm(a2 - a1)\n                I = np.eye(dim)\n                M = np.outer(unit_vec, unit_vec)\n                C = M + 1e-6 * (I - M)\n            else:\n                unit_vec = (a2 - a1)/np.linalg.norm(a2 - a1)\n                I = np.eye(dim)\n                M = np.outer(unit_vec, unit_vec)\n                C = M + 1e-6 * (I - M)\n            r1 = c_best/2.0\n            r2 = math.sqrt(c_best**2 - c_min**2)/2.0 if c_best > c_min else 0.0\n            lengths = np.array([r1] + [r2]*(dim-1))\n            while True:\n                # Sample point in unit ball\n                sample = np.random.normal(0,1,dim)\n                sample = sample/np.linalg.norm(sample)\n                rad = random.random()**(1.0/dim)\n                sample = sample * rad\n                p_sample = c + np.dot(np.linalg.cholesky(C), sample*lengths)\n                p_t = tuple(float(x) for x in p_sample)\n                if is_valid_node(p_t):\n                    return p_t\n\n        iter_count = 0\n        # Alternate trees\n        tree_a = tree_start\n        tree_b = tree_goal\n        while iter_count < self.max_iter:\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n            # Sample point with goal bias and informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample_point = goal_pos\n            else:\n                sample_point = informed_sample()\n            extended = extend_and_rewire(tree_a, tree_b, sample_point)\n            # Swap trees to alternate growth\n            tree_a, tree_b = tree_b, tree_a\n            iter_count += 1\n\n        # If no success, attempt best partial path from closest pairs\n        if not success:\n            # Try connect closest pair for partial path\n            from_nodes = tree_start\n            to_nodes = tree_goal\n            min_pair_dist = float('inf')\n            best_pair = (None, None)\n            for n1 in from_nodes:\n                for n2 in to_nodes:\n                    d = distance(n1.position, n2.position)\n                    if d < min_pair_dist and is_valid_edge(n1.position, n2.position):\n                        min_pair_dist = d\n                        best_pair = (n1,n2)\n            if best_pair[0] is not None and best_pair[1] is not None:\n                path1 = best_pair[0].path_from_root()\n                path2 = best_pair[1].path_from_root()\n                best_path = path1 + path2[::-1]\n                success = False  # Because not connected via edge actually\n        # Post-process best_path with smoothing\n        if best_path and len(best_path) > 2:\n            best_path = self._shortcut_smooth(best_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, bounds):\n        import random\n        import math\n        path = path[:]\n        def dist_ind(i,j):\n            return math.dist(path[i], path[j])\n        def is_collision_free(p1, p2):\n            return (self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=1.0) is False)\n        length = len(path)\n        if length < 3:\n            return path\n        for _ in range(self.smoothing_iters):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i+2, len(path) -1)\n            if is_collision_free(path[i], path[j]):\n                # shortcut path segment\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 181\nSyntaxError: name 'best_cost' is used prior to nonlocal declaration\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 120, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 75, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": "The algorithm is a Bidirectional Informed RRT* with Adaptive Radius and Incremental Tree Rewiring, combined with Post-Processing Path Smoothing and Early Pruning. It efficiently grows two trees from start and goal by focused ellipsoidal informed sampling, adaptive connection radius proportional to the tree size, and incremental connection attempts, allowing continuous rewiring for path cost improvement. Rigorous collision checking and dynamic parent-child relationship management maintain tree consistency while incrementally improving path quality. Finally, a path smoothing step reduces waypoint redundancy and path sharpness. The approach balances exploration and exploitation, ensuring rapid convergence, robust and high-quality path finding with reduced search times and smoother final paths.",
    "planning_mechanism": "The planner alternates growing two trees with adaptive neighbor radii, employs ellipsoidal informed sampling after initial solutions to focus search, incrementally connects trees with rewiring and dynamic cost updates, and performs smoothing on the extracted path to optimize smoothness and length. Collision checks prevent invalid expansions, and a hard 30-second timeout ensures practical runtime while always returning the best found path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\n        # Recursively update children cost to keep consistency\n        for c in self.children:\n            dist = math.dist(self.position, c.position)\n            c.update_parent(self, self.cost + dist)\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, delay_limit=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.delay_limit = delay_limit  # seconds hard time limit\n\n    def plan(self, map):\n        bounds = map.size\n        start_p = map.start\n        goal_p = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start_p)]\n        tree_goal = [Node(goal_p)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_min = math.dist(start_p, goal_p)\n        c_best = float(\"inf\")\n        best_path = []\n        success = False\n\n        # Start timing for hard limit\n        start_time = time.monotonic()\n\n        # Adaptive neighbor radius parameters\n        eta = self.step_size\n        gamma_rrt_star = 50.0 if dim==2 else 60.0  # Scaling for radius constant\n\n        def adaptive_radius(n_nodes):\n            # Radius adaptive per RRT* theoretical bound\n            r = min(eta * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dim), eta * 50)\n            return max(r, eta * 0.5)\n\n        # Precompute rotation and scaling matrix for informed sampling\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                # Uniform sample anywhere\n                while True:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n            # Else ellipsoidal informed sampling\n            from_pos = start_p\n            to_pos = goal_p\n            x_center = [(s + g) / 2 for s, g in zip(from_pos, to_pos)]\n            diff = [g - s for s, g in zip(from_pos, to_pos)]\n            dist_d = math.dist(from_pos, to_pos)\n            # unit vector from start to goal\n            if dist_d == 0:\n                return tuple(x_center)\n            a1 = [x / dist_d for x in diff]\n\n            # Construct orthonormal basis via Gram-Schmidt\n            def orthonormal_basis(v):\n                basis = [v]\n                for i in range(dim-1):\n                    vec = [0]*dim\n                    vec[i if i < dim else dim-1] = 1\n                    for b in basis:\n                        proj = sum(vec[j]*b[j] for j in range(dim))\n                        vec = [vec[j]-proj*b[j] for j in range(dim)]\n                    norm = math.sqrt(sum(x*x for x in vec))\n                    if norm > 1e-10:\n                        basis.append([x/norm for x in vec])\n                return basis\n\n            basis = orthonormal_basis(a1) if dim>1 else [a1]\n\n            # Rotation matrix from unit vector to x-axis\n            # To apply rotation efficiently, derive basis matrix B^T (columns are basis vectors)\n            B = [list(col) for col in zip(*basis)]  # transpose to get columns as basis\n            # Inverse of orthonormal matrix = transpose\n            B_T = [list(row) for row in zip(*B)]\n\n            r1 = c_best / 2.0\n            if c_best*c_best - c_min*c_min < 0:\n                r2 = 0.0\n            else:\n                r2 = math.sqrt(max(0., c_best*c_best - c_min*c_min)) / 2.0\n            L_diag = [r1] + [r2]*(dim-1)\n\n            while True:\n                # Sample uniformly in unit ball scaled to ellipsoid\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-10:\n                    continue\n                x_ball = [x / norm_ball for x in x_ball]\n                radius = random.random() ** (1/dim)\n                x_ball = [x * radius for x in x_ball]\n\n                # Scale and rotate\n                x_scaled = [L_diag[i]*x_ball[i] for i in range(dim)]\n                # multiply by B_T: x_rand = B_T * x_scaled + x_center\n                x_rand = []\n                for i in range(dim):\n                    s = 0.\n                    for j in range(dim):\n                        s += B_T[i][j]*x_scaled[j]\n                    x_rand.append(s + x_center[i])\n                # Clip to bounds and collision check\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    p = tuple(x_rand)\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        # Helper to steer from 'from_pos' to 'to_pos' with max step_size\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[i] + ratio*(to_pos[i]-from_pos[i]) for i in range(len(from_pos)))\n\n        # Extract path from start tree node and goal tree node\n        def extract_path(n_start, n_goal):\n            path_start = []\n            node = n_start\n            while node is not None:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n\n            path_goal = []\n            node = n_goal\n            nodes_goal_chain = []\n            while node is not None:\n                nodes_goal_chain.append(node)\n                node = node.parent\n            path_goal = [n.position for n in nodes_goal_chain]\n\n            return path_start + path_goal\n\n        # Path smoothing by shortcutting collisions along the path\n        def smooth_path(path):\n            if len(path) <= 2:\n                return path[:]\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) -1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(smoothed[-1], path[j], obstacles, is_3d, resolution= self.step_size/3):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        # Find nearest node in given tree to point p\n        def nearest(tree, p):\n            return min(tree, key=lambda node: math.dist(node.position, p))\n\n        # Find nodes near point p within radius\n        def near(tree, p, r):\n            result = []\n            r2 = r*r\n            for node in tree:\n                d2 = sum((node.position[i]-p[i])**2 for i in range(dim))\n                if d2 <= r2:\n                    result.append(node)\n            return result\n\n        # Incremental connect, tries to connect node_new to tree_other by multiple small steps\n        def incremental_connect(node_new, tree_other):\n            # Greedy approach: from node_new position -> nearest node_other\n            node_other = nearest(tree_other, node_new.position)\n            direction = tuple(node_other.position[i] - node_new.position[i] for i in range(dim))\n            dist_total = math.dist(node_new.position, node_other.position)\n            steps = max(1, int(dist_total / eta))\n            last_node = node_new\n\n            for step_i in range(1, steps + 1):\n                interp_pos = tuple(node_new.position[i] + direction[i]*step_i/steps for i in range(dim))\n                if self._is_in_obstacle(interp_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, interp_pos, obstacles, is_3d, resolution=eta/3):\n                    return None\n                new_cost = last_node.cost + math.dist(last_node.position, interp_pos)\n                # Check cost pruning: only continue if this new cost + heuristic < c_best\n                heuristic = math.dist(interp_pos, goal_p)\n                if new_cost + heuristic >= c_best:\n                    return None\n                new_node = Node(interp_pos, last_node, new_cost)\n                last_node.add_child(new_node)\n                tree_other.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((last_node, new_node))\n                last_node = new_node\n\n            # After intermediary nodes, try connect final node\n            if last_node and node_other and not self._is_edge_in_obstacle(last_node.position, node_other.position, obstacles, is_3d, resolution=eta/3):\n                new_cost = last_node.cost + math.dist(last_node.position, node_other.position)\n                path_cost = new_cost + node_other.cost\n                nonlocal c_best, best_path, success\n                if path_cost < c_best:\n                    c_best = path_cost\n                    # Connect node_other parent link can remain (other tree)\n                    # Connect the last_node to node_other\n                    if node_other.parent is None or node_other.cost > new_cost:\n                        node_other.update_parent(last_node, new_cost)\n                    # Extract combined path\n                    best_path = extract_path(last_node, node_other)\n                    success = True\n                    return last_node, node_other\n            return None\n\n        # Rewiring near new_node for tree improvement\n        def rewire(tree, new_node, radius):\n            near_nodes = near(tree, new_node.position, radius)\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                dist_new_to_near = math.dist(new_node.position, near_node.position)\n                new_cost = new_node.cost + dist_new_to_near\n                if new_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=eta/3):\n                        near_node.update_parent(new_node, new_cost)\n                        # forcibly update edges list for bookkeeping\n                        if (near_node.parent, near_node) not in edges:\n                            edges.append((near_node.parent, near_node))\n\n        for iter in range(self.max_iter):\n            if time.monotonic() - start_time > self.delay_limit:\n                # Return best path so far within time limit\n                if len(best_path) > 1:\n                    smoothed_path = smooth_path(best_path)\n                else:\n                    smoothed_path = best_path\n                return PlannerResult(success, smoothed_path, all_nodes, edges)\n\n            # Swap trees alternate iterations (bidirectional balancing)\n            if iter % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            radius = adaptive_radius(len(tree_a))\n\n            sample_p = informed_sample()\n\n            nearest_node = nearest(tree_a, sample_p)\n            new_pos = steer(nearest_node.position, sample_p, eta)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=eta/3):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            # Early pruning by cost + heuristic\n            heuristic = math.dist(new_pos, goal_p)\n            if new_cost + heuristic >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewire neighbors\n            rewire(tree_a, new_node, radius)\n\n            # Incremental connection attempt to other tree\n            inc_connect_result = incremental_connect(new_node, tree_b)\n            if inc_connect_result:\n                # Path updated inside incremental_connect\n                pass\n\n        # After loop ends, return best path found (smoothed)\n        if len(best_path) > 1:\n            best_path = smooth_path(best_path)\n\n        return PlannerResult(success, best_path, all_nodes, edges)\n\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 245\nSyntaxError: name 'c_best' is used prior to nonlocal declaration\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is a state-of-the-art, adaptive, bi-directional RRT* variant with informed sampling and incremental rewiring. It features a dual-tree structure that grows alternately from start and goal, uses dynamic neighbor radius based on node count and space dimension, performs efficient rewiring with recursive cost updates to children, and applies post-processing path smoothing by shortcutting. The planner stops either when a high-quality path is found or when a 30-second time limit is reached, returning the best path found so far. It ensures strict obstacle and edge collision checks within map bounds, improving efficiency, path length, smoothness, robustness, and overall planning performance.",
    "planning_mechanism": "The planner builds two RRT* trees from start and goal simultaneously, alternating expansions. Sampling is biased using informed ellipse sampling when a solution exists to focus search in promising regions. Each extension performs rewiring of neighbors with adaptive search radius to locally optimize costs. Once the trees connect, the best path is constructed and further improved by iterative shortcut smoothing. Early stopping occurs when time limit or max iterations are reached, returning the best solution so far.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position       # tuple floats (2D or 3D)\n        self.parent = parent           # Node or None\n        self.cost = cost               # cost from root to this node\n        self.children = []\n        self.valid = True              # collision validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        # Update this node's parent and cost\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update costs of descendants to maintain consistency\n        self._update_children_costs()\n\n    def _update_children_costs(self):\n        for child in self.children:\n            new_cost = self.cost + distance(self.position, child.position)\n            if child.cost != new_cost:\n                child.cost = new_cost\n                child._update_children_costs()\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, max_time_sec=30.0,\n                 goal_sample_rate=0.1, neighbor_factor=2.0,\n                 smoothing_iters=50, collision_resolution=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_time_sec = max_time_sec\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.smoothing_iters = smoothing_iters\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map):\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        # Bi-directional trees from start and goal\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        edges = []  # (parent, child)\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        start_time = time.monotonic()\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fpos, tpos):\n            dist = distance(fpos, tpos)\n            steps = max(1, int(dist / self.collision_resolution))\n            for i in range(steps+1):\n                interp = tuple(fpos[j] + (tpos[j]-fpos[j]) * (i/steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist == 0:\n                return None\n            step = min(self.step_size, dist)\n            direction = tuple((to_pos[i]-from_pos[i])/dist for i in range(dim))\n            new_pos = tuple(from_pos[i] + direction[i]*step for i in range(dim))\n            if not in_bounds(new_pos):\n                return None\n            return new_pos\n\n        def get_nearest_node(nodes, point):\n            return min(nodes, key=lambda n: distance(n.position, point))\n\n        def adaptive_radius(n_nodes):\n            # RRT* neighbor radius: gamma * (log(n)/n)^(1/d) clamped by step_size * factor\n            import math\n            if n_nodes <= 1:\n                return self.step_size * self.neighbor_factor\n            r = self.neighbor_factor * ((math.log(n_nodes) / n_nodes) ** (1/dim))\n            r = max(r, self.step_size)  # minimum radius at least step_size\n            r = min(r, self.step_size * 10)  # clamp max for efficiency\n            return r\n\n        def get_near_nodes(nodes, new_pos, radius):\n            return [n for n in nodes if distance(n.position, new_pos) <= radius]\n\n        def reconstruct_path(node_from_start, node_from_goal):\n            path_start = []\n            node = node_from_start\n            while node is not None:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n\n            path_goal = []\n            node = node_from_goal\n            while node is not None:\n                path_goal.append(node.position)\n                node = node.parent\n\n            return path_start + path_goal\n\n        def try_connect_trees(n_start, n_goal):\n            if is_edge_in_obstacle(n_start.position, n_goal.position):\n                return None\n            return reconstruct_path(n_start, n_goal)\n\n        def informed_sample(cost_best):\n            # Ellipsoidal informed sampling around line start-goal\n            # If no best cost, uniform sampling\n            if cost_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            # else do informed ellipsoidal sampling\n            # Using numpy-like approach manually\n            import math\n            import random as rand\n            c_min = distance(start_pos, goal_pos)\n            if cost_best < c_min:\n                cost_best = c_min + 1e-6  # numerical safety\n\n            # Unit vector from start to goal\n            unit_vec = tuple((goal_pos[i] - start_pos[i]) / c_min for i in range(dim))\n\n            # Rotation matrix to align x-axis with unit_vec (approximate)\n            # For dim=2 or 3 only\n            if dim == 2:\n                import math\n                theta = math.atan2(unit_vec[1], unit_vec[0])\n                def rot(p):\n                    x,y = p\n                    cos_t = math.cos(theta)\n                    sin_t = math.sin(theta)\n                    return (cos_t*x - sin_t*y, sin_t*x + cos_t*y)\n                def inv_rot(p):\n                    x,y = p\n                    cos_t = math.cos(theta)\n                    sin_t = math.sin(theta)\n                    return (cos_t*x + sin_t*y, -sin_t*x + cos_t*y)\n            else:\n                # For 3D, use Gram-Schmidt orthonormal basis\n                # Here a simplified spherical sampling and projection since no numpy\n                def rot(p): return p\n                def inv_rot(p): return p\n\n            # Radii of ellipse\n            r1 = cost_best / 2.0\n            r2 = ( (cost_best**2 - c_min**2) ** 0.5 ) / 2.0 if (cost_best**2 - c_min**2) > 0 else 0.0\n            if r2 < 1e-10:\n                r2 = 1e-10\n\n            for _ in range(10):  # max 10 tries to get a sample inside ellipse\n                # Sample inside unit circle/sphere\n                if dim ==2:\n                    angle = random.uniform(0, 2*math.pi)\n                    radius = random.uniform(0,1)**0.5\n                    local_sample = (radius*math.cos(angle)*r1, radius*math.sin(angle)*r2)\n                    sample = tuple(start_pos[i] + unit_vec[i]*r1 + inv_rot(local_sample)[i] if i<2 else start_pos[i] for i in range(dim))\n                elif dim ==3:\n                    # Sample uniformly inside unit sphere\n                    import random\n                    while True:\n                        x = random.uniform(-1,1)\n                        y = random.uniform(-1,1)\n                        z = random.uniform(-1,1)\n                        if x*x + y*y + z*z <= 1:\n                            break\n                    sample = tuple(start_pos[i] + unit_vec[i]*r1 + [x*r2,y*r2,z*r2][i] if i<3 else start_pos[i] for i in range(dim))\n                else:\n                    # fallback uniform\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if in_bounds(sample) and not is_in_obstacle(sample):\n                    return sample\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def shortcut_path(path):\n            # Try smoothing path by shortcutting between random pairs if feasible\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, min(i+10, len(path)-1))\n                if not is_edge_in_obstacle(path[i], path[j]):\n                    # shortcut feasible, remove intermediate points\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Alternate expansions from both trees\n        def extend(tree_own, tree_other):\n            n_nodes = len(tree_own) + len(tree_other)\n            radius = adaptive_radius(n_nodes)\n\n            # Sample point: goal bias or informed if best path exists\n            if success and random.random() < self.goal_sample_rate:\n                sample_pt = tree_other[-1].position  # goal position in other tree\n            else:\n                sample_pt = informed_sample(best_cost)\n\n            nearest = get_nearest_node(tree_own, sample_pt)\n            new_pos = steer(nearest.position, sample_pt)\n            if new_pos is None:\n                return None, None\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest.position, new_pos):\n                return None, None\n\n            new_node = Node(new_pos)\n\n            near_nodes = get_near_nodes(tree_own, new_pos, radius)\n\n            # Choose best parent among near nodes (lowest cost + edge valid)\n            min_cost = nearest.cost + distance(nearest.position, new_pos)\n            best_parent = nearest\n            for near in near_nodes:\n                c = near.cost + distance(near.position, new_pos)\n                if c < min_cost and not is_edge_in_obstacle(near.position, new_pos):\n                    min_cost = c\n                    best_parent = near\n\n            new_node.update_parent(best_parent, min_cost)\n            tree_own.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better path through new_node\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                c_through_new = new_node.cost + distance(new_node.position, near.position)\n                if c_through_new < near.cost and not is_edge_in_obstacle(new_node.position, near.position):\n                    # Remove old edge\n                    if near.parent is not None:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                    near.update_parent(new_node, c_through_new)\n                    edges.append((new_node, near))\n\n            # Try to connect new_node to other tree\n            nearest_other = get_nearest_node(tree_other, new_node.position)\n            dist_connect = distance(new_node.position, nearest_other.position)\n            if dist_connect <= self.step_size:\n                if not is_edge_in_obstacle(new_node.position, nearest_other.position):\n                    # Construct candidate path\n                    possible_path = reconstruct_path(new_node, nearest_other)\n                    total_cost = new_node.cost + distance(new_node.position, nearest_other.position) + nearest_other.cost\n                    if total_cost < best_cost:\n                        nonlocal best_cost, best_path, success\n                        best_cost = total_cost\n                        best_path = possible_path\n                        success = True\n            return new_node, best_parent\n\n        # Main loop alternating trees\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.max_time_sec:\n                break\n            # Expand from start tree\n            new_nS, _ = extend(tree_start, tree_goal)\n            if time.monotonic() - start_time > self.max_time_sec:\n                break\n            # Expand from goal tree\n            new_nG, _ = extend(tree_goal, tree_start)\n\n            # Early exit if success found\n            if success and best_cost < float('inf'):\n                # Optionally could stop immediately here, but continue to smooth later\n                pass\n\n        if success:\n            # Post process path smoothing by shortcutting\n            smoothed_path = shortcut_path(best_path)\n            return PlannerResult(success=True, path=smoothed_path, nodes=tree_start + tree_goal, edges=edges)\n        else:\n            # No connection found, attempt best partial path if any node close to goal/start\n            # Find best candidate from start tree to goal or vice versa\n            close_to_goal = min(tree_start, key=lambda n: distance(n.position, goal_pos), default=None)\n            close_to_start = min(tree_goal, key=lambda n: distance(n.position, start_pos), default=None)\n            cand_path = []\n            cand_cost = float('inf')\n            if close_to_goal and distance(close_to_goal.position, goal_pos) <= self.step_size:\n                if not is_edge_in_obstacle(close_to_goal.position, goal_pos) and not is_in_obstacle(goal_pos):\n                    goal_node = Node(goal_pos, parent=close_to_goal,\n                                     cost=close_to_goal.cost + distance(close_to_goal.position, goal_pos))\n                    cand_path = []\n                    node = goal_node\n                    while node:\n                        cand_path.append(node.position)\n                        node = node.parent\n                    cand_path.reverse()\n                    cand_cost = goal_node.cost\n            if close_to_start and distance(close_to_start.position, start_pos) <= self.step_size:\n                # unlikely scenario but check symmetrically (no goal reached)\n                pass\n\n            if cand_cost < float('inf'):\n                smoothed_path = shortcut_path(cand_path)\n                return PlannerResult(success=False, path=smoothed_path, nodes=tree_start + tree_goal, edges=edges)\n\n            # Otherwise return empty path\n            return PlannerResult(success=False, path=[], nodes=tree_start + tree_goal, edges=edges)",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 296\nSyntaxError: name 'best_cost' is used prior to nonlocal declaration\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm, called SmartBidirectional RRT*, combines adaptive bidirectional sampling with dynamic rewiring and informed sampling bias to significantly improve planning efficiency, path quality, robustness, success rate, smoothness, and path length while reducing search time. It features adaptive neighborhood radius for rewiring, persistent best-path tracking with early termination on improvement, goal-biased sampling combined with local informed sampling near path candidates, and recursive incremental rewiring with cost propagation for continuous path refinement.",
    "planning_mechanism": "The planner incrementally grows two trees from both start and goal states, alternately sampling points with a bias toward the goal and around current best path nodes. Each new node addition triggers rewiring within an adaptive radius considering sampling density, updating parents and costs to improve path quality. Bidirectional connections are attempted incrementally, rewiring the connected branches. The algorithm records and updates the best feasible path found so far and uses early stopping once a quality threshold or time limit is reached. Path smoothing by randomized shortcutting further enhances smoothness and length reduction. Comprehensive collision checks ensure validity, and all operations maintain coherence in tree structure and cost bookkeeping.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional['Node']=None, cost: float=0.0):\n        self.position = position          # Coordinates (2D or 3D)\n        self.parent = parent              # Parent Node or None\n        self.cost = cost                  # Cost from root\n        self.children: List[Node] = []    # Children nodes list\n        self.valid = True                 # Validity flag (collision etc.)\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        new_parent.children.append(self)\n        cost_diff = new_cost - self.cost\n        self.cost = new_cost\n        # Recursively update descendants cost by cost_diff\n        stack = list(self.children)\n        while stack:\n            c = stack.pop()\n            c.cost += cost_diff\n            stack.extend(c.children)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, gamma: float=50.0, time_limit: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma          # Tuning rewiring radius constant\n        self.time_limit = time_limit\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def within_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes: List[Node] = start_tree + goal_tree\n        edges: List[Tuple[Node, Node]] = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        success = False\n\n        def is_collision_node(pos):\n            if not within_bounds(pos):\n                return True\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_collision_edge(a, b):\n            if not within_bounds(a) or not within_bounds(b):\n                return True\n            return self._is_edge_in_obstacle(a, b, obstacles, is_3d)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            return interpolate(from_pos, to_pos, self.step_size / d)\n\n        def neighborhood_radius(n_nodes):\n            # Adaptive radius per RRT* theory: gamma * (log(n)/n)^(1/dim)\n            if n_nodes <= 1:\n                return self.step_size * 5\n            radius = self.gamma * ((math.log(n_nodes) / n_nodes) ** (1/dim))\n            return min(max(radius, self.step_size), self.step_size * 30)\n\n        def neighbors(tree, point, radius):\n            result = []\n            r2 = radius * radius\n            for node in tree:\n                d2 = sum((node.position[i] - point[i]) ** 2 for i in range(dim))\n                if d2 <= r2:\n                    result.append(node)\n            return result\n\n        def try_rewire(tree, new_node):\n            # Rewire neighbors whose cost can improve via new_node\n            n_radius = neighborhood_radius(len(tree))\n            nbors = neighbors(tree, new_node.position, n_radius)\n            for nb in nbors:\n                if nb == new_node.parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nb.position)\n                if cost_through_new + 1e-8 < nb.cost:  # small epsilon to avoid oscillations\n                    nb.update_parent(new_node, cost_through_new)\n\n        def extend_and_rewire(tree, other_tree):\n            rand_pt = goal_pos if random.random() < 0.2 else self._sample_around_best(best_path, bounds, obstacles, is_3d, dim)\n            nearest = min(tree, key=lambda n: dist(n.position, rand_pt))\n            new_pos = steer(nearest.position, rand_pt)\n            if is_collision_node(new_pos): \n                return None\n            if is_collision_edge(nearest.position, new_pos):\n                return None\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Try rewiring neighbors around new_node in this tree\n            try_rewire(tree, new_node)\n\n            # Incrementally attempt connecting other tree to new_node\n            connected_node = incremental_connect_and_rewire(new_node, other_tree)\n            if connected_node:\n                # Found connection, form combined path\n                path1 = new_node.path_from_root()\n                path2 = connected_node.path_from_root()\n                path2.reverse()\n                combined_path = path1 + path2[1:]  # avoid double node pos\n                nonlocal best_path, best_cost, success\n                path_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                if path_cost < best_cost:\n                    best_cost = path_cost\n                    best_path = combined_path\n                    success = True\n                return True\n            return False\n\n        def incremental_connect_and_rewire(node_new: Node, tree: List[Node]) -> Optional[Node]:\n            # Try to extend tree toward node_new.position incrementally with rewiring until connection or fail\n            current_nearest = min(tree, key=lambda n: dist(n.position, node_new.position))\n            target_pos = node_new.position\n            last_added = None\n            for _ in range(30):  # limit extension steps to avoid infinite loops\n                new_pos = steer(current_nearest.position, target_pos)\n                if is_collision_node(new_pos) or is_collision_edge(current_nearest.position, new_pos):\n                    break\n                c_cost = current_nearest.cost + dist(current_nearest.position, new_pos)\n                candidate_node = Node(new_pos, parent=current_nearest, cost=c_cost)\n                current_nearest.add_child(candidate_node)\n                tree.append(candidate_node)\n                nodes.append(candidate_node)\n                edges.append((current_nearest, candidate_node))\n                # Rewire neighbors around candidate_node\n                try_rewire(tree, candidate_node)\n                if dist(candidate_node.position, target_pos) < self.step_size * 0.7:\n                    # Close enough, connect final virtual node with cost\n                    final_cost = candidate_node.cost + dist(candidate_node.position, target_pos)\n                    final_node = Node(target_pos, parent=candidate_node, cost=final_cost)\n                    candidate_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((candidate_node, final_node))\n                    return final_node\n                current_nearest = candidate_node\n                last_added = candidate_node\n            return None\n\n        def sample_free(bounds, obstacles, is_3d):\n            while True:\n                if is_3d:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]),\n                         random.uniform(0, bounds[2]))\n                else:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        # Sampling guided by best known path: sample around its nodes to encourage refinement\n        def sample_around_best(best_path, bounds, obstacles, is_3d, dim):\n            if not best_path or random.random() < 0.1:\n                return sample_free(bounds, obstacles, is_3d)\n            else:\n                # pick random node from best path and sample in a small ball around it\n                base = random.choice(best_path)\n                radius = self.step_size * 3\n                attempt = 0\n                while attempt < 20:\n                    sample = tuple(random.uniform(max(0, base[i] - radius), min(bounds[i], base[i] + radius)) for i in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n                    attempt += 1\n                # fallback\n                return sample_free(bounds, obstacles, is_3d)\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            # Alternate extension between start and goal trees\n            trees = [(start_tree, goal_tree), (goal_tree, start_tree)]\n            extended = False\n            for (tree_a, tree_b) in trees:\n                if time.monotonic() - start_time > self.time_limit:\n                    break\n                extended |= extend_and_rewire(tree_a, tree_b)\n                if success and best_cost < self.step_size * 2:\n                    # Early termination if path sufficiently good\n                    iter_count = self.max_iter\n                    break\n\n            iter_count += 1\n\n        # If we found a path, apply path smoothing by randomized shortcutting\n        if success:\n            best_path = self._smooth_path(best_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(success, best_path, nodes, edges)\n\n    def _smooth_path(self, path: List[Tuple[float, ...]], obstacles, is_3d, bounds, iterations: int=100) -> List[Tuple[float, ...]]:\n        path = path[:]\n        length = len(path)\n        if length < 3:\n            return path\n\n        def can_connect(a, b):\n            return not self._is_edge_in_obstacle(a, b, obstacles, is_3d)\n\n        for _ in range(iterations):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i+2, len(path) -1)\n            if can_connect(path[i], path[j]):\n                # shortcut possible, remove intermediate nodes\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.75):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 148\nSyntaxError: name 'best_path' is used prior to nonlocal declaration\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": "This algorithm is a hybrid bidirectional asymptotically optimal planner combining adaptive bidirectional informed sampling with dynamic radius rewiring and iterative path smoothing. It adaptively adjusts step sizes near obstacles, employs goal biasing, and propagates cost changes through the tree to optimize path quality and smoothness. Early termination on improvements reduces planning time, while rigorous collision checks and pruning maintain robustness and success rate.",
    "planning_mechanism": "The planner grows two trees from start and goal employing bidirectional sampling with adaptive step sizes and rewiring within a dynamically computed radius. Nodes update parents with recursive cost propagation to children, maintaining accurate cost and improving rewiring effects. The planner attempts incremental connection between trees, pruning worse branches early and continually updating the best solution path. After termination, a randomized iterative path smoothing method shortcuts the path to enhance smoothness and shorten length. The search immediately halts if time exceeds 30 seconds, returning the best feasible path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float,...] position in space\n        self.parent = parent              # Parent Node or None\n        self.cost = cost                  # Cost from root\n        self.children = []                # List of child Nodes\n        self.valid = True                 # Valid node flag\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Remove self from old parent's children\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\n        self._propagate_cost_to_children()\n\n    def _propagate_cost_to_children(self):\n        # Recursively update cost of descendants\n        for c in self.children:\n            old_cost = c.cost\n            c.cost = self.cost + self._dist(self.position, c.position)\n            if abs(c.cost - old_cost) > 1e-9:\n                c._propagate_cost_to_children()\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(p1, p2):\n        import math\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self, max_iter=5000, base_step=5.0, goal_sample_rate=0.1, gamma=50.0, radius_min=5.0, radius_max=50.0):\n        self.max_iter = max_iter        # Maximum iterations allowed\n        self.base_step = base_step      # Base step size for extension\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal directly\n        self.gamma = gamma              # Gamma parameter for adaptive radius\n        self.radius_min = radius_min    # Minimum rewiring radius\n        self.radius_max = radius_max    # Maximum rewiring radius\n\n    def plan(self, map):\n        import random, math, time\n\n        start_time = time.monotonic()\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        tree_start = [Node(start, parent=None, cost=0.0)]\n        tree_goal = [Node(goal, parent=None, cost=0.0)]\n\n        nodes_all = tree_start + tree_goal\n        edges = []\n\n        c_best = float(\"inf\")\n        c_min = math.dist(start, goal)\n\n        best_path = []\n        success = False\n\n        # For quick access in rewiring radius adapt calculation\n        volume_unit_ball = math.pi if dim == 2 else 4/3*math.pi\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_max\n            val = self.gamma * (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            return max(self.radius_min, min(self.radius_max, val))\n\n        # Precompute heuristic distance for informed sampling ellipse\n        def informed_sample(c_best_local):\n            # If no solution yet, uniform random sample\n            if c_best_local == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Sample inside prolate hyperspheroid defined by start, goal, cost c_best_local\n            import numpy as np\n            x_center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a1 = a1 / norm_a1\n            # Create rotation matrix that aligns x-axis with unit vector a1\n            I = np.eye(dim)\n            M = np.outer(a1, I[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n            r1 = c_best_local / 2.0\n            r2 = math.sqrt(c_best_local ** 2 - c_min ** 2) / 2.0 if c_best_local > c_min else 0\n            L = np.diag([r1] + [r2] * (dim - 1))\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                x_ball /= np.linalg.norm(x_ball)\n                # Scale radius with uniform random inside unit ball\n                x_ball *= random.random() ** (1.0 / dim)\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(2, int(dist))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step_len):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step_len:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step_len / dist for d in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: math.dist(n.position, point))\n\n        def neighbors(nodes, point, radius):\n            return [n for n in nodes if math.dist(n.position, point) <= radius]\n\n        def can_connect(p1, p2):\n            if self._is_in_obstacle(p2, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def connect_trees(node_a, tree_b):\n            # Attempt to connect node_a to its nearest node in tree_b\n            nearest_b = min(tree_b, key=lambda n: math.dist(n.position, node_a.position))\n            if can_connect(node_a.position, nearest_b.position):\n                total_cost = node_a.cost + nearest_b.cost + math.dist(node_a.position, nearest_b.position)\n                return total_cost, node_a, nearest_b\n            return float(\"inf\"), None, None\n\n        def path_from_connection(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def rewire(new_node, near_nodes):\n            # Rewire neighbors if cost can be improved via new_node\n            for near in near_nodes:\n                if near == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_through_new + 1e-9 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.update_parent(new_node, cost_through_new)\n\n        def try_extend_and_rewire(tree_from, tree_to):\n            sample = informed_sample(c_best)\n            nearest_node = nearest(tree_from, sample)\n            step_len = adaptive_step(nearest_node.position, sample)\n            new_pos = steer(nearest_node.position, sample, step_len)\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            if new_cost + math.dist(new_pos, goal) >= c_best + 1e-9:\n                # Prune worse\n                return None\n\n            new_node = Node(new_pos)\n            # Choose best parent near new_node\n            radius = adaptive_radius(len(tree_from)+len(tree_to))\n            near_nodes = neighbors(tree_from, new_pos, radius)\n            min_cost = new_cost\n            best_parent = nearest_node\n            for near in near_nodes:\n                temp_cost = near.cost + math.dist(near.position, new_pos)\n                if temp_cost + 1e-9 < min_cost and can_connect(near.position, new_pos):\n                    min_cost = temp_cost\n                    best_parent = near\n            new_node.update_parent(best_parent, min_cost)\n\n            tree_from.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors with new node\n            near_nodes_2 = neighbors(tree_from, new_pos, radius)\n            rewire(new_node, near_nodes_2)\n\n            # Try connect to tree_to\n            connect_cost, node_a, node_b = connect_trees(new_node, tree_to)\n            nonlocal c_best, best_path, success\n            if connect_cost + 1e-9 < c_best:\n                c_best = connect_cost\n                best_path = path_from_connection(node_a, node_b)\n                success = True\n                return new_node\n            return new_node\n\n        def iterative_path_smoothing(path, iters=30):\n            # Attempt random shortcut with collision checks to improve smoothness\n            if len(path) < 3:\n                return path\n            new_path = path[:]\n            for _ in range(iters):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                p1, p2 = new_path[i], new_path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    # Shortcut possible - remove intermediate points\n                    new_path = new_path[:i + 1] + new_path[j:]\n            return new_path\n\n        for iter in range(self.max_iter):\n            if time.monotonic() - start_time > 30.0:\n                break\n\n            # Alternate tree growth\n            if iter % 2 == 0:\n                active_tree, other_tree = tree_start, tree_goal\n            else:\n                active_tree, other_tree = tree_goal, tree_start\n\n            new_node = try_extend_and_rewire(active_tree, other_tree)\n\n            if success and time.monotonic() - start_time > 0.01:\n                # Early stop if improved path found and some time passed\n                break\n\n        # After termination, apply path smoothing if successful\n        if success and best_path:\n            best_path = iterative_path_smoothing(best_path, iters=50)\n\n        return type(\"PlannerResult\", (), dict(\n            success=success,\n            path=best_path,\n            nodes=nodes_all,\n            edges=edges\n        ))()\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        # Check if pos lies within any obstacle\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 218\nSyntaxError: name 'c_best' is used prior to nonlocal declaration\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": "This new bidirectional RRT* planner integrates adaptive neighbor radius scaling, incremental connect-and-rewire, and dynamic step sizing based on obstacle proximity to improve planning efficiency, path quality, robustness, success rate, and smoothness while reducing search time and path length. It uses goal bias sampling, keeps comprehensive node and edge management, performs continuous local rewiring for cost improvement, and applies randomized path smoothing at the end. Early termination is enforced at a 30-second wall-clock time limit, returning the best-found path if timed out.",
    "planning_mechanism": "The planner grows two trees from start and goal positions simultaneously, alternately sampling points with a goal bias, extending and rewiring locally with adaptive neighbor radius computed from current node count and dimension. It incrementally tries to connect the two trees by stepwise extending towards each other with collision checks. When a connection is found, it reconstructs the path, applies path smoothing with randomized shortcutting, and returns the best path found within the time limit, maintaining detailed node and edge lists throughout for structure coherence and efficient updates.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position         # Tuple[float, ...] 2D or 3D\n        self.parent = parent             # Node or None\n        self.cost = cost                 # Path cost to this node\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_costs_recursive(self):\n        for child in self.children:\n            dist = self._distance(child.position)\n            new_cost = self.cost + dist\n            if new_cost < child.cost:\n                child.cost = new_cost\n                child.update_costs_recursive()\n\n    def _distance(self, pos):\n        import math\n        return math.dist(self.position, pos)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1, min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0, max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map):\n        import math, random, time\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start, cost=0.0)]\n        goal_tree = [Node(goal, cost=0.0)]\n        nodes = [start_tree[0], goal_tree[0]]\n        edges = []\n\n        success = False\n        best_cost = float(\"inf\")\n        best_path = []\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def compute_neighbor_radius(num_nodes):\n            import math\n            # Gamma formula from Karaman & Frazzoli 2011 scaled and clamped\n            gamma_rrt_star = 50.0\n            radius = min(self.max_neighbor_radius,\n                         max(self.min_neighbor_radius,\n                             gamma_rrt_star * (math.log(num_nodes + 1) / (num_nodes + 1)) ** (1 / dim)))\n            return radius\n\n        def steer(from_pos, to_pos, step):\n            dist = distance(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(dim))\n\n        def sample_free(tree_idx):\n            # tree_idx: 0 for start_tree, 1 for goal_tree\n            if random.random() < self.goal_sample_rate:\n                return goal if tree_idx == 0 else start\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: distance(n.position, point))\n\n        def near(tree, point, radius):\n            res = []\n            for n in tree:\n                if distance(n.position, point) <= radius:\n                    res.append(n)\n            return res\n\n        def is_collision_free(from_pos, to_pos):\n            return (not self._is_in_obstacle(to_pos, obstacles, is_3d)\n                    and not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d))\n\n        def try_extend(tree, point, nodes_list, edges_list):\n            # Extend tree toward point up to adaptive step size\n            nearest_node = nearest(tree, point)\n            step = self._adaptive_step(nearest_node.position, point, obstacles, is_3d, self.base_step)\n            new_pos = steer(nearest_node.position, point, step)\n            if (in_bounds(new_pos)\n                and is_collision_free(nearest_node.position, new_pos)):\n                cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=cost)\n                nearest_node.add_child(new_node)\n                tree.append(new_node)\n                nodes_list.append(new_node)\n                edges_list.append((nearest_node, new_node))\n                return new_node\n            return None\n\n        def rewire(tree, new_node, nodes_list, edges_list):\n            n_nodes = len(tree)\n            radius = compute_neighbor_radius(n_nodes)\n            near_nodes = near(tree, new_node.position, radius)\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                if not is_collision_free(new_node.position, near_node.position):\n                    continue\n                new_cost = new_node.cost + distance(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    # Remove old edge\n                    if near_node.parent:\n                        near_node.parent.remove_child(near_node)\n                        if (near_node.parent, near_node) in edges_list:\n                            edges_list.remove((near_node.parent, near_node))\n                    # Reparent near_node to new_node\n                    near_node.parent = new_node\n                    near_node.cost = new_cost\n                    new_node.add_child(near_node)\n                    edges_list.append((new_node, near_node))\n                    # Update downstream costs recursively\n                    near_node.update_costs_recursive()\n\n        def try_connect(tree_from, tree_to, nodes_list, edges_list):\n            # Incrementally attempt to connect tree_from to tree_to by successive steering and rewiring\n            max_connect_steps = int(math.ceil(distance(tree_from[-1].position, tree_to[-1].position) / self.base_step))\n            current_node = tree_from[-1]\n            for _ in range(max_connect_steps):\n                nearest_in_to = nearest(tree_to, current_node.position)\n                step = self._adaptive_step(current_node.position, nearest_in_to.position, obstacles, is_3d, self.base_step)\n                new_pos = steer(current_node.position, nearest_in_to.position, step)\n                if not in_bounds(new_pos):\n                    return None\n                if not is_collision_free(current_node.position, new_pos):\n                    return None\n                new_cost = current_node.cost + distance(current_node.position, new_pos)\n                if nearest_in_to.cost + distance(new_pos, nearest_in_to.position) + new_cost > best_cost:\n                    return None\n                new_node = Node(new_pos, parent=current_node, cost=new_cost)\n                current_node.add_child(new_node)\n                tree_from.append(new_node)\n                nodes_list.append(new_node)\n                edges_list.append((current_node, new_node))\n                rewire(tree_from, new_node, nodes_list, edges_list)\n                # Check if can connect directly to tree_to node\n                dist_to_nearest = distance(new_node.position, nearest_in_to.position)\n                if dist_to_nearest <= self.base_step:\n                    if is_collision_free(new_node.position, nearest_in_to.position):\n                        connect_cost = new_node.cost + dist_to_nearest + nearest_in_to.cost\n                        nonlocal best_cost, best_path, success\n                        if connect_cost < best_cost:\n                            best_cost = connect_cost\n                            path_from_start = new_node.path_from_root()\n                            path_from_goal = nearest_in_to.path_from_root()\n                            # Remove duplicated node at connection\n                            best_path = path_from_start + path_from_goal[::-1][1:]\n                            success = True\n                        return new_node\n                current_node = new_node\n            return None\n\n        def smooth_path(path, max_iter=30):\n            # Randomized shortcut smoothing with collision checks\n            if len(path) < 3:\n                return path\n            for _ in range(max_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if j <= i + 1:\n                    continue\n                if is_collision_free(path[i], path[j]):\n                    # shortcut path between path[i] and path[j]\n                    new_path = path[:i + 1] + path[j:]\n                    path = new_path\n            return path\n\n        # Main loop\n        tree_selector = 0  # 0: start_tree grows, 1: goal_tree grows\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > self.max_time_sec:\n                # Timeout, return best found so far\n                break\n\n            tree_a = start_tree if tree_selector == 0 else goal_tree\n            tree_b = goal_tree if tree_selector == 0 else start_tree\n\n            sample_point = sample_free(tree_selector)\n\n            new_node_a = try_extend(tree_a, sample_point, nodes, edges)\n            if new_node_a is not None:\n                rewire(tree_a, new_node_a, nodes, edges)\n                connected_node_b = try_connect(tree_b, tree_a, nodes, edges)\n\n                if connected_node_b:\n                    # Also rewire other tree for new connection\n                    rewire(tree_b, connected_node_b, nodes, edges)\n\n            tree_selector = 1 - tree_selector  # Toggle tree\n\n        if success and best_path:\n            best_path = smooth_path(best_path, max_iter=50)\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d, base_step):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return max(base_step * 0.4, 0.8)\n        return base_step",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 188\nSyntaxError: name 'best_cost' is used prior to nonlocal declaration\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 120, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 75, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 120, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 75, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nAttributeError: module 'planning_module' has no attribute 'Planner'\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": "This novel planner, Adaptive Informed Gaussian-PRM (AIG-PRM), integrates Gaussian-based informed sampling within a PRM framework with adaptive neighbor radius and multi-stage incremental connection to dramatically improve planning efficiency, path quality, and smoothness. It balances global graph connectivity and local refinement, incorporates pruning strategies, and performs post-extraction path smoothing to output compact, feasible, and near-optimal paths within the 30-second time limit.",
    "planning_mechanism": "The planner incrementally constructs a probabilistic roadmap by sampling nodes with Gaussian-informed bias around the current best path ellipse and goal bias, connecting nodes dynamically with an adaptive radius that shrinks as nodes increase. It verifies node and edge collisions rigorously, rewires local graph neighborhoods if cost improvements are possible, and performs multi-stage connections from both start and goal trees to bridge them efficiently. Upon early connection detection or timeout, it reconstructs and smooths the path with randomized shortcutting to yield smoother and lower-cost trajectories.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root (start or goal)\n        self.children = []\n        self.valid = True               # Validity flag for potential pruning\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_and_propagate(self, new_cost):\n        if new_cost < self.cost:\n            old_cost = self.cost\n            self.cost = new_cost\n            for child in self.children:\n                child.update_cost_and_propagate(child.cost - old_cost + new_cost)\nclass Planner:\n    def __init__(self, max_iter: int=5000, base_step: float=5.0, max_radius: float=30.0, min_radius: float=5.0, smoothing_iters: int=100):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Data structures\n        nodes_start = [Node(start_pos, parent=None, cost=0.0)]\n        nodes_goal = [Node(goal_pos, parent=None, cost=0.0)]\n        all_nodes = nodes_start + nodes_goal\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def euclidean(a, b):\n            return math.dist(a, b)\n\n        def is_in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def adaptive_neighbor_radius(num_nodes):\n            # Decaying radius with log factor for connectivity and efficiency\n            if num_nodes < 2:\n                return self.max_radius\n            r = self.max_radius * (math.log(num_nodes) / num_nodes)**(1/dim)\n            return max(min(r, self.max_radius), self.min_radius)\n\n        # Collision utilities\n        def node_in_collision(pos):\n            if not is_in_bounds(pos):\n                return True\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_collision(p1, p2, resolution=1.0):\n            distance = dist(p1,p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d]) * (i/steps) for d in range(dim))\n                if node_in_collision(interp):\n                    return True\n            return False\n\n        # Sampling utilities\n        def informed_ellipse_sample(c_best, start, goal):\n            # Sample inside ellipsoid defined by foci start,goal and cost c_best\n            import math, random\n            if c_best == float('inf'):\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n            c_min = dist(start, goal)\n            if c_min == 0:\n                return start\n            # Ellipse center\n            center = tuple((start[d]+goal[d])*0.5 for d in range(dim))\n            # Axis lengths\n            r1 = c_best/2\n            r2 = math.sqrt(c_best**2 - c_min**2)/2 if c_best > c_min else 0\n            # Coordinate frame (rotation matrix) aligned with line start->goal\n            x_vector = [goal[d]-start[d] for d in range(dim)]\n            norm_x = math.sqrt(sum(x*x for x in x_vector))\n            if norm_x == 0:  # start==goal\n                basis = [ [1 if i==d else 0 for d in range(dim)] for i in range(dim) ]\n            else:\n                x_unit = [x_vector[d]/norm_x for d in range(dim)]\n                # Construct orthonormal basis with Gram-Schmidt, fill with arbitrary orthogonal basis\n                basis = [x_unit]\n                for i in range(1, dim):\n                    # Create orthogonal vector to previous vectors in basis by random vector - projection\n                    while True:\n                        rand_vec = [random.gauss(0,1) for _ in range(dim)]\n                        # Orthogonalize\n                        for bvec in basis:\n                            proj = sum(rand_vec[d]*bvec[d] for d in range(dim))\n                            rand_vec = [rand_vec[d]-proj*bvec[d] for d in range(dim)]\n                        norm_rand = math.sqrt(sum(x*x for x in rand_vec))\n                        if norm_rand > 1e-6:\n                            rand_vec = [x/norm_rand for x in rand_vec]\n                            basis.append(rand_vec)\n                            break\n                # basis is orthonormal matrix: dim x dim where basis[i] = ith basis vector\n\n            # Sample uniformly from unit dim-ball using gaussian and normalize radius w^(1/dim)\n            from random import random as rand\n            from math import pow\n            while True:\n                sample_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_sample = math.sqrt(sum(x*x for x in sample_ball))\n                if norm_sample < 1e-15:\n                    continue\n                unit_sample = [x/norm_sample for x in sample_ball]\n                radius = rand()**(1/dim)\n                unit_sample = [x*radius for x in unit_sample]\n\n                # scale by ellipse axes\n                axes = [r1] + [r2]*(dim-1)\n                scaled = [unit_sample[i]*axes[i] for i in range(dim)]\n\n                # rotate by basis: rotated = sum_i scaled[i]*basis[i]\n                rotated = [0.0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        rotated[i] += scaled[j]*basis[j][i]\n\n                sample = tuple(center[d] + rotated[d] for d in range(dim))\n                if is_in_bounds(sample) and not node_in_collision(sample):\n                    return sample\n\n        def goal_biased_sample(goal, p_goal=0.1):\n            # With probability p_goal, sample goal exactly, else uniform in bounds without obstacles\n            if random.random() < p_goal:\n                return goal\n            else:\n                for _ in range(100):\n                    sample = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if not node_in_collision(sample):\n                        return sample\n                return goal  # fallback\n\n        # Rewire utilities\n        def find_neighbors(node_list, node, radius):\n            neighbors = []\n            for n in node_list:\n                if n is node:\n                    continue\n                if dist(n.position, node.position) <= radius:\n                    neighbors.append(n)\n            return neighbors\n\n        def try_rewire(new_node, neighbors, node_list):\n            # Attempt rewiring neighbors to new_node if cost decrease possible and collision free\n            import math\n            for near in neighbors:\n                if near is new_node.parent:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, near.position)\n                if potential_cost + dist(near.position, goal_pos) >= best_cost:\n                    continue\n                if potential_cost < near.cost:\n                    if not edge_in_collision(new_node.position, near.position):\n                        # Rewire\n                        if near.parent:\n                            near.parent.remove_child(near)\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = potential_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        near.update_cost_and_propagate(potential_cost)\n\n        def connect_trees(new_node, other_nodes):\n            # Try multi-step incremental connect attempts towards any node in other_nodes close enough\n            import math\n            nearest_other = None\n            nearest_dist = float('inf')\n            for on in other_nodes:\n                d = dist(new_node.position, on.position)\n                if d < nearest_dist:\n                    nearest_dist = d\n                    nearest_other = on\n            if nearest_other is None:\n                return None\n\n            if nearest_dist > self.base_step * 3:\n                return None\n\n            # Try incremental connect from new_node to nearest_other.position\n            current = new_node\n            reached_node = None\n            while True:\n                step_pos = self._steer(current.position, nearest_other.position, self.base_step)\n                if node_in_collision(step_pos) or edge_in_collision(current.position, step_pos):\n                    break\n                new_cost = current.cost + dist(current.position, step_pos)\n                if new_cost + dist(step_pos, goal_pos) >= best_cost:\n                    break\n                new_node_cand = Node(step_pos, parent=current, cost=new_cost)\n                current.add_child(new_node_cand)\n                all_nodes.append(new_node_cand)\n                edges.append((current, new_node_cand))\n                current = new_node_cand\n                # Check distance to nearest_other\n                if dist(current.position, nearest_other.position) <= self.base_step:\n                    # check edge to nearest_other\n                    if not edge_in_collision(current.position, nearest_other.position):\n                        # Connect to other tree node\n                        bridge_cost = current.cost + dist(current.position, nearest_other.position) + nearest_other.cost\n                        nonlocal best_cost, best_path, success\n                        if bridge_cost < best_cost:\n                            best_cost = bridge_cost\n                            path_from_start = current.path_from_root()\n                            path_from_goal = nearest_other.path_from_root()\n                            best_path = path_from_start + path_from_goal[::-1]\n                            success = True\n                        reached_node = current\n                    break\n            return reached_node\n\n        def path_smoothing(path):\n            # Random shortcut smoothing\n            if len(path) < 3:\n                return path\n            import random\n            from_pos = path\n            pts = list(from_pos)\n            for _ in range(self.smoothing_iters):\n                if len(pts) < 3:\n                    break\n                i = random.randint(0, len(pts) - 2)\n                j = random.randint(i+1, len(pts) - 1)\n                if j == i + 1:\n                    continue\n                p1 = pts[i]\n                p2 = pts[j]\n                if not edge_in_collision(p1, p2, resolution=max(0.5, self.base_step*0.5)):\n                    # shortcut possible: remove points between i and j,\n                    # replace with direct edge\n                    new_pts = pts[:i+1] + pts[j:]\n                    pts = new_pts\n            return pts\n\n        # Main loop\n        # Start and goal graph grow alternately, sampling guided by ellipse informed with best_cost or uniform otherwise\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break  # Time limit\n\n            # Alternate trees\n            if iter_count % 2 == 0:\n                tree_a = nodes_start\n                tree_b = nodes_goal\n            else:\n                tree_a = nodes_goal\n                tree_b = nodes_start\n\n            c_best_local = best_cost if success else float('inf')\n            sample = informed_ellipse_sample(c_best_local, start_pos, goal_pos)\n            # 5% goal bias to speed up connection\n            if random.random() < 0.05:\n                sample = goal_pos\n\n            if node_in_collision(sample):\n                continue\n\n            nearest = min(tree_a, key=lambda n: dist(n.position, sample))\n            vector = tuple(sample[d] - nearest.position[d] for d in range(dim))\n            length = math.sqrt(sum(v * v for v in vector))\n            if length < 1e-6:\n                continue\n            scale = min(self.base_step, length) / length\n            new_pos = tuple(nearest.position[d] + vector[d] * scale for d in range(dim))\n\n            if node_in_collision(new_pos) or edge_in_collision(nearest.position, new_pos):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            # Prune nodes that cannot lead to better solution\n            if not success and new_cost > best_cost:\n                continue\n            if success and new_cost + dist(new_pos, goal_pos) >= best_cost:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Adaptive rewiring radius\n            r = adaptive_neighbor_radius(len(tree_a))\n            neighbors = find_neighbors(tree_a, new_node, r)\n            try_rewire(new_node, neighbors, tree_a)\n\n            # Attempt connection to other tree\n            connect_trees(new_node, tree_b)\n\n        # At end or timeout: reconstruct path if success else empty\n        if success and best_path:\n            smoothed_path = path_smoothing(best_path)\n        else:\n            smoothed_path = []\n\n        return PlannerResult(success=success, path=smoothed_path, nodes=all_nodes, edges=edges)\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 264\nSyntaxError: name 'best_cost' is used prior to nonlocal declaration\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": "This planner introduces an adaptive bidirectional informed RRT* with dynamic neighborhood rewiring and heuristic-driven sampling focused in an ellipsoidal informed region. It incorporates adaptive step sizing that decreases near obstacles for safer exploration, continuous incremental connection attempts between trees with rewiring, and aggressive pruning of nodes exceeding current best path cost to improve efficiency. This combination reduces unnecessary expansions, enhances path quality via progressive rewiring, boosts robustness against obstacles through adaptive stepping, and cuts planning time by focusing the search within the informed subset of the state space. The path extraction merges two joined trees with smooth cost-optimized connectivity. <The algorithm grows two trees from start and goal positions with informed ellipsoidal sampling biased by the current best path cost. At each iteration, a sample is generated within an ellipsoidal region focused on improving the path cost. Each tree grows towards the sample using adaptive step size modulation depending on nearby obstacles. Newly added nodes are rewired within a dynamic neighborhood radius to minimize costs. After extending one tree, it attempts incremental connections and rewiring with nearby nodes from the other tree to progressively improve the connecting path. Pruning of nodes that cannot improve the current best solution further refines the search. The algorithm terminates when a collision-free connection between trees is found or when the 30-second timeout is reached, returning the best discovered path so far.",
    "planning_mechanism": "The algorithm grows two trees from start and goal positions with informed ellipsoidal sampling biased by the current best path cost. At each iteration, a sample is generated within an ellipsoidal region focused on improving the path cost. Each tree grows towards the sample using adaptive step size modulation depending on nearby obstacles. Newly added nodes are rewired within a dynamic neighborhood radius to minimize costs. After extending one tree, it attempts incremental connections and rewiring with nearby nodes from the other tree to progressively improve the connecting path. Pruning of nodes that cannot improve the current best solution further refines the search. The algorithm terminates when a collision-free connection between trees is found or when the 30-second timeout is reached, returning the best discovered path so far.}\n\n```python\nimport time\nimport math\nimport random\n\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float,...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from start\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\nclass Planner:\n    def __init__(self, max_iter: int = 10000, base_step_size: float = 5.0, neighbor_radius: float = 20.0, goal_sample_rate: float=0.10):\n        self.max_iter = max_iter\n        self.base_step_size = base_step_size\n        self.neighbor_radius = neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size                     # Tuple[int,...]\n        start_pos = map.start                 # Tuple[float,...]\n        goal_pos = map.goal                   # Tuple[float,...]\n        obstacles = map.obstacles             # List rectangles cuboids\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Initialize trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        success = False\n        best_path = []\n        c_best = math.dist(start_pos, goal_pos) * float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        # Precompute ellipsoid center for informed sampling\n        x_center = tuple((s + g) * 0.5 for s, g in zip(start_pos, goal_pos))\n\n        # For ellipsoid sampling transformation matrices\n        # Will compute on-demand when c_best < inf\n\n        def dist2(a, b):\n            return sum((a[i]-b[i])**2 for i in range(dim))**0.5\n\n        def steer(from_p, to_p, step):\n            d = dist2(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def is_collision_node(pos):\n            if any(o for o in obstacles if ( (is_3d and o[0] <= pos[0] <= o[0]+o[3] and o[1] <= pos[1] <= o[1]+o[4] and o[2] <= pos[2] <= o[2]+o[5]) or\n                                            (not is_3d and o[0] <= pos[0] <= o[0]+o[2] and o[1] <= pos[1] <= o[1]+o[3]) )):\n                return True\n            return False\n\n        def is_collision_edge(p1, p2, resolution=1.0):\n            dist = dist2(p1, p2)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_collision_node(interp):\n                    return True\n            return False\n\n        def nearest_node(tree, pos):\n            min_n = None\n            min_d = float('inf')\n            for n in tree:\n                d = dist2(n.position, pos)\n                if d < min_d:\n                    min_d = d\n                    min_n = n\n            return min_n\n\n        def near_nodes(tree, new_node, radius):\n            neighbors = []\n            for n in tree:\n                if dist2(n.position, new_node.position) <= radius:\n                    neighbors.append(n)\n            return neighbors\n\n        # Ellipsoidal informed sampling as in RRT*Informed\n        def informed_sample():\n            # With probability goal_sample_rate, bias sample to goal directly\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n\n            if c_best == float('inf'):\n                # Uniform sample in bounds\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            # Ellipsoid parameters\n            r1 = c_best / 2.0\n            if c_best**2 - c_min**2 < 1e-6:\n                # Avoid sqrt domain error:\n                r2 = 0.0\n            else:\n                r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n\n            # Unit vector from start to goal (a1)\n            a1 = tuple((goal_pos[i] - start_pos[i]) / c_min for i in range(dim))\n\n            # Build rotation matrix C to rotate x-axis to a1 (for 2D/3D):\n            # We use Householder transform type approach for arbitrary dim up to 3D\n            import math as _math\n            import numpy as np\n            e1 = np.zeros(dim)\n            e1[0] = 1.0\n            a1_np = np.array(a1)\n            if np.allclose(a1_np, e1):\n                C = np.eye(dim)\n            else:\n                v = e1 - a1_np\n                v = v / np.linalg.norm(v)\n                C = np.eye(dim) - 2 * np.outer(v, v)\n\n            # Scaling matrix along axes\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                # Sample unit ball\n                x_ball = np.random.normal(0,1,dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                # Sample distance radius in unit ball\n                c = random.random() ** (1/dim)\n                x_ball *= c\n                # Transform to the ellipsoid\n                x_rand = C @ L @ x_ball + np.array(x_center)\n                if all(0 <= x_rand[i] <= bounds[i] for i in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_p, to_p):\n            # Starting from base step size, reduce if obstacles detected in path at finer sampling\n            step = self.base_step_size\n            dist = dist2(from_p, to_p)\n            steps = max(2, int(dist))\n            for i in range(1, steps + 1):\n                interp = tuple(from_p[d] + (to_p[d] - from_p[d]) * (i / steps) for d in range(dim))\n                if is_collision_node(interp):\n                    # Reduce step size proportional to 0.3x base, min 1.0\n                    return max(self.base_step_size * 0.3, 1.0)\n            return step\n\n        def rewire(tree, new_node, radius):\n            neighbors = near_nodes(tree, new_node, radius)\n            for near in neighbors:\n                if near == new_node.parent:\n                    continue\n                if is_collision_edge(new_node.position, near.position):\n                    continue\n                potential_cost = new_node.cost + dist2(new_node.position, near.position)\n                if potential_cost < near.cost:\n                    # Rewire near to new_node\n                    if near.parent is not None:\n                        near.parent.remove_child(near)\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                    new_node.add_child(near)\n                    near.cost = potential_cost\n                    edges.append((new_node, near))\n\n        def extend_and_rewire(tree, other_tree):\n            sample = informed_sample()\n\n            nearest = nearest_node(tree, sample)\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if is_collision_node(new_pos):\n                return None\n            if is_collision_edge(nearest.position, new_pos):\n                return None\n\n            cost = nearest.cost + dist2(nearest.position, new_pos)\n            # Prune nodes that can't improve c_best\n            if cost + dist2(new_pos, goal_pos)",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float,...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from start\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, base_step_size: float = 5.0, neighbor_radius: float = 20.0, goal_sample_rate: float=0.10):\n        self.max_iter = max_iter\n        self.base_step_size = base_step_size\n        self.neighbor_radius = neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size                     # Tuple[int,...]\n        start_pos = map.start                 # Tuple[float,...]\n        goal_pos = map.goal                   # Tuple[float,...]\n        obstacles = map.obstacles             # List rectangles cuboids\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Initialize trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        success = False\n        best_path = []\n        c_best = math.dist(start_pos, goal_pos) * float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        # Precompute ellipsoid center for informed sampling\n        x_center = tuple((s + g) * 0.5 for s, g in zip(start_pos, goal_pos))\n\n        # For ellipsoid sampling transformation matrices\n        # Will compute on-demand when c_best < inf\n\n        def dist2(a, b):\n            return sum((a[i]-b[i])**2 for i in range(dim))**0.5\n\n        def steer(from_p, to_p, step):\n            d = dist2(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def is_collision_node(pos):\n            if any(o for o in obstacles if ( (is_3d and o[0] <= pos[0] <= o[0]+o[3] and o[1] <= pos[1] <= o[1]+o[4] and o[2] <= pos[2] <= o[2]+o[5]) or\n                                            (not is_3d and o[0] <= pos[0] <= o[0]+o[2] and o[1] <= pos[1] <= o[1]+o[3]) )):\n                return True\n            return False\n\n        def is_collision_edge(p1, p2, resolution=1.0):\n            dist = dist2(p1, p2)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_collision_node(interp):\n                    return True\n            return False\n\n        def nearest_node(tree, pos):\n            min_n = None\n            min_d = float('inf')\n            for n in tree:\n                d = dist2(n.position, pos)\n                if d < min_d:\n                    min_d = d\n                    min_n = n\n            return min_n\n\n        def near_nodes(tree, new_node, radius):\n            neighbors = []\n            for n in tree:\n                if dist2(n.position, new_node.position) <= radius:\n                    neighbors.append(n)\n            return neighbors\n\n        # Ellipsoidal informed sampling as in RRT*Informed\n        def informed_sample():\n            # With probability goal_sample_rate, bias sample to goal directly\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n\n            if c_best == float('inf'):\n                # Uniform sample in bounds\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            # Ellipsoid parameters\n            r1 = c_best / 2.0\n            if c_best**2 - c_min**2 < 1e-6:\n                # Avoid sqrt domain error:\n                r2 = 0.0\n            else:\n                r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n\n            # Unit vector from start to goal (a1)\n            a1 = tuple((goal_pos[i] - start_pos[i]) / c_min for i in range(dim))\n\n            # Build rotation matrix C to rotate x-axis to a1 (for 2D/3D):\n            # We use Householder transform type approach for arbitrary dim up to 3D\n            import math as _math\n            import numpy as np\n            e1 = np.zeros(dim)\n            e1[0] = 1.0\n            a1_np = np.array(a1)\n            if np.allclose(a1_np, e1):\n                C = np.eye(dim)\n            else:\n                v = e1 - a1_np\n                v = v / np.linalg.norm(v)\n                C = np.eye(dim) - 2 * np.outer(v, v)\n\n            # Scaling matrix along axes\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                # Sample unit ball\n                x_ball = np.random.normal(0,1,dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                # Sample distance radius in unit ball\n                c = random.random() ** (1/dim)\n                x_ball *= c\n                # Transform to the ellipsoid\n                x_rand = C @ L @ x_ball + np.array(x_center)\n                if all(0 <= x_rand[i] <= bounds[i] for i in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_p, to_p):\n            # Starting from base step size, reduce if obstacles detected in path at finer sampling\n            step = self.base_step_size\n            dist = dist2(from_p, to_p)\n            steps = max(2, int(dist))\n            for i in range(1, steps + 1):\n                interp = tuple(from_p[d] + (to_p[d] - from_p[d]) * (i / steps) for d in range(dim))\n                if is_collision_node(interp):\n                    # Reduce step size proportional to 0.3x base, min 1.0\n                    return max(self.base_step_size * 0.3, 1.0)\n            return step\n\n        def rewire(tree, new_node, radius):\n            neighbors = near_nodes(tree, new_node, radius)\n            for near in neighbors:\n                if near == new_node.parent:\n                    continue\n                if is_collision_edge(new_node.position, near.position):\n                    continue\n                potential_cost = new_node.cost + dist2(new_node.position, near.position)\n                if potential_cost < near.cost:\n                    # Rewire near to new_node\n                    if near.parent is not None:\n                        near.parent.remove_child(near)\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                    new_node.add_child(near)\n                    near.cost = potential_cost\n                    edges.append((new_node, near))\n\n        def extend_and_rewire(tree, other_tree):\n            sample = informed_sample()\n\n            nearest = nearest_node(tree, sample)\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if is_collision_node(new_pos):\n                return None\n            if is_collision_edge(nearest.position, new_pos):\n                return None\n\n            cost = nearest.cost + dist2(nearest.position, new_pos)\n            # Prune nodes that can't improve c_best\n            if cost + dist2(new_pos, goal_pos) >= c_best:\n                return None\n\n            new_node = Node(new_pos, nearest, cost)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire in own tree\n            rewire(tree, new_node, self.neighbor_radius)\n\n            # Attempt incremental connection & rewiring with other tree\n            connected, conn_path, conn_cost = connect_and_rewire(new_node, other_tree)\n            nonlocal success, best_path, c_best\n            if connected and conn_cost < c_best:\n                c_best = conn_cost\n                best_path = conn_path\n                success = True\n\n            return new_node\n\n        def connect_and_rewire(node, other_tree):\n            # Incrementally try to connect to nearest node(s) in other_tree with rewiring\n            best_conn_cost = float('inf')\n            best_path = []\n            connected = False\n\n            near_others = near_nodes(other_tree, node, self.neighbor_radius)\n            near_others.sort(key=lambda n: dist2(n.position, node.position))\n\n            for other_node in near_others:\n                if is_collision_edge(node.position, other_node.position) == False:\n                    total_cost = node.cost + dist2(node.position, other_node.position) + other_node.cost\n                    if total_cost < c_best and total_cost < best_conn_cost:\n                        # Connect by adding a temporary connector node at other_node.position if different\n                        # To avoid invalid tree structure, we connect node and other_node by a virtual edge for path only\n                        # But here, for graph maintenance, we add a connector node on other_tree side if cost improvement possible\n                        # We attempt rewiring other_tree towards node:\n\n                        # Attempt rewiring other_tree nodes through connecting node\n                        rewire(other_tree, node, self.neighbor_radius)\n\n                        # Compose path from start to node + from goal to other_node reversed\n                        path_a = node.path_from_root()\n                        path_b = other_node.path_from_root()\n                        full_path = path_a + path_b[::-1]\n                        best_conn_cost = total_cost\n                        best_path = full_path\n                        connected = True\n            return connected, best_path, best_conn_cost\n\n        def prune(tree, cost_limit):\n            # Remove nodes that have cost + heuristic > cost_limit (to speed up)\n            to_remove = []\n            for n in tree:\n                if n.cost + dist2(n.position, goal_pos if n in tree_start else start_pos) >= cost_limit:\n                    if n.parent is not None and n.parent != n:\n                        n.parent.remove_child(n)\n                    to_remove.append(n)\n            for n in to_remove:\n                try:\n                    tree.remove(n)\n                    nodes.remove(n)\n                    edges[:] = [e for e in edges if e[0] != n and e[1] != n]\n                except ValueError:\n                    pass\n\n        # Alternate growing trees each iteration\n        trees = [tree_start, tree_goal]\n\n        for iteration in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > TIME_LIMIT:\n                # Timeout, return best path so far\n                break\n\n            # Alternate trees, first start then goal etc.\n            tree_ind = iteration % 2\n            tree_a = trees[tree_ind]\n            tree_b = trees[1 - tree_ind]\n\n            new_node = extend_and_rewire(tree_a, tree_b)\n            if new_node is None:\n                continue\n\n            # Optionally prune both trees to keep search focused\n            if c_best < float('inf'):\n                prune(tree_start, c_best)\n                prune(tree_goal, c_best)\n\n            if success:\n                # Check elapsed for early return\n                if time.monotonic() - start_time > TIME_LIMIT:\n                    break\n                # Continue to attempt improvement but can break early\n                # Here, break immediately to return fastest\n                break\n\n        # Return successful or best found path\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 224\nSyntaxError: name 'c_best' is used prior to nonlocal declaration\n"
    }
}
