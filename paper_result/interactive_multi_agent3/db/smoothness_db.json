[
    {
        "operator": "e2",
        "algorithm_description": "A hybrid bidirectional RRT* planner with goal bias sampling, dynamic neighbor radius, and incremental rewiring that grows two trees from start and goal, efficiently connecting them and optimizing paths to improve time, path length, and smoothness under a 30-second limit. The planner alternates extensions between the two trees using nearest neighbor searches and rewiring with a radius that shrinks logarithmically to balance exploration and exploitation. It incorporates goal bias sampling to guide growth toward the goal and performs path extraction upon connection, returning the best path found if time expires.",
        "planning_mechanism": "The planner initializes two trees and at each iteration samples a point with goal bias. It extends one tree toward the sample, rewires nearby nodes to optimize costs, then attempts to connect the other tree to the newly added node. The neighbor radius shrinks over time for finer rewiring. Collision checks for nodes and edges are performed strictly. When the trees connect, the joint path is extracted. The search halts if 30 seconds elapsed, providing the best path so far.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success = False\n        best_path = []\n        best_cost = math.inf\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def distance(a,b):\n            return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_dist):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_dist:\n                return to_pos\n            ratio = max_dist / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fpos, tpos, resolution=1.0):\n            dist = distance(fpos, tpos)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps+1):\n                inter = tuple(fpos[d] + (tpos[d]-fpos[d]) * (i/steps) for d in range(dim))\n                if is_in_obstacle(inter):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: distance(n.position, point))\n\n        def near(tree, point, radius):\n            return [n for n in tree if distance(n.position, point) <= radius]\n\n        def extract_path(node_a, node_b):\n            path_a = []\n            cur = node_a\n            while cur:\n                path_a.append(cur.position)\n                cur = cur.parent\n            path_b = []\n            cur = node_b\n            while cur:\n                path_b.append(cur.position)\n                cur = cur.parent\n            return path_a[::-1] + path_b\n\n        def update_best_path(node_a, node_b):\n            nonlocal best_cost, best_path, success\n            path = extract_path(node_a, node_b)\n            cost = node_a.cost + node_b.cost + distance(node_a.position, node_b.position)\n            if cost < best_cost:\n                best_cost = cost\n                best_path = path\n                success = True\n\n        def try_connect(t1, t2, new_node):\n            connect_node = nearest(t2, new_node.position)\n            dist = distance(new_node.position, connect_node.position)\n            if dist <= self.step_size and not is_edge_in_obstacle(new_node.position, connect_node.position):\n                update_best_path(new_node, connect_node)\n                return True\n            return False\n\n        def rewire(tree, new_node, neighbor_radius):\n            near_nodes = near(tree, new_node.position, neighbor_radius)\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, near_node.position)\n                if cost_through_new + 1e-10 < near_node.cost and not is_edge_in_obstacle(new_node.position, near_node.position):\n                    if (near_node.parent,new_node) not in edges:\n                        # Remove old edge\n                        old_edge = (near_node.parent, near_node)\n                        if old_edge in edges:\n                            edges.remove(old_edge)\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n        def choose_parent(tree, new_pos, near_nodes, nearest_node):\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost = near_node.cost + distance(near_node.position, new_pos)\n                if cost + 1e-10 < min_cost:\n                    if not is_edge_in_obstacle(near_node.position, new_pos):\n                        min_cost = cost\n                        best_parent = near_node\n            return best_parent, min_cost\n\n        # Logarithmically shrinking radius: gamma * (log(n)/n)^{1/d}\n        def neighbor_radius(n):\n            # gamma chosen as 30 * step_size empirically\n            gamma = 30.0 * self.step_size\n            r = gamma * ((math.log(max(n,2))/max(n,2))**(1/dim))\n            return max(r, self.step_size*1.1)  # Lower bound radius\n\n        # Progressively alternate trees to maintain balance\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Goal biasing 10%\n            if random.random() < 0.1:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if is_in_obstacle(sample):\n                continue\n\n            # Alternate tree extension\n            if i % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            near_nodes = near(tree_a, new_pos, neighbor_radius(len(tree_a)))\n            best_parent, min_cost = choose_parent(tree_a, new_pos, near_nodes, nearest_node)\n            new_node = Node(new_pos, best_parent, min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            rewire(tree_a, new_node, neighbor_radius(len(tree_a)))\n\n            # Try to connect the other tree\n            if try_connect(tree_a, tree_b, new_node):\n                # Return immediately on successful connection with best path found\n                return PlannerResult(True, best_path, nodes, edges)\n\n        # Timeout or max_iter reached; return best known path\n        return PlannerResult(success, best_path, nodes, edges)",
        "objective": -9.56469,
        "time_improvement": -12.0,
        "length_improvement": 17.0,
        "smoothness_improvement": 635.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.059640908241271974,
                "num_nodes_avg": 153.3,
                "path_length_avg": 166.05377840818173,
                "smoothness_avg": 0.041459720213323434,
                "success_improvement": 0.0,
                "time_improvement": -130.60594048453115,
                "length_improvement": 8.983292763972708,
                "smoothness_improvement": 548.9346525619546,
                "objective_score": -31.047133224165943
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.04015326499938965,
                "num_nodes_avg": 301.1,
                "path_length_avg": 230.68238717193293,
                "smoothness_avg": 0.031820966671546595,
                "success_improvement": 0.0,
                "time_improvement": 75.56475003906536,
                "length_improvement": 22.9915793376491,
                "smoothness_improvement": 718.7763921747655,
                "objective_score": 40.0582545751829
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.03955848217010498,
                "num_nodes_avg": 283.8,
                "path_length_avg": 123.55329125489155,
                "smoothness_avg": 0.058074694551369176,
                "success_improvement": 0.0,
                "time_improvement": 19.08114938503833,
                "length_improvement": 17.941786923996816,
                "smoothness_improvement": 638.705828065364,
                "objective_score": 19.682946110236408
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This algorithm is an improved bidirectional RRT* variant that employs alternating tree expansion, goal-biased sampling, and a logarithmically shrinking adaptive neighbor radius for rewiring. It carefully maintains edge and parent-child consistency during rewiring and tracks the best path found so far to enable early termination and improved path smoothness.",
        "planning_mechanism": "The planner alternates growth between two trees rooted at start and goal, samples points with goal biasing, extends and rewires each tree\u2019s nodes within an adaptive radius that shrinks as the tree grows, and attempts to connect the trees. On each iteration, it updates the best path found and returns it if the 30-second limit expires. This approach balances efficient exploration and exploitation, optimizing path length and smoothness while reducing planning time.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, gamma_rrt_star: float = 50.0, max_radius: float = 60.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import time, math, random\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, parent=None, cost=0.0)\n        goal_root = Node(goal_pos, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        dimension = len(bounds)\n\n        def sample_free():\n            # Goal bias with 15% probability for faster convergence\n            if random.random() < 0.15:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, pos):\n            n = max(1, len(tree))\n            scale = max(1.0, sum(bounds) / dimension)\n            r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / dimension))\n            radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def choose_parent(new_pos, tree):\n            neighbors = near_nodes(tree, new_pos)\n            nearest_node = nearest(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for nb in neighbors:\n                if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost_to_new = nb.cost + math.dist(nb.position, new_pos)\n                    if cost_to_new < min_cost:\n                        min_cost = cost_to_new\n                        best_parent = nb\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(pivot, neighbors):\n            for nb in neighbors:\n                if nb == pivot.parent:\n                    continue  # No need to rewire parent\n                if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                    new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        # Remove old edge\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        # Rewire\n                        pivot.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((pivot, nb))\n\n        def extend_and_rewire(tree, sample_pt):\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n            new_node, neighbors = choose_parent(new_pos, tree)\n            rewire(new_node, neighbors)\n            return new_node\n\n        def connect_and_rewire(tree, target_node):\n            nearest_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(nearest_node.position, target_node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    return None\n                connect_node, neighbors = choose_parent(new_pos, tree)\n                rewire(connect_node, neighbors)\n\n                if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                    if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                        not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                        final_node = Node(target_node.position, parent=None,\n                                         cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                        connect_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((connect_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = connect_node\n\n        def update_best_path(node_a, node_b):\n            nonlocal best_cost, best_path, success\n            cost = node_a.cost + node_b.cost + math.dist(node_a.position, node_b.position)\n            if cost < best_cost:\n                best_cost = cost\n                path_a = node_a.path_from_root()\n                path_b = node_b.path_from_root()\n                # Remove duplicated connection node\n                if path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                best_path = path_a + path_b[::-1]\n                success = True\n\n        for iter_n in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                # Return best path found so far\n                return PlannerResult(success, best_path, nodes, edges)\n\n            sample = sample_free()\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n            new_node_b = connect_and_rewire(tree_b, new_node_a)\n            if new_node_b is not None:\n                update_best_path(new_node_a, new_node_b)\n                # Early exit once connected\n                return PlannerResult(True, best_path, nodes, edges)\n            tree_a, tree_b = tree_b, tree_a\n\n        # Timeout reached but return best path found\n        return PlannerResult(success, best_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 12.74394,
        "time_improvement": -71.0,
        "length_improvement": 13.0,
        "smoothness_improvement": 185.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.03062777519226074,
                "num_nodes_avg": 113.4,
                "path_length_avg": 165.29958062717503,
                "smoothness_avg": 0.017728440006473854,
                "success_improvement": 0.0,
                "time_improvement": -18.42453630296102,
                "length_improvement": 9.396680518771097,
                "smoothness_improvement": 177.48858402497052,
                "objective_score": 0.998090340499205
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.05584428310394287,
                "num_nodes_avg": 283.9,
                "path_length_avg": 258.68618441086676,
                "smoothness_avg": 0.010592462512259404,
                "success_improvement": 0.0,
                "time_improvement": 66.01598857391085,
                "length_improvement": 13.643105774681825,
                "smoothness_improvement": 172.5516898827977,
                "objective_score": 28.853418486396336
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.176558780670166,
                "num_nodes_avg": 412.7,
                "path_length_avg": 127.37884227021114,
                "smoothness_avg": 0.023962087443044688,
                "success_improvement": 0.0,
                "time_improvement": -261.1598022485762,
                "length_improvement": 15.40103809278519,
                "smoothness_improvement": 204.7959835782153,
                "objective_score": -68.08333790101067
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "A hybrid bidirectional asymptotically optimal path planner combining adaptive rewiring, goal bias sampling, consistent edge/parent management, and early-best-path tracking to produce shorter, smoother paths efficiently within time limits. It grows two trees from start and goal, alternately extending toward random samples with goal bias, uses an adaptive neighbor radius for targeted rewiring, keeps edge and parent-child data consistent, attempts rapid tree connections, and returns the best path found within a 30-second limit.",
        "planning_mechanism": "The planner initializes two trees rooted at the start and goal positions. It samples points with a goal bias to accelerate convergence. Each iteration extends one tree toward the sample using fixed maximum steps, rewires neighbors found using an adaptive radius to minimize path cost and smoothness, and attempts to connect to the other tree via an iterative steer-and-connect process that also rewires. Edge and node collision checks ensure path validity. Parent-child and edge lists remain consistent during rewiring. The planner tracks the best connecting path by cost and terminates early or at time limit, returning the best found path.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, gamma_rrt_star: float=50.0, max_radius: float=50.0, goal_bias: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n        self.goal_bias = goal_bias\n        self.time_limit = 30.0  # seconds\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        success = False\n\n        start_time = time.monotonic()\n\n        def time_exceeded():\n            return (time.monotonic() - start_time) > self.time_limit\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def steered(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def is_in_obstacle(p):\n            for o in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = o\n                    px,py,pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x,y,w,h = o\n                    px,py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(fpos, tpos, resolution=1.0):\n            d = dist(fpos, tpos)\n            steps = max(1,int(d / resolution))\n            for step in range(steps+1):\n                inter = tuple(fpos[i] + (tpos[i]-fpos[i])*(step/steps) for i in range(len(fpos)))\n                if is_in_obstacle(inter):\n                    return True\n            return False\n\n        def near_nodes(tree: List[Node], pos: Tuple[float,...]) -> List[Node]:\n            n = max(1,len(tree))\n            dim = len(pos)\n            scale = max(1.0, sum(bounds)/dim)\n            r_theory = self.gamma_rrt_star * ((math.log(n+1)/(n+1))**(1.0/dim))\n            radius = max(self.step_size*2.0, min(self.max_radius, r_theory*0.5 + scale*0.015))\n            return [nd for nd in tree if dist(nd.position,pos) <= radius]\n\n        def choose_parent_and_add(tree: List[Node], new_pos: Tuple[float,...]) -> Optional[Tuple[Node,List[Node]]]:\n            nearest = min(tree, key=lambda nd: dist(nd.position,new_pos))\n            if is_in_obstacle(new_pos): return None\n            if edge_in_obstacle(nearest.position,new_pos): return None\n            neighbors = near_nodes(tree,new_pos)\n            min_cost = nearest.cost + dist(nearest.position,new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                if nb == nearest: continue\n                if edge_in_obstacle(nb.position,new_pos): continue\n                cand_cost = nb.cost + dist(nb.position,new_pos)\n                if cand_cost < min_cost:\n                    min_cost = cand_cost\n                    best_parent = nb\n            new_node = Node(new_pos, None, min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent,new_node))\n            return new_node, neighbors\n\n        def rewire(pivot: Node, neighbors: List[Node]):\n            for nb in neighbors:\n                if nb is pivot: continue\n                if edge_in_obstacle(pivot.position, nb.position): continue\n                new_cost = pivot.cost + dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    # Remove old parent edge if exists\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float,...]) -> Optional[Node]:\n            nearest = min(tree, key=lambda nd: dist(nd.position, sample))\n            new_pos = steered(nearest.position, sample)\n            if is_in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                return None\n            res = choose_parent_and_add(tree, new_pos)\n            if res is None:\n                return None\n            new_node, neighbors = res\n            rewire(new_node, neighbors)\n            return new_node\n\n        def connect_and_rewire(tree: List[Node], target_node: Node) -> Optional[Node]:\n            nearest = min(tree, key=lambda nd: dist(nd.position, target_node.position))\n            curr = nearest\n            while True:\n                new_pos = steered(curr.position, target_node.position)\n                if is_in_obstacle(new_pos) or edge_in_obstacle(curr.position, new_pos):\n                    return None\n                res = choose_parent_and_add(tree, new_pos)\n                if res is None:\n                    return None\n                new_node, neighbors = res\n                rewire(new_node, neighbors)\n                if dist(new_node.position, target_node.position) <= self.step_size:\n                    if not edge_in_obstacle(new_node.position, target_node.position) and not is_in_obstacle(target_node.position):\n                        final_node = Node(target_node.position, None, new_node.cost + dist(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                curr = new_node\n\n        # Alternate expansion vars\n        tree_a, tree_b = tree_start, tree_goal\n\n        for iteration in range(self.max_iter):\n            if time_exceeded():\n                break\n            # Sample with goal bias\n            if random.random() < self.goal_bias:\n                sample_pt = goal_pos if tree_a is tree_start else start_pos\n            else:\n                sample_pt = tuple(random.uniform(0,bounds[d]) for d in range(len(bounds)))\n                if is_in_obstacle(sample_pt):\n                    continue\n\n            new_node_a = extend_and_rewire(tree_a, sample_pt)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = connect_and_rewire(tree_b, new_node_a)\n            if new_node_b is not None:\n                # Extract path and check cost\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                candidate_path = path_a + path_b[::-1]\n                candidate_cost = new_node_a.cost + new_node_b.cost - dist(new_node_a.position, new_node_b.position)\n                if candidate_cost < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    success = True\n                # Early return to improve runtime\n                if best_path and time.monotonic() - start_time > 0.1:\n                    # Yield faster convergence by returning early\n                    break\n            # Swap trees to alternate growth\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success, best_path, nodes, edges)",
        "objective": 29.39176,
        "time_improvement": -135.0,
        "length_improvement": 17.0,
        "smoothness_improvement": 205.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.1076784610748291,
                "num_nodes_avg": 390.3,
                "path_length_avg": 154.18408348873172,
                "smoothness_avg": 0.019648058564061502,
                "success_improvement": 0.0,
                "time_improvement": -316.34665732512264,
                "length_improvement": 15.48926063667552,
                "smoothness_improvement": 207.53478296963442,
                "objective_score": -84.5727669006833
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.10791921615600586,
                "num_nodes_avg": 624.3,
                "path_length_avg": 246.74452337231727,
                "smoothness_avg": 0.011418218250762089,
                "success_improvement": 0.0,
                "time_improvement": 34.32581329562554,
                "length_improvement": 17.62957595100447,
                "smoothness_improvement": 193.7989798022895,
                "objective_score": 21.844484458301793
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.10839545726776123,
                "num_nodes_avg": 471.6,
                "path_length_avg": 125.45012299295556,
                "smoothness_avg": 0.024564682980715784,
                "success_improvement": 0.0,
                "time_improvement": -121.72832052234313,
                "length_improvement": 16.682001600995804,
                "smoothness_improvement": 212.4609543384158,
                "objective_score": -25.446990424413375
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "An adaptive bidirectional RRT* planner with goal biasing, incremental rewiring, and informed sampling to efficiently find and iteratively improve a near-optimal path within a 30-second limit. The planner balances growth between start and goal trees, performs adaptive radius neighbor searches for rewiring, and applies an ellipsoidal informed sampling once a solution is found to enhance convergence and path smoothness.",
        "planning_mechanism": "The planner alternates expansions of two trees towards random samples biased towards the goal, incrementally rewires nodes with neighbors in adaptive shrinking radius to improve path cost and smoothness, and upon initial solution discovery, switches to single-tree informed RRT* refinement sampling inside an ellipsoid defined by current best cost to optimize the path further, always enforcing collision checking on nodes and edges, and returning the best path found upon timeout or success.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        # Parameters for rewiring and goal bias\n        self.goal_sample_rate = 0.15        # Probability to sample the goal (goal bias)\n        self.gamma_rrt_star = 50.0          # Parameter for adaptive neighbor radius\n        self.improve_tol = 1e-6             # Improvement tolerance for path cost updates\n        self.time_limit = 30.0              # seconds time limit\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        # Goal biased sampling with specified probability\n        if random.random() < goal_bias_prob:\n            # sample goal directly if free\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                return goal\n        # Otherwise uniform sample within bounds and free space\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        # Linear nearest search (simple but acceptable)\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _path_cost(self, node):\n        return node.cost\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # Avoid duplicating connecting node\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        # If no solution yet, uniform sample\n        if c_best == float(\"inf\") or c_best < c_min - 1e-10:\n            # fallback to uniform sampling\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        # Ellipsoid sampling inside prolate hyperspheroid\n        # Code adapted from literature informed RRT* sampling, avoids numpy:\n        dim = len(bounds)\n        center = tuple((s + g)/2 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            # Avoid degenerate case\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        # Construct basis for rotation - produce orthonormal matrix with a1 as first column\n        # Here only rotate axis to x direction, so use rotated coordinates is not required for sampling uniform ball\n        # Instead sample in unit ball, then scale and translate\n\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n\n        while True:\n            # Sample random point in unit ball in R^dim\n            rnd_dir = []\n            # Sample standard normal gaussian vector\n            for _ in range(dim):\n                rnd_dir.append(random.gauss(0,1))\n            norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n            if norm_dir < 1e-12: continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n\n            # Radius scaling to distribute uniformly inside ball\n            r = random.random() ** (1.0/dim)\n            ball_point = [r * x for x in unit_dir]\n\n            # Scale ball_point components for ellipsoid radii\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n\n            # Rotate scaled vector to align with real coordinate system (only one axis, so just shift)\n            # Since rotation matrix is large effort and only affects orientation, approximate by axis aligned\n            # We rotate by vector a1/norm_a1 using Householder reflection or simplified since high cost\n            # To simplify, we place along the direction a1 by scaling only the first coordinate\n            # This is acceptable for performance and uniformity compromise\n            # Align first dimension with a1 direction:\n            # new_point = center + rotation * scaled\n\n            # Construct base vector in direction a1:\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            # Add components in other basis directions orthogonal to a1\n            # We don't construct orthonormal basis explicitly, skip to keep simplicity and avoid foreign dependencies\n\n            # As an approximation, add the other components along axes orthogonal by spreading them equally\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            # Clamp point inside bounds\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        time_limit = self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n\n        def can_finish():\n            return time.monotonic() - time_start > time_limit\n\n        # Phase 1: Bidirectional RRT* until initial solution found\n        for it in range(self.max_iter):\n            if can_finish():\n                break\n\n            # Alternate expansion: even expands start tree, odd goal tree\n            expand_start_tree = (it % 2 == 0)\n            if expand_start_tree:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            # Sampling with goal bias\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos if expand_start_tree else start_pos, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors within adaptive rewiring radius\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes) ** (1/dim)), self.step_size * 20)\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            # Choose parent with minimum cost + edge cost + no collision between parent to new_pos\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes if cheaper via new_node\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and \\\n                   not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    # Rewire\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            # Attempt to connect from other tree\n            nearest_node_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_node_other.position, new_node.position)\n            if dist_connect <= self.step_size and \\\n               not self._is_edge_in_obstacle(nearest_node_other.position, new_node.position, obstacles, is_3d):\n\n                # Connect the two trees\n                connect_node = Node(new_node.position, parent=nearest_node_other,\n                                   cost=nearest_node_other.cost + dist_connect)\n                nearest_node_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_node_other, connect_node))\n\n                # Construct path: new_node from tree_a and connect_node from tree_b\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_node_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start_tree else new_node\n                    found_solution = True\n                    success_state = True\n\n            if found_solution:\n                break\n\n        # Phase 2: Single-tree informed RRT* refinement if solution found\n        if found_solution and best_goal_node:\n            # Reset tree for refinement: use start_root plus best path nodes (re-create properly)\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node,\n                                cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n            no_improve_count = 0\n            post_opt_iters = self.max_iter // 2\n\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if can_finish() or no_improve_count >= 150:\n                    break\n\n                # Informed sampling inside ellipsoid defined by best_cost\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min,\n                                                              start_pos, goal_pos, bounds, obstacles, is_3d)\n\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size * 20)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                    if candidate_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired_any = False\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        rewired_any = True\n\n                # Check if can connect directly to goal\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and \\\n                   not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired_any:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": -21.85805,
        "time_improvement": 39.0,
        "length_improvement": 15.0,
        "smoothness_improvement": 286.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.021411538124084473,
                "num_nodes_avg": 92.3,
                "path_length_avg": 161.62176685276987,
                "smoothness_avg": 0.026296503737064592,
                "success_improvement": 0.0,
                "time_improvement": 17.21071942180759,
                "length_improvement": 11.41254852721125,
                "smoothness_improvement": 311.59738725690346,
                "objective_score": 13.568731879153544
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.03712928295135498,
                "num_nodes_avg": 109.2,
                "path_length_avg": 246.37899691959302,
                "smoothness_avg": 0.013803575390083797,
                "success_improvement": 0.0,
                "time_improvement": 77.40499284926345,
                "length_improvement": 17.75159920201941,
                "smoothness_improvement": 255.17593710033827,
                "objective_score": 35.14833706149237
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.03867461681365967,
                "num_nodes_avg": 101.4,
                "path_length_avg": 127.66449265035354,
                "smoothness_avg": 0.030873705973109955,
                "success_improvement": 0.0,
                "time_improvement": 20.889140107088526,
                "length_improvement": 15.211322711504014,
                "smoothness_improvement": 292.7112611180333,
                "objective_score": 16.857091964619134
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "A hybrid bidirectional RRT* planner with adaptive rewiring radius, balanced goal-biased tree expansions, ellipsoidal informed sampling refinement, and recursive cost propagation for incremental path improvement. It employs efficient incremental rewiring during both bidirectional growth and single-tree refinement phases under a strict 30-second limit, always enforcing collision-free nodes and edges. The planner dynamically balances exploration and exploitation for faster convergence, better path quality, and enhanced smoothness.",
        "planning_mechanism": "The planner alternately expands two trees from start and goal with goal-biased sampling, uses adaptive logarithmic neighbor radius for rewiring, attempts connection to merge trees, and then refines the path using ellipsoidal informed samples with recursive cost updates until time expires, returning the best collision-free path found so far.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position         # Tuple[float, ...]\n        self.parent = parent             # Node or None\n        self.cost = cost                 # Cost from root\n        self.children = []               # List[Node]\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15     # Probability to sample goal/start in respective trees\n        self.gamma_rrt_star = 40.0       # Adaption parameter for neighbor radius\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0           # Hard time limit in seconds\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob:\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_node = node\n                best_dist = d\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_best < c_min - 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n        while True:\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _propagate_cost_to_descendants(self, node: Node):\n        # Propagate cost updates recursively to children\n        for child in node.children:\n            old_cost = child.cost\n            child.cost = node.cost + self._dist(node.position, child.position)\n            if abs(child.cost - old_cost) > 1e-10:\n                self._propagate_cost_to_descendants(child)\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n\n        def time_exceeded():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for it in range(self.max_iter):\n            if time_exceeded():\n                break\n            expand_start_tree = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start_tree else (tree_goal, tree_start)\n\n            sample_pt = self._sample(bounds, obstacles, is_3d,\n                                     goal_pos if expand_start_tree else start_pos,\n                                     self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)),\n                         self.step_size * 12)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                cost_candidate = near.cost + self._dist(near.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors with recursive cost updates\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    self._propagate_cost_to_descendants(near)\n\n            # Attempt connection\n            nearest_node_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_node_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_node_other.position, new_node.position, obstacles, is_3d):\n                # Connect by adopting new_node position in tree_b\n                connect_node = Node(new_node.position, parent=nearest_node_other, cost=nearest_node_other.cost + dist_connect)\n                nearest_node_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_node_other, connect_node))\n\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_node_other.cost)\n                    goal_node_for_path = connect_node\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n                    goal_node_for_path = new_node\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = goal_node_for_path\n                    found_solution = True\n                    success_state = True\n\n                # Early exit on first found solution to refine later\n                if found_solution:\n                    break\n\n        # Refinement phase\n        if found_solution and best_goal_node is not None:\n            # Reconstruct single tree from best path (start to goal)\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            max_no_improve = 150\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if time_exceeded() or no_improve_count >= max_no_improve:\n                    break\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)),\n                             self.step_size * 12)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near in near_nodes:\n                    cost_candidate = near.cost + self._dist(near.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired_any = False\n                for near in near_nodes:\n                    if near == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        self._propagate_cost_to_descendants(near)\n                        rewired_any = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired_any:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": -21.41658,
        "time_improvement": 42.0,
        "length_improvement": 13.0,
        "smoothness_improvement": 216.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.025189828872680665,
                "num_nodes_avg": 111.2,
                "path_length_avg": 164.23961870298234,
                "smoothness_avg": 0.022259303009276386,
                "success_improvement": 0.0,
                "time_improvement": 2.6016814779305992,
                "length_improvement": 9.977662445592637,
                "smoothness_improvement": 248.4064289453182,
                "objective_score": 8.009134055461354
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.0332127571105957,
                "num_nodes_avg": 114.7,
                "path_length_avg": 258.74349057657577,
                "smoothness_avg": 0.010733412225408526,
                "success_improvement": 0.0,
                "time_improvement": 79.7883927520825,
                "length_improvement": 13.623975327101634,
                "smoothness_improvement": 176.17842752409942,
                "objective_score": 32.99179515950623
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.02702016830444336,
                "num_nodes_avg": 94.5,
                "path_length_avg": 128.70631973867714,
                "smoothness_avg": 0.025448376165527135,
                "success_improvement": 0.0,
                "time_improvement": 44.7288964926287,
                "length_improvement": 14.519390765914297,
                "smoothness_improvement": 223.70146642177033,
                "objective_score": 23.24881073944604
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This algorithm refines bidirectional RRT* by integrating goal-biased sampling, adaptive logarithmically shrinking neighbor radius for rewiring, and early incremental best-path updates. It balances tree expansions, utilizes efficient collision checks, and incorporates dynamic rewiring to improve planning time, path smoothness, and cost. The planner halts immediately upon a valid path or when the 30-second time limit is reached, returning the best solution found.",
        "planning_mechanism": "A bidirectional planner alternately grows two trees from start and goal using goal-biased samples. Each extension steers with fixed steps, chooses optimal parents within an adaptive neighborhood radius, and rewires neighbors to locally optimize paths. It attempts to connect the two trees at each iteration, updating and tracking the best path by cost. Incremental rewiring and goal biasing accelerate convergence, and strict consistency of parent-child and edges maintains path validity. The algorithm respects map boundaries and obstacle constraints, and enforces early termination on timeout or successful connection.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma_rrt_star=50.0, max_radius=60.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        import time, math, random\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        dimension = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = dimension == 3\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dimension))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            # 15% goal bias to enhance convergence\n            if random.random() < 0.15:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not _is_in_obstacle(p):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, pos):\n            n = max(1, len(tree))\n            scale = max(1.0, sum(bounds) / dimension)\n            r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / dimension))\n            radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def choose_parent(new_pos, tree):\n            neighbors = near_nodes(tree, new_pos)\n            nearest_node = nearest(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in neighbors:\n                if not _is_edge_in_obstacle(nb.position, new_pos):\n                    cost_to_new = nb.cost + math.dist(nb.position, new_pos)\n                    if cost_to_new < min_cost:\n                        min_cost = cost_to_new\n                        best_parent = nb\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(pivot, neighbors):\n            for nb in neighbors:\n                if nb == pivot.parent:\n                    continue\n                if not _is_edge_in_obstacle(pivot.position, nb.position):\n                    new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        pivot.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((pivot, nb))\n\n        def extend_and_rewire(tree, sample_pt):\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if _is_in_obstacle(new_pos):\n                return None\n            if _is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_node, neighbors = choose_parent(new_pos, tree)\n            rewire(new_node, neighbors)\n            return new_node\n\n        def connect_and_rewire(tree, target_node):\n            nearest_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(nearest_node.position, target_node.position)\n                if _is_in_obstacle(new_pos):\n                    return None\n                if _is_edge_in_obstacle(nearest_node.position, new_pos):\n                    return None\n                connect_node, neighbors = choose_parent(new_pos, tree)\n                rewire(connect_node, neighbors)\n                if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                    if (not _is_edge_in_obstacle(connect_node.position, target_node.position)\n                            and not _is_in_obstacle(target_node.position)):\n                        final_node = Node(target_node.position, parent=None,\n                                         cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                        connect_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((connect_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = connect_node\n\n        def update_best_path(node_a, node_b):\n            nonlocal best_cost, best_path, success\n            connect_dist = math.dist(node_a.position, node_b.position)\n            total_cost = node_a.cost + node_b.cost + connect_dist\n            if total_cost < best_cost:\n                best_cost = total_cost\n                path_a = node_a.path_from_root()\n                path_b = node_b.path_from_root()\n                if path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                best_path = path_a + path_b[::-1]\n                success = True\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                # Time limit reached: return best path found\n                return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n            sample = sample_free()\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = connect_and_rewire(tree_b, new_node_a)\n            if new_node_b is not None:\n                update_best_path(new_node_a, new_node_b)\n                # Early termination on connection\n                return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # End of iterations: return best available path\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
        "objective": 1.26573,
        "time_improvement": -33.0,
        "length_improvement": 13.0,
        "smoothness_improvement": 181.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.027007746696472167,
                "num_nodes_avg": 114.4,
                "path_length_avg": 162.3602534286026,
                "smoothness_avg": 0.017185160995433314,
                "success_improvement": 0.0,
                "time_improvement": -4.427430952468747,
                "length_improvement": 11.007772332928688,
                "smoothness_improvement": 168.98508775293104,
                "objective_score": 6.121359552781243
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.05060133934020996,
                "num_nodes_avg": 281.0,
                "path_length_avg": 258.2118047478927,
                "smoothness_avg": 0.010853935606003383,
                "success_improvement": 0.0,
                "time_improvement": 69.20657946109982,
                "length_improvement": 13.80146736044408,
                "smoothness_improvement": 179.27958091628727,
                "objective_score": 29.939252159177833
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.12834506034851073,
                "num_nodes_avg": 333.2,
                "path_length_avg": 130.65665794387155,
                "smoothness_avg": 0.023091575071760274,
                "success_improvement": 0.0,
                "time_improvement": -162.53622979897614,
                "length_improvement": 13.224068995149436,
                "smoothness_improvement": 193.72313047001697,
                "objective_score": -39.85781189025309
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "An enhanced bidirectional RRT* planner featuring adaptive rewiring radius, balanced goal-biased tree extension, ellipsoidal informed sampling refinement, and integrated caching for nearest neighbor queries to improve runtime. It concurrently grows two trees with dynamic goal biasing, efficiently rewires nodes within an adaptively shrinking radius, and upon finding a feasible path, refines it with focused informed sampling until a 30-second termination, returning the best collision-free path found.",
        "planning_mechanism": "The planner alternates balanced expansions of start and goal trees with adaptive goal bias sampling and steering constrained by step size. It efficiently manages parent-child relationships and rewiring with an adaptive radius proportional to the tree size and space dimension, reducing redundant checks. It applies ellipsoidal informed sampling after an initial solution to concentrate search around promising corridors. Nearest neighbor queries are cached and updated incrementally for runtime gain. Collisions are strictly checked for nodes and edges. The search interrupts upon time expiration, ensuring the best path found is returned for robust operation.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        \n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n        \n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            \n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = 45.0\n        self.goal_sample_rate = 0.18\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0\n        # Cache for nearest neighbor acceleration\n        self._nn_cache = {}\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, fpos, tpos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(fpos, tpos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(fpos[d] + (tpos[d]-fpos[d])*(i/steps) for d in range(len(fpos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    \n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        r = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d]-from_pos[d])*r for d in range(len(from_pos)))\n    \n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n    \n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob, ellipsoid=None):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        dim = len(bounds)\n        if ellipsoid is None:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        else:\n            center, c1, c2, a1, norm_a1 = ellipsoid\n            while True:\n                rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n                norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n                if norm_dir < 1e-12:\n                    continue\n                unit_dir = [x / norm_dir for x in rnd_dir]\n                r = random.random() ** (1.0/dim)\n                ball_point = [r*x for x in unit_dir]\n                scaled = [c1*ball_point[0]] + [c2*ball_point[i] for i in range(1, dim)]\n                dir_a1 = [x / norm_a1 for x in a1]\n                point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n                for i in range(1, dim):\n                    point[i] += scaled[i]\n                pt = tuple(min(max(0.0, point[d]), bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        # Use cached index if available for same tree object to speed nearest neighbor\n        key = id(tree)\n        if key not in self._nn_cache:\n            self._nn_cache[key] = tree[:]\n        else:\n            if len(self._nn_cache[key]) != len(tree):\n                self._nn_cache[key] = tree[:]\n        return min(self._nn_cache[key], key=lambda n: self._dist(n.position, point))\n    \n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        # Filter cached to speed\n        key = id(tree)\n        if key not in self._nn_cache:\n            self._nn_cache[key] = tree[:]\n        result = []\n        for n in self._nn_cache[key]:\n            if self._dist(n.position, point) <= radius:\n                result.append(n)\n        return result\n    \n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        path_from_start = node_start.path_from_root()\n        path_from_goal = node_goal.path_from_root()\n        path_from_goal.reverse()\n        return path_from_start + path_from_goal[1:]\n    \n    def _ellipsoid_parameters(self, c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...], bounds):\n        dim = len(bounds)\n        center = tuple((s+g)/2 for s,g in zip(start,goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            norm_a1 = 1e-12  # prevent degenerate\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n        return (center, c1, c2, a1, norm_a1)\n    \n    def _propagate_cost_to_children(self, node: Node):\n        for c in node.children:\n            old_cost = c.cost\n            c.cost = node.cost + self._dist(node.position, c.position)\n            if abs(c.cost - old_cost) > 1e-10:\n                self._propagate_cost_to_children(c)\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        start_time = time.monotonic()\n\n        def time_exceeded():\n            return (time.monotonic() - start_time) > self.time_limit\n\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for i in range(self.max_iter):\n            if time_exceeded():\n                break\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n\n            goal_bias = self.goal_sample_rate\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal if expand_start else start, goal_bias)\n\n            nearest = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, resolution=1.0):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)), self.step_size * 15)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near in near_nodes:\n                cost_cand = near.cost + self._dist(near.position, new_pos)\n                if cost_cand < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_cand\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    self._propagate_cost_to_children(near)\n\n            # Try connect trees\n            nearest_b = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_b.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_b.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_b, cost=nearest_b.cost + dist_connect)\n                nearest_b.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_b, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_b.cost)\n                    goal_node_for_path = connect_node\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n                    goal_node_for_path = new_node\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = goal_node_for_path\n                    found_solution = True\n                    success_state = True\n\n                # Stop early on first solution to refine later\n                if found_solution:\n                    break\n\n        if found_solution and best_goal_node:\n            # Rebuild tree from start root with best path nodes\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children.clear()\n            start_root.cost = 0.0\n\n            prev = start_root\n            for pos in best_path[1:]:\n                n = Node(pos, parent=prev, cost=prev.cost + self._dist(prev.position, pos))\n                prev.add_child(n)\n                tree.append(n)\n                nodes.append(n)\n                edges.append((prev, n))\n                prev = n\n            best_goal_node = prev\n            best_cost = best_goal_node.cost\n\n            # Ellipsoid parameters for informed sampling\n            c_min = self._dist(start, goal)\n            no_improve_count = 0\n            max_no_improve = 150\n            refinement_iters = self.max_iter // 2\n\n            for _ in range(refinement_iters):\n                if time_exceeded() or no_improve_count >= max_no_improve:\n                    break\n                ellipsoid = self._ellipsoid_parameters(best_cost, c_min, start, goal, bounds)\n                sample_pt = self._sample(bounds, obstacles, is_3d, goal, 0.0, ellipsoid)\n                nearest = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_tree_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_tree_nodes) / n_tree_nodes) ** (1.0 / dim)), self.step_size * 15)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near in near_nodes:\n                    cost_candidate = near.cost + self._dist(near.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near in near_nodes:\n                    if near is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_via_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_via_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        self._propagate_cost_to_children(near)\n                        rewired = True\n\n                dist_to_goal = self._dist(new_node.position, goal)\n                if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal, obstacles, is_3d):\n                    goal_node = Node(goal, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": -13.83763,
        "time_improvement": 17.0,
        "length_improvement": 12.0,
        "smoothness_improvement": 224.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.025319766998291016,
                "num_nodes_avg": 124.3,
                "path_length_avg": 163.2394983196226,
                "smoothness_avg": 0.022534320283976204,
                "success_improvement": 0.0,
                "time_improvement": 2.09926619713116,
                "length_improvement": 10.525844275633734,
                "smoothness_improvement": 252.71104650394102,
                "objective_score": 8.208841657039294
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.04371612071990967,
                "num_nodes_avg": 119.0,
                "path_length_avg": 261.4357946273634,
                "smoothness_avg": 0.011276384089395365,
                "success_improvement": 0.0,
                "time_improvement": 73.39657591656308,
                "length_improvement": 12.72520674127337,
                "smoothness_improvement": 190.14948467130657,
                "objective_score": 30.604844243089474
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.060172200202941895,
                "num_nodes_avg": 108.8,
                "path_length_avg": 129.2796635396884,
                "smoothness_avg": 0.025811603953994167,
                "success_improvement": 0.0,
                "time_improvement": -23.085240188387644,
                "length_improvement": 14.138603112980558,
                "smoothness_improvement": 228.32169708038452,
                "objective_score": 2.6991982966739645
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "A tuned adaptive bidirectional RRT* planner with recursive descendant cost propagation, enhanced goal bias, and ellipsoidal informed refinement that balances exploration and exploitation. It uses adaptive neighbor radius shrinking for rewiring, efficient collision checking, consistent edge and parent-child updates, and early termination on a 30-second limit to improve planning time, path smoothness, and path length.",
        "planning_mechanism": "A bidirectional RRT* grows two trees from start and goal alternately with goal bias sampling until first connection, then conducts single-tree ellipsoidal informed RRT* refinement focused on the best path. Neighbor radius adapts with tree size. Rewiring propagates cost updates recursively to descendants ensuring path cost consistency and smoother paths. The best path is updated progressively and returned when time limit is reached.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.18          # goal bias probability\n        self.gamma_rrt_star = 40.0            # adaptive radius multiplier tuned for balance\n        self.improve_tol = 1e-6               # small tolerance for cost improvements\n        self.time_limit = 30.0                # hard time limit in seconds\n        self.max_radius_factor = 12.0         # max radius factor for neighbor search\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point):\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # avoid duplicate connecting node\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        if c_best == float(\"inf\") or c_best < c_min - 1e-10:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        dim = len(bounds)\n        center = tuple((s+g)/2 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n\n        while True:\n            rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0/dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _update_costs_recursive(self, node: Node):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_costs_recursive(child)\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        # Phase 1: Bidirectional growth until initial path found\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size * self.max_radius_factor)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire within neighbors with recursive cost update\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    self._update_costs_recursive(near_node)\n\n            # Attempt connection to other tree\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n                    success_state = True\n                    break\n\n        # Phase 2: Refinement via single-tree informed RRT*\n        if found_solution and best_goal_node is not None:\n            tree = [start_root]\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n            no_improve_count = 0\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if timed_out() or no_improve_count >= 120:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size * self.max_radius_factor)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        self._update_costs_recursive(near_node)\n                        rewired = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
        "objective": -26.48735,
        "time_improvement": 58.0,
        "length_improvement": 13.0,
        "smoothness_improvement": 228.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.017215156555175783,
                "num_nodes_avg": 208.5,
                "path_length_avg": 160.40239983380974,
                "smoothness_avg": 0.02374652355073028,
                "success_improvement": 0.0,
                "time_improvement": 33.43633614808805,
                "length_improvement": 12.08090291241019,
                "smoothness_improvement": 271.6846599701681,
                "objective_score": 18.637865891723372
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.03504271507263183,
                "num_nodes_avg": 467.1,
                "path_length_avg": 253.42542860882128,
                "smoothness_avg": 0.010719255016317384,
                "success_improvement": 0.0,
                "time_improvement": 78.67477272090856,
                "length_improvement": 15.399297483864519,
                "smoothness_improvement": 175.8141523371588,
                "objective_score": 33.72108106827707
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.019155335426330567,
                "num_nodes_avg": 300.1,
                "path_length_avg": 131.29531716904052,
                "smoothness_avg": 0.02638587363121502,
                "success_improvement": 0.0,
                "time_improvement": 60.81680487189903,
                "length_improvement": 12.799901947476434,
                "smoothness_improvement": 235.62636498645543,
                "objective_score": 27.103114454987843
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "An optimized bidirectional RRT* planner with incremental nearest neighbor caching, adaptive rewiring radius, and efficient ellipsoidal informed sampling refinement, incorporating subtree cost update propagation, balanced goal-biased tree expansion, and early pruning strategies for faster convergence and smoother, shorter paths within a strict 30-second time limit.",
        "planning_mechanism": "The planner alternates growth of two trees from start and goal with adaptive radius rewiring and goal bias. Nearest neighbor queries use incremental caching to reduce computation. Upon initial solution discovery, it performs focused refinement via ellipsoidal informed sampling in a single tree. Rewiring propagates cost changes to descendants to maintain consistency, and collision checks prune expansions early. The best feasible path found within the time limit is returned.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = 40.0  # Tuned parameter\n        self.goal_sample_rate = 0.2\n        self.time_limit = 30.0\n        self.improve_tol = 1e-7\n        \n        # Nearest neighbor cache keyed by tree id: stores nodes list snapshot\n        self._nn_cache = {}\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        r = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d]-from_pos[d])*r for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob, ellipsoid=None):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        dim = len(bounds)\n        if ellipsoid is None:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        else:\n            center, c1, c2, a1, norm_a1 = ellipsoid\n            while True:\n                rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n                norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n                if norm_dir < 1e-12:\n                    continue\n                unit_dir = [x / norm_dir for x in rnd_dir]\n                r = random.random() ** (1.0/dim)\n                ball_point = [r*x for x in unit_dir]\n                scaled = [c1*ball_point[0]] + [c2*ball_point[i] for i in range(1, dim)]\n                dir_a1 = [x / norm_a1 for x in a1]\n                point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n                for i in range(1, dim):\n                    point[i] += scaled[i]\n                pt = tuple(min(max(0.0, point[d]), bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        key = id(tree)\n        if key not in self._nn_cache or len(self._nn_cache[key]) != len(tree):\n            self._nn_cache[key] = list(tree)\n        nearest_node = min(self._nn_cache[key], key=lambda n: self._dist(n.position, point))\n        return nearest_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        key = id(tree)\n        if key not in self._nn_cache or len(self._nn_cache[key]) != len(tree):\n            self._nn_cache[key] = list(tree)\n        candidates = [n for n in self._nn_cache[key] if self._dist(n.position, point) <= radius]\n        return candidates\n\n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoid_parameters(self, c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...], bounds):\n        dim = len(bounds)\n        center = tuple((s + g) * 0.5 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            norm_a1 = 1e-12\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n        return (center, c1, c2, a1, norm_a1)\n\n    def _propagate_cost(self, node: Node):\n        for child in node.children:\n            old_cost = child.cost\n            child.cost = node.cost + self._dist(node.position, child.position)\n            if abs(child.cost - old_cost) > 1e-10:\n                self._propagate_cost(child)\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        start_time = time.monotonic()\n        time_limit = self.time_limit\n        \n        def time_exceeded():\n            return (time.monotonic() - start_time) > time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success = False\n\n        for i in range(self.max_iter):\n            if time_exceeded():\n                break\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n            goal_bias = self.goal_sample_rate\n            \n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, goal_bias)\n\n            nearest = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, resolution=1.0):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            # Adaptive radius with upper limit\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)), self.step_size * 12)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for near in near_nodes:\n                if near is nearest:\n                    continue\n                cost_candidate = near.cost + self._dist(near.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    # Remove old edge\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    # Propagate cost to children recursively\n                    self._propagate_cost(near)\n\n            # Attempt to connect trees\n            nearest_b = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_b.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_b.position, new_node.position, obstacles, is_3d):\n                # Create connecting node in tree_b as child of nearest_b\n                conn_node = Node(new_node.position, parent=nearest_b, cost=nearest_b.cost + dist_connect)\n                nearest_b.add_child(conn_node)\n                tree_b.append(conn_node)\n                nodes.append(conn_node)\n                edges.append((nearest_b, conn_node))\n\n                if expand_start:\n                    cur_path = self._build_path(new_node, conn_node)\n                    cur_cost = new_node.cost + (conn_node.cost - nearest_b.cost)\n                    goal_node_for_path = conn_node\n                else:\n                    cur_path = self._build_path(conn_node, new_node)\n                    cur_cost = conn_node.cost + (new_node.cost - best_parent.cost)\n                    goal_node_for_path = new_node\n\n                if cur_cost + self.improve_tol < best_cost:\n                    best_cost = cur_cost\n                    best_path = cur_path\n                    best_goal_node = goal_node_for_path\n                    found_solution = True\n                    success = True\n\n                if found_solution:\n                    break\n\n        # If solution found, start refinement via ellipsoidal informed sampling\n        if found_solution and best_goal_node:\n            # Rebuild single tree from start_root along best path nodes\n            # Clear old children\n            start_root.children.clear()\n            start_root.cost = 0.0\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            prev = start_root\n            for pos in best_path[1:]:\n                nd = Node(pos, parent=prev, cost=prev.cost + self._dist(prev.position, pos))\n                prev.add_child(nd)\n                tree.append(nd)\n                nodes.append(nd)\n                edges.append((prev, nd))\n                prev = nd\n            best_goal_node = prev\n            best_cost = best_goal_node.cost\n\n            c_min = self._dist(start_pos, goal_pos)\n            no_improve_count = 0\n            max_no_improve = 150\n            refinement_max_iter = self.max_iter // 2\n\n            for _ in range(refinement_max_iter):\n                if time_exceeded() or no_improve_count >= max_no_improve:\n                    break\n                ellipsoid = self._ellipsoid_parameters(best_cost, c_min, start_pos, goal_pos, bounds)\n                sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos, 0.0, ellipsoid)\n\n                nearest = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest.position, sample_pt)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)), self.step_size * 12)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near in near_nodes:\n                    cost_cand = near.cost + self._dist(near.position, new_pos)\n                    if cost_cand < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_cand\n                        best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                \n                rewired = False\n                for near in near_nodes:\n                    if near is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_via_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_via_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        self._propagate_cost(near)\n                        rewired = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        success = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success else best_path\n        else:\n            extracted_path = best_path\n            success = found_solution\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": -12.40664,
        "time_improvement": 11.0,
        "length_improvement": 13.0,
        "smoothness_improvement": 197.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.024726438522338866,
                "num_nodes_avg": 136.2,
                "path_length_avg": 158.9240097978004,
                "smoothness_avg": 0.02154214850608637,
                "success_improvement": 0.0,
                "time_improvement": 4.393414211438477,
                "length_improvement": 12.89123191773616,
                "smoothness_improvement": 237.18140364446492,
                "objective_score": 10.238670432295564
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.035642027854919434,
                "num_nodes_avg": 112.6,
                "path_length_avg": 250.04126451818865,
                "smoothness_avg": 0.011241461904313998,
                "success_improvement": 0.0,
                "time_improvement": 78.31006121761729,
                "length_improvement": 16.52902886508012,
                "smoothness_improvement": 189.2509116957298,
                "objective_score": 34.35669024281191
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.07304487228393555,
                "num_nodes_avg": 103.4,
                "path_length_avg": 133.94841461811015,
                "smoothness_avg": 0.020864073099746132,
                "success_improvement": 0.0,
                "time_improvement": -49.416933721475225,
                "length_improvement": 11.037840948728759,
                "smoothness_improvement": 165.38946980308978,
                "objective_score": -7.375428198189863
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "A hybrid bidirectional RRT* planner integrating adaptive neighborhood rewiring with incremental informed path refinement. The algorithm alternates tree expansions from start and goal, uses adaptive radius for rewiring with efficient nearest and near searches, and upon initial path discovery switches to an incremental informed sampling refinement phase centered on the current best path. Recursive cost updates, consistent parent-child-edge management, goal bias sampling, and collision checks enforce path validity while improving path length, smoothness, and planning efficiency within a strict 30-second time limit.",
        "planning_mechanism": "A bidirectional RRT* grows two trees from start and goal with adaptive rewiring radii and goal bias sampling, connecting them when feasible to form an initial solution. This switches to a single-tree incremental informed refinement phase, sampling inside an ellipsoidal subspace around the best path to improve path cost and smoothness. Parent-child edges are maintained carefully with recursive cost propagation upon rewiring. Early stopping is triggered on time limit or convergence, returning the best path found with success status.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_recursively(self, new_cost: float):\n        if new_cost + 1e-14 >= self.cost:\n            return\n        diff = new_cost - self.cost\n        self.cost = new_cost\n        for c in self.children:\n            c.update_cost_recursively(c.cost + diff)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = 30.0\n        self.goal_sample_rate = 0.25\n        self.time_limit = 30.0\n        self.improve_tol = 1e-9\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        return math.dist(p1, p2)\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _sample_uniform(self, bounds: Tuple[int, ...], obstacles, is_3d: bool):\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _sample_goal_bias(self, bounds: Tuple[int, ...], obstacles, is_3d: bool, goal_pos: Tuple[float, ...], goal_bias: float):\n        if random.random() < goal_bias and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n            return goal_pos\n        return self._sample_uniform(bounds, obstacles, is_3d)\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float('inf') or c_best < c_min - 1e-14:\n            # No solution yet: uniform sampling\n            return self._sample_uniform(bounds, obstacles, is_3d)\n\n        center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n        vec = tuple(g - s for s, g in zip(start, goal))\n        norm_vec = math.sqrt(sum(x * x for x in vec))\n        if norm_vec < 1e-14:\n            return self._sample_uniform(bounds, obstacles, is_3d)\n        a1 = tuple(x / norm_vec for x in vec)\n\n        c1 = c_best * 0.5\n        try:\n            c2 = math.sqrt(max(c_best ** 2 - c_min ** 2, 0.0)) * 0.5\n        except Exception:\n            c2 = 0.0\n\n        while True:\n            direction = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in direction))\n            if norm_dir < 1e-14:\n                continue\n            unit_dir = [x / norm_dir for x in direction]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n\n            scaled = [c1 * ball_point[0]] + [c2 * bp for bp in ball_point[1:]]\n            # Construct orthonormal basis with a1 as first axis\n            # Simple method: rotate vector in axis-aligned system\n            point = [center[d] + a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        radius_sq = radius * radius\n        result = []\n        for n in tree:\n            dist_sq = sum((n.position[d] - point[d]) ** 2 for d in range(len(point)))\n            if dist_sq <= radius_sq:\n                result.append(n)\n        return result\n\n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        def timed_out() -> bool:\n            return (time.monotonic() - start_time) >= self.time_limit\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = tree_start[:] + tree_goal[:]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        max_rewire_radius_factor = 10.0\n        max_rewire_radius = self.step_size * max_rewire_radius_factor\n\n        # -------------------- Bidirectional phase --------------------\n        for it in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            goal_sample = goal_pos if expand_start else start_pos\n\n            sample = self._sample_goal_bias(bounds, obstacles, is_3d, goal_sample, self.goal_sample_rate)\n\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), max_rewire_radius)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near_n in near_nodes:\n                candidate_cost = near_n.cost + self._dist(near_n.position, new_pos)\n                if candidate_cost + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_n.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near_n\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near nodes with recursive cost updates\n            for near_n in near_nodes:\n                if near_n is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_n.position)\n                if cost_through_new + self.improve_tol < near_n.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_n.position, obstacles, is_3d):\n                        if near_n.parent:\n                            try:\n                                edges.remove((near_n.parent, near_n))\n                            except ValueError:\n                                pass\n                            near_n.parent.remove_child(near_n)\n                        near_n.parent = new_node\n                        near_n.update_cost_recursively(cost_through_new)\n                        new_node.add_child(near_n)\n                        edges.append((new_node, near_n))\n\n            # Attempt to connect trees\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_to_other = self._dist(nearest_other.position, new_node.position)\n            if dist_to_other <= self.step_size:\n                if not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    # Connect trees by creating a connecting node on the other tree\n                    connect_node = Node(new_node.position,\n                                        parent=nearest_other,\n                                        cost=nearest_other.cost + dist_to_other)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    if expand_start:\n                        candidate_path = self._build_path(new_node, connect_node)\n                        candidate_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    else:\n                        candidate_path = self._build_path(connect_node, new_node)\n                        candidate_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                    if candidate_cost + self.improve_tol < best_cost:\n                        best_cost = candidate_cost\n                        best_path = candidate_path\n                        best_goal_node = connect_node if expand_start else new_node\n                        found_solution = True\n                        success_state = True\n\n                    # Once initial path found, break to start refinement\n                    if found_solution:\n                        break\n            if found_solution:\n                break\n\n        # -------------------- Incremental informed refinement phase --------------------\n        if found_solution and best_goal_node:\n            # Reinitialize single-tree with the found path\n            tree = [Node(start_pos, cost=0.0)]\n            nodes = [tree[0]]\n            edges = []\n            tree[0].children = []\n\n            prev = tree[0]\n            for pos in best_path[1:]:\n                c = prev.cost + self._dist(prev.position, pos)\n                n = Node(pos, parent=prev, cost=c)\n                prev.add_child(n)\n                tree.append(n)\n                nodes.append(n)\n                edges.append((prev, n))\n                prev = n\n\n            best_goal_node = prev\n            best_cost = best_goal_node.cost\n\n            c_min = self._dist(start_pos, goal_pos)\n            no_improve_count = 0\n            max_no_improve = 100\n            refinement_iters = self.max_iter // 2\n\n            for _ in range(refinement_iters):\n                if timed_out() or no_improve_count >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min,\n                                                              start_pos, goal_pos,\n                                                              bounds, obstacles, is_3d)\n\n                nearest = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), max_rewire_radius)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near_n in near_nodes:\n                    candidate_cost = near_n.cost + self._dist(near_n.position, new_pos)\n                    if candidate_cost + self.improve_tol < min_cost:\n                        if not self._is_edge_in_obstacle(near_n.position, new_pos, obstacles, is_3d):\n                            min_cost = candidate_cost\n                            best_parent = near_n\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near_n in near_nodes:\n                    if near_n is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_n.position)\n                    if cost_through_new + self.improve_tol < near_n.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near_n.position, obstacles, is_3d):\n                            if near_n.parent:\n                                try:\n                                    edges.remove((near_n.parent, near_n))\n                                except ValueError:\n                                    pass\n                                near_n.parent.remove_child(near_n)\n                            near_n.parent = new_node\n                            near_n.update_cost_recursively(cost_through_new)\n                            new_node.add_child(near_n)\n                            edges.append((new_node, near_n))\n                            rewired = True\n\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                        goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                        new_node.add_child(goal_node)\n                        tree.append(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n\n                        if goal_node.cost + self.improve_tol < best_cost:\n                            best_cost = goal_node.cost\n                            best_goal_node = goal_node\n                            no_improve_count = 0\n                            success_state = True\n                        else:\n                            no_improve_count += 1\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            if best_goal_node:\n                extracted_path = best_goal_node.path_from_root()\n            else:\n                extracted_path = best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": -15.78863,
        "time_improvement": 26.0,
        "length_improvement": 12.0,
        "smoothness_improvement": 131.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.025350546836853026,
                "num_nodes_avg": 80.7,
                "path_length_avg": 159.44212186387108,
                "smoothness_avg": 0.016914811536104846,
                "success_improvement": 0.0,
                "time_improvement": 1.9802536966702367,
                "length_improvement": 12.607246484311755,
                "smoothness_improvement": 164.75353164119315,
                "objective_score": 8.98219165779409
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.04258110523223877,
                "num_nodes_avg": 101.5,
                "path_length_avg": 264.79743783191964,
                "smoothness_avg": 0.007870517390592788,
                "success_improvement": 0.0,
                "time_improvement": 74.08728904166492,
                "length_improvement": 11.602993480057835,
                "smoothness_improvement": 102.51408136449002,
                "objective_score": 29.700553207356624
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.04729220867156982,
                "num_nodes_avg": 79.0,
                "path_length_avg": 132.80804150961566,
                "smoothness_avg": 0.01772934582986569,
                "success_improvement": 0.0,
                "time_improvement": 3.2614256459426256,
                "length_improvement": 11.795222468658766,
                "smoothness_improvement": 125.5159703117091,
                "objective_score": 8.683141026536592
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "An adaptive bidirectional RRT* planner with efficient incremental rewiring, recursive cost propagation, and dynamic neighbor radius limiting. The planner balances tree expansions with goal bias, caches nearest neighbors to minimize redundant computation, and triggers ellipsoidal informed sampling refinement after an initial solution is found. It maintains consistent edge and parent-child relationships to improve path smoothness and quality, while enforcing early termination upon timeout to guarantee timely results.",
        "planning_mechanism": "The planner grows two trees alternately from start and goal with adaptive rewiring neighborhoods that shrink logarithmically, uses goal-biased and obstacle-aware sampling, and connects trees when possible. Upon first solution, it refines paths by sampling within an ellipsoid based on current best cost, rewiring neighbors efficiently with recursive cost updating, and pruning unnecessary edges. It terminates when the time limit is reached, returning the best path found.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True  # Indicates if node is free from obstacle\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.gamma_rrt_star = 40.0\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0\n        try:\n            dist = sum((to_pos[d] - from_pos[d]) ** 2 for d in range(len(from_pos))) ** 0.5\n        except Exception:\n            dist = 0\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, p1, p2):\n        return sum((p1[d] - p2[d]) ** 2 for d in range(len(p1))) ** 0.5\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point, cached=None):\n        best_node = None\n        best_dist = float(\"inf\")\n        if cached is not None:\n            nodes_to_check = cached\n        else:\n            nodes_to_check = tree\n        for node in nodes_to_check:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _update_cost_recursive(self, node):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                child.cost = new_cost\n                self._update_cost_recursive(child)\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_best < c_min - 1e-10:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        center = tuple((s + g)*0.5 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = sum(x * x for x in a1) ** 0.5\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best * 0.5\n        c2 = max((c_best * c_best - c_min * c_min), 0) ** 0.5 * 0.5\n        while True:\n            rnd_dir = []\n            for _ in range(dim):\n                rnd_dir.append(random.gauss(0, 1))\n            norm_dir = sum(x * x for x in rnd_dir) ** 0.5\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        treestart = [Node(start_pos, cost=0.0)]\n        treegoal = [Node(goal_pos, cost=0.0)]\n\n        nodes = [treestart[0], treegoal[0]]\n        edges = []\n\n        best_cost = float(\"inf\")\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        time_start = time.monotonic()\n        def time_over():\n            return time.monotonic() - time_start > self.time_limit\n\n        max_neighbor_radius = self.step_size * 12\n\n        for it in range(self.max_iter):\n            if time_over():\n                break\n            expand_start = (it % 2 == 0)\n            tree_from = treestart if expand_start else treegoal\n            tree_to = treegoal if expand_start else treestart\n            # Sample biased towards opposite goal\n            sample_goal = goal_pos if expand_start else start_pos\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n\n            nearest = self._nearest(tree_from, sample_pt)\n            new_pos = self._steer(nearest.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_from) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), max_neighbor_radius)\n\n            near_nodes = self._near(tree_from, new_pos, radius)\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near in near_nodes:\n                cost_cand = near.cost + self._dist(near.position, new_pos)\n                if cost_cand + self.improve_tol < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_cand\n                    best_parent = near\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    self._update_cost_recursive(near)\n\n            nearest_other = self._nearest(tree_to, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_to.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n                    success_state = True\n            if found_solution:\n                break\n\n        if found_solution and best_goal_node:\n            # Prepare single-tree refinement on start tree\n            refined_tree = [Node(start_pos, cost=0.0)]\n            nodes = [refined_tree[0]]\n            edges = []\n            refined_tree[0].children = []\n            refined_tree[0].cost = 0.0\n\n            prev = refined_tree[0]\n            for p in best_path[1:]:\n                n = Node(p, parent=prev, cost=prev.cost + self._dist(prev.position, p))\n                prev.add_child(n)\n                refined_tree.append(n)\n                nodes.append(n)\n                edges.append((prev, n))\n                prev = n\n\n            best_goal_node = prev\n            best_cost = best_goal_node.cost\n            no_improve_count = 0\n            max_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(max_opt_iters):\n                if time_over() or no_improve_count >= 150:\n                    break\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest = self._nearest(refined_tree, sample_pt)\n                new_pos = self._steer(nearest.position, sample_pt)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(refined_tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), max_neighbor_radius)\n                near_nodes = self._near(refined_tree, new_pos, radius)\n                min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near in near_nodes:\n                    cost_cand = near.cost + self._dist(near.position, new_pos)\n                    if cost_cand + self.improve_tol < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_cand\n                        best_parent = near\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                refined_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired_any = False\n                for near in near_nodes:\n                    if near == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        self._update_cost_recursive(near)\n                        rewired_any = True\n\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(new_goal_node)\n                    refined_tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired_any:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": 40.15593,
        "time_improvement": -162.0,
        "length_improvement": 12.0,
        "smoothness_improvement": 205.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.045547890663146975,
                "num_nodes_avg": 114.1,
                "path_length_avg": 162.35762146251975,
                "smoothness_avg": 0.021828592751507586,
                "success_improvement": 0.0,
                "time_improvement": -76.1142556878941,
                "length_improvement": 11.009214955244868,
                "smoothness_improvement": 241.6648781089417,
                "objective_score": -15.0204233426766
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.11712124347686767,
                "num_nodes_avg": 116.2,
                "path_length_avg": 263.8098389248626,
                "smoothness_avg": 0.009960499450304543,
                "success_improvement": 0.0,
                "time_improvement": 28.725924027940174,
                "length_improvement": 11.93268242169186,
                "smoothness_improvement": 156.29082511410428,
                "objective_score": 16.55884078696769
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.2629024744033813,
                "num_nodes_avg": 103.2,
                "path_length_avg": 129.88529366049312,
                "smoothness_avg": 0.024937401502235425,
                "success_improvement": 0.0,
                "time_improvement": -437.780139315556,
                "length_improvement": 13.736372423749357,
                "smoothness_improvement": 217.20190642092612,
                "objective_score": -122.00620880831256
            }
        ],
        "success_rate": 1.0
    }
]