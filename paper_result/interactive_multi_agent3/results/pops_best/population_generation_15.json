{
     "operator": "m1",
     "algorithm_description": "A bidirectional RRT* planner with adaptive fixed-radius rewiring, goal-biased and informed sampling, early solution detection with incremental local refinement, and progressive shortcut smoothing to balance fast convergence and high-quality smooth paths within a strict 30-second limit. The planner alternates growing trees from start and goal, performs rewiring without costly recursive subtree updates, employs ellipsoidal informed sampling after initial solution, and uses multiple passes of efficient local shortcut smoothing to enhance path smoothness and reduce length.",
     "planning_mechanism": "The algorithm maintains two RRT* trees grown alternately towards sampled points with goal bias; neighbors are searched within an adaptively computed fixed radius based on node count and environment dimension. Rewiring updates costs locally without recursive cascades. Upon first connection of the two trees, the best path is recorded and a shorter refinement phase using ellipsoidal sampling improves the path incrementally. After planning or timeout, the final path undergoes multiple iterative shortcut smoothing passes, reducing sharp turns and unnecessary waypoints for smoothness improvements. The time limit is enforced strictly to stop planning and return the current best path if exceeded.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]\n        self.parent = parent          # Node or None\n        self.cost = cost              # Cost from root\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n        self.goal_sample_rate = 0.15\n        self.time_limit = 30.0\n        self.improve_tol = 1e-8\n        self.check_resolution = 1.0\n\n    def plan(self, map):\n        import time, math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            steps = max(1, int(distance / self.check_resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample(goal):\n            if random.random() < self.goal_sample_rate and not is_in_obstacle(goal):\n                return goal\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d_ = dist(node.position, point)\n                if d_ < best_dist:\n                    best_dist = d_\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            res = []\n            r2 = radius * radius\n            for node in tree:\n                d_ = dist(node.position, point)\n                if d_ <= radius:\n                    res.append(node)\n            return res\n\n        def rewiring_radius(n):\n            if n <= 1:\n                return self.step_size * 2.0\n            gamma = 20.0  # Tuned constant\n            r = gamma * (math.log(n)/n) ** (1/dim)\n            return max(r, self.step_size)\n\n        def build_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            path_goal.reverse()\n            return path_start + path_goal[1:]\n\n        def shortcut_path(path):\n            # Multiple passes of shortcutting for smoother curves\n            if len(path) <= 2:\n                return path[:]\n            for _ in range(3):  # Iteratively improve smoothness\n                new_path = [path[0]]\n                i = 0\n                n = len(path)\n                while i < n - 1:\n                    j = n - 1\n                    while j > i + 1:\n                        if not is_edge_in_obstacle(path[i], path[j]):\n                            break\n                        j -= 1\n                    new_path.append(path[j])\n                    i = j\n                path = new_path\n            return path\n\n        # Initialize trees\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        best_goal_node = None\n\n        for iter_ in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (iter_ % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = sample(sample_goal)\n            nearest_node = nearest(tree_a, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            radius = rewiring_radius(len(tree_a))\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nnode in near_nodes:\n                cc = nnode.cost + dist(nnode.position, new_pos)\n                if cc + self.improve_tol < min_cost and not is_edge_in_obstacle(nnode.position, new_pos):\n                    min_cost = cc\n                    best_parent = nnode\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Local rewiring (no recursive cost update for speed)\n            for nnode in near_nodes:\n                if nnode is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nnode.position)\n                if cost_through_new + self.improve_tol < nnode.cost and not is_edge_in_obstacle(new_node.position, nnode.position):\n                    if nnode.parent:\n                        try:\n                            edges.remove((nnode.parent, nnode))\n                        except ValueError:\n                            pass\n                        nnode.parent.remove_child(nnode)\n                    nnode.parent = new_node\n                    nnode.cost = cost_through_new\n                    new_node.add_child(nnode)\n                    edges.append((new_node, nnode))\n\n            # Try connecting trees\n            nearest_other = nearest(tree_b, new_node.position)\n            dist_connect = dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not is_edge_in_obstacle(nearest_other.position, new_node.position):\n                # Connect trees by adding a node in tree_b\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    path = build_path(new_node, connect_node)\n                    path_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = build_path(connect_node, new_node)\n                    path_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if path_cost + self.improve_tol < best_cost:\n                    best_cost = path_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n\n            if found_solution:\n                # Early stop after first solution to save time\n                break\n\n        # Incremental Refinement via ellipsoidal informed sampling to improve path\n        if found_solution and best_goal_node:\n            c_min = dist(start_pos, goal_pos)\n            c_best = best_cost\n            tree = [start_root]\n            start_root.children.clear()\n            start_root.cost = 0.0\n\n            # Insert best path nodes into new tree (no duplicates)\n            prev_node = start_root\n            for pos in best_path[1:]:\n                n_cost = prev_node.cost + dist(prev_node.position, pos)\n                n_node = Node(pos, parent=prev_node, cost=n_cost)\n                prev_node.add_child(n_node)\n                tree.append(n_node)\n                nodes.append(n_node)\n                edges.append((prev_node, n_node))\n                prev_node = n_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            max_no_improve = 100\n            refinement_iters = min(self.max_iter//3, 1000)\n\n            def ellipsoidal_sample():\n                if c_best == float('inf') or c_best < c_min - 1e-12:\n                    while True:\n                        pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if not is_in_obstacle(pt):\n                            return pt\n                center = tuple((s+g)*0.5 for s,g in zip(start_pos, goal_pos))\n                a1 = tuple(g - s for s,g in zip(start_pos, goal_pos))\n                norm_a1 = math.sqrt(sum(x*x for x in a1))\n                if norm_a1 < 1e-12:\n                    while True:\n                        pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if not is_in_obstacle(pt):\n                            return pt\n                c1 = c_best * 0.5\n                c2 = 0.5 * math.sqrt(max(c_best*c_best - c_min*c_min, 0))\n                while True:\n                    rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n                    norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n                    if norm_dir < 1e-12:\n                        continue\n                    unit_dir = [x / norm_dir for x in rnd_dir]\n                    r = random.random() ** (1.0/dim)\n                    ball_point = [r * x for x in unit_dir]\n                    scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n                    dir_a1 = [x / norm_a1 for x in a1]\n                    point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n                    for i in range(1, dim):\n                        point[i] += scaled[i]\n                    pt = tuple(max(0, min(bounds[d], point[d])) for d in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n\n            for _ in range(refinement_iters):\n                if timed_out() or no_improve_count >= max_no_improve:\n                    break\n                s_pt = ellipsoidal_sample()\n                n_node = nearest(tree, s_pt)\n                new_pos = steer(n_node.position, s_pt)\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(n_node.position, new_pos):\n                    no_improve_count += 1\n                    continue\n                near_nodes = near(tree, new_pos, rewiring_radius(len(tree)))\n                min_cost = n_node.cost + dist(n_node.position, new_pos)\n                best_parent = n_node\n                for n_ in near_nodes:\n                    c_cand = n_.cost + dist(n_.position, new_pos)\n                    if c_cand + self.improve_tol < min_cost and not is_edge_in_obstacle(n_.position, new_pos):\n                        min_cost = c_cand\n                        best_parent = n_\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                rewired_flag = False\n                for n_ in near_nodes:\n                    if n_ is best_parent: \n                        continue\n                    cost_th = new_node.cost + dist(new_node.position, n_.position)\n                    if cost_th + self.improve_tol < n_.cost and not is_edge_in_obstacle(new_node.position, n_.position):\n                        if n_.parent:\n                            try:\n                                edges.remove((n_.parent, n_))\n                            except Exception:\n                                pass\n                            n_.parent.remove_child(n_)\n                        n_.parent = new_node\n                        n_.cost = cost_th\n                        new_node.add_child(n_)\n                        edges.append((new_node, n_))\n                        rewired_flag = True\n                dist_to_goal = dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        found_solution = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n                if not rewired_flag:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if found_solution else best_path\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            extracted_path = best_path\n\n        success_state = bool(extracted_path)\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
     "objective": -36.43867,
     "time_improvement": 60.0,
     "length_improvement": 17.0,
     "smoothness_improvement": 1653.0,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.017981839179992676,
               "num_nodes_avg": 185.9,
               "path_length_avg": 162.59923720922134,
               "smoothness_avg": 0.05228999958836421,
               "success_improvement": 0.0,
               "time_improvement": 30.471901618791254,
               "length_improvement": 10.87678153583121,
               "smoothness_improvement": 718.4520431094295,
               "objective_score": 19.25989962268325
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.022843813896179198,
               "num_nodes_avg": 366.6,
               "path_length_avg": 235.69548545844145,
               "smoothness_avg": 0.1106068428399279,
               "success_improvement": 0.0,
               "time_improvement": 86.09840812141438,
               "length_improvement": 21.318062835578978,
               "smoothness_improvement": 2745.9937331600827,
               "objective_score": 52.35032880357211
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.018364214897155763,
               "num_nodes_avg": 319.3,
               "path_length_avg": 121.68574565278978,
               "smoothness_avg": 0.12525212938789504,
               "success_improvement": 0.0,
               "time_improvement": 62.43508141859384,
               "length_improvement": 19.182121789947647,
               "smoothness_improvement": 1493.1978406635246,
               "objective_score": 37.705786702864366
          }
     ],
     "success_rate": 1.0
}