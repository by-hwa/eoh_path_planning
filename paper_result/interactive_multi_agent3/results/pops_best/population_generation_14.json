{
     "operator": "time_expert",
     "algorithm_description": "An enhanced bidirectional RRT* planner with fixed-radius neighbor search and early solution-directed termination, prioritizing computational efficiency and path quality. It employs balanced goal-biased sampling, avoids recursive cost propagation by local rewiring only, and utilizes a compact post-solution pruning step to ensure smooth, short paths within a strict 30-second planning window.",
     "planning_mechanism": "The planner grows two trees alternately from start and goal using goal bias and fixed extended radius rewiring. Upon connection, it halts growth early and refines the best path locally by pruning redundant nodes and shortcutting edges under obstacle constraints, avoiding costly global rewiring. Both collision checks and sampling strictly respect map bounds and obstacle constraints, ensuring timely and feasible path discovery.",
     "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.25  # Balanced goal bias\n        self.gamma_rrt_star = 30.0    # Fixed factor for neighbor radius\n        self.time_limit = 30.0        # seconds\n        self.max_rewire_radius = 15.0 # Capped rewiring radius to limit computation\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1,int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos,to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        r = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d]-from_pos[d])*r for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        # Linear scan - could be improved (but fast enough for moderate nodes)\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best = node\n                best_dist = d\n        return best\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        res = []\n        for node in tree:\n            if self._dist(node.position, point) <= radius:\n                res.append(node)\n        return res\n\n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        # Build path from node_start root to node_goal root and connect\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _shortcut_path(self, path: List[Tuple[float, ...]], obstacles, is_3d) -> List[Tuple[float, ...]]:\n        # Attempt to shortcut path by skipping intermediate nodes where possible\n        if len(path) <= 2:\n            return path[:]\n        shortcut_path = [path[0]]\n        idx = 0\n        while idx < len(path)-1:\n            next_idx = len(path)-1\n            # Try to find farthest reachable node without collision\n            for j in range(len(path)-1, idx, -1):\n                if not self._is_edge_in_obstacle(path[idx], path[j], obstacles, is_3d):\n                    next_idx = j\n                    break\n            shortcut_path.append(path[next_idx])\n            idx = next_idx\n        return shortcut_path\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - start_time) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        best_goal_node = None\n        found_solution = False\n        success = False\n\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n            nearest = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            # Fixed radius with upper cap to limit neighbors checked\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)) if n_nodes > 1 else self.step_size*2, self.max_rewire_radius)\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            # Choose best parent minimizing cost\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near in near_nodes:\n                if near is nearest:\n                    continue\n                cost_candidate = near.cost + self._dist(near.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent,new_node))\n\n            # Rewiring neighbors without recursive cost propagation for speed\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    # Change parent, update cost, update edges\n                    if near.parent:\n                        near.parent.remove_child(near)\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    # No recursive cost propagation to descendants to reduce overhead\n\n            # Try connect to other tree\n            nearest_b = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_b.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_b.position, new_node.position, obstacles, is_3d):\n                # Connect by creating new connecting node in tree_b as child of nearest_b\n                conn_node = Node(new_node.position, parent=nearest_b, cost=nearest_b.cost + dist_connect)\n                nearest_b.add_child(conn_node)\n                tree_b.append(conn_node)\n                nodes.append(conn_node)\n                edges.append((nearest_b, conn_node))\n\n                # Build path\n                if expand_start:\n                    cur_path = self._build_path(new_node, conn_node)\n                    cur_cost = new_node.cost + (conn_node.cost - nearest_b.cost)\n                else:\n                    cur_path = self._build_path(conn_node, new_node)\n                    cur_cost = conn_node.cost + (new_node.cost - best_parent.cost)\n\n                if cur_cost < best_cost:\n                    best_cost = cur_cost\n                    best_path = cur_path\n                    best_goal_node = conn_node if expand_start else new_node\n                    found_solution = True\n                    success = True\n\n                # Early termination upon solution find to save planning time\n                break\n\n        # If solution found, perform fast shortcutting pruning for smoothness (no extra rewiring)\n        if found_solution and best_path:\n            pruned_path = self._shortcut_path(best_path, obstacles, is_3d)\n            extracted_path = pruned_path\n        else:\n            extracted_path = best_path\n            success = found_solution\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
     "objective": -34.89579,
     "time_improvement": 55.0,
     "length_improvement": 16.0,
     "smoothness_improvement": 1778.0,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.012917184829711914,
               "num_nodes_avg": 108.3,
               "path_length_avg": 163.51846744486653,
               "smoothness_avg": 0.047042774543765466,
               "success_improvement": 0.0,
               "time_improvement": 50.05475865629264,
               "length_improvement": 10.37293687753887,
               "smoothness_improvement": 636.321576629899,
               "objective_score": 24.42179760656061
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.028571557998657227,
               "num_nodes_avg": 306.4,
               "path_length_avg": 238.2101483315511,
               "smoothness_avg": 0.12766555635173507,
               "success_improvement": 0.0,
               "time_improvement": 82.61279222297007,
               "length_improvement": 20.478595987977428,
               "smoothness_improvement": 3184.926718713584,
               "objective_score": 52.99562885324539
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.03236863613128662,
               "num_nodes_avg": 362.2,
               "path_length_avg": 126.56340895880092,
               "smoothness_avg": 0.126854052156657,
               "success_improvement": 0.0,
               "time_improvement": 33.788338479350664,
               "length_improvement": 15.942610071462218,
               "smoothness_improvement": 1513.5741800405376,
               "objective_score": 27.26993848688522
          }
     ],
     "success_rate": 1.0
}