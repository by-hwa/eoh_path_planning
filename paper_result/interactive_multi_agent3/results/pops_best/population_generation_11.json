{
     "operator": "m2",
     "algorithm_description": "A hybrid bidirectional RRT* planner with fixed-radius rewiring, goal-biased sampling, and incremental path cost updating, designed for efficient exploration and rapid convergence to short, smooth paths. It alternates expansions from start and goal trees, connects trees with collision-free edges, and maintains best path tracking with early stopping under a 30-second time limit. Edge and node collision checks, consistent tree updates, and pruning ensure high path quality and robustness.",
     "planning_mechanism": "The planner samples with goal bias, extends trees via fixed step size steer functions, uses a fixed-radius neighborhood for parent selection and rewiring to optimize path costs, alternates between start and goal expansions, attempts immediate connections, keeps track of best path found, and stops early either on timeout or solution stabilization, thus improving planning time, path length, and smoothness.",
     "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15  # Goal bias probability\n        self.fixed_radius = 15.0       # Fixed rewiring/neighbor radius\n        self.time_limit = 30.0         # Hard time limit in seconds\n        self.improve_tol = 1e-9        # Small tolerance for cost comparison\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for itr in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (itr % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            near_nodes = self._near(tree_a, new_pos, self.fixed_radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper paths exist through new_node\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        self._update_costs_recursive(near_node, edges)\n\n            # Attempt to connect trees\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    # Build combined path\n                    if expand_start:\n                        path = self._build_path(new_node, connect_node)\n                        total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    else:\n                        path = self._build_path(connect_node, new_node)\n                        total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        best_goal_node = connect_node if expand_start else new_node\n                        found_solution = True\n                        success_state = True\n\n            if found_solution:\n                # Early stop on improvement for efficiency\n                break\n\n        extracted_path = best_path if found_solution else []\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _update_costs_recursive(self, node: Node, edges: List[Tuple[Node, Node]]):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                if child.parent:\n                    try:\n                        edges.remove((child.parent, child))\n                    except ValueError:\n                        pass\n                    child.parent.remove_child(child)\n                child.parent = node\n                child.cost = new_cost\n                edges.append((node, child))\n                self._update_costs_recursive(child, edges)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        return math.dist(p1, p2)\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # Remove duplicated connection node position to avoid double count\n        combined = path_start + path_goal[1:]\n        return combined\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": -29.79261,
     "time_improvement": 64.0,
     "length_improvement": 15.0,
     "smoothness_improvement": 286.0,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.014900636672973634,
               "num_nodes_avg": 124.9,
               "path_length_avg": 159.47130040463088,
               "smoothness_avg": 0.02276354128553975,
               "success_improvement": 0.0,
               "time_improvement": 42.38559681404182,
               "length_improvement": 12.591253263757743,
               "smoothness_improvement": 256.29885293978236,
               "objective_score": 21.5519252671661
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.03198549747467041,
               "num_nodes_avg": 320.0,
               "path_length_avg": 240.61799786727897,
               "smoothness_avg": 0.01613382883159849,
               "success_improvement": 0.0,
               "time_improvement": 80.53524100891183,
               "length_improvement": 19.674786506845358,
               "smoothness_improvement": 315.1350365642233,
               "objective_score": 37.541119389601874
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.015687036514282226,
               "num_nodes_avg": 203.9,
               "path_length_avg": 129.30542997382435,
               "smoothness_avg": 0.03047932298139177,
               "success_improvement": 0.0,
               "time_improvement": 67.91138348452755,
               "length_improvement": 14.121490274293217,
               "smoothness_improvement": 287.69473857370235,
               "objective_score": 30.284782902802707
          }
     ],
     "success_rate": 1.0
}