{
    "operator": "m2",
    "algorithm_description": "This algorithm is an enhanced informed RRT* planner that incorporates adaptive neighbor radius based on the number of nodes and problem dimension, aggressive early stopping after limited no improvement in path cost, and an efficient rewiring mechanism with goal biasing. The step size is tuned for better exploration, and collision checks have a balanced resolution to reduce overhead without sacrificing validity. It performs uniform sampling initially, switches to ellipsoidal informed sampling after the first feasible path, continues post-optimization with rewiring, and enforces a strict 30-second hard wall-clock limit.",
    "planning_mechanism": "The planner grows one tree from start with uniform sampling; upon first solution, it switches to informed ellipsoidal sampling bounded by the current best path cost. For each sample, it steers within step size, selects the best parent in an adaptively computed neighbor radius, rewires nearby nodes if cost improves, and connects to the goal when within step size and collision free. Post-solution iterations continue with early termination if no cost improvement is observed for a set threshold or if 30 seconds elapse. Node and edge collision checks are strictly enforced before additions.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0,\n                 post_opt_iters: int = 500, max_no_improve: int = 100,\n                 improve_tol: float = 1e-5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> type(map.start):  # Return type not specified, assume PlannerResult externally defined\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start)\n        nodes.append(root)\n\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        c_min = math.dist(start, goal)\n\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        def current_time_exceeded():\n            return (time.monotonic() - start_time) > 30.0\n\n        def adaptive_radius(n_nodes):\n            gamma_rrt = 2.0 * (1.5 * math.pow((1 + 1.0/dim), 1.0/dim))  # Chosen nominal constant\n            return min(self.step_size * 5, gamma_rrt * math.pow(math.log(n_nodes + 1) / (n_nodes + 1), 1.0/dim))\n\n        def sample():\n            if not found_first_solution:\n                # Uniform sampling inside bounds\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            else:\n                # Informed sampling inside prolate hyperspheroid\n                # Calculate rotation and scaling matrices\n                import numpy as np\n\n                c_best = best_cost\n                c_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n                a1 = np.array(goal) - np.array(start)\n                norm_a1 = np.linalg.norm(a1)\n                if norm_a1 < 1e-12:\n                    return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                e1 = a1 / norm_a1\n\n                L_diag = [c_best/2.0] + [math.sqrt(c_best**2 - c_min**2)/2.0] * (dim - 1)\n                L = np.diag(L_diag)\n                I = np.eye(dim)\n                # Compute rotation matrix C that aligns the x-axis to a1\n                # Using SVD to get rotation matrix (from parent code)\n                U, _, Vt = np.linalg.svd(np.outer(e1, I[:, 0]))\n                C = U @ np.diag([1]*(dim-1)+[np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n\n                while True:\n                    x_ball = np.random.normal(0, 1, dim)\n                    norm_x = np.linalg.norm(x_ball)\n                    if norm_x < 1e-12:\n                        continue\n                    x_ball = x_ball / norm_x * (random.random() ** (1.0 / dim))\n                    x_rand = C @ (L @ x_ball) + c_center\n                    if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                        return tuple(float(x_rand[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            else:\n                return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * self.step_size / dist for d in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fpos, tpos, resolution=1.0):\n            distance = math.dist(fpos, tpos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                interp = tuple(fpos[d] + (tpos[d] - fpos[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        for iter_count in range(self.max_iter):\n            if current_time_exceeded():\n                break\n\n            x_rand = sample()\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, x_rand))\n            x_new_pos = steer(nearest_node.position, x_rand)\n\n            if is_in_obstacle(x_new_pos) or is_edge_in_obstacle(nearest_node.position, x_new_pos, resolution=1.0):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            new_node = Node(x_new_pos)\n            n_nodes = len(nodes)\n            radius = adaptive_radius(n_nodes)\n            near_nodes = [n for n in nodes if math.dist(n.position, x_new_pos) <= radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, x_new_pos)\n            best_parent = nearest_node\n            for near_n in near_nodes:\n                cost_to_new = near_n.cost + math.dist(near_n.position, x_new_pos)\n                if cost_to_new + self.improve_tol < min_cost:\n                    if not is_edge_in_obstacle(near_n.position, x_new_pos, resolution=1.0):\n                        min_cost = cost_to_new\n                        best_parent = near_n\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for near_n in near_nodes:\n                if near_n is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_n.position)\n                if cost_through_new + self.improve_tol < near_n.cost:\n                    if not is_edge_in_obstacle(new_node.position, near_n.position, resolution=1.0):\n                        try:\n                            edges.remove((near_n.parent, near_n))\n                        except ValueError:\n                            pass\n                        near_n.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_n))\n\n            dist_to_goal = math.dist(new_node.position, goal)\n            if dist_to_goal <= self.step_size:\n                if (not is_in_obstacle(goal)) and (not is_edge_in_obstacle(new_node.position, goal, resolution=1.0)):\n                    goal_node = Node(goal)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_cost + self.improve_tol < best_cost:\n                        best_cost = goal_cost\n                        best_goal_node = goal_node\n                        success_state = True\n                        extracted_path = goal_node.path_from_root()\n                        no_improve_streak = 0\n                        post_iter_count = 0\n                        found_first_solution = True\n                    else:\n                        no_improve_streak += 1\n                        post_iter_count += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n            else:\n                if found_first_solution:\n                    no_improve_streak += 1\n                    post_iter_count += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        if success_state and best_goal_node is not None and not extracted_path:\n            extracted_path = best_goal_node.path_from_root()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nAttributeError: type object 'map' has no attribute 'start'\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": "A bidirectional RRT* planner with KD-tree accelerated nearest neighbor searches, adaptive shrinking rewiring radius, and lazy collision checking. It integrates batch rewiring and focused ellipsoidal informed sampling after initial path discovery to efficiently reduce planning time and improve path length and smoothness. Early termination within a hard 30-second limit and incremental best path updates ensure robust performance.",
    "planning_mechanism": "The planner grows two trees from start and goal alternately, using KD-tree based nearest neighbor queries for efficient exploration. Upon first connection, it switches to ellipsoidal informed sampling confined around the best cost path to accelerate refinement. Adaptive rewiring radius shrinking and lazy collision checks reduce unnecessary computations. The planner maintains consistent parent-child relations with batch rewiring to minimize path cost while building smooth trajectories, returning the best path found when hitting the time limit.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional['Node']=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List['Node'] = []\n        self.valid = True  # For collision validity if needed\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=10000, step_size: float=3.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.18\n        self.gamma_rrt_star = 25.0\n        self.time_limit = 30.0\n        self.improve_tol = 1e-8\n        self.lazy_collision_resolution = 3  # max retries to skip collision checks for performance\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = euclidean(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = euclidean(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _sample(self, bounds: Tuple[int, ...], obstacles, is_3d: bool,\n                goal: Tuple[float, ...], goal_bias_prob: float,\n                c_best: float = float(\"inf\"), c_min: float = float(\"inf\"),\n                start: Optional[Tuple[float, ...]] = None) -> Tuple[float, ...]:\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_best < c_min - 1e-12 or start is None:\n            if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n                return goal\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        # Informed ellipsoidal sampling\n        center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n        a1 = tuple(goal[d] - start[d] for d in range(dim))\n        c1_norm = math.sqrt(sum(x * x for x in a1))\n        if c1_norm < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best * 0.5\n        c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) * 0.5\n        while True:\n            # Sample uniformly in unit ball\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * u for u in unit_dir]\n\n            # Scale ellipsoid axis\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / c1_norm for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(min(max(0.0, point[d]), bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree_nodes: List[Node], kd_tree_obj: Optional[KDTree], point: Tuple[float, ...]) -> Node:\n        if not tree_nodes:\n            return None\n        if kd_tree_obj is None:\n            # fallback linear search (should not happen if kd_tree built)\n            best_node = None\n            best_dist = float(\"inf\")\n            for node in tree_nodes:\n                d = euclidean_sq(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n        else:\n            nearest_node, _ = kd_tree_obj.nearest(point)\n            return nearest_node\n\n    def _near(self, tree_nodes: List[Node], kd_tree_obj: Optional[KDTree],\n              point: Tuple[float, ...], radius: float) -> List[Node]:\n        if not tree_nodes:\n            return []\n        if kd_tree_obj is None:\n            result = []\n            r_sq = radius * radius\n            for n in tree_nodes:\n                if euclidean_sq(n.position, point) <= r_sq:\n                    result.append(n)\n            return result\n        else:\n            return kd_tree_obj.near(point, radius)\n\n    def _update_descendants_costs(self, node: Node):\n        queue = deque(node.children)\n        while queue:\n            child = queue.popleft()\n            old_cost = child.cost\n            new_cost = child.parent.cost + euclidean(child.position, child.parent.position)\n            if new_cost + self.improve_tol < old_cost:\n                child.cost = new_cost\n                queue.extend(child.children)\n\n    def _rewire(self, tree_nodes: List[Node], kd_tree_obj: KDTree,\n                edges: List[Tuple[Node, Node]], new_node: Node, near_nodes: List[Node],\n                obstacles, is_3d):\n        for near in near_nodes:\n            if near is new_node.parent:\n                continue\n            cost_through_new = new_node.cost + euclidean(new_node.position, near.position)\n            if cost_through_new + self.improve_tol < near.cost:\n                # Lazy collision checking with limited retries for speed\n                if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    # Remove old parent edge\n                    if near.parent is not None:\n                        try:\n                            edges.remove((near.parent, near))\n                            near.parent.remove_child(near)\n                        except ValueError:\n                            pass\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    self._update_descendants_costs(near)\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = []\n        node = start_node\n        while node:\n            path_start.append(node.position)\n            node = node.parent\n        path_start.reverse()\n        path_goal = []\n        node = goal_node\n        while node:\n            path_goal.append(node.position)\n            node = node.parent\n        # Remove duplicate connection point\n        return path_start + path_goal[1:]\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        time_limit = self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        solution_found = False\n\n        def time_exceeded() -> bool:\n            return (time.monotonic() - time_start) > time_limit\n\n        def build_kd(tree_nodes: List[Node]) -> Optional[KDTree]:\n            if not tree_nodes:\n                return None\n            # Build balanced KDTree every 50 iterations or so\n            return KDTree(tree_nodes)\n\n        iter_count = 0\n        kd_start = build_kd(tree_start)\n        kd_goal = build_kd(tree_goal)\n\n        # Phase 1: Bidirectional growth until first connection or timeout\n        while iter_count < self.max_iter and not solution_found:\n            if time_exceeded():\n                break\n            expansion_from_start = (iter_count % 2 == 0)\n            tree_a = tree_start if expansion_from_start else tree_goal\n            tree_b = tree_goal if expansion_from_start else tree_start\n            kd_a = kd_start if expansion_from_start else kd_goal\n            kd_b = kd_goal if expansion_from_start else kd_start\n\n            goal_pos_sample = goal_pos if expansion_from_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos_sample, self.goal_sample_rate)\n            nearest_node = self._nearest(tree_a, kd_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                iter_count += 1\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                iter_count += 1\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 15.0)\n            near_nodes = self._near(tree_a, kd_a, new_pos, radius)\n\n            # Choose best parent minimizing cost\n            min_cost = nearest_node.cost + euclidean(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                cost_candidate = near.cost + euclidean(near.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    # Lazy collision check to avoid overhead\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for path improvement\n            self._rewire(tree_a, kd_a, edges, new_node, near_nodes, obstacles, is_3d)\n\n            # Connect with other tree if close\n            nearest_other = self._nearest(tree_b, kd_b, new_node.position)\n            if nearest_other:\n                dist_connect = euclidean(nearest_other.position, new_node.position)\n                if dist_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                        # Connect other tree to new_node\n                        connect_node = Node(new_node.position, parent=nearest_other,\n                                           cost=nearest_other.cost + dist_connect)\n                        nearest_other.add_child(connect_node)\n                        tree_b.append(connect_node)\n                        nodes.append(connect_node)\n                        edges.append((nearest_other, connect_node))\n\n                        # Compute path and cost\n                        if expansion_from_start:\n                            path = self._build_path(new_node, connect_node)\n                            total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                        else:\n                            path = self._build_path(connect_node, new_node)\n                            total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                        if total_cost + self.improve_tol < best_cost:\n                            best_cost = total_cost\n                            best_path = path\n                            best_goal_node = connect_node if expansion_from_start else new_node\n                            solution_found = True\n\n            iter_count += 1\n            # Rebuild KD-trees periodically for accuracy and speed\n            if iter_count % 50 == 0:\n                kd_start = build_kd(tree_start)\n                kd_goal = build_kd(tree_goal)\n\n        # Phase 2: Ellipsoidal informed sampling refinement if solution found\n        if solution_found and best_goal_node is not None:\n            # Rebuild tree rooted at start for refinement\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children.clear()\n            start_root.cost = 0.0\n            prev_node = start_root\n            for pos in best_path[1:]:\n                cost_to_pos = prev_node.cost + euclidean(prev_node.position, pos)\n                new_node = Node(pos, parent=prev_node, cost=cost_to_pos)\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n            c_min = euclidean(start_pos, goal_pos)\n\n            kd = build_kd(tree)\n            no_improve_count = 0\n            max_no_improve = 150\n            iter_refine = 0\n            max_refine_iters = self.max_iter // 2\n\n            while iter_refine < max_refine_iters:\n                if time_exceeded() or no_improve_count >= max_no_improve:\n                    break\n                sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos, 0.0, best_cost, c_min, start_pos)\n                nearest_node = self._nearest(tree, kd, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    iter_refine += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    iter_refine += 1\n                    continue\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 15.0)\n                near_nodes = self._near(tree, kd, new_pos, radius)\n\n                min_cost = nearest_node.cost + euclidean(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near in near_nodes:\n                    cost_candidate = near.cost + euclidean(near.position, new_pos)\n                    if cost_candidate + self.improve_tol < min_cost:\n                        if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                            min_cost = cost_candidate\n                            best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                self._rewire(tree, kd, edges, new_node, near_nodes, obstacles, is_3d)\n\n                dist_to_goal = euclidean(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                        new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                        new_node.add_child(new_goal_node)\n                        tree.append(new_goal_node)\n                        nodes.append(new_goal_node)\n                        edges.append((new_node, new_goal_node))\n                        if new_goal_node.cost + self.improve_tol < best_cost:\n                            best_goal_node = new_goal_node\n                            best_cost = new_goal_node.cost\n                            no_improve_count = 0\n                        else:\n                            no_improve_count += 1\n                else:\n                    no_improve_count += 1\n                iter_refine += 1\n                if iter_refine % 50 == 0:\n                    kd = build_kd(tree)\n\n            extracted_path = best_goal_node.path_from_root() if best_goal_node else best_path\n            success_state = True if best_goal_node else False\n\n        else:\n            extracted_path = best_path\n            success_state = solution_found\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nNameError: name 'KDTree' is not defined\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": "A unidirectional PRM* (Probabilistic Roadmap) planner enhanced with a grid-based spatial index for efficient neighbor retrieval, adaptive connection radius scaling based on sample count and space dimensionality, and path smoothing via shortcutting post-processing. The planner samples collision-free points, builds a roadmap by connecting neighbors within an adaptive radius using collision-checked edges, and uses Dijkstra's algorithm to find the shortest path. Finally, it refines the path by shortcutting to improve smoothness and reduce length before returning. The planner aborts and returns the best path found upon exceeding a 30-second runtime limit or after exhaustively building the roadmap.",
    "planning_mechanism": "The planner first samples a fixed number of collision-free nodes uniformly within the free space. It indexes nodes in a spatial grid for efficient neighbor queries. Each node attempts to connect to nearby nodes within a radius that shrinks adaptively as node count grows to limit edge count and computational overhead. Edges are only added if collision-free. After roadmap construction, the planner runs Dijkstra\u2019s shortest path from start to goal nodes. It then performs iterative shortcut smoothing on the resulting path to improve smoothness without collisions. The planner returns the best available path once time limit is reached or roadmap is fully processed.",
    "code": "class Node:\n    def __init__(self, position):\n        self.position = position      # Tuple[float, ...]\n        self.neighbors = []           # List[Node]\n        self.cost = float(\"inf\")      # For Dijkstra\n        self.prev = None              # For path reconstruction\nclass Planner:\n    def __init__(self, max_samples=4000, resolution=1.0):\n        self.max_samples = max_samples\n        self.resolution = resolution\n        self.time_limit = 30.0\n        self.grid_cell_size = None\n        self.dimension = 0\n        self.is_3d = False\n\n    def _grid_key(self, pos):\n        return tuple(int(p / self.grid_cell_size) for p in pos)\n\n    def _grid_insert(self, node, grid):\n        key = self._grid_key(node.position)\n        if key not in grid:\n            grid[key] = []\n        grid[key].append(node)\n\n    def _grid_near_nodes(self, pos, radius, grid):\n        key_center = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell_size) + 1\n        candidates = []\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        key = (key_center[0] + dx, key_center[1] + dy, key_center[2] + dz)\n                        if key in grid:\n                            candidates.extend(grid[key])\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    key = (key_center[0] + dx, key_center[1] + dy)\n                    if key in grid:\n                        candidates.extend(grid[key])\n        r_sq = radius * radius\n        return [n for n in candidates if self._dist_sq(pos, n.position) <= r_sq]\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        self.is_3d = len(bounds) == 3\n        self.dimension = len(bounds)\n        if self.dimension == 0:\n            return PlannerResult(False, [], [], [])\n        self.grid_cell_size = max(1.0, max(bounds) * 0.05)\n\n        def in_bounds(p):\n            for i in range(self.dimension):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if self.is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_collision_free(a, b):\n            dist = math.dist(a, b)\n            steps = max(1, int(dist / self.resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(self.dimension))\n                if not in_bounds(interp) or is_in_obstacle(interp):\n                    return False\n            return True\n\n        def dist_sq(a, b):\n            s = 0\n            for i in range(self.dimension):\n                diff = a[i] - b[i]\n                s += diff * diff\n            return s\n\n        self._dist_sq = dist_sq\n\n        # Sample collision-free nodes, include start and goal explicitly\n        nodes = []\n        nodes.append(Node(start_pos))\n        nodes.append(Node(goal_pos))\n\n        grid = {}\n        self._grid_insert(nodes[0], grid)\n        self._grid_insert(nodes[1], grid)\n\n        time_start = time.monotonic()\n        def timeout():\n            return time.monotonic() - time_start > self.time_limit\n\n        samples = 2\n        max_samples = self.max_samples\n\n        # Uniform random sampling collision-free\n        while samples < max_samples and not timeout():\n            p = tuple(random.uniform(0, bounds[i]) for i in range(self.dimension))\n            if not is_in_obstacle(p):\n                n = Node(p)\n                nodes.append(n)\n                self._grid_insert(n, grid)\n                samples += 1\n\n        if timeout() and samples < 3:  # too few samples, no solution\n            return PlannerResult(False, [], nodes, [])\n\n        # Adaptive connection radius following PRM* theory: gamma * (log(n)/n)^(1/d)\n        # gamma chosen conservatively but ensuring connectivity\n        gamma = 40.0\n        n = len(nodes)\n        r = gamma * ((math.log(n) / n) ** (1 / self.dimension))\n        r = min(r, max(bounds) * 0.15)\n        self._distance = math.dist\n\n        edges = []\n\n        # Connect roadmap edges for each node to neighbors within radius,\n        # only if edge is collision-free.\n        for i, node in enumerate(nodes):\n            if timeout():\n                break\n            near_nodes = self._grid_near_nodes(node.position, r, grid)\n            for nbr in near_nodes:\n                if nbr is node:\n                    continue\n                if nbr in node.neighbors:\n                    continue  # edge already created\n                # Check edge collision\n                if is_edge_collision_free(node.position, nbr.position):\n                    node.neighbors.append(nbr)\n                    nbr.neighbors.append(node)\n                    edges.append((node, nbr))\n\n        if timeout():\n            # Time limit reached before planning path; will attempt shortest path on current roadmap\n            pass\n\n        # Dijkstra's algorithm to find shortest path from start to goal\n        import heapq\n        start_node = nodes[0]\n        goal_node = nodes[1]\n        for node in nodes:\n            node.cost = float(\"inf\")\n            node.prev = None\n        start_node.cost = 0.0\n        heap = [(0.0, start_node)]\n\n        while heap and not timeout():\n            current_cost, current_node = heapq.heappop(heap)\n            if current_node is goal_node:\n                break\n            if current_cost > current_node.cost:\n                continue\n            for neighbor in current_node.neighbors:\n                alt = current_node.cost + self._distance(current_node.position, neighbor.position)\n                if alt < neighbor.cost:\n                    neighbor.cost = alt\n                    neighbor.prev = current_node\n                    heapq.heappush(heap, (alt, neighbor))\n\n        # Reconstruct path if exists\n        path = []\n        if goal_node.prev is not None or goal_node is start_node:\n            cur = goal_node\n            while cur:\n                path.append(cur.position)\n                cur = cur.prev\n            path.reverse()\n\n        # Path shortcut smoothing: iteratively try connecting non-adjacent points directly\n        # and remove intermediate nodes if edge collision-free.\n        def shortcut_smooth(path):\n            if len(path) < 3:\n                return path\n            changed = True\n            max_iter = 200\n            iter_count = 0\n            while changed and iter_count < max_iter:\n                changed = False\n                iter_count += 1\n                i = 0\n                while i < len(path) - 2:\n                    j = len(path) - 1\n                    while j > i + 1:\n                        if is_edge_collision_free(path[i], path[j]):\n                            # Shortcut possible, remove intermediate points\n                            path = path[:i + 1] + path[j:]\n                            changed = True\n                            break\n                        j -= 1\n                    if not changed:\n                        i += 1\n                    else:\n                        break\n            return path\n\n        smooth_path = shortcut_smooth(path) if path else []\n\n        success = len(smooth_path) >= 2\n\n        return PlannerResult(\n            success=success,\n            path=smooth_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: Planner.__init__() got an unexpected keyword argument 'max_iter'\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
