[
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* planner with adaptive fixed-radius rewiring, goal-biased and informed sampling, early solution detection with incremental local refinement, and progressive shortcut smoothing to balance fast convergence and high-quality smooth paths within a strict 30-second limit. The planner alternates growing trees from start and goal, performs rewiring without costly recursive subtree updates, employs ellipsoidal informed sampling after initial solution, and uses multiple passes of efficient local shortcut smoothing to enhance path smoothness and reduce length.",
          "planning_mechanism": "The algorithm maintains two RRT* trees grown alternately towards sampled points with goal bias; neighbors are searched within an adaptively computed fixed radius based on node count and environment dimension. Rewiring updates costs locally without recursive cascades. Upon first connection of the two trees, the best path is recorded and a shorter refinement phase using ellipsoidal sampling improves the path incrementally. After planning or timeout, the final path undergoes multiple iterative shortcut smoothing passes, reducing sharp turns and unnecessary waypoints for smoothness improvements. The time limit is enforced strictly to stop planning and return the current best path if exceeded.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]\n        self.parent = parent          # Node or None\n        self.cost = cost              # Cost from root\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n        self.goal_sample_rate = 0.15\n        self.time_limit = 30.0\n        self.improve_tol = 1e-8\n        self.check_resolution = 1.0\n\n    def plan(self, map):\n        import time, math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            steps = max(1, int(distance / self.check_resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample(goal):\n            if random.random() < self.goal_sample_rate and not is_in_obstacle(goal):\n                return goal\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d_ = dist(node.position, point)\n                if d_ < best_dist:\n                    best_dist = d_\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            res = []\n            r2 = radius * radius\n            for node in tree:\n                d_ = dist(node.position, point)\n                if d_ <= radius:\n                    res.append(node)\n            return res\n\n        def rewiring_radius(n):\n            if n <= 1:\n                return self.step_size * 2.0\n            gamma = 20.0  # Tuned constant\n            r = gamma * (math.log(n)/n) ** (1/dim)\n            return max(r, self.step_size)\n\n        def build_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            path_goal.reverse()\n            return path_start + path_goal[1:]\n\n        def shortcut_path(path):\n            # Multiple passes of shortcutting for smoother curves\n            if len(path) <= 2:\n                return path[:]\n            for _ in range(3):  # Iteratively improve smoothness\n                new_path = [path[0]]\n                i = 0\n                n = len(path)\n                while i < n - 1:\n                    j = n - 1\n                    while j > i + 1:\n                        if not is_edge_in_obstacle(path[i], path[j]):\n                            break\n                        j -= 1\n                    new_path.append(path[j])\n                    i = j\n                path = new_path\n            return path\n\n        # Initialize trees\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        best_goal_node = None\n\n        for iter_ in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (iter_ % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = sample(sample_goal)\n            nearest_node = nearest(tree_a, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            radius = rewiring_radius(len(tree_a))\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nnode in near_nodes:\n                cc = nnode.cost + dist(nnode.position, new_pos)\n                if cc + self.improve_tol < min_cost and not is_edge_in_obstacle(nnode.position, new_pos):\n                    min_cost = cc\n                    best_parent = nnode\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Local rewiring (no recursive cost update for speed)\n            for nnode in near_nodes:\n                if nnode is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nnode.position)\n                if cost_through_new + self.improve_tol < nnode.cost and not is_edge_in_obstacle(new_node.position, nnode.position):\n                    if nnode.parent:\n                        try:\n                            edges.remove((nnode.parent, nnode))\n                        except ValueError:\n                            pass\n                        nnode.parent.remove_child(nnode)\n                    nnode.parent = new_node\n                    nnode.cost = cost_through_new\n                    new_node.add_child(nnode)\n                    edges.append((new_node, nnode))\n\n            # Try connecting trees\n            nearest_other = nearest(tree_b, new_node.position)\n            dist_connect = dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not is_edge_in_obstacle(nearest_other.position, new_node.position):\n                # Connect trees by adding a node in tree_b\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    path = build_path(new_node, connect_node)\n                    path_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = build_path(connect_node, new_node)\n                    path_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if path_cost + self.improve_tol < best_cost:\n                    best_cost = path_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n\n            if found_solution:\n                # Early stop after first solution to save time\n                break\n\n        # Incremental Refinement via ellipsoidal informed sampling to improve path\n        if found_solution and best_goal_node:\n            c_min = dist(start_pos, goal_pos)\n            c_best = best_cost\n            tree = [start_root]\n            start_root.children.clear()\n            start_root.cost = 0.0\n\n            # Insert best path nodes into new tree (no duplicates)\n            prev_node = start_root\n            for pos in best_path[1:]:\n                n_cost = prev_node.cost + dist(prev_node.position, pos)\n                n_node = Node(pos, parent=prev_node, cost=n_cost)\n                prev_node.add_child(n_node)\n                tree.append(n_node)\n                nodes.append(n_node)\n                edges.append((prev_node, n_node))\n                prev_node = n_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            max_no_improve = 100\n            refinement_iters = min(self.max_iter//3, 1000)\n\n            def ellipsoidal_sample():\n                if c_best == float('inf') or c_best < c_min - 1e-12:\n                    while True:\n                        pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if not is_in_obstacle(pt):\n                            return pt\n                center = tuple((s+g)*0.5 for s,g in zip(start_pos, goal_pos))\n                a1 = tuple(g - s for s,g in zip(start_pos, goal_pos))\n                norm_a1 = math.sqrt(sum(x*x for x in a1))\n                if norm_a1 < 1e-12:\n                    while True:\n                        pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if not is_in_obstacle(pt):\n                            return pt\n                c1 = c_best * 0.5\n                c2 = 0.5 * math.sqrt(max(c_best*c_best - c_min*c_min, 0))\n                while True:\n                    rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n                    norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n                    if norm_dir < 1e-12:\n                        continue\n                    unit_dir = [x / norm_dir for x in rnd_dir]\n                    r = random.random() ** (1.0/dim)\n                    ball_point = [r * x for x in unit_dir]\n                    scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n                    dir_a1 = [x / norm_a1 for x in a1]\n                    point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n                    for i in range(1, dim):\n                        point[i] += scaled[i]\n                    pt = tuple(max(0, min(bounds[d], point[d])) for d in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n\n            for _ in range(refinement_iters):\n                if timed_out() or no_improve_count >= max_no_improve:\n                    break\n                s_pt = ellipsoidal_sample()\n                n_node = nearest(tree, s_pt)\n                new_pos = steer(n_node.position, s_pt)\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(n_node.position, new_pos):\n                    no_improve_count += 1\n                    continue\n                near_nodes = near(tree, new_pos, rewiring_radius(len(tree)))\n                min_cost = n_node.cost + dist(n_node.position, new_pos)\n                best_parent = n_node\n                for n_ in near_nodes:\n                    c_cand = n_.cost + dist(n_.position, new_pos)\n                    if c_cand + self.improve_tol < min_cost and not is_edge_in_obstacle(n_.position, new_pos):\n                        min_cost = c_cand\n                        best_parent = n_\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                rewired_flag = False\n                for n_ in near_nodes:\n                    if n_ is best_parent: \n                        continue\n                    cost_th = new_node.cost + dist(new_node.position, n_.position)\n                    if cost_th + self.improve_tol < n_.cost and not is_edge_in_obstacle(new_node.position, n_.position):\n                        if n_.parent:\n                            try:\n                                edges.remove((n_.parent, n_))\n                            except Exception:\n                                pass\n                            n_.parent.remove_child(n_)\n                        n_.parent = new_node\n                        n_.cost = cost_th\n                        new_node.add_child(n_)\n                        edges.append((new_node, n_))\n                        rewired_flag = True\n                dist_to_goal = dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        found_solution = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n                if not rewired_flag:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if found_solution else best_path\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            extracted_path = best_path\n\n        success_state = bool(extracted_path)\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
          "objective": -36.43867,
          "time_improvement": 60.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1653.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017981839179992676,
                    "num_nodes_avg": 185.9,
                    "path_length_avg": 162.59923720922134,
                    "smoothness_avg": 0.05228999958836421,
                    "success_improvement": 0.0,
                    "time_improvement": 30.471901618791254,
                    "length_improvement": 10.87678153583121,
                    "smoothness_improvement": 718.4520431094295,
                    "objective_score": 19.25989962268325
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022843813896179198,
                    "num_nodes_avg": 366.6,
                    "path_length_avg": 235.69548545844145,
                    "smoothness_avg": 0.1106068428399279,
                    "success_improvement": 0.0,
                    "time_improvement": 86.09840812141438,
                    "length_improvement": 21.318062835578978,
                    "smoothness_improvement": 2745.9937331600827,
                    "objective_score": 52.35032880357211
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018364214897155763,
                    "num_nodes_avg": 319.3,
                    "path_length_avg": 121.68574565278978,
                    "smoothness_avg": 0.12525212938789504,
                    "success_improvement": 0.0,
                    "time_improvement": 62.43508141859384,
                    "length_improvement": 19.182121789947647,
                    "smoothness_improvement": 1493.1978406635246,
                    "objective_score": 37.705786702864366
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An improved bidirectional RRT* planner featuring adaptive rewiring radius based on tree size and workspace scale, goal-biased sampling to accelerate convergence, incremental non-recursive rewiring for cost optimization, early termination upon first valid path discovery to limit planning time, and a concise post-processing shortcutting for path smoothness within a 30-second hard time limit.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal states, samples points biased towards the goal, connects new nodes via a step-size limited extension, rewires neighbors within an adaptively computed radius to minimize path cost, and attempts connection between trees. Upon connecting, it early-stops, extracts the combined path, and applies shortcutting to smooth the path while respecting collision constraints, all under strict collision checking and bounded workspace constraints.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter:int=5000, step_size:float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2  # goal bias\n        self.gamma_rrt_star = 40.0   # rewiring radius factor\n        self.max_rewire_radius = 50.0\n        self.time_limit = 30.0       # seconds\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = math.dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if math.dist(node.position, point) <= radius]\n\n    def _sample(self, bounds, obstacles, is_3d, goal):\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _build_path(self, node_start, node_goal):\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        if len(path) <= 2:\n            return path[:]\n        shortcut = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortcut.append(path[j])\n            i = j\n        return shortcut\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n\n        def timed_out():\n            return (time.monotonic() - start_time) > self.time_limit\n\n        tree_start = [Node(start, cost=0.0)]\n        tree_goal = [Node(goal, cost=0.0)]\n        nodes = list(tree_start + tree_goal)\n        edges = []\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n\n        for iter_count in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (iter_count % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal if expand_start else start\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal)\n            nearest = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            r = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)) if n_nodes > 1 else self.step_size*2\n            radius = min(r, self.max_rewire_radius)\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near in near_nodes:\n                if near is nearest:\n                    continue\n                c = near.cost + math.dist(near.position, new_pos)\n                if c < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = c\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors non-recursively for speed\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_through_new < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        near.parent.remove_child(near)\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            # Try connecting to other tree\n            nearest_b = self._nearest(tree_b, new_node.position)\n            dist_connect = math.dist(nearest_b.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_b.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_b, cost=nearest_b.cost + dist_connect)\n                nearest_b.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_b, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    cost = new_node.cost + (connect_node.cost - nearest_b.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_path = path\n                    found_solution = True\n\n                # Early termination on first found solution\n                break\n\n        if found_solution and best_path:\n            pruned_path = self._shortcut_path(best_path, obstacles, is_3d)\n            final_path = pruned_path\n        else:\n            final_path = best_path\n\n        return PlannerResult(\n            success=found_solution,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -36.26177,
          "time_improvement": 62.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1672.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012625908851623536,
                    "num_nodes_avg": 103.0,
                    "path_length_avg": 164.87498169989678,
                    "smoothness_avg": 0.04858417756921969,
                    "success_improvement": 0.0,
                    "time_improvement": 51.18099856189387,
                    "length_improvement": 9.629409919012868,
                    "smoothness_improvement": 660.4478811885014,
                    "objective_score": 24.43418492591839
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.019319438934326173,
                    "num_nodes_avg": 271.7,
                    "path_length_avg": 232.03427155195612,
                    "smoothness_avg": 0.12010507348073766,
                    "success_improvement": 0.0,
                    "time_improvement": 88.24316479687397,
                    "length_improvement": 22.540281419763005,
                    "smoothness_improvement": 2990.390048847121,
                    "objective_score": 54.9490685351556
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025907230377197266,
                    "num_nodes_avg": 366.8,
                    "path_length_avg": 129.31737878879724,
                    "smoothness_avg": 0.11528828010842909,
                    "success_improvement": 0.0,
                    "time_improvement": 47.00546659689346,
                    "length_improvement": 14.113554440329642,
                    "smoothness_improvement": 1366.458413283569,
                    "objective_score": 29.402064709683664
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "An enhanced bidirectional RRT* planner with fixed-radius neighbor search and early solution-directed termination, prioritizing computational efficiency and path quality. It employs balanced goal-biased sampling, avoids recursive cost propagation by local rewiring only, and utilizes a compact post-solution pruning step to ensure smooth, short paths within a strict 30-second planning window.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal using goal bias and fixed extended radius rewiring. Upon connection, it halts growth early and refines the best path locally by pruning redundant nodes and shortcutting edges under obstacle constraints, avoiding costly global rewiring. Both collision checks and sampling strictly respect map bounds and obstacle constraints, ensuring timely and feasible path discovery.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.25  # Balanced goal bias\n        self.gamma_rrt_star = 30.0    # Fixed factor for neighbor radius\n        self.time_limit = 30.0        # seconds\n        self.max_rewire_radius = 15.0 # Capped rewiring radius to limit computation\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1,int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos,to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        r = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d]-from_pos[d])*r for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        # Linear scan - could be improved (but fast enough for moderate nodes)\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best = node\n                best_dist = d\n        return best\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        res = []\n        for node in tree:\n            if self._dist(node.position, point) <= radius:\n                res.append(node)\n        return res\n\n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        # Build path from node_start root to node_goal root and connect\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _shortcut_path(self, path: List[Tuple[float, ...]], obstacles, is_3d) -> List[Tuple[float, ...]]:\n        # Attempt to shortcut path by skipping intermediate nodes where possible\n        if len(path) <= 2:\n            return path[:]\n        shortcut_path = [path[0]]\n        idx = 0\n        while idx < len(path)-1:\n            next_idx = len(path)-1\n            # Try to find farthest reachable node without collision\n            for j in range(len(path)-1, idx, -1):\n                if not self._is_edge_in_obstacle(path[idx], path[j], obstacles, is_3d):\n                    next_idx = j\n                    break\n            shortcut_path.append(path[next_idx])\n            idx = next_idx\n        return shortcut_path\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - start_time) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        best_goal_node = None\n        found_solution = False\n        success = False\n\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n            nearest = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            # Fixed radius with upper cap to limit neighbors checked\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)) if n_nodes > 1 else self.step_size*2, self.max_rewire_radius)\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            # Choose best parent minimizing cost\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near in near_nodes:\n                if near is nearest:\n                    continue\n                cost_candidate = near.cost + self._dist(near.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent,new_node))\n\n            # Rewiring neighbors without recursive cost propagation for speed\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    # Change parent, update cost, update edges\n                    if near.parent:\n                        near.parent.remove_child(near)\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    # No recursive cost propagation to descendants to reduce overhead\n\n            # Try connect to other tree\n            nearest_b = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_b.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_b.position, new_node.position, obstacles, is_3d):\n                # Connect by creating new connecting node in tree_b as child of nearest_b\n                conn_node = Node(new_node.position, parent=nearest_b, cost=nearest_b.cost + dist_connect)\n                nearest_b.add_child(conn_node)\n                tree_b.append(conn_node)\n                nodes.append(conn_node)\n                edges.append((nearest_b, conn_node))\n\n                # Build path\n                if expand_start:\n                    cur_path = self._build_path(new_node, conn_node)\n                    cur_cost = new_node.cost + (conn_node.cost - nearest_b.cost)\n                else:\n                    cur_path = self._build_path(conn_node, new_node)\n                    cur_cost = conn_node.cost + (new_node.cost - best_parent.cost)\n\n                if cur_cost < best_cost:\n                    best_cost = cur_cost\n                    best_path = cur_path\n                    best_goal_node = conn_node if expand_start else new_node\n                    found_solution = True\n                    success = True\n\n                # Early termination upon solution find to save planning time\n                break\n\n        # If solution found, perform fast shortcutting pruning for smoothness (no extra rewiring)\n        if found_solution and best_path:\n            pruned_path = self._shortcut_path(best_path, obstacles, is_3d)\n            extracted_path = pruned_path\n        else:\n            extracted_path = best_path\n            success = found_solution\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -34.89579,
          "time_improvement": 55.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1778.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012917184829711914,
                    "num_nodes_avg": 108.3,
                    "path_length_avg": 163.51846744486653,
                    "smoothness_avg": 0.047042774543765466,
                    "success_improvement": 0.0,
                    "time_improvement": 50.05475865629264,
                    "length_improvement": 10.37293687753887,
                    "smoothness_improvement": 636.321576629899,
                    "objective_score": 24.42179760656061
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028571557998657227,
                    "num_nodes_avg": 306.4,
                    "path_length_avg": 238.2101483315511,
                    "smoothness_avg": 0.12766555635173507,
                    "success_improvement": 0.0,
                    "time_improvement": 82.61279222297007,
                    "length_improvement": 20.478595987977428,
                    "smoothness_improvement": 3184.926718713584,
                    "objective_score": 52.99562885324539
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03236863613128662,
                    "num_nodes_avg": 362.2,
                    "path_length_avg": 126.56340895880092,
                    "smoothness_avg": 0.126854052156657,
                    "success_improvement": 0.0,
                    "time_improvement": 33.788338479350664,
                    "length_improvement": 15.942610071462218,
                    "smoothness_improvement": 1513.5741800405376,
                    "objective_score": 27.26993848688522
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "An advanced bidirectional RRT* planner with adaptive fixed-radius rewiring, recursive cost propagation, goal-biased and informed sampling, and post-planning shortcut path smoothing to ensure efficient exploration, improved path length, and smoothness within a hard 30-second time limit.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal with a fixed radius for neighbor rewiring and goal bias sampling, connects them upon feasible edges, then refines the best path through informed sampling and shortcut smoothing before termination or timeout, maintaining consistent cost propagation and collision-free constraints throughout.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float, ...]\n        self.parent = parent      # Node or None\n        self.cost = cost          # Cost from root to this node\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n\n        # Fixed radius for neighbor search (tuned empirically)\n        self.fixed_radius = 15.0\n\n        # Probability of sampling the goal (goal bias)\n        self.goal_sample_rate = 0.2\n\n        # Small tolerance for cost improvement\n        self.improve_tol = 1e-6\n\n        # Resolution for collision checking along edges\n        self.check_resolution = 1.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d):\n        dist = 0.0\n        try:\n            dist = math.dist(from_pos, to_pos)\n        except:\n            # fallback if math.dist unavailable\n            dist = sum((f - t) ** 2 for f, t in zip(from_pos, to_pos)) ** 0.5\n        steps = max(1, int(dist / self.check_resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = 0.0\n        try:\n            dist = math.dist(from_pos, to_pos)\n        except:\n            dist = sum((f - t) ** 2 for f, t in zip(from_pos, to_pos)) ** 0.5\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        try:\n            return math.dist(p1, p2)\n        except:\n            return sum((a - b) ** 2 for a, b in zip(p1, p2)) ** 0.5\n\n    def _sample(self, bounds, obstacles, is_3d, goal):\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        res = []\n        r2 = radius * radius\n        for node in tree:\n            d = 0.0\n            if hasattr(math, 'dist'):\n                d = math.dist(node.position, point)\n            else:\n                d = sum((a - b) ** 2 for a,b in zip(node.position, point)) ** 0.5\n            if d <= radius:\n                res.append(node)\n        return res\n\n    def _update_costs_recursive(self, node):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_costs_recursive(child)\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # avoid duplicate connecting node position\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        if c_best == float('inf') or c_best < c_min - 1e-10:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        dim = len(bounds)\n        center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = sum(x * x for x in a1) ** 0.5\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c1 = c_best * 0.5\n        c2 = (max(c_best * c_best - c_min * c_min, 0.0) ** 0.5) * 0.5\n\n        while True:\n            # Sample unit ball in dim dimension\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = sum(x*x for x in rnd_dir) ** 0.5\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            # Scale sample to ellipsoid axes:\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            # Rotation aligns first axis with a1 vector (approximate)\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _try_shortcut(self, path, obstacles, is_3d):\n        if len(path) <= 2:\n            return path[:]\n        smoothed_path = [path[0]]\n        idx = 0\n        n = len(path)\n        while idx < n - 1:\n            next_idx = n - 1\n            while next_idx > idx + 1:\n                if not self._is_edge_in_obstacle(path[idx], path[next_idx], obstacles, is_3d):\n                    break\n                next_idx -= 1\n            smoothed_path.append(path[next_idx])\n            idx = next_idx\n        return smoothed_path\n\n    def plan(self, map):\n        import time, math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        time_start = time.monotonic()\n\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        # Alternate expansions\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n\n            expanding_start = (i % 2 == 0)\n            tree_a = tree_start if expanding_start else tree_goal\n            tree_b = tree_goal if expanding_start else tree_start\n            sample_goal = goal_pos if expanding_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            radius = self.fixed_radius\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    # Update edge and parent-child relations\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    # Recursively update costs of descendants\n                    self._update_costs_recursive(near_node)\n\n            # Attempt connection to opposite tree\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                # Connect trees by adding a connecting node\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expanding_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expanding_start else new_node\n                    found_solution = True\n                    success_state = True\n                    break\n\n        # Refinement phase if solution found\n        if found_solution and best_goal_node is not None:\n            # Build a tree rooted at start for informed RRT*\n            tree = [start_root]\n            start_root.children = []\n            start_root.cost = 0.0\n\n            # Copy best path into tree\n            prev_node = start_root\n            for pos in best_path[1:]:\n                n_cost = prev_node.cost + self._dist(prev_node.position, pos)\n                new_node = Node(pos, parent=prev_node, cost=n_cost)\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            max_no_improve = 120\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if timed_out() or no_improve_count >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                near_nodes = self._near(tree, new_pos, self.fixed_radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                    if cost_candidate + self.improve_tol < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        self._update_costs_recursive(near_node)\n                        rewired = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n            # Post-process path shortcutting for smoothness\n            if len(extracted_path) > 2:\n                extracted_path = self._try_shortcut(extracted_path, obstacles, is_3d)\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
          "objective": -31.02063,
          "time_improvement": 46.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1385.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02439420223236084,
                    "num_nodes_avg": 210.6,
                    "path_length_avg": 166.9287719242713,
                    "smoothness_avg": 0.04447081982954099,
                    "success_improvement": 0.0,
                    "time_improvement": 5.678030163354109,
                    "length_improvement": 8.503694952644477,
                    "smoothness_improvement": 596.0649002632317,
                    "objective_score": 9.785950521909077
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0319866418838501,
                    "num_nodes_avg": 379.0,
                    "path_length_avg": 229.74939855856366,
                    "smoothness_avg": 0.09565426382163486,
                    "success_improvement": 0.0,
                    "time_improvement": 80.53454457926001,
                    "length_improvement": 23.303037791380007,
                    "smoothness_improvement": 2361.2531051120586,
                    "objective_score": 49.9484515741663
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024246406555175782,
                    "num_nodes_avg": 322.2,
                    "path_length_avg": 119.89049793872327,
                    "smoothness_avg": 0.1019188821406457,
                    "success_improvement": 0.0,
                    "time_improvement": 50.40276465737084,
                    "length_improvement": 20.374439841120928,
                    "smoothness_improvement": 1196.4006579596712,
                    "objective_score": 33.32749659168216
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A hybrid bidirectional RRT* planner with fixed-radius rewiring, goal-biased sampling, and incremental path cost updating, designed for efficient exploration and rapid convergence to short, smooth paths. It alternates expansions from start and goal trees, connects trees with collision-free edges, and maintains best path tracking with early stopping under a 30-second time limit. Edge and node collision checks, consistent tree updates, and pruning ensure high path quality and robustness.",
          "planning_mechanism": "The planner samples with goal bias, extends trees via fixed step size steer functions, uses a fixed-radius neighborhood for parent selection and rewiring to optimize path costs, alternates between start and goal expansions, attempts immediate connections, keeps track of best path found, and stops early either on timeout or solution stabilization, thus improving planning time, path length, and smoothness.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15  # Goal bias probability\n        self.fixed_radius = 15.0       # Fixed rewiring/neighbor radius\n        self.time_limit = 30.0         # Hard time limit in seconds\n        self.improve_tol = 1e-9        # Small tolerance for cost comparison\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for itr in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (itr % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            near_nodes = self._near(tree_a, new_pos, self.fixed_radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper paths exist through new_node\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        self._update_costs_recursive(near_node, edges)\n\n            # Attempt to connect trees\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    # Build combined path\n                    if expand_start:\n                        path = self._build_path(new_node, connect_node)\n                        total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    else:\n                        path = self._build_path(connect_node, new_node)\n                        total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        best_goal_node = connect_node if expand_start else new_node\n                        found_solution = True\n                        success_state = True\n\n            if found_solution:\n                # Early stop on improvement for efficiency\n                break\n\n        extracted_path = best_path if found_solution else []\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _update_costs_recursive(self, node: Node, edges: List[Tuple[Node, Node]]):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                if child.parent:\n                    try:\n                        edges.remove((child.parent, child))\n                    except ValueError:\n                        pass\n                    child.parent.remove_child(child)\n                child.parent = node\n                child.cost = new_cost\n                edges.append((node, child))\n                self._update_costs_recursive(child, edges)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        return math.dist(p1, p2)\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # Remove duplicated connection node position to avoid double count\n        combined = path_start + path_goal[1:]\n        return combined\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -29.79261,
          "time_improvement": 64.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 286.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014900636672973634,
                    "num_nodes_avg": 124.9,
                    "path_length_avg": 159.47130040463088,
                    "smoothness_avg": 0.02276354128553975,
                    "success_improvement": 0.0,
                    "time_improvement": 42.38559681404182,
                    "length_improvement": 12.591253263757743,
                    "smoothness_improvement": 256.29885293978236,
                    "objective_score": 21.5519252671661
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03198549747467041,
                    "num_nodes_avg": 320.0,
                    "path_length_avg": 240.61799786727897,
                    "smoothness_avg": 0.01613382883159849,
                    "success_improvement": 0.0,
                    "time_improvement": 80.53524100891183,
                    "length_improvement": 19.674786506845358,
                    "smoothness_improvement": 315.1350365642233,
                    "objective_score": 37.541119389601874
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.015687036514282226,
                    "num_nodes_avg": 203.9,
                    "path_length_avg": 129.30542997382435,
                    "smoothness_avg": 0.03047932298139177,
                    "success_improvement": 0.0,
                    "time_improvement": 67.91138348452755,
                    "length_improvement": 14.121490274293217,
                    "smoothness_improvement": 287.69473857370235,
                    "objective_score": 30.284782902802707
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner using fixed step size and fixed neighbor radius with non-recursive rewiring, goal-biased sampling, and early termination upon first solution discovery to balance planning time and path quality. It alternates growing trees from start and goal, connects them when possible, and maintains coherent parent-child links with cost updates limited to local rewiring to reduce overhead. No extensive post-processing or adaptive radius computations are performed, favoring simplicity and efficiency.",
          "planning_mechanism": "A bidirectional RRT* alternates expansions from start and goal trees, samples points with goal bias, extends towards samples by a fixed step, connects trees when paths are close, refines connections locally with fixed radius rewiring, and stops when a collision-free connecting path is first found or timeout occurs, returning the best path discovered.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"] = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15          # goal bias sampling rate\n        self.fixed_radius = 14.0               # fixed neighbor radius for rewiring\n        self.time_limit = 30.0                 # seconds\n        self.improve_tol = 1e-9                # tolerance for cost improvement\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start: List[Node] = [start_root]\n        tree_goal: List[Node] = [goal_root]\n\n        nodes: List[Node] = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float(\"inf\")\n        success_state = False\n\n        for itr in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (itr % 2 == 0)\n            tree_a = tree_start if expand_start else tree_goal\n            tree_b = tree_goal if expand_start else tree_start\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            near_nodes = self._near(tree_a, new_pos, self.fixed_radius)\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire locally but only with direct rewiring (no recursive updates)\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt to connect to other tree\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    if expand_start:\n                        path = self._build_path(new_node, connect_node)\n                        total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    else:\n                        path = self._build_path(connect_node, new_node)\n                        total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        success_state = True\n                    break  # early stop at first found solution\n\n            if success_state:\n                break\n\n        extracted_path = best_path if success_state else []\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        return math.dist(p1, p2)\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # Avoid duplicate connection point\n        return path_start + path_goal[1:]\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -29.41149,
          "time_improvement": 67.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 262.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015022873878479004,
                    "num_nodes_avg": 127.2,
                    "path_length_avg": 166.58720661496753,
                    "smoothness_avg": 0.021817355324787333,
                    "success_improvement": 0.0,
                    "time_improvement": 41.91295770493012,
                    "length_improvement": 8.69091231112256,
                    "smoothness_improvement": 241.48898797830705,
                    "objective_score": 18.995879638044105
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.026909470558166504,
                    "num_nodes_avg": 294.0,
                    "path_length_avg": 243.31536602427045,
                    "smoothness_avg": 0.014871472156801322,
                    "success_improvement": 0.0,
                    "time_improvement": 83.6242547295916,
                    "length_improvement": 18.774327376604038,
                    "smoothness_improvement": 282.65369008293095,
                    "objective_score": 37.76514129525456
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01235973834991455,
                    "num_nodes_avg": 187.9,
                    "path_length_avg": 131.1163729137751,
                    "smoothness_avg": 0.028411044937784503,
                    "success_improvement": 0.0,
                    "time_improvement": 74.71753802696283,
                    "length_improvement": 12.918748201413955,
                    "smoothness_improvement": 261.3863945234228,
                    "objective_score": 31.473442301554336
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A tuned adaptive bidirectional RRT* planner with recursive descendant cost propagation, enhanced goal bias, and ellipsoidal informed refinement that balances exploration and exploitation. It uses adaptive neighbor radius shrinking for rewiring, efficient collision checking, consistent edge and parent-child updates, and early termination on a 30-second limit to improve planning time, path smoothness, and path length.",
          "planning_mechanism": "A bidirectional RRT* grows two trees from start and goal alternately with goal bias sampling until first connection, then conducts single-tree ellipsoidal informed RRT* refinement focused on the best path. Neighbor radius adapts with tree size. Rewiring propagates cost updates recursively to descendants ensuring path cost consistency and smoother paths. The best path is updated progressively and returned when time limit is reached.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.18          # goal bias probability\n        self.gamma_rrt_star = 40.0            # adaptive radius multiplier tuned for balance\n        self.improve_tol = 1e-6               # small tolerance for cost improvements\n        self.time_limit = 30.0                # hard time limit in seconds\n        self.max_radius_factor = 12.0         # max radius factor for neighbor search\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point):\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # avoid duplicate connecting node\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        if c_best == float(\"inf\") or c_best < c_min - 1e-10:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        dim = len(bounds)\n        center = tuple((s+g)/2 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n\n        while True:\n            rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0/dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _update_costs_recursive(self, node: Node):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_costs_recursive(child)\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        # Phase 1: Bidirectional growth until initial path found\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size * self.max_radius_factor)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire within neighbors with recursive cost update\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    self._update_costs_recursive(near_node)\n\n            # Attempt connection to other tree\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n                    success_state = True\n                    break\n\n        # Phase 2: Refinement via single-tree informed RRT*\n        if found_solution and best_goal_node is not None:\n            tree = [start_root]\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n            no_improve_count = 0\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if timed_out() or no_improve_count >= 120:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size * self.max_radius_factor)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        self._update_costs_recursive(near_node)\n                        rewired = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
          "objective": -26.48735,
          "time_improvement": 58.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 228.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017215156555175783,
                    "num_nodes_avg": 208.5,
                    "path_length_avg": 160.40239983380974,
                    "smoothness_avg": 0.02374652355073028,
                    "success_improvement": 0.0,
                    "time_improvement": 33.43633614808805,
                    "length_improvement": 12.08090291241019,
                    "smoothness_improvement": 271.6846599701681,
                    "objective_score": 18.637865891723372
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03504271507263183,
                    "num_nodes_avg": 467.1,
                    "path_length_avg": 253.42542860882128,
                    "smoothness_avg": 0.010719255016317384,
                    "success_improvement": 0.0,
                    "time_improvement": 78.67477272090856,
                    "length_improvement": 15.399297483864519,
                    "smoothness_improvement": 175.8141523371588,
                    "objective_score": 33.72108106827707
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.019155335426330567,
                    "num_nodes_avg": 300.1,
                    "path_length_avg": 131.29531716904052,
                    "smoothness_avg": 0.02638587363121502,
                    "success_improvement": 0.0,
                    "time_improvement": 60.81680487189903,
                    "length_improvement": 12.799901947476434,
                    "smoothness_improvement": 235.62636498645543,
                    "objective_score": 27.103114454987843
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -26.388981117243627,
          "time_improvement": 63.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 183.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01468205451965332,
                    "num_nodes_avg": 73.3,
                    "path_length_avg": 170.0777299899863,
                    "smoothness_avg": 0.01815393444540405,
                    "success_improvement": 0.0,
                    "time_improvement": 43.23076072126553,
                    "length_improvement": 6.77770113839239,
                    "smoothness_improvement": 184.14849597019096,
                    "objective_score": 17.956591379266047
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03251075744628906,
                    "num_nodes_avg": 236.4,
                    "path_length_avg": 260.6786075049101,
                    "smoothness_avg": 0.010607444299952517,
                    "success_improvement": 0.0,
                    "time_improvement": 80.2155943076742,
                    "length_improvement": 12.977977597171186,
                    "smoothness_improvement": 172.93718207108697,
                    "objective_score": 32.7161507609604
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016566014289855956,
                    "num_nodes_avg": 149.1,
                    "path_length_avg": 131.24402594159469,
                    "smoothness_avg": 0.022953022539448645,
                    "success_improvement": 0.0,
                    "time_improvement": 66.11339055320946,
                    "length_improvement": 12.833967138520164,
                    "smoothness_improvement": 191.96075248589716,
                    "objective_score": 28.494201211504425
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -25.88903997320672,
          "time_improvement": 62.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 175.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012654733657836915,
                    "num_nodes_avg": 142.7,
                    "path_length_avg": 168.74937337871444,
                    "smoothness_avg": 0.01750117800517029,
                    "success_improvement": 0.0,
                    "time_improvement": 51.06954533721745,
                    "length_improvement": 7.505794446187998,
                    "smoothness_improvement": 173.93144019723505,
                    "objective_score": 20.693997469864208
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.020306038856506347,
                    "num_nodes_avg": 272.4,
                    "path_length_avg": 258.7447467197662,
                    "smoothness_avg": 0.010763143861376633,
                    "success_improvement": 0.0,
                    "time_improvement": 87.64276989224348,
                    "length_improvement": 13.623555990348581,
                    "smoothness_improvement": 176.94344393239058,
                    "objective_score": 35.351681781544144
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02561664581298828,
                    "num_nodes_avg": 265.8,
                    "path_length_avg": 134.34631990981856,
                    "smoothness_avg": 0.02165635834384294,
                    "success_improvement": 0.0,
                    "time_improvement": 47.59987183319978,
                    "length_improvement": 10.773571200189904,
                    "smoothness_improvement": 175.46727962758771,
                    "objective_score": 21.621440668211815
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with uniform rewiring radius, goal-biased sampling, and early path connection checking. It maintains consistent parent-child relations and incremental cost updates without recursive propagation. The planner alternates tree expansions from start and goal, uses fixed step steering, and respects a 30-second time limit, returning the best path found.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal by sampling free points biased toward the opposite tree's root. New nodes are connected via nearest neighbors, rewiring locally with a uniform radius for cost improvement. On each expansion, it attempts to connect the two trees to form a solution. The method uses simple collision checking and incremental updates avoiding recursion for efficient time use while balancing exploration and refinement.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.1\n        self.rewire_radius = 15.0\n        self.time_limit = 30.0\n        self.improve_tol = 1e-6\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, target, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(target, obstacles, is_3d):\n            return target\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best, best_dist = None, float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best, best_dist = node, d\n        return best\n\n    def _near(self, tree, point, radius):\n        res = []\n        r_sq = radius * radius\n        for node in tree:\n            d_sq = sum((a - b) ** 2 for a, b in zip(node.position, point))\n            if d_sq <= r_sq:\n                res.append(node)\n        return res\n\n    def _build_path(self, start_node, goal_node):\n        path_from_start = start_node.path_from_root()\n        path_from_goal = goal_node.path_from_root()\n        path_from_goal.reverse()\n        return path_from_start + path_from_goal[1:]\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        time_start = time.monotonic()\n        def time_exceeded():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        best_goal_node = None\n        found_solution = False\n\n        for i in range(self.max_iter):\n            if time_exceeded():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            target = goal_pos if expand_start else start_pos\n            sample = self._sample(bounds, obstacles, is_3d, target, self.goal_sample_rate)\n\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            near_nodes = self._near(tree_a, new_pos, self.rewire_radius)\n\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_to_other = self._dist(new_node.position, nearest_other.position)\n\n            if dist_to_other <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    connect_node = Node(new_node.position,\n                                    parent=nearest_other,\n                                    cost=nearest_other.cost + dist_to_other)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    if expand_start:\n                        path = self._build_path(new_node, connect_node)\n                        total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                        goal_node_for_path = connect_node\n                    else:\n                        path = self._build_path(connect_node, new_node)\n                        total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n                        goal_node_for_path = new_node\n\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        best_goal_node = goal_node_for_path\n                        found_solution = True\n\n            if found_solution:\n                break\n\n        final_path = best_path if found_solution else []\n\n        return PlannerResult(success=found_solution,\n                             path=final_path,\n                             nodes=nodes,\n                             edges=edges)",
          "objective": -25.63427,
          "time_improvement": 53.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 293.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01984410285949707,
                    "num_nodes_avg": 143.3,
                    "path_length_avg": 171.67360458367028,
                    "smoothness_avg": 0.022584930568577976,
                    "success_improvement": 0.0,
                    "time_improvement": 23.27132268888971,
                    "length_improvement": 5.90297698534299,
                    "smoothness_improvement": 253.5032073599508,
                    "objective_score": 11.79069903467246
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025874114036560057,
                    "num_nodes_avg": 243.0,
                    "path_length_avg": 242.09986453995447,
                    "smoothness_avg": 0.016588755758426728,
                    "success_improvement": 0.0,
                    "time_improvement": 84.25432043918015,
                    "length_improvement": 19.180096758339072,
                    "smoothness_improvement": 326.84063406213465,
                    "objective_score": 38.41855735706817
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024422097206115722,
                    "num_nodes_avg": 210.2,
                    "path_length_avg": 125.00263383013859,
                    "smoothness_avg": 0.031336834215711706,
                    "success_improvement": 0.0,
                    "time_improvement": 50.04338065783512,
                    "length_improvement": 16.979202595794742,
                    "smoothness_improvement": 298.6022181793566,
                    "objective_score": 26.693546845724164
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An enhanced bidirectional RRT* planner with adaptive fixed-radius rewiring, balanced tree expansion, goal bias sampling, and non-recursive cost updates. It uses an efficient early connection detection, balanced neighbor search, and selective rewire to improve planning time while maintaining path quality and smoothness. The planning stops after 30 seconds or if a satisfactory path is found, returning the current best.",
          "planning_mechanism": "A bidirectional planner grows two trees alternately from start and goal using goal-biased sampling with a fixed step size. For each new node, rewiring is performed locally in a fixed-radius neighborhood without recursive cost propagation to reduce overhead. The nearest neighbors are searched via efficient pruning based on a fixed radius. Upon finding a connection between trees, the best path is updated and planning may terminate early. Consistent edge and parent updates maintain tree validity.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=10000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2    # goal bias probability\n        self.rewire_radius = 10.0      # fixed radius for rewiring to control overhead\n        self.time_limit = 30.0         # seconds\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal):\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point):\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point, radius):\n        radius_sq = radius*radius\n        dim = len(point)\n        result = []\n        for node in tree:\n            # squared dist for efficiency\n            dist_sq = sum((node.position[d] - point[d])**2 for d in range(dim))\n            if dist_sq <= radius_sq:\n                result.append(node)\n        return result\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start: List[Node] = [start_root]\n        tree_goal: List[Node] = [goal_root]\n        nodes: List[Node] = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        success_state = False\n\n        time_start = time.monotonic()\n\n        # Alternate tree expansion\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - time_start > self.time_limit:\n                break\n\n            expand_start = (iter_count % 2 == 0)\n            tree_a = tree_start if expand_start else tree_goal\n            tree_b = tree_goal if expand_start else tree_start\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_point = self._sample(bounds, obstacles, is_3d, sample_goal)\n            nearest_node = self._nearest(tree_a, sample_point)\n            new_pos = self._steer(nearest_node.position, sample_point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            dist_to_parent = self._dist(nearest_node.position, new_pos)\n            min_cost = nearest_node.cost + dist_to_parent\n            best_parent = nearest_node\n\n            # Fixed radius rewiring neighbors\n            near_nodes = self._near(tree_a, new_pos, self.rewire_radius)\n            for near_node in near_nodes:\n                cost_through_near = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_through_near < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_near\n                        best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node without recursion\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Rewire near_node to new_node\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        # Do not recurse cost update to keep time low\n\n            # Attempt to connect trees directly at new_node pos\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    # Connect by adding a node in tree_b at new_node's position with cost\n                    connect_cost = nearest_other.cost + dist_connect\n                    connect_node = Node(new_node.position, parent=nearest_other, cost=connect_cost)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    # Build combined path\n                    if expand_start:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n                    else:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    path_goal.reverse()\n                    combined_path = path_start + path_goal[1:]  # merge avoid duplicate\n\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = combined_path\n                        success_state = True\n                        # Early termination on first found path\n                        break\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -25.59587,
          "time_improvement": 61.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 161.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01631131172180176,
                    "num_nodes_avg": 138.0,
                    "path_length_avg": 167.04103096183044,
                    "smoothness_avg": 0.01581183459495707,
                    "success_improvement": 0.0,
                    "time_improvement": 36.931118404070936,
                    "length_improvement": 8.442163995300026,
                    "smoothness_improvement": 147.48954735946702,
                    "objective_score": 16.882081655198633
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.032275938987731935,
                    "num_nodes_avg": 287.8,
                    "path_length_avg": 257.1157017506108,
                    "smoothness_avg": 0.010703326882045994,
                    "success_improvement": 0.0,
                    "time_improvement": 80.3584929668585,
                    "length_improvement": 14.167378090512239,
                    "smoothness_improvement": 175.40430996978455,
                    "objective_score": 33.484996294213815
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017235589027404786,
                    "num_nodes_avg": 196.1,
                    "path_length_avg": 135.00966227832785,
                    "smoothness_avg": 0.02040266093776916,
                    "success_improvement": 0.0,
                    "time_improvement": 64.7437419926231,
                    "length_improvement": 10.333010783995237,
                    "smoothness_improvement": 159.52034116064578,
                    "objective_score": 26.4205307739873
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified and robust bidirectional RRT planner using fixed-step extension and goal-biased sampling that grows two trees from start and goal. It efficiently samples collision-free points within bounds, extends nearest nodes in the active tree towards samples while checking node and edge collisions, and attempts connecting opposite trees to find a feasible path. Planning halts on success or after a hard 30-second limit, returning the best found path. This design balances simplicity, efficiency, and path quality without complex rewiring or heavy neighbor searches, promoting generalizability and stable performance.",
          "planning_mechanism": "The planner alternates growth from the start and goal trees by sampling mostly random points with a small goal bias. Each iteration extends the active tree's nearest node toward the sample by a fixed step size, verifying node and edge collision. After adding a new node, it tries to connect the other tree within one step. If successful, it merges their paths. Search terminates upon success or time limit, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"] = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # probability to sample goal directly\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        is_3d = len(bounds) == 3\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success = False\n        best_path: List[Tuple[float, ...]] = []\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_p: Tuple[float, ...], to_p: Tuple[float, ...], resolution=1.0) -> bool:\n            distance = math.dist(from_p, to_p)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_p[d] + (to_p[d] - from_p[d]) * (i / steps) for d in range(len(from_p)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free() -> Tuple[float, ...]:\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                if is_3d:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(2))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(len(from_p)))\n\n        def extend(tree: List[Node], sample: Tuple[float, ...]) -> Optional[Node]:\n            near_node = nearest(tree, sample)\n            new_pos = steer(near_node.position, sample)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(near_node.position, new_pos):\n                return None\n            new_cost = near_node.cost + math.dist(near_node.position, new_pos)\n            new_node = Node(new_pos, parent=near_node, cost=new_cost)\n            near_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((near_node, new_node))\n            return new_node\n\n        def connect(tree: List[Node], node: Node) -> Optional[Node]:\n            near_node = nearest(tree, node.position)\n            dist = math.dist(near_node.position, node.position)\n            if dist <= self.step_size:\n                if is_in_obstacle(node.position) or is_edge_in_obstacle(near_node.position, node.position):\n                    return None\n                new_cost = near_node.cost + dist\n                new_node = Node(node.position, parent=near_node, cost=new_cost)\n                near_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((near_node, new_node))\n                return new_node\n            else:\n                new_pos = steer(near_node.position, node.position)\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(near_node.position, new_pos):\n                    return None\n                new_cost = near_node.cost + math.dist(near_node.position, new_pos)\n                new_node = Node(new_pos, parent=near_node, cost=new_cost)\n                near_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((near_node, new_node))\n                return None\n\n        tree_a = tree_start\n        tree_b = tree_goal\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            new_node = extend(tree_a, sample)\n            if new_node is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connected_node = connect(tree_b, new_node)\n            if connected_node is not None:\n                success = True\n                path_from_start = new_node.path_from_root()\n                path_from_goal = connected_node.path_from_root()\n                # Remove duplicate connection node from goal path start\n                best_path = path_from_start + path_from_goal[-2::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
          "objective": -25.31044,
          "time_improvement": 89.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 69.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.004116058349609375,
                    "num_nodes_avg": 100.0,
                    "path_length_avg": 186.50859214468096,
                    "smoothness_avg": 0.01083676150431979,
                    "success_improvement": 0.0,
                    "time_improvement": 84.08495888491464,
                    "length_improvement": -2.228314772268034,
                    "smoothness_improvement": 69.61884994686052,
                    "objective_score": 24.236593051847876
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.012918996810913085,
                    "num_nodes_avg": 290.6,
                    "path_length_avg": 305.74548850411804,
                    "smoothness_avg": 0.006610629509046964,
                    "success_improvement": 0.0,
                    "time_improvement": 92.13815075003298,
                    "length_improvement": -2.0666444586099937,
                    "smoothness_improvement": 70.09625871175474,
                    "objective_score": 26.751939843402667
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.004724693298339844,
                    "num_nodes_avg": 160.3,
                    "path_length_avg": 156.8139079605709,
                    "smoothness_avg": 0.013068898818260644,
                    "success_improvement": 0.0,
                    "time_improvement": 90.33540393269195,
                    "length_improvement": -4.1483309915455795,
                    "smoothness_improvement": 66.23542832250818,
                    "objective_score": 24.942799726492776
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "A bidirectional RRT* planner with adaptive fixed-radius rewiring, goal-biased sampling, and recursive cost updates that efficiently balances exploration and exploitation. The algorithm alternates expansions between start and goal trees with fixed-radius neighbor search to limit rewiring overhead. It tracks the best path with early termination on improvement to reduce planning time. Edge and node collision checks ensure path validity, while cost updates propagate recursively for consistent, smooth, and low-cost paths within a 30-second time limit.",
          "planning_mechanism": "A bidirectional sampling-based planner that samples with goal bias, grows two trees by fixed step sizes, uses adaptive fixed-radius rewiring based on node count and dimension to reduce neighbor evaluations, connects trees when close, and performs recursive cost updating for optimized rewiring. Early stopping on solution improvement and efficient collision checks contribute to reduced planning time and improved path quality.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15    # Goal bias probability\n        self.time_limit = 30.0          # Hard time limit in seconds\n        self.improve_tol = 1e-9         # Small tolerance for cost improvements\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float(\"inf\")\n        found_solution = False\n        success = False\n\n        # Adaptive fixed radius for neighbor search (based on RRT* theory)\n        def rewiring_radius(n: int) -> float:\n            if n <= 1:\n                return self.step_size * 2\n            gamma_r = 30.0  # hand-tuned constant for radius scaling\n            r = gamma_r * (math.log(n) / n) ** (1/dim)\n            return max(r, self.step_size)\n\n        for itr in range(self.max_iter):\n            if timed_out():\n                break\n\n            # Alternate trees\n            expand_start = (itr % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            radius = rewiring_radius(len(tree_a))\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            # Choose parent minimizing cost + distance from parent to new node\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if passing through new_node offers cheaper path\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        self._update_costs_recursive(near_node, edges)\n\n            # Attempt to connect trees\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    # Link trees by adding new node to tree_b\n                    connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    # Build combined path from start to goal\n                    if expand_start:\n                        path = self._build_path(new_node, connect_node)\n                        path_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    else:\n                        path = self._build_path(connect_node, new_node)\n                        path_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                    if path_cost + self.improve_tol < best_cost:\n                        best_cost = path_cost\n                        best_path = path\n                        found_solution = True\n                        success = True\n\n            if found_solution:\n                # Early termination on improvement to reduce planning time\n                break\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _update_costs_recursive(self, node: Node, edges: List[Tuple[Node, Node]]):\n        # Upon rewiring, recursively update costs and edges of children\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                if child.parent:\n                    try:\n                        edges.remove((child.parent, child))\n                    except ValueError:\n                        pass\n                    child.parent.remove_child(child)\n                child.parent = node\n                child.cost = new_cost\n                edges.append((node, child))\n                self._update_costs_recursive(child, edges)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        return math.dist(p1, p2)\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # Exclude duplicate connecting position to avoid repetition\n        combined = path_start + path_goal[1:]\n        return combined\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.71377,
          "time_improvement": 70.0,
          "length_improvement": 5.0,
          "smoothness_improvement": 135.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013166141510009766,
                    "num_nodes_avg": 149.0,
                    "path_length_avg": 167.92513770947517,
                    "smoothness_avg": 0.01719467639795058,
                    "success_improvement": 0.0,
                    "time_improvement": 49.09214941553891,
                    "length_improvement": 7.957571077348025,
                    "smoothness_improvement": 169.13402446535358,
                    "objective_score": 20.347857593397258
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.018252086639404298,
                    "num_nodes_avg": 260.9,
                    "path_length_avg": 286.64962201456353,
                    "smoothness_avg": 0.008089599894158899,
                    "success_improvement": 0.0,
                    "time_improvement": 88.8927015188115,
                    "length_improvement": 4.308105419644362,
                    "smoothness_improvement": 108.15123197999512,
                    "objective_score": 29.793429867330044
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01366419792175293,
                    "num_nodes_avg": 218.6,
                    "path_length_avg": 146.1829738133406,
                    "smoothness_avg": 0.017891955502714767,
                    "success_improvement": 0.0,
                    "time_improvement": 72.04920083513254,
                    "length_improvement": 2.912229278360186,
                    "smoothness_improvement": 127.5843533477518,
                    "objective_score": 24.00001958429463
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An enhanced bidirectional RRT* planner with goal bias, adaptive rewiring radius, efficient steering and collision checks, recursive cost propagation for improved path cost and smoothness, and early termination upon time limit or solution. The planner alternates tree expansions from start and goal, uses goal-biased sampling, rewires nodes within adaptive radius, and merges the trees upon feasible connection. It maintains consistent parent-child relationships and edge lists to ensure path quality and returns the best path found within 30 seconds.",
          "planning_mechanism": "A bidirectional RRT* approach that grows two trees alternately towards randomly sampled or goal-biased points using fixed step size steering. Each added node undergoes rewiring with neighbors within a dynamically adjusted radius, updating costs recursively. The trees attempt early connections each iteration, and the algorithm terminates upon first path found or time expiration, returning the best discovered path with coherent node and edge data.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True  # For collision or pruning if needed\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = 0.15         # Probability to sample the goal\n        self.gamma = 40.0             # Radius multiplier for rewiring\n        self.improve_tol = 1e-6       # Tolerance for cost improvement\n        self.time_limit = 30.0        # Hard time limit in seconds\n        self.max_radius_factor = 12.0 # Max radius factor relative to step_size\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal_pos):\n        if random.random() < self.goal_bias and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n            return goal_pos\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree: List[Node], point):\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point, radius: float):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _update_costs_recursive(self, node: Node):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_costs_recursive(child)\n\n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        path_from_start = node_start.path_from_root()\n        path_from_goal = node_goal.path_from_root()\n        path_from_goal.reverse()\n        # Avoid duplicating connecting node position twice\n        return path_from_start + path_from_goal[1:]\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        success_state = False\n\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos if expand_start else start_pos)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size * self.max_radius_factor)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    self._update_costs_recursive(near_node)\n\n            # Attempt connection to other tree\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                # Attach connection node to tree_b\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                # Build candidate path\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    success_state = True\n                    break\n\n        return PlannerResult(success=success_state, path=best_path, nodes=nodes, edges=edges)",
          "objective": -24.61754,
          "time_improvement": 61.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 193.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009621047973632812,
                    "num_nodes_avg": 97.6,
                    "path_length_avg": 164.31220468255123,
                    "smoothness_avg": 0.023315744650501093,
                    "success_improvement": 0.0,
                    "time_improvement": 62.79951325638851,
                    "length_improvement": 9.93787691999248,
                    "smoothness_improvement": 264.94203473022714,
                    "objective_score": 26.127290302563175
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02230513095855713,
                    "num_nodes_avg": 273.4,
                    "path_length_avg": 266.18287057210443,
                    "smoothness_avg": 0.009924123364819862,
                    "success_improvement": 0.0,
                    "time_improvement": 86.4262233621099,
                    "length_improvement": 11.14049615391379,
                    "smoothness_improvement": 155.3548422339481,
                    "objective_score": 33.388938912150984
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03204865455627441,
                    "num_nodes_avg": 330.6,
                    "path_length_avg": 142.5087361224591,
                    "smoothness_avg": 0.020315103476053527,
                    "success_improvement": 0.0,
                    "time_improvement": 34.44287676918223,
                    "length_improvement": 5.352483004246246,
                    "smoothness_improvement": 158.4066167104425,
                    "objective_score": 14.336385916854628
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A straightforward bidirectional RRT planner that grows two trees from start and goal by iteratively sampling free points and extending the nearest node from each tree towards the sample with a fixed step size; it alternates tree extensions, checks for collision-free connections between trees to find a complete path, and returns the best found path within a 30-second time limit.",
          "planning_mechanism": "The planner maintains two trees rooted at start and goal, samples collision-free points uniformly within map bounds, extends the nearest node in the active tree toward the sampled point, alternates trees each iteration, and tries to connect the opposite tree to the newly added node. Upon successful connection, it merges the two partial paths into a complete solution. Planning stops when the path is found or time limit expires, returning the current best path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        success = False\n        time_limit = 30.0\n        start_time = time.monotonic()\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def extend(tree, sample):\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def connect_trees(tree, node):\n            nearest_node = nearest(tree, node.position)\n            dist = math.dist(nearest_node.position, node.position)\n            if dist > self.step_size:\n                new_pos = steer(nearest_node.position, node.position)\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n                nearest_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n                # attempt direct connection if close\n                if math.dist(new_node.position, node.position) <= self.step_size:\n                    if not is_edge_in_obstacle(new_node.position, node.position):\n                        final_node = Node(node.position, parent=new_node, cost=new_node.cost + math.dist(new_node.position, node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                return None\n            else:\n                if is_in_obstacle(node.position) or is_edge_in_obstacle(nearest_node.position, node.position):\n                    return None\n                final_node = Node(node.position, parent=nearest_node, cost=nearest_node.cost + dist)\n                nearest_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_node, final_node))\n                return final_node\n\n        def sample_free():\n            while True:\n                if is_3d:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(2))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        tree_a = tree_start\n        tree_b = tree_goal\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            new_node = extend(tree_a, sample)\n            if new_node is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connected_node = connect_trees(tree_b, new_node)\n            if connected_node is not None:\n                success = True\n                path_a = new_node.path_from_root()\n                path_b = connected_node.path_from_root()\n                best_path = path_a + path_b[-2::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
          "objective": -24.61746,
          "time_improvement": 87.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.003728294372558594,
                    "num_nodes_avg": 84.9,
                    "path_length_avg": 180.87966860281307,
                    "smoothness_avg": 0.01103987851253821,
                    "success_improvement": 0.0,
                    "time_improvement": 85.58427670636823,
                    "length_improvement": 0.8569874170311926,
                    "smoothness_improvement": 72.7980722011218,
                    "objective_score": 26.553465823134793
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009920716285705566,
                    "num_nodes_avg": 246.6,
                    "path_length_avg": 301.0670492796362,
                    "smoothness_avg": 0.006705809145069515,
                    "success_improvement": 0.0,
                    "time_improvement": 93.96275291096713,
                    "length_improvement": -0.5048467840713801,
                    "smoothness_improvement": 72.54529930173578,
                    "objective_score": 28.248644299355988
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009735631942749023,
                    "num_nodes_avg": 234.2,
                    "path_length_avg": 163.86030235550345,
                    "smoothness_avg": 0.012918469003538813,
                    "success_improvement": 0.0,
                    "time_improvement": 80.08527871645923,
                    "length_improvement": -8.82821063541575,
                    "smoothness_improvement": 64.3219721828204,
                    "objective_score": 19.05026709460242
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified, robust bidirectional RRT planner with goal-biased sampling and incremental tree extension that balances exploration between start and goal trees, while performing efficient collision checks and early path updates. It avoids complex rewiring and uses straightforward nearest neighbor selection to maintain generality and simplicity for various environments.",
          "planning_mechanism": "A planning mechanism where two trees grow alternately from start and goal by sampling free configurations biased toward the goal, extending toward these samples in fixed step increments, and attempting quick connections between trees after each extension. The planner tracks the best path incrementally, respects a 30-second runtime limit, and returns the best feasible path found, emphasizing simplicity and consistent collision checking to enhance generalization and robustness.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child_node) -> None:\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=10000, step_size: float=5.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        success = False\n\n        def dist(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n            return math.dist(p1, p2)\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], resolution: float=1.0) -> bool:\n            d = dist(from_pos, to_pos)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[dim] + (to_pos[dim] - from_pos[dim]) * (i / steps) for dim in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free() -> Tuple[float, ...]:\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[dim]) for dim in range(len(bounds)))\n                if not is_in_obstacle(p):\n                    return p\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def extend(tree: List[Node], sample_point: Tuple[float, ...]) -> Node:\n            nearest_node = nearest(tree, sample_point)\n            new_pos = steer(nearest_node.position, sample_point)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def try_connect(tree: List[Node], target_node: Node) -> Node:\n            nearest_node = nearest(tree, target_node.position)\n            d = dist(nearest_node.position, target_node.position)\n            if d > self.step_size:\n                new_pos = steer(nearest_node.position, target_node.position)\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                    return None\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n                if dist(new_node.position, target_node.position) <= self.step_size:\n                    if (not is_in_obstacle(target_node.position) and \n                        not is_edge_in_obstacle(new_node.position, target_node.position)):\n                        final_node = Node(target_node.position, parent=new_node,\n                                          cost=new_node.cost + dist(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                return None\n            else:\n                if is_in_obstacle(target_node.position) or is_edge_in_obstacle(nearest_node.position, target_node.position):\n                    return None\n                final_node = Node(target_node.position, parent=nearest_node, cost=nearest_node.cost + d)\n                nearest_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_node, final_node))\n                return final_node\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        active_tree, passive_tree = tree_start, tree_goal\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            new_node = extend(active_tree, sample)\n            if new_node is None:\n                active_tree, passive_tree = passive_tree, active_tree\n                continue\n\n            connected = try_connect(passive_tree, new_node)\n            if connected is not None:\n                path_from_start = new_node.path_from_root()\n                path_from_goal = connected.path_from_root()\n                path_from_goal.reverse()\n                full_path = path_from_start + path_from_goal[1:]\n                total_cost = new_node.cost + (connected.cost - (connected.parent.cost if connected.parent else 0))\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = full_path\n                    success = True\n                break\n\n            active_tree, passive_tree = passive_tree, active_tree\n\n        return PlannerResult(success, best_path, nodes, edges)",
          "objective": -23.99146,
          "time_improvement": 85.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 67.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.005986332893371582,
                    "num_nodes_avg": 102.9,
                    "path_length_avg": 186.3878844459078,
                    "smoothness_avg": 0.010717739755280646,
                    "success_improvement": 0.0,
                    "time_improvement": 76.85340536155462,
                    "length_improvement": -2.162152969834569,
                    "smoothness_improvement": 67.75590111453309,
                    "objective_score": 22.09750933213831
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.012749218940734863,
                    "num_nodes_avg": 257.1,
                    "path_length_avg": 308.38377975949993,
                    "smoothness_avg": 0.006534880980414862,
                    "success_improvement": 0.0,
                    "time_improvement": 92.24146899067176,
                    "length_improvement": -2.9473820186597015,
                    "smoothness_improvement": 68.1471945105909,
                    "objective_score": 26.244747458558663
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.006320595741271973,
                    "num_nodes_avg": 198.8,
                    "path_length_avg": 157.6342104276583,
                    "smoothness_avg": 0.012998822830330053,
                    "success_improvement": 0.0,
                    "time_improvement": 87.07090579496337,
                    "length_improvement": -4.693136831579113,
                    "smoothness_improvement": 65.34406692850246,
                    "objective_score": 23.632109974184054
               }
          ],
          "success_rate": 1.0
     }
]