[
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -26.388981117243627,
          "time_improvement": 63.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 183.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01468205451965332,
                    "num_nodes_avg": 73.3,
                    "path_length_avg": 170.0777299899863,
                    "smoothness_avg": 0.01815393444540405,
                    "success_improvement": 0.0,
                    "time_improvement": 43.23076072126553,
                    "length_improvement": 6.77770113839239,
                    "smoothness_improvement": 184.14849597019096,
                    "objective_score": 17.956591379266047
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03251075744628906,
                    "num_nodes_avg": 236.4,
                    "path_length_avg": 260.6786075049101,
                    "smoothness_avg": 0.010607444299952517,
                    "success_improvement": 0.0,
                    "time_improvement": 80.2155943076742,
                    "length_improvement": 12.977977597171186,
                    "smoothness_improvement": 172.93718207108697,
                    "objective_score": 32.7161507609604
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016566014289855956,
                    "num_nodes_avg": 149.1,
                    "path_length_avg": 131.24402594159469,
                    "smoothness_avg": 0.022953022539448645,
                    "success_improvement": 0.0,
                    "time_improvement": 66.11339055320946,
                    "length_improvement": 12.833967138520164,
                    "smoothness_improvement": 191.96075248589716,
                    "objective_score": 28.494201211504425
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -25.88903997320672,
          "time_improvement": 62.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 175.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012654733657836915,
                    "num_nodes_avg": 142.7,
                    "path_length_avg": 168.74937337871444,
                    "smoothness_avg": 0.01750117800517029,
                    "success_improvement": 0.0,
                    "time_improvement": 51.06954533721745,
                    "length_improvement": 7.505794446187998,
                    "smoothness_improvement": 173.93144019723505,
                    "objective_score": 20.693997469864208
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.020306038856506347,
                    "num_nodes_avg": 272.4,
                    "path_length_avg": 258.7447467197662,
                    "smoothness_avg": 0.010763143861376633,
                    "success_improvement": 0.0,
                    "time_improvement": 87.64276989224348,
                    "length_improvement": 13.623555990348581,
                    "smoothness_improvement": 176.94344393239058,
                    "objective_score": 35.351681781544144
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02561664581298828,
                    "num_nodes_avg": 265.8,
                    "path_length_avg": 134.34631990981856,
                    "smoothness_avg": 0.02165635834384294,
                    "success_improvement": 0.0,
                    "time_improvement": 47.59987183319978,
                    "length_improvement": 10.773571200189904,
                    "smoothness_improvement": 175.46727962758771,
                    "objective_score": 21.621440668211815
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A straightforward bidirectional RRT planner that grows two trees from start and goal by iteratively sampling free points and extending the nearest node from each tree towards the sample with a fixed step size; it alternates tree extensions, checks for collision-free connections between trees to find a complete path, and returns the best found path within a 30-second time limit.",
          "planning_mechanism": "The planner maintains two trees rooted at start and goal, samples collision-free points uniformly within map bounds, extends the nearest node in the active tree toward the sampled point, alternates trees each iteration, and tries to connect the opposite tree to the newly added node. Upon successful connection, it merges the two partial paths into a complete solution. Planning stops when the path is found or time limit expires, returning the current best path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        success = False\n        time_limit = 30.0\n        start_time = time.monotonic()\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def extend(tree, sample):\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def connect_trees(tree, node):\n            nearest_node = nearest(tree, node.position)\n            dist = math.dist(nearest_node.position, node.position)\n            if dist > self.step_size:\n                new_pos = steer(nearest_node.position, node.position)\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n                nearest_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n                # attempt direct connection if close\n                if math.dist(new_node.position, node.position) <= self.step_size:\n                    if not is_edge_in_obstacle(new_node.position, node.position):\n                        final_node = Node(node.position, parent=new_node, cost=new_node.cost + math.dist(new_node.position, node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                return None\n            else:\n                if is_in_obstacle(node.position) or is_edge_in_obstacle(nearest_node.position, node.position):\n                    return None\n                final_node = Node(node.position, parent=nearest_node, cost=nearest_node.cost + dist)\n                nearest_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_node, final_node))\n                return final_node\n\n        def sample_free():\n            while True:\n                if is_3d:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(2))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        tree_a = tree_start\n        tree_b = tree_goal\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            new_node = extend(tree_a, sample)\n            if new_node is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connected_node = connect_trees(tree_b, new_node)\n            if connected_node is not None:\n                success = True\n                path_a = new_node.path_from_root()\n                path_b = connected_node.path_from_root()\n                best_path = path_a + path_b[-2::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
          "objective": -24.61746,
          "time_improvement": 87.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.003728294372558594,
                    "num_nodes_avg": 84.9,
                    "path_length_avg": 180.87966860281307,
                    "smoothness_avg": 0.01103987851253821,
                    "success_improvement": 0.0,
                    "time_improvement": 85.58427670636823,
                    "length_improvement": 0.8569874170311926,
                    "smoothness_improvement": 72.7980722011218,
                    "objective_score": 26.553465823134793
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009920716285705566,
                    "num_nodes_avg": 246.6,
                    "path_length_avg": 301.0670492796362,
                    "smoothness_avg": 0.006705809145069515,
                    "success_improvement": 0.0,
                    "time_improvement": 93.96275291096713,
                    "length_improvement": -0.5048467840713801,
                    "smoothness_improvement": 72.54529930173578,
                    "objective_score": 28.248644299355988
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009735631942749023,
                    "num_nodes_avg": 234.2,
                    "path_length_avg": 163.86030235550345,
                    "smoothness_avg": 0.012918469003538813,
                    "success_improvement": 0.0,
                    "time_improvement": 80.08527871645923,
                    "length_improvement": -8.82821063541575,
                    "smoothness_improvement": 64.3219721828204,
                    "objective_score": 19.05026709460242
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT that grows two trees from start and goal by extending towards random samples within map bounds, with straightforward collision checking and edge validation. The trees alternately extend, and upon nearby connection attempts, the shortest feasible path joining both trees is extracted. This reduces complexity by avoiding local rewiring and ensures efficient early solution discovery with clear parent-child relationships.",
          "planning_mechanism": "The planner initializes two trees at start and goal. It samples free points uniformly, extends the nearest node of the active tree towards the sample with a fixed step size if collision-free, then tries to connect the other tree to this new node. Trees swap roles each iteration. If nodes connect successfully, the path is reconstructed by concatenating the two tree paths. Planning terminates upon reaching the goal or hitting a 30-second time limit, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        success_state = False\n        extracted_path = []\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connected_node = self._connect_tree(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if connected_node is not None:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = connected_node.path_from_root()\n                # avoid duplicate join node\n                extracted_path = path_a + path_b[-2::-1] \n                break\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n            else:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(2))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, sample_point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest_node.position, sample_point)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            return None\n        new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n        nearest_node.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((nearest_node, new_node))\n        return new_node\n\n    def _connect_tree(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, target_node.position)\n        dist = math.dist(nearest_node.position, target_node.position)\n        if dist > self.step_size:\n            new_pos = self._steer(nearest_node.position, target_node.position)\n            if (self._is_in_obstacle(new_pos, obstacles, is_3d) or \n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            if math.dist(new_node.position, target_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, target_node.position, obstacles, is_3d):\n                final_node = Node(target_node.position, parent=new_node, cost=new_node.cost + math.dist(new_node.position, target_node.position))\n                new_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((new_node, final_node))\n                return final_node\n            return None\n        else:\n            if (self._is_in_obstacle(target_node.position, obstacles, is_3d) or \n                self._is_edge_in_obstacle(nearest_node.position, target_node.position, obstacles, is_3d)):\n                return None\n            final_node = Node(target_node.position, parent=nearest_node, cost=nearest_node.cost + dist)\n            nearest_node.add_child(final_node)\n            tree.append(final_node)\n            nodes.append(final_node)\n            edges.append((nearest_node, final_node))\n            return final_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.81258,
          "time_improvement": 85.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 67.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.005401754379272461,
                    "num_nodes_avg": 114.2,
                    "path_length_avg": 191.91931169727346,
                    "smoothness_avg": 0.010422378140458174,
                    "success_improvement": 0.0,
                    "time_improvement": 79.11372100741177,
                    "length_improvement": -5.19401589738194,
                    "smoothness_improvement": 63.13285045454905,
                    "objective_score": 20.933371016067113
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009308695793151855,
                    "num_nodes_avg": 249.9,
                    "path_length_avg": 303.7405843856087,
                    "smoothness_avg": 0.0065543332961882795,
                    "success_improvement": 0.0,
                    "time_improvement": 94.33519768518391,
                    "length_improvement": -1.397349755886233,
                    "smoothness_improvement": 68.64771660637766,
                    "objective_score": 27.80538803505532
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009527850151062011,
                    "num_nodes_avg": 232.6,
                    "path_length_avg": 155.08847600410883,
                    "smoothness_avg": 0.013322467560618296,
                    "success_improvement": 0.0,
                    "time_improvement": 80.51030674685057,
                    "length_improvement": -3.002381242304039,
                    "smoothness_improvement": 69.46080400879985,
                    "objective_score": 22.69896729871675
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -23.251988789791394,
          "time_improvement": 88.0,
          "length_improvement": -6.0,
          "smoothness_improvement": 61.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.004858589172363282,
                    "num_nodes_avg": 96.9,
                    "path_length_avg": 195.62876654039616,
                    "smoothness_avg": 0.010095393324640415,
                    "success_improvement": 0.0,
                    "time_improvement": 81.2139090674435,
                    "length_improvement": -7.227226876970991,
                    "smoothness_improvement": 58.01482802810868,
                    "objective_score": 20.317910734190995
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009849953651428222,
                    "num_nodes_avg": 232.3,
                    "path_length_avg": 307.1548722605045,
                    "smoothness_avg": 0.0063714004239236776,
                    "success_improvement": 0.0,
                    "time_improvement": 94.00581547777178,
                    "length_improvement": -2.537137323353922,
                    "smoothness_improvement": 63.94072204178738,
                    "objective_score": 26.999165859528116
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.005633759498596192,
                    "num_nodes_avg": 141.3,
                    "path_length_avg": 161.6340659525489,
                    "smoothness_avg": 0.01267178640865572,
                    "success_improvement": 0.0,
                    "time_improvement": 88.47586362623284,
                    "length_improvement": -7.3496504185589835,
                    "smoothness_improvement": 61.18418778412257,
                    "objective_score": 22.438889775655074
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT planner that alternates tree growth from start and goal, samples uniformly without goal bias, extends towards samples with fixed step size, and attempts direct connection between trees when close enough. It efficiently checks collisions for nodes and edges, returns the best path found within 30 seconds, and uses straightforward data structures for easy generalization.",
          "planning_mechanism": "The planner grows two trees alternatingly from start and goal by sampling free points and extending the nearest node in the active tree towards the sample by a fixed step. After each extension, it tries to directly connect to the opposite tree within step size. If connected, it returns the combined path. The process repeats until a path is found or time expires, ensuring valid node and edge insertions, and provides the best path found before timeout.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes.extend([start_root, goal_root])\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], resolution=1.0) -> bool:\n            dist = math.dist(from_pos, to_pos)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def sample_free() -> Tuple[float, ...]:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def extend(tree: List[Node], sample: Tuple[float, ...]) -> Node or None:\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def try_connect(tree: List[Node], node: Node) -> Node or None:\n            nearest_node = nearest(tree, node.position)\n            dist = math.dist(nearest_node.position, node.position)\n            if dist <= self.step_size:\n                if not is_edge_in_obstacle(nearest_node.position, node.position):\n                    final_node = Node(node.position, parent=nearest_node, cost=nearest_node.cost + dist)\n                    nearest_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((nearest_node, final_node))\n                    return final_node\n            return None\n\n        tree_a, tree_b = tree_start, tree_goal\n        best_path: List[Tuple[float, ...]] = []\n        success = False\n        time_limit = 30.0\n        start_time = time.monotonic()\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            new_node = extend(tree_a, sample)\n            if new_node is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connected_node = try_connect(tree_b, new_node)\n            if connected_node is not None:\n                success = True\n                path_a = new_node.path_from_root()\n                path_b = connected_node.path_from_root()\n                best_path = path_a + path_b[-2::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
          "objective": -22.02776,
          "time_improvement": 81.0,
          "length_improvement": -4.0,
          "smoothness_improvement": 66.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.005957841873168945,
                    "num_nodes_avg": 121.2,
                    "path_length_avg": 189.80776231442943,
                    "smoothness_avg": 0.010682871420312283,
                    "success_improvement": 0.0,
                    "time_improvement": 76.96356797817029,
                    "length_improvement": -4.036642221003974,
                    "smoothness_improvement": 67.21013595447693,
                    "objective_score": 21.003135740621083
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01022179126739502,
                    "num_nodes_avg": 251.5,
                    "path_length_avg": 302.65797170520227,
                    "smoothness_avg": 0.006605927499947617,
                    "success_improvement": 0.0,
                    "time_improvement": 93.77953387673223,
                    "length_improvement": -1.0359424818883414,
                    "smoothness_improvement": 69.9752726309083,
                    "objective_score": 27.862171037041207
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013717174530029297,
                    "num_nodes_avg": 317.4,
                    "path_length_avg": 162.2962061221566,
                    "smoothness_avg": 0.01272618929081355,
                    "success_improvement": 0.0,
                    "time_improvement": 71.94083453753878,
                    "length_improvement": -7.789412391485782,
                    "smoothness_improvement": 61.876188429567115,
                    "objective_score": 17.217983868518
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An adaptive bidirectional RRT* planner with goal biasing, incremental rewiring, and informed sampling to efficiently find and iteratively improve a near-optimal path within a 30-second limit. The planner balances growth between start and goal trees, performs adaptive radius neighbor searches for rewiring, and applies an ellipsoidal informed sampling once a solution is found to enhance convergence and path smoothness.",
          "planning_mechanism": "The planner alternates expansions of two trees towards random samples biased towards the goal, incrementally rewires nodes with neighbors in adaptive shrinking radius to improve path cost and smoothness, and upon initial solution discovery, switches to single-tree informed RRT* refinement sampling inside an ellipsoid defined by current best cost to optimize the path further, always enforcing collision checking on nodes and edges, and returning the best path found upon timeout or success.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        # Parameters for rewiring and goal bias\n        self.goal_sample_rate = 0.15        # Probability to sample the goal (goal bias)\n        self.gamma_rrt_star = 50.0          # Parameter for adaptive neighbor radius\n        self.improve_tol = 1e-6             # Improvement tolerance for path cost updates\n        self.time_limit = 30.0              # seconds time limit\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        # Goal biased sampling with specified probability\n        if random.random() < goal_bias_prob:\n            # sample goal directly if free\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                return goal\n        # Otherwise uniform sample within bounds and free space\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        # Linear nearest search (simple but acceptable)\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _path_cost(self, node):\n        return node.cost\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # Avoid duplicating connecting node\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        # If no solution yet, uniform sample\n        if c_best == float(\"inf\") or c_best < c_min - 1e-10:\n            # fallback to uniform sampling\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        # Ellipsoid sampling inside prolate hyperspheroid\n        # Code adapted from literature informed RRT* sampling, avoids numpy:\n        dim = len(bounds)\n        center = tuple((s + g)/2 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            # Avoid degenerate case\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        # Construct basis for rotation - produce orthonormal matrix with a1 as first column\n        # Here only rotate axis to x direction, so use rotated coordinates is not required for sampling uniform ball\n        # Instead sample in unit ball, then scale and translate\n\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n\n        while True:\n            # Sample random point in unit ball in R^dim\n            rnd_dir = []\n            # Sample standard normal gaussian vector\n            for _ in range(dim):\n                rnd_dir.append(random.gauss(0,1))\n            norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n            if norm_dir < 1e-12: continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n\n            # Radius scaling to distribute uniformly inside ball\n            r = random.random() ** (1.0/dim)\n            ball_point = [r * x for x in unit_dir]\n\n            # Scale ball_point components for ellipsoid radii\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n\n            # Rotate scaled vector to align with real coordinate system (only one axis, so just shift)\n            # Since rotation matrix is large effort and only affects orientation, approximate by axis aligned\n            # We rotate by vector a1/norm_a1 using Householder reflection or simplified since high cost\n            # To simplify, we place along the direction a1 by scaling only the first coordinate\n            # This is acceptable for performance and uniformity compromise\n            # Align first dimension with a1 direction:\n            # new_point = center + rotation * scaled\n\n            # Construct base vector in direction a1:\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            # Add components in other basis directions orthogonal to a1\n            # We don't construct orthonormal basis explicitly, skip to keep simplicity and avoid foreign dependencies\n\n            # As an approximation, add the other components along axes orthogonal by spreading them equally\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            # Clamp point inside bounds\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        time_limit = self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n\n        def can_finish():\n            return time.monotonic() - time_start > time_limit\n\n        # Phase 1: Bidirectional RRT* until initial solution found\n        for it in range(self.max_iter):\n            if can_finish():\n                break\n\n            # Alternate expansion: even expands start tree, odd goal tree\n            expand_start_tree = (it % 2 == 0)\n            if expand_start_tree:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            # Sampling with goal bias\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos if expand_start_tree else start_pos, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors within adaptive rewiring radius\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes) ** (1/dim)), self.step_size * 20)\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            # Choose parent with minimum cost + edge cost + no collision between parent to new_pos\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes if cheaper via new_node\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and \\\n                   not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    # Rewire\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            # Attempt to connect from other tree\n            nearest_node_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_node_other.position, new_node.position)\n            if dist_connect <= self.step_size and \\\n               not self._is_edge_in_obstacle(nearest_node_other.position, new_node.position, obstacles, is_3d):\n\n                # Connect the two trees\n                connect_node = Node(new_node.position, parent=nearest_node_other,\n                                   cost=nearest_node_other.cost + dist_connect)\n                nearest_node_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_node_other, connect_node))\n\n                # Construct path: new_node from tree_a and connect_node from tree_b\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_node_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start_tree else new_node\n                    found_solution = True\n                    success_state = True\n\n            if found_solution:\n                break\n\n        # Phase 2: Single-tree informed RRT* refinement if solution found\n        if found_solution and best_goal_node:\n            # Reset tree for refinement: use start_root plus best path nodes (re-create properly)\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node,\n                                cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n            no_improve_count = 0\n            post_opt_iters = self.max_iter // 2\n\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if can_finish() or no_improve_count >= 150:\n                    break\n\n                # Informed sampling inside ellipsoid defined by best_cost\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min,\n                                                              start_pos, goal_pos, bounds, obstacles, is_3d)\n\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size * 20)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                    if candidate_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired_any = False\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        rewired_any = True\n\n                # Check if can connect directly to goal\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and \\\n                   not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired_any:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -21.85805,
          "time_improvement": 39.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 286.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021411538124084473,
                    "num_nodes_avg": 92.3,
                    "path_length_avg": 161.62176685276987,
                    "smoothness_avg": 0.026296503737064592,
                    "success_improvement": 0.0,
                    "time_improvement": 17.21071942180759,
                    "length_improvement": 11.41254852721125,
                    "smoothness_improvement": 311.59738725690346,
                    "objective_score": 13.568731879153544
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03712928295135498,
                    "num_nodes_avg": 109.2,
                    "path_length_avg": 246.37899691959302,
                    "smoothness_avg": 0.013803575390083797,
                    "success_improvement": 0.0,
                    "time_improvement": 77.40499284926345,
                    "length_improvement": 17.75159920201941,
                    "smoothness_improvement": 255.17593710033827,
                    "objective_score": 35.14833706149237
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03867461681365967,
                    "num_nodes_avg": 101.4,
                    "path_length_avg": 127.66449265035354,
                    "smoothness_avg": 0.030873705973109955,
                    "success_improvement": 0.0,
                    "time_improvement": 20.889140107088526,
                    "length_improvement": 15.211322711504014,
                    "smoothness_improvement": 292.7112611180333,
                    "objective_score": 16.857091964619134
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -19.463672592061652,
          "time_improvement": 78.0,
          "length_improvement": -7.0,
          "smoothness_improvement": 78.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008280038833618164,
                    "num_nodes_avg": 104.3,
                    "path_length_avg": 206.72066848824505,
                    "smoothness_avg": 0.011079765008698384,
                    "success_improvement": 0.0,
                    "time_improvement": 67.98462332681883,
                    "length_improvement": -13.30687409702089,
                    "smoothness_improvement": 73.42238248094127,
                    "objective_score": 12.77837445223782
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.013870835304260254,
                    "num_nodes_avg": 224.1,
                    "path_length_avg": 301.37655385959613,
                    "smoothness_avg": 0.007247119668786048,
                    "success_improvement": 0.0,
                    "time_improvement": 91.55890989607673,
                    "length_improvement": -0.60816832145739,
                    "smoothness_improvement": 86.47360896717294,
                    "objective_score": 27.535140020784446
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.012821125984191894,
                    "num_nodes_avg": 218.9,
                    "path_length_avg": 161.68779197151838,
                    "smoothness_avg": 0.013782767682665054,
                    "success_improvement": 0.0,
                    "time_improvement": 73.77374658185289,
                    "length_improvement": -7.385332682200414,
                    "smoothness_improvement": 75.31578758541383,
                    "objective_score": 18.077503303162686
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional planner combining goal-biased sampling, adaptive rewiring with logarithmically shrinking neighbor radius, and efficient early best-path tracking to optimize path length, smoothness, and planning time. It maintains consistent edge and parent-child relationships, employs incremental collision checks, and terminates early upon time limit or path completion.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately using goal-biased sampling, extends toward samples by a fixed step size, and rewires neighbors within an adaptive radius that shrinks logarithmically with tree size. It attempts to connect the trees after each extension and updates the best path if a shorter connection is found. The method incorporates proactive early termination on time limit or successful connectivity, balanced exploration and exploitation, and consistent edge management to improve path quality and smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, gamma_rrt_star: float=50.0, max_radius: float=60.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import time, math, random\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dimension = len(bounds)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            distance = math.dist(from_pos, to_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dimension))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            # 15% goal bias for fast convergence\n            if random.random() < 0.15:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not _is_in_obstacle(p):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, pos):\n            n = max(1, len(tree))\n            scale = max(1.0, sum(bounds) / dimension)\n            r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / dimension))\n            radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def choose_parent(new_pos, tree):\n            neighbors = near_nodes(tree, new_pos)\n            nearest_node = nearest(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for nb in neighbors:\n                if not _is_edge_in_obstacle(nb.position, new_pos):\n                    cost_to_new = nb.cost + math.dist(nb.position, new_pos)\n                    if cost_to_new < min_cost:\n                        min_cost = cost_to_new\n                        best_parent = nb\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(pivot, neighbors):\n            for nb in neighbors:\n                if nb == pivot.parent:\n                    continue\n                if not _is_edge_in_obstacle(pivot.position, nb.position):\n                    new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        pivot.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((pivot, nb))\n\n        def extend_and_rewire(tree, sample_pt):\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if _is_in_obstacle(new_pos):\n                return None\n            if _is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_node, neighbors = choose_parent(new_pos, tree)\n            rewire(new_node, neighbors)\n            return new_node\n\n        def connect_and_rewire(tree, target_node):\n            nearest_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(nearest_node.position, target_node.position)\n                if _is_in_obstacle(new_pos):\n                    return None\n                if _is_edge_in_obstacle(nearest_node.position, new_pos):\n                    return None\n                connect_node, neighbors = choose_parent(new_pos, tree)\n                rewire(connect_node, neighbors)\n                if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                    if (not _is_edge_in_obstacle(connect_node.position, target_node.position) and\n                        not _is_in_obstacle(target_node.position)):\n                        final_node = Node(target_node.position, parent=None,\n                                         cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                        connect_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((connect_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = connect_node\n\n        def update_best_path(node_a, node_b):\n            nonlocal best_cost, best_path, success\n            dist_connect = math.dist(node_a.position, node_b.position)\n            total_cost = node_a.cost + node_b.cost + dist_connect\n            if total_cost < best_cost:\n                best_cost = total_cost\n                path_a = node_a.path_from_root()\n                path_b = node_b.path_from_root()\n                if path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                best_path = path_a + path_b[::-1]\n                success = True\n\n        for iter_n in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                # Return best path found so far on timeout\n                return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n            sample = sample_free()\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n            new_node_b = connect_and_rewire(tree_b, new_node_a)\n            if new_node_b is not None:\n                update_best_path(new_node_a, new_node_b)\n                # Early return on connection\n                return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n            tree_a, tree_b = tree_b, tree_a\n\n        # Return best path found after max iterations or no connection\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
          "objective": -18.21176,
          "time_improvement": 38.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 166.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017172026634216308,
                    "num_nodes_avg": 84.8,
                    "path_length_avg": 166.1136358917928,
                    "smoothness_avg": 0.017405039468317472,
                    "success_improvement": 0.0,
                    "time_improvement": 33.60310114679745,
                    "length_improvement": 8.950483928702955,
                    "smoothness_improvement": 172.42666332731423,
                    "objective_score": 16.31335401789758
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05594196319580078,
                    "num_nodes_avg": 296.0,
                    "path_length_avg": 269.4414713435546,
                    "smoothness_avg": 0.009859582258951003,
                    "success_improvement": 0.0,
                    "time_improvement": 65.95654540133718,
                    "length_improvement": 10.052681422781044,
                    "smoothness_improvement": 153.69415309286282,
                    "objective_score": 26.587043239534093
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04169762134552002,
                    "num_nodes_avg": 219.8,
                    "path_length_avg": 134.3477221843536,
                    "smoothness_avg": 0.021378713251996768,
                    "success_improvement": 0.0,
                    "time_improvement": 14.705433384720349,
                    "length_improvement": 10.772639876212878,
                    "smoothness_improvement": 171.93565455293327,
                    "objective_score": 11.734892213908497
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A hybrid planner integrating unidirectional RRT*-style asymptotically optimal sampling with local rewiring and a bidirectional RRT extension for faster initial solution discovery. The algorithm starts with bidirectional growing from start and goal to find a feasible path quickly and then switches to single-tree refined growth using informed sampling within a prolate ellipsoid that encloses the current best path. Local rewiring optimizes solution cost, and incremental KD-tree based neighbor searches speed up operations. Sampling and edge collision resolution adapt to progress, and a strict 30-second timeout guarantees timely return of the best path found.",
          "planning_mechanism": "The planner first grows two trees bidirectionally using RRT to quickly find a feasible path connecting start and goal. Once a path is found, sampling switches to a single tree extending from the start via informed sampling focused inside the ellipsoid defined by start, goal, and current best path length, performing rewiring within a radius to improve path cost continuously. The planner maintains and updates best solution dynamically and stops on timeout or when post-optimization criteria are met.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 post_opt_iters: int = 500,\n                 no_improve_limit: int = 150,\n                 improve_tol: float = 1e-6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        best_path = []\n        nodes = []\n        edges = []\n\n        # Bidirectional trees init\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_goal_node = None\n        best_cost = float(\"inf\")\n        c_min = math.dist(start, goal)\n\n        # For rewiring radius calculation\n        dim = len(bounds)\n\n        # For post-optimization single-tree phase\n        found_solution = False\n        elapsed_post_iters = 0\n        no_improve_count = 0\n\n        # For KD-tree acceleration of near queries\n        # Simple spatial index: store points for start_tree nodes\n        from bisect import bisect_left, insort\n\n        # Store positions separately for quick nearest search\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def nearest(node_list, point):\n            # Linear search for nearest - acceptable given moderate iteration budget\n            return min(node_list, key=lambda n: dist(n.position, point))\n\n        def near(node_list, point, radius):\n            return [n for n in node_list if dist(n.position, point) <= radius]\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            distance = dist(from_pos, to_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n\n        def sample_informed(c_best):\n            # Ellipsoidal informed sampling inside prolate hyperspheroid\n            if c_best == float(\"inf\"):\n                return sample_uniform()\n\n            import numpy as np\n\n            c_min_local = c_min\n            center = [(s + g) / 2 for s, g in zip(start, goal)]\n            a1 = [g - s for s, g in zip(start, goal)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-12:\n                return sample_uniform()\n            a1 = [x / norm_a1 for x in a1]\n\n            L = np.diag([c_best / 2] + [math.sqrt(c_best ** 2 - c_min_local ** 2) / 2] * (dim - 1))\n            x_center = np.array(center)\n\n            I = np.eye(dim)\n            M = np.outer(a1, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)])).dot(Vt)\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(x_ball)\n                if norm < 1e-12:\n                    continue\n                x_ball /= norm\n                r = random.random() ** (1.0 / dim)\n                x_ball *= r\n                rnd = C.dot(L.dot(x_ball)) + x_center\n                if all(0 <= rnd[d] <= bounds[d] for d in range(dim)):\n                    pt = tuple(float(x) for x in rnd)\n                    if not is_in_obstacle(pt):\n                        return pt\n\n        def connect_trees(tree_from, tree_to):\n            # Attempt to connect tree_to to tree_from with incremental steps\n            import math\n\n            nearest_to = nearest(tree_to, tree_from[-1].position)\n\n            current = nearest_to\n            while True:\n                new_pos = steer(current.position, tree_from[-1].position)\n                if is_in_obstacle(new_pos):\n                    return None\n                if is_edge_in_obstacle(current.position, new_pos) or is_edge_in_obstacle(new_pos, tree_from[-1].position):\n                    return None\n                new_node = Node(new_pos, parent=current)\n                new_node.cost = current.cost + dist(current.position, new_pos)\n                current.add_child(new_node)\n                tree_to.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n                if dist(new_node.position, tree_from[-1].position) <= self.step_size:\n                    # Final check\n                    if (not is_edge_in_obstacle(new_node.position, tree_from[-1].position)):\n                        final_node = Node(tree_from[-1].position, parent=new_node)\n                        final_node.cost = new_node.cost + dist(new_node.position, final_node.position)\n                        new_node.add_child(final_node)\n                        tree_to.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n\n        time_start = time.monotonic()\n        time_limit = 30.0\n\n        # Phase 1: Bidirectional RRT to find initial solution quickly\n        for iter_cnt in range(self.max_iter):\n            # Check time limit\n            if time.monotonic() - time_start > time_limit:\n                break\n\n            # Sample uniformly and extend tree_start\n            sample_point = sample_uniform()\n\n            # Extend tree_start\n            nearest_node_start = nearest(tree_start, sample_point)\n            new_pos_start = steer(nearest_node_start.position, sample_point)\n            if (not is_in_obstacle(new_pos_start)) and (not is_edge_in_obstacle(nearest_node_start.position, new_pos_start)):\n                new_node_start = Node(new_pos_start)\n                cost_val = nearest_node_start.cost + dist(nearest_node_start.position, new_pos_start)\n                new_node_start.cost = cost_val\n                nearest_node_start.add_child(new_node_start)\n                tree_start.append(new_node_start)\n                nodes.append(new_node_start)\n                edges.append((nearest_node_start, new_node_start))\n\n                # Try to connect tree_goal to new_node_start\n                nearest_node_goal = nearest(tree_goal, new_node_start.position)\n                new_pos_goal = steer(nearest_node_goal.position, new_node_start.position)\n                if (not is_in_obstacle(new_pos_goal)) and (not is_edge_in_obstacle(nearest_node_goal.position, new_pos_goal)):\n                    new_node_goal = Node(new_pos_goal, parent=nearest_node_goal)\n                    new_node_goal.cost = nearest_node_goal.cost + dist(nearest_node_goal.position, new_pos_goal)\n                    nearest_node_goal.add_child(new_node_goal)\n                    tree_goal.append(new_node_goal)\n                    nodes.append(new_node_goal)\n                    edges.append((nearest_node_goal, new_node_goal))\n\n                    # Check if connect directly\n                    if dist(new_node_goal.position, new_node_start.position) <= self.step_size:\n                        if not is_edge_in_obstacle(new_node_goal.position, new_node_start.position):\n                            # Connect and form path\n                            goal_connect_node = Node(new_node_start.position, parent=new_node_goal)\n                            goal_connect_node.cost = new_node_goal.cost + dist(new_node_goal.position, new_node_start.position)\n                            new_node_goal.add_child(goal_connect_node)\n                            tree_goal.append(goal_connect_node)\n                            nodes.append(goal_connect_node)\n                            edges.append((new_node_goal, goal_connect_node))\n\n                            path_start = new_node_start.path_from_root()\n                            path_goal = goal_connect_node.path_from_root()\n                            if path_goal:\n                                path_goal.reverse()\n                            full_path = path_start + path_goal[1:]\n                            path_cost = new_node_start.cost + (goal_connect_node.cost - new_node_goal.cost)\n\n                            if path_cost + self.improve_tol < best_cost:\n                                best_cost = path_cost\n                                best_goal_node = goal_connect_node\n                                best_path = full_path\n                                success = True\n                                found_solution = True\n                            break\n\n            # Also try growing goal tree towards sampled sample\n            sample_point = sample_uniform()\n            nearest_node_goal = nearest(tree_goal, sample_point)\n            new_pos_goal = steer(nearest_node_goal.position, sample_point)\n            if (not is_in_obstacle(new_pos_goal)) and (not is_edge_in_obstacle(nearest_node_goal.position, new_pos_goal)):\n                new_node_goal = Node(new_pos_goal)\n                cost_val = nearest_node_goal.cost + dist(nearest_node_goal.position, new_pos_goal)\n                new_node_goal.cost = cost_val\n                nearest_node_goal.add_child(new_node_goal)\n                tree_goal.append(new_node_goal)\n                nodes.append(new_node_goal)\n                edges.append((nearest_node_goal, new_node_goal))\n\n                # Try connect tree_start to new_node_goal\n                nearest_node_start = nearest(tree_start, new_node_goal.position)\n                new_pos_start = steer(nearest_node_start.position, new_node_goal.position)\n                if (not is_in_obstacle(new_pos_start)) and (not is_edge_in_obstacle(nearest_node_start.position, new_pos_start)):\n                    new_node_start = Node(new_pos_start, parent=nearest_node_start)\n                    new_node_start.cost = nearest_node_start.cost + dist(nearest_node_start.position, new_pos_start)\n                    nearest_node_start.add_child(new_node_start)\n                    tree_start.append(new_node_start)\n                    nodes.append(new_node_start)\n                    edges.append((nearest_node_start, new_node_start))\n\n                    if dist(new_node_start.position, new_node_goal.position) <= self.step_size:\n                        if not is_edge_in_obstacle(new_node_start.position, new_node_goal.position):\n                            goal_connect_node = Node(new_node_goal.position, parent=new_node_start)\n                            goal_connect_node.cost = new_node_start.cost + dist(new_node_start.position, new_node_goal.position)\n                            new_node_start.add_child(goal_connect_node)\n                            tree_start.append(goal_connect_node)\n                            nodes.append(goal_connect_node)\n                            edges.append((new_node_start, goal_connect_node))\n\n                            path_start = goal_connect_node.path_from_root()\n                            path_goal = new_node_goal.path_from_root()\n                            if path_goal:\n                                path_goal.reverse()\n                            full_path = path_start + path_goal[1:]\n                            path_cost = goal_connect_node.cost + (new_node_goal.cost)\n\n                            if path_cost + self.improve_tol < best_cost:\n                                best_cost = path_cost\n                                best_goal_node = goal_connect_node\n                                best_path = full_path\n                                success = True\n                                found_solution = True\n                            break\n\n            if found_solution:\n                break\n\n        # Phase 2: Single-tree informed RRT* rewiring refinement\n        if found_solution and best_goal_node:\n            # Use single tree from start plus goal_node appended\n            tree = [start_root] + [n for n in nodes if n not in (start_root, goal_root)] + [best_goal_node]\n            # Reset nodes and edges structures for refinement to keep consistency\n            nodes = [start_root]\n            edges = []\n            tree = [start_root]\n            start_root.children = []\n            start_root.cost = 0.0\n\n            # Insert initial best path nodes\n            previous_node = start_root\n            for p in best_path[1:]:\n                new_node = Node(p)\n                new_node.cost = previous_node.cost + dist(previous_node.position, p)\n                new_node.parent = previous_node\n                previous_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((previous_node, new_node))\n                previous_node = new_node\n\n            best_cost = new_node.cost\n            best_goal_node = new_node\n            success = True\n            extracted_path = best_goal_node.path_from_root()\n\n            c_min = math.dist(start, goal)\n\n            post_iter_count = 0\n            no_improve_streak = 0\n\n            for i in range(self.post_opt_iters):\n                if time.monotonic() - time_start > time_limit:\n                    break\n\n                # Informed sampling\n                x_rand = sample_informed(best_cost)\n\n                # Nearest and near neighbors search\n                x_nearest = nearest(tree, x_rand)\n                x_new_pos = steer(x_nearest.position, x_rand)\n                if is_in_obstacle(x_new_pos) or is_edge_in_obstacle(x_nearest.position, x_new_pos):\n                    no_improve_streak += 1\n                    post_iter_count += 1\n                    if no_improve_streak >= self.no_improve_limit:\n                        break\n                    continue\n\n                # Near nodes radius adaptive\n                gamma_rrt_star = 30.0  # a constant coefficient for radius\n                radius = min(gamma_rrt_star * ((math.log(len(tree) + 1) / (len(tree) + 1)) ** (1 / dim)), self.step_size * 20)\n                near_nodes = near(tree, x_new_pos, radius)\n\n                # Choose best parent\n                min_cost = x_nearest.cost + dist(x_nearest.position, x_new_pos)\n                best_parent = x_nearest\n                for n in near_nodes:\n                    new_cost = n.cost + dist(n.position, x_new_pos)\n                    if new_cost < min_cost and not is_edge_in_obstacle(n.position, x_new_pos):\n                        best_parent = n\n                        min_cost = new_cost\n\n                # Create new node and add to tree/refinement\n                x_new = Node(x_new_pos)\n                x_new.cost = min_cost\n                best_parent.add_child(x_new)\n                x_new.parent = best_parent\n                tree.append(x_new)\n                nodes.append(x_new)\n                edges.append((best_parent, x_new))\n\n                # Rewire neighbors if cheaper through x_new\n                for n in near_nodes:\n                    if n == best_parent:\n                        continue\n                    alt_cost = x_new.cost + dist(x_new.position, n.position)\n                    if alt_cost + 1e-12 < n.cost and not is_edge_in_obstacle(x_new.position, n.position):\n                        # Remove old edge n.parent -> n\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            n.parent.remove_child(n)\n                        n.parent = x_new\n                        n.cost = alt_cost\n                        x_new.add_child(n)\n                        edges.append((x_new, n))\n\n                # Check goal reach condition\n                if dist(x_new.position, goal) < self.step_size and not is_edge_in_obstacle(x_new.position, goal):\n                    new_goal_node = Node(goal)\n                    new_goal_node.cost = x_new.cost + dist(x_new.position, goal)\n                    x_new.add_child(new_goal_node)\n                    new_goal_node.parent = x_new\n                    nodes.append(new_goal_node)\n                    edges.append((x_new, new_goal_node))\n\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        extracted_path = best_goal_node.path_from_root()\n                        no_improve_streak = 0\n                        success = True\n                    else:\n                        no_improve_streak += 1\n\n                else:\n                    no_improve_streak += 1\n\n                post_iter_count += 1\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.no_improve_limit:\n                    break\n\n            if success and best_goal_node:\n                extracted_path = best_goal_node.path_from_root()\n            else:\n                extracted_path = best_path\n\n        else:\n            # No solution found in bidirectional phase: fail early\n            extracted_path = []\n            success = False\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -16.43239,
          "time_improvement": 51.0,
          "length_improvement": 1.0,
          "smoothness_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021007657051086426,
                    "num_nodes_avg": 166.7,
                    "path_length_avg": 178.57139078821234,
                    "smoothness_avg": 0.01089048020807648,
                    "success_improvement": 0.0,
                    "time_improvement": 18.772355175338323,
                    "length_improvement": 2.122191064216494,
                    "smoothness_improvement": 70.45966431268502,
                    "objective_score": 7.257319512694818
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03780534267425537,
                    "num_nodes_avg": 247.8,
                    "path_length_avg": 300.52119057497464,
                    "smoothness_avg": 0.006304153987544167,
                    "success_improvement": 0.0,
                    "time_improvement": 76.99357703244651,
                    "length_improvement": -0.32262343678369665,
                    "smoothness_improvement": 62.21042279809224,
                    "objective_score": 23.215551161654194
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02070934772491455,
                    "num_nodes_avg": 199.9,
                    "path_length_avg": 147.70638510285244,
                    "smoothness_avg": 0.014035244649167852,
                    "success_improvement": 0.0,
                    "time_improvement": 57.63799511620115,
                    "length_improvement": 1.900452036916589,
                    "smoothness_improvement": 78.52727596341828,
                    "objective_score": 18.824306136827385
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT planner with alternating tree expansion, uniform sampling without goal bias, fixed step size steering, direct tree connection attempts, and incremental best-path tracking within a 30-second limit to improve generalization and maintain balanced exploration.",
          "planning_mechanism": "A bidirectional planner grows two trees from start and goal points alternatively by sampling reachable free points, extending trees towards samples with fixed steps and checking collisions for nodes and edges. After each extension, it attempts to connect the opposite tree directly to the newly added node if within step size, returning the combined path immediately upon success. The process continues until a path is found or the 30-second timeout is reached, returning the best path found so far.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0\n        try:\n            import math\n        except:\n            pass\n        dist = 0\n        dist = sum((to_pos[d] - from_pos[d])**2 for d in range(len(from_pos)))**0.5\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = 0\n        dist = sum((to_pos[d] - from_pos[d])**2 for d in range(len(from_pos)))**0.5\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = 0\n            d = sum((node.position[i]-point[i])**2 for i in range(len(point)))**0.5\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map):\n        import time\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        success = False\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        tree_a, tree_b = tree_start, tree_goal\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = self._sample_free(bounds, obstacles, is_3d)\n            nearest_node = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest_node.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node = Node(new_pos, parent=nearest_node,\n                            cost=nearest_node.cost + \n                            sum((new_pos[d]-nearest_node.position[d])**2 for d in range(len(new_pos)))**0.5)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Try to connect trees directly\n            nearest_in_other = self._nearest(tree_b, new_pos)\n            dist_connect = sum((nearest_in_other.position[d]-new_pos[d])**2 for d in range(len(new_pos)))**0.5\n            if dist_connect <= self.step_size and \\\n               not self._is_edge_in_obstacle(nearest_in_other.position, new_pos, obstacles, is_3d):\n                connected_node = Node(new_pos, parent=nearest_in_other,\n                                      cost=nearest_in_other.cost + dist_connect)\n                nearest_in_other.add_child(connected_node)\n                tree_b.append(connected_node)\n                nodes.append(connected_node)\n                edges.append((nearest_in_other, connected_node))\n\n                # Extract path\n                path_start = new_node.path_from_root()\n                path_goal = connected_node.path_from_root()\n                best_path = path_start + path_goal[-2::-1]\n                success = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -13.63419,
          "time_improvement": 52.0,
          "length_improvement": -4.0,
          "smoothness_improvement": 67.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008094406127929688,
                    "num_nodes_avg": 107.2,
                    "path_length_avg": 192.97970859638593,
                    "smoothness_avg": 0.010407655485757568,
                    "success_improvement": 0.0,
                    "time_improvement": 68.70238578118662,
                    "length_improvement": -5.775236240849632,
                    "smoothness_improvement": 62.90240893772817,
                    "objective_score": 17.460086034534847
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04489636421203613,
                    "num_nodes_avg": 281.4,
                    "path_length_avg": 304.73876560133533,
                    "smoothness_avg": 0.006559560824594926,
                    "success_improvement": 0.0,
                    "time_improvement": 72.678339311263,
                    "length_improvement": -1.730571376749036,
                    "smoothness_improvement": 68.78222467751719,
                    "objective_score": 21.10907009071706
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.041781044006347655,
                    "num_nodes_avg": 253.5,
                    "path_length_avg": 156.51329180257372,
                    "smoothness_avg": 0.0132417238903637,
                    "success_improvement": 0.0,
                    "time_improvement": 14.534788166322269,
                    "length_improvement": -3.948676053207013,
                    "smoothness_improvement": 68.43375048303919,
                    "objective_score": 2.333399570387669
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional RRT* planner with goal bias sampling, dynamic neighbor radius, and incremental rewiring that grows two trees from start and goal, efficiently connecting them and optimizing paths to improve time, path length, and smoothness under a 30-second limit. The planner alternates extensions between the two trees using nearest neighbor searches and rewiring with a radius that shrinks logarithmically to balance exploration and exploitation. It incorporates goal bias sampling to guide growth toward the goal and performs path extraction upon connection, returning the best path found if time expires.",
          "planning_mechanism": "The planner initializes two trees and at each iteration samples a point with goal bias. It extends one tree toward the sample, rewires nearby nodes to optimize costs, then attempts to connect the other tree to the newly added node. The neighbor radius shrinks over time for finer rewiring. Collision checks for nodes and edges are performed strictly. When the trees connect, the joint path is extracted. The search halts if 30 seconds elapsed, providing the best path so far.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success = False\n        best_path = []\n        best_cost = math.inf\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def distance(a,b):\n            return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_dist):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_dist:\n                return to_pos\n            ratio = max_dist / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fpos, tpos, resolution=1.0):\n            dist = distance(fpos, tpos)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps+1):\n                inter = tuple(fpos[d] + (tpos[d]-fpos[d]) * (i/steps) for d in range(dim))\n                if is_in_obstacle(inter):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: distance(n.position, point))\n\n        def near(tree, point, radius):\n            return [n for n in tree if distance(n.position, point) <= radius]\n\n        def extract_path(node_a, node_b):\n            path_a = []\n            cur = node_a\n            while cur:\n                path_a.append(cur.position)\n                cur = cur.parent\n            path_b = []\n            cur = node_b\n            while cur:\n                path_b.append(cur.position)\n                cur = cur.parent\n            return path_a[::-1] + path_b\n\n        def update_best_path(node_a, node_b):\n            nonlocal best_cost, best_path, success\n            path = extract_path(node_a, node_b)\n            cost = node_a.cost + node_b.cost + distance(node_a.position, node_b.position)\n            if cost < best_cost:\n                best_cost = cost\n                best_path = path\n                success = True\n\n        def try_connect(t1, t2, new_node):\n            connect_node = nearest(t2, new_node.position)\n            dist = distance(new_node.position, connect_node.position)\n            if dist <= self.step_size and not is_edge_in_obstacle(new_node.position, connect_node.position):\n                update_best_path(new_node, connect_node)\n                return True\n            return False\n\n        def rewire(tree, new_node, neighbor_radius):\n            near_nodes = near(tree, new_node.position, neighbor_radius)\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, near_node.position)\n                if cost_through_new + 1e-10 < near_node.cost and not is_edge_in_obstacle(new_node.position, near_node.position):\n                    if (near_node.parent,new_node) not in edges:\n                        # Remove old edge\n                        old_edge = (near_node.parent, near_node)\n                        if old_edge in edges:\n                            edges.remove(old_edge)\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n        def choose_parent(tree, new_pos, near_nodes, nearest_node):\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost = near_node.cost + distance(near_node.position, new_pos)\n                if cost + 1e-10 < min_cost:\n                    if not is_edge_in_obstacle(near_node.position, new_pos):\n                        min_cost = cost\n                        best_parent = near_node\n            return best_parent, min_cost\n\n        # Logarithmically shrinking radius: gamma * (log(n)/n)^{1/d}\n        def neighbor_radius(n):\n            # gamma chosen as 30 * step_size empirically\n            gamma = 30.0 * self.step_size\n            r = gamma * ((math.log(max(n,2))/max(n,2))**(1/dim))\n            return max(r, self.step_size*1.1)  # Lower bound radius\n\n        # Progressively alternate trees to maintain balance\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Goal biasing 10%\n            if random.random() < 0.1:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if is_in_obstacle(sample):\n                continue\n\n            # Alternate tree extension\n            if i % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            near_nodes = near(tree_a, new_pos, neighbor_radius(len(tree_a)))\n            best_parent, min_cost = choose_parent(tree_a, new_pos, near_nodes, nearest_node)\n            new_node = Node(new_pos, best_parent, min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            rewire(tree_a, new_node, neighbor_radius(len(tree_a)))\n\n            # Try to connect the other tree\n            if try_connect(tree_a, tree_b, new_node):\n                # Return immediately on successful connection with best path found\n                return PlannerResult(True, best_path, nodes, edges)\n\n        # Timeout or max_iter reached; return best known path\n        return PlannerResult(success, best_path, nodes, edges)",
          "objective": -9.56469,
          "time_improvement": -12.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 635.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.059640908241271974,
                    "num_nodes_avg": 153.3,
                    "path_length_avg": 166.05377840818173,
                    "smoothness_avg": 0.041459720213323434,
                    "success_improvement": 0.0,
                    "time_improvement": -130.60594048453115,
                    "length_improvement": 8.983292763972708,
                    "smoothness_improvement": 548.9346525619546,
                    "objective_score": -31.047133224165943
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04015326499938965,
                    "num_nodes_avg": 301.1,
                    "path_length_avg": 230.68238717193293,
                    "smoothness_avg": 0.031820966671546595,
                    "success_improvement": 0.0,
                    "time_improvement": 75.56475003906536,
                    "length_improvement": 22.9915793376491,
                    "smoothness_improvement": 718.7763921747655,
                    "objective_score": 40.0582545751829
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03955848217010498,
                    "num_nodes_avg": 283.8,
                    "path_length_avg": 123.55329125489155,
                    "smoothness_avg": 0.058074694551369176,
                    "success_improvement": 0.0,
                    "time_improvement": 19.08114938503833,
                    "length_improvement": 17.941786923996816,
                    "smoothness_improvement": 638.705828065364,
                    "objective_score": 19.682946110236408
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional RRT* algorithm with adaptive goal-biased sampling, dynamic rewiring radius based on tree size, incremental collision checking, and consistent edge management. It interleaves expansions from start and goal trees, rewires neighbors for path improvement, and updates the best feasible path found within a 30-second time limit to optimize path smoothness, length, and planning efficiency. Early termination occurs upon finding a satisfactory path or timeout.",
          "planning_mechanism": "The planner grows two trees from start and goal by sampling with goal bias, extending towards samples with step size limits, and rewiring nearby nodes within an adaptively shrinking radius to optimize path cost and smoothness. After each expansion, it attempts to connect the trees and updates the best path found. The process repeats with swapped trees to balance exploration until a time limit or solution is reached.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List['Node'] = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=4.0, gamma_rrt_star: float=40.0, max_radius: float=50.0, goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        success = False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def near_nodes(tree: List[Node], position: Tuple[float, ...]) -> List[Node]:\n            n = max(1, len(tree))\n            scale = max(1.0, sum(bounds) / dim)\n            radius = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / dim))\n            radius = max(self.step_size * 2.0, min(self.max_radius, radius * 0.5 + scale * 0.02))\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def check_and_add_node(new_pos: Tuple[float, ...], tree: List[Node], other_tree: List[Node]) -> Node or None:\n            nearest_node = nearest(tree, new_pos)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in neighbors:\n                if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    c = nb.cost + dist(nb.position, new_pos)\n                    if c < min_cost:\n                        min_cost = c\n                        best_parent = nb\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            # Rewire neighbors\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    new_cost = new_node.cost + dist(new_node.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        new_node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((new_node, nb))\n            return new_node\n\n        def try_connect_trees(node_a: Node, tree_b: List[Node]) -> Node or None:\n            nearest_node_b = nearest(tree_b, node_a.position)\n            current_from = nearest_node_b\n            while True:\n                new_pos = steer(current_from.position, node_a.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current_from.position, new_pos, obstacles, is_3d):\n                    return None\n                neighbors = near_nodes(tree_b, new_pos)\n                min_cost = current_from.cost + dist(current_from.position, new_pos)\n                best_parent = current_from\n                for nb in neighbors:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        c = nb.cost + dist(nb.position, new_pos)\n                        if c < min_cost:\n                            min_cost = c\n                            best_parent = nb\n                new_node = Node(new_pos, parent=None, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                # Rewire neighbors\n                for nb in neighbors:\n                    if nb is best_parent:\n                        continue\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        new_cost = new_node.cost + dist(new_node.position, nb.position)\n                        if new_cost + 1e-12 < nb.cost:\n                            if nb.parent:\n                                try:\n                                    edges.remove((nb.parent, nb))\n                                except ValueError:\n                                    pass\n                                nb.parent.remove_child(nb)\n                            new_node.add_child(nb)\n                            nb.cost = new_cost\n                            edges.append((new_node, nb))\n                if dist(new_node.position, node_a.position) <= self.step_size:\n                    if (not self._is_edge_in_obstacle(new_node.position, node_a.position, obstacles, is_3d)\n                        and not self._is_in_obstacle(node_a.position, obstacles, is_3d)):\n                        final_node = Node(node_a.position, parent=None,\n                                         cost=new_node.cost + dist(new_node.position, node_a.position))\n                        new_node.add_child(final_node)\n                        tree_b.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current_from = new_node\n\n        def update_best_path(node_a: Node, node_b: Node):\n            nonlocal best_cost, best_path, success\n            c = node_a.cost + node_b.cost + dist(node_a.position, node_b.position)\n            if c < best_cost:\n                best_cost = c\n                path_a = node_a.path_from_root()\n                path_b = node_b.path_from_root()\n                if path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                best_path = path_a + path_b[::-1]\n                success = True\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                return PlannerResult(success, best_path, nodes, edges)\n\n            sample = sample_free()\n            new_node = check_and_add_node(sample, tree_a, tree_b)\n            if new_node is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n            connected_node = try_connect_trees(new_node, tree_b)\n            if connected_node is not None:\n                update_best_path(new_node, connected_node)\n                return PlannerResult(True, best_path, nodes, edges)\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success, best_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -5.03252,
          "time_improvement": 43.0,
          "length_improvement": -15.0,
          "smoothness_improvement": 228.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0237290620803833,
                    "num_nodes_avg": 119.0,
                    "path_length_avg": 208.92143850417187,
                    "smoothness_avg": 0.014699740823621665,
                    "success_improvement": 0.0,
                    "time_improvement": 8.249843283306912,
                    "length_improvement": -14.513151016182935,
                    "smoothness_improvement": 130.0828648877908,
                    "objective_score": -5.582523300278733
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009206151962280274,
                    "num_nodes_avg": 117.9,
                    "path_length_avg": 328.3614076921484,
                    "smoothness_avg": 0.015232898956729881,
                    "success_improvement": 0.0,
                    "time_improvement": 94.39760068377784,
                    "length_improvement": -9.61648924671473,
                    "smoothness_improvement": 291.95346197029437,
                    "objective_score": 24.009153966955985
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03624804019927978,
                    "num_nodes_avg": 177.5,
                    "path_length_avg": 181.66398396811618,
                    "smoothness_avg": 0.028406281638645288,
                    "success_improvement": 0.0,
                    "time_improvement": 25.852823741875575,
                    "length_improvement": -20.652568242297846,
                    "smoothness_improvement": 261.3258057099621,
                    "objective_score": -3.329064794266225
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a sampling-based path planning algorithm that incrementally builds a space-filling tree rooted at the start position by randomly sampling the configuration space and extending the nearest existing node toward the sample. It continues this process until the goal is reached or a maximum number of iterations is exceeded.",
          "planning_mechanism": "The planner randomly samples free configurations, finds the nearest node in the current tree, attempts to extend toward the sample by a fixed step size, and adds the new node if the move is valid. This repeats until the goal is reached or iteration limit is hit.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            unit = tuple(d / length for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, length) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_position))\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -3.527725190191713,
          "time_improvement": 11.0,
          "length_improvement": 0.0,
          "smoothness_improvement": 1.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027602267265319825,
                    "num_nodes_avg": 440.3,
                    "path_length_avg": 182.456236550706,
                    "smoothness_avg": 0.006392478687258005,
                    "success_improvement": 0.0,
                    "time_improvement": -6.7261882812788105,
                    "length_improvement": -0.007154457526746365,
                    "smoothness_improvement": 0.05617294523809996,
                    "objective_score": -2.0218682941735002
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.1811903238296509,
                    "num_nodes_avg": 1573.1,
                    "path_length_avg": 306.6918871377287,
                    "smoothness_avg": 0.0038348995818691597,
                    "success_improvement": 0.0,
                    "time_improvement": -10.263283778978199,
                    "length_improvement": -2.3825795630835094,
                    "smoothness_improvement": -1.3252715919853058,
                    "objective_score": -4.5151592295034915
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024657821655273436,
                    "num_nodes_avg": 553.4,
                    "path_length_avg": 144.96168668928667,
                    "smoothness_avg": 0.008142102523219058,
                    "success_improvement": 0.0,
                    "time_improvement": 49.56119452628273,
                    "length_improvement": 3.7233500347133996,
                    "smoothness_improvement": 3.566943107853563,
                    "objective_score": 17.12020309425213
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a simplified single-tree RRT planner with uniform random sampling and goal biasing to efficiently explore and find a collision-free path. It grows a tree by sampling free points biased towards the goal, extends the nearest node toward these samples in fixed step sizes while performing collision checks for nodes and edges, and returns the best path found within a 30-second time limit. Early termination occurs upon reaching the goal vicinity or time expiration. The approach balances simplicity with improved convergence speed and path feasibility.",
          "planning_mechanism": "The planner increments a single tree from the start node by randomly sampling points within map boundaries, occasionally biasing samples directly to the goal position. It finds the nearest existing node to each sample and attempts to extend toward the sample in a fixed step. Only collision-free nodes and edges are added. Once a node reaches sufficiently close to the goal, or time runs out, the planner reconstructs the path by tracing parents back to the start and returns it along with all explored nodes and edges.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        TIME_LIMIT = 30.0\n        start_time = time.monotonic()\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Sample with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            step_ratio = min(self.step_size / dist, 1.0)\n            new_pos = tuple(nearest_node.position[d] + direction[d] * step_ratio for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check goal proximity\n            if math.dist(new_pos, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_cost + math.dist(new_pos, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node is not None:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -0.59002,
          "time_improvement": 4.0,
          "length_improvement": -1.0,
          "smoothness_improvement": -1.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018040561676025392,
                    "num_nodes_avg": 311.8,
                    "path_length_avg": 183.53508519764716,
                    "smoothness_avg": 0.006329305929047844,
                    "success_improvement": 0.0,
                    "time_improvement": 30.244846786385928,
                    "length_improvement": -0.5984884963659995,
                    "smoothness_improvement": -0.9326179025910396,
                    "objective_score": 8.709697848583223
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.1657809019088745,
                    "num_nodes_avg": 1443.7,
                    "path_length_avg": 311.02144593126803,
                    "smoothness_avg": 0.0037945369181750094,
                    "success_improvement": 0.0,
                    "time_improvement": -0.8858875350264284,
                    "length_improvement": -3.8279109078070936,
                    "smoothness_improvement": -2.3638320008873523,
                    "objective_score": -2.5743319651966217
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05738208293914795,
                    "num_nodes_avg": 806.0,
                    "path_length_avg": 148.42759319646757,
                    "smoothness_avg": 0.007786332159702805,
                    "success_improvement": 0.0,
                    "time_improvement": -17.37791600197615,
                    "length_improvement": 1.4214599613763468,
                    "smoothness_improvement": -0.9584296558365674,
                    "objective_score": -4.365290972046219
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a simplified single-tree Rapidly-exploring Random Tree (RRT) planner with uniform random sampling and goal biasing. It incrementally grows a tree from the start by sampling random free points, extending the nearest node toward them by a fixed step size while performing necessary collision checks. The planner stops when the goal is reached or time expires, returning the best found path.",
          "planning_mechanism": "The planner uses a single tree rooted at start, samples points biased toward the goal, extends toward samples by limited step size if collision-free, records nodes and edges, and reconstructs the path upon reaching goal vicinity or timeout.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0  # seconds\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Goal biasing sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Compute direction and step\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            ratio = min(self.step_size / length, 1.0)\n            new_pos = tuple(nearest_node.position[d] + direction[d] * ratio for d in range(len(bounds)))\n\n            # Check collisions\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached\n            if math.dist(new_pos, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_pos, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        # Extract path if success\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 0.30165,
          "time_improvement": 1.0,
          "length_improvement": -1.0,
          "smoothness_improvement": -1.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.026476287841796876,
                    "num_nodes_avg": 409.9,
                    "path_length_avg": 185.31724552740917,
                    "smoothness_avg": 0.006286208741477205,
                    "success_improvement": 0.0,
                    "time_improvement": -2.372506360854019,
                    "length_improvement": -1.5753188132461502,
                    "smoothness_improvement": -1.6071824751122672,
                    "objective_score": -1.6649791085794572
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.21507534980773926,
                    "num_nodes_avg": 1716.2,
                    "path_length_avg": 304.8790407222185,
                    "smoothness_avg": 0.003826648371960445,
                    "success_improvement": 0.0,
                    "time_improvement": -30.88399992049096,
                    "length_improvement": -1.7773992496953286,
                    "smoothness_improvement": -1.5375811660428151,
                    "objective_score": -10.339327431794699
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.031033658981323244,
                    "num_nodes_avg": 510.8,
                    "path_length_avg": 150.20628867767402,
                    "smoothness_avg": 0.00785439436045736,
                    "success_improvement": 0.0,
                    "time_improvement": 36.51910090111794,
                    "length_improvement": 0.2401351151360828,
                    "smoothness_improvement": -0.0926834860676902,
                    "objective_score": 11.099347921986693
               }
          ],
          "success_rate": 1.0
     }
]