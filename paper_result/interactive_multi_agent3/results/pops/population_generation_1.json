[
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -26.388981117243627,
          "time_improvement": 63.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 183.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01468205451965332,
                    "num_nodes_avg": 73.3,
                    "path_length_avg": 170.0777299899863,
                    "smoothness_avg": 0.01815393444540405,
                    "success_improvement": 0.0,
                    "time_improvement": 43.23076072126553,
                    "length_improvement": 6.77770113839239,
                    "smoothness_improvement": 184.14849597019096,
                    "objective_score": 17.956591379266047
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03251075744628906,
                    "num_nodes_avg": 236.4,
                    "path_length_avg": 260.6786075049101,
                    "smoothness_avg": 0.010607444299952517,
                    "success_improvement": 0.0,
                    "time_improvement": 80.2155943076742,
                    "length_improvement": 12.977977597171186,
                    "smoothness_improvement": 172.93718207108697,
                    "objective_score": 32.7161507609604
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016566014289855956,
                    "num_nodes_avg": 149.1,
                    "path_length_avg": 131.24402594159469,
                    "smoothness_avg": 0.022953022539448645,
                    "success_improvement": 0.0,
                    "time_improvement": 66.11339055320946,
                    "length_improvement": 12.833967138520164,
                    "smoothness_improvement": 191.96075248589716,
                    "objective_score": 28.494201211504425
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -25.88903997320672,
          "time_improvement": 62.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 175.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012654733657836915,
                    "num_nodes_avg": 142.7,
                    "path_length_avg": 168.74937337871444,
                    "smoothness_avg": 0.01750117800517029,
                    "success_improvement": 0.0,
                    "time_improvement": 51.06954533721745,
                    "length_improvement": 7.505794446187998,
                    "smoothness_improvement": 173.93144019723505,
                    "objective_score": 20.693997469864208
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.020306038856506347,
                    "num_nodes_avg": 272.4,
                    "path_length_avg": 258.7447467197662,
                    "smoothness_avg": 0.010763143861376633,
                    "success_improvement": 0.0,
                    "time_improvement": 87.64276989224348,
                    "length_improvement": 13.623555990348581,
                    "smoothness_improvement": 176.94344393239058,
                    "objective_score": 35.351681781544144
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02561664581298828,
                    "num_nodes_avg": 265.8,
                    "path_length_avg": 134.34631990981856,
                    "smoothness_avg": 0.02165635834384294,
                    "success_improvement": 0.0,
                    "time_improvement": 47.59987183319978,
                    "length_improvement": 10.773571200189904,
                    "smoothness_improvement": 175.46727962758771,
                    "objective_score": 21.621440668211815
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A straightforward bidirectional RRT planner that grows two trees from start and goal by iteratively sampling free points and extending the nearest node from each tree towards the sample with a fixed step size; it alternates tree extensions, checks for collision-free connections between trees to find a complete path, and returns the best found path within a 30-second time limit.",
          "planning_mechanism": "The planner maintains two trees rooted at start and goal, samples collision-free points uniformly within map bounds, extends the nearest node in the active tree toward the sampled point, alternates trees each iteration, and tries to connect the opposite tree to the newly added node. Upon successful connection, it merges the two partial paths into a complete solution. Planning stops when the path is found or time limit expires, returning the current best path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        success = False\n        time_limit = 30.0\n        start_time = time.monotonic()\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def extend(tree, sample):\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def connect_trees(tree, node):\n            nearest_node = nearest(tree, node.position)\n            dist = math.dist(nearest_node.position, node.position)\n            if dist > self.step_size:\n                new_pos = steer(nearest_node.position, node.position)\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n                nearest_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n                # attempt direct connection if close\n                if math.dist(new_node.position, node.position) <= self.step_size:\n                    if not is_edge_in_obstacle(new_node.position, node.position):\n                        final_node = Node(node.position, parent=new_node, cost=new_node.cost + math.dist(new_node.position, node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                return None\n            else:\n                if is_in_obstacle(node.position) or is_edge_in_obstacle(nearest_node.position, node.position):\n                    return None\n                final_node = Node(node.position, parent=nearest_node, cost=nearest_node.cost + dist)\n                nearest_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_node, final_node))\n                return final_node\n\n        def sample_free():\n            while True:\n                if is_3d:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(2))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        tree_a = tree_start\n        tree_b = tree_goal\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            new_node = extend(tree_a, sample)\n            if new_node is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connected_node = connect_trees(tree_b, new_node)\n            if connected_node is not None:\n                success = True\n                path_a = new_node.path_from_root()\n                path_b = connected_node.path_from_root()\n                best_path = path_a + path_b[-2::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
          "objective": -24.61746,
          "time_improvement": 87.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.003728294372558594,
                    "num_nodes_avg": 84.9,
                    "path_length_avg": 180.87966860281307,
                    "smoothness_avg": 0.01103987851253821,
                    "success_improvement": 0.0,
                    "time_improvement": 85.58427670636823,
                    "length_improvement": 0.8569874170311926,
                    "smoothness_improvement": 72.7980722011218,
                    "objective_score": 26.553465823134793
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009920716285705566,
                    "num_nodes_avg": 246.6,
                    "path_length_avg": 301.0670492796362,
                    "smoothness_avg": 0.006705809145069515,
                    "success_improvement": 0.0,
                    "time_improvement": 93.96275291096713,
                    "length_improvement": -0.5048467840713801,
                    "smoothness_improvement": 72.54529930173578,
                    "objective_score": 28.248644299355988
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009735631942749023,
                    "num_nodes_avg": 234.2,
                    "path_length_avg": 163.86030235550345,
                    "smoothness_avg": 0.012918469003538813,
                    "success_improvement": 0.0,
                    "time_improvement": 80.08527871645923,
                    "length_improvement": -8.82821063541575,
                    "smoothness_improvement": 64.3219721828204,
                    "objective_score": 19.05026709460242
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT that grows two trees from start and goal by extending towards random samples within map bounds, with straightforward collision checking and edge validation. The trees alternately extend, and upon nearby connection attempts, the shortest feasible path joining both trees is extracted. This reduces complexity by avoiding local rewiring and ensures efficient early solution discovery with clear parent-child relationships.",
          "planning_mechanism": "The planner initializes two trees at start and goal. It samples free points uniformly, extends the nearest node of the active tree towards the sample with a fixed step size if collision-free, then tries to connect the other tree to this new node. Trees swap roles each iteration. If nodes connect successfully, the path is reconstructed by concatenating the two tree paths. Planning terminates upon reaching the goal or hitting a 30-second time limit, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        success_state = False\n        extracted_path = []\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connected_node = self._connect_tree(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if connected_node is not None:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = connected_node.path_from_root()\n                # avoid duplicate join node\n                extracted_path = path_a + path_b[-2::-1] \n                break\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n            else:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(2))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, sample_point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest_node.position, sample_point)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            return None\n        new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n        nearest_node.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((nearest_node, new_node))\n        return new_node\n\n    def _connect_tree(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, target_node.position)\n        dist = math.dist(nearest_node.position, target_node.position)\n        if dist > self.step_size:\n            new_pos = self._steer(nearest_node.position, target_node.position)\n            if (self._is_in_obstacle(new_pos, obstacles, is_3d) or \n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            if math.dist(new_node.position, target_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, target_node.position, obstacles, is_3d):\n                final_node = Node(target_node.position, parent=new_node, cost=new_node.cost + math.dist(new_node.position, target_node.position))\n                new_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((new_node, final_node))\n                return final_node\n            return None\n        else:\n            if (self._is_in_obstacle(target_node.position, obstacles, is_3d) or \n                self._is_edge_in_obstacle(nearest_node.position, target_node.position, obstacles, is_3d)):\n                return None\n            final_node = Node(target_node.position, parent=nearest_node, cost=nearest_node.cost + dist)\n            nearest_node.add_child(final_node)\n            tree.append(final_node)\n            nodes.append(final_node)\n            edges.append((nearest_node, final_node))\n            return final_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.81258,
          "time_improvement": 85.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 67.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.005401754379272461,
                    "num_nodes_avg": 114.2,
                    "path_length_avg": 191.91931169727346,
                    "smoothness_avg": 0.010422378140458174,
                    "success_improvement": 0.0,
                    "time_improvement": 79.11372100741177,
                    "length_improvement": -5.19401589738194,
                    "smoothness_improvement": 63.13285045454905,
                    "objective_score": 20.933371016067113
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009308695793151855,
                    "num_nodes_avg": 249.9,
                    "path_length_avg": 303.7405843856087,
                    "smoothness_avg": 0.0065543332961882795,
                    "success_improvement": 0.0,
                    "time_improvement": 94.33519768518391,
                    "length_improvement": -1.397349755886233,
                    "smoothness_improvement": 68.64771660637766,
                    "objective_score": 27.80538803505532
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009527850151062011,
                    "num_nodes_avg": 232.6,
                    "path_length_avg": 155.08847600410883,
                    "smoothness_avg": 0.013322467560618296,
                    "success_improvement": 0.0,
                    "time_improvement": 80.51030674685057,
                    "length_improvement": -3.002381242304039,
                    "smoothness_improvement": 69.46080400879985,
                    "objective_score": 22.69896729871675
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -23.251988789791394,
          "time_improvement": 88.0,
          "length_improvement": -6.0,
          "smoothness_improvement": 61.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.004858589172363282,
                    "num_nodes_avg": 96.9,
                    "path_length_avg": 195.62876654039616,
                    "smoothness_avg": 0.010095393324640415,
                    "success_improvement": 0.0,
                    "time_improvement": 81.2139090674435,
                    "length_improvement": -7.227226876970991,
                    "smoothness_improvement": 58.01482802810868,
                    "objective_score": 20.317910734190995
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009849953651428222,
                    "num_nodes_avg": 232.3,
                    "path_length_avg": 307.1548722605045,
                    "smoothness_avg": 0.0063714004239236776,
                    "success_improvement": 0.0,
                    "time_improvement": 94.00581547777178,
                    "length_improvement": -2.537137323353922,
                    "smoothness_improvement": 63.94072204178738,
                    "objective_score": 26.999165859528116
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.005633759498596192,
                    "num_nodes_avg": 141.3,
                    "path_length_avg": 161.6340659525489,
                    "smoothness_avg": 0.01267178640865572,
                    "success_improvement": 0.0,
                    "time_improvement": 88.47586362623284,
                    "length_improvement": -7.3496504185589835,
                    "smoothness_improvement": 61.18418778412257,
                    "objective_score": 22.438889775655074
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -19.463672592061652,
          "time_improvement": 78.0,
          "length_improvement": -7.0,
          "smoothness_improvement": 78.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008280038833618164,
                    "num_nodes_avg": 104.3,
                    "path_length_avg": 206.72066848824505,
                    "smoothness_avg": 0.011079765008698384,
                    "success_improvement": 0.0,
                    "time_improvement": 67.98462332681883,
                    "length_improvement": -13.30687409702089,
                    "smoothness_improvement": 73.42238248094127,
                    "objective_score": 12.77837445223782
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.013870835304260254,
                    "num_nodes_avg": 224.1,
                    "path_length_avg": 301.37655385959613,
                    "smoothness_avg": 0.007247119668786048,
                    "success_improvement": 0.0,
                    "time_improvement": 91.55890989607673,
                    "length_improvement": -0.60816832145739,
                    "smoothness_improvement": 86.47360896717294,
                    "objective_score": 27.535140020784446
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.012821125984191894,
                    "num_nodes_avg": 218.9,
                    "path_length_avg": 161.68779197151838,
                    "smoothness_avg": 0.013782767682665054,
                    "success_improvement": 0.0,
                    "time_improvement": 73.77374658185289,
                    "length_improvement": -7.385332682200414,
                    "smoothness_improvement": 75.31578758541383,
                    "objective_score": 18.077503303162686
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A hybrid planner integrating unidirectional RRT*-style asymptotically optimal sampling with local rewiring and a bidirectional RRT extension for faster initial solution discovery. The algorithm starts with bidirectional growing from start and goal to find a feasible path quickly and then switches to single-tree refined growth using informed sampling within a prolate ellipsoid that encloses the current best path. Local rewiring optimizes solution cost, and incremental KD-tree based neighbor searches speed up operations. Sampling and edge collision resolution adapt to progress, and a strict 30-second timeout guarantees timely return of the best path found.",
          "planning_mechanism": "The planner first grows two trees bidirectionally using RRT to quickly find a feasible path connecting start and goal. Once a path is found, sampling switches to a single tree extending from the start via informed sampling focused inside the ellipsoid defined by start, goal, and current best path length, performing rewiring within a radius to improve path cost continuously. The planner maintains and updates best solution dynamically and stops on timeout or when post-optimization criteria are met.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 post_opt_iters: int = 500,\n                 no_improve_limit: int = 150,\n                 improve_tol: float = 1e-6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        best_path = []\n        nodes = []\n        edges = []\n\n        # Bidirectional trees init\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_goal_node = None\n        best_cost = float(\"inf\")\n        c_min = math.dist(start, goal)\n\n        # For rewiring radius calculation\n        dim = len(bounds)\n\n        # For post-optimization single-tree phase\n        found_solution = False\n        elapsed_post_iters = 0\n        no_improve_count = 0\n\n        # For KD-tree acceleration of near queries\n        # Simple spatial index: store points for start_tree nodes\n        from bisect import bisect_left, insort\n\n        # Store positions separately for quick nearest search\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def nearest(node_list, point):\n            # Linear search for nearest - acceptable given moderate iteration budget\n            return min(node_list, key=lambda n: dist(n.position, point))\n\n        def near(node_list, point, radius):\n            return [n for n in node_list if dist(n.position, point) <= radius]\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            distance = dist(from_pos, to_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n\n        def sample_informed(c_best):\n            # Ellipsoidal informed sampling inside prolate hyperspheroid\n            if c_best == float(\"inf\"):\n                return sample_uniform()\n\n            import numpy as np\n\n            c_min_local = c_min\n            center = [(s + g) / 2 for s, g in zip(start, goal)]\n            a1 = [g - s for s, g in zip(start, goal)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-12:\n                return sample_uniform()\n            a1 = [x / norm_a1 for x in a1]\n\n            L = np.diag([c_best / 2] + [math.sqrt(c_best ** 2 - c_min_local ** 2) / 2] * (dim - 1))\n            x_center = np.array(center)\n\n            I = np.eye(dim)\n            M = np.outer(a1, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)])).dot(Vt)\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(x_ball)\n                if norm < 1e-12:\n                    continue\n                x_ball /= norm\n                r = random.random() ** (1.0 / dim)\n                x_ball *= r\n                rnd = C.dot(L.dot(x_ball)) + x_center\n                if all(0 <= rnd[d] <= bounds[d] for d in range(dim)):\n                    pt = tuple(float(x) for x in rnd)\n                    if not is_in_obstacle(pt):\n                        return pt\n\n        def connect_trees(tree_from, tree_to):\n            # Attempt to connect tree_to to tree_from with incremental steps\n            import math\n\n            nearest_to = nearest(tree_to, tree_from[-1].position)\n\n            current = nearest_to\n            while True:\n                new_pos = steer(current.position, tree_from[-1].position)\n                if is_in_obstacle(new_pos):\n                    return None\n                if is_edge_in_obstacle(current.position, new_pos) or is_edge_in_obstacle(new_pos, tree_from[-1].position):\n                    return None\n                new_node = Node(new_pos, parent=current)\n                new_node.cost = current.cost + dist(current.position, new_pos)\n                current.add_child(new_node)\n                tree_to.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n                if dist(new_node.position, tree_from[-1].position) <= self.step_size:\n                    # Final check\n                    if (not is_edge_in_obstacle(new_node.position, tree_from[-1].position)):\n                        final_node = Node(tree_from[-1].position, parent=new_node)\n                        final_node.cost = new_node.cost + dist(new_node.position, final_node.position)\n                        new_node.add_child(final_node)\n                        tree_to.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n\n        time_start = time.monotonic()\n        time_limit = 30.0\n\n        # Phase 1: Bidirectional RRT to find initial solution quickly\n        for iter_cnt in range(self.max_iter):\n            # Check time limit\n            if time.monotonic() - time_start > time_limit:\n                break\n\n            # Sample uniformly and extend tree_start\n            sample_point = sample_uniform()\n\n            # Extend tree_start\n            nearest_node_start = nearest(tree_start, sample_point)\n            new_pos_start = steer(nearest_node_start.position, sample_point)\n            if (not is_in_obstacle(new_pos_start)) and (not is_edge_in_obstacle(nearest_node_start.position, new_pos_start)):\n                new_node_start = Node(new_pos_start)\n                cost_val = nearest_node_start.cost + dist(nearest_node_start.position, new_pos_start)\n                new_node_start.cost = cost_val\n                nearest_node_start.add_child(new_node_start)\n                tree_start.append(new_node_start)\n                nodes.append(new_node_start)\n                edges.append((nearest_node_start, new_node_start))\n\n                # Try to connect tree_goal to new_node_start\n                nearest_node_goal = nearest(tree_goal, new_node_start.position)\n                new_pos_goal = steer(nearest_node_goal.position, new_node_start.position)\n                if (not is_in_obstacle(new_pos_goal)) and (not is_edge_in_obstacle(nearest_node_goal.position, new_pos_goal)):\n                    new_node_goal = Node(new_pos_goal, parent=nearest_node_goal)\n                    new_node_goal.cost = nearest_node_goal.cost + dist(nearest_node_goal.position, new_pos_goal)\n                    nearest_node_goal.add_child(new_node_goal)\n                    tree_goal.append(new_node_goal)\n                    nodes.append(new_node_goal)\n                    edges.append((nearest_node_goal, new_node_goal))\n\n                    # Check if connect directly\n                    if dist(new_node_goal.position, new_node_start.position) <= self.step_size:\n                        if not is_edge_in_obstacle(new_node_goal.position, new_node_start.position):\n                            # Connect and form path\n                            goal_connect_node = Node(new_node_start.position, parent=new_node_goal)\n                            goal_connect_node.cost = new_node_goal.cost + dist(new_node_goal.position, new_node_start.position)\n                            new_node_goal.add_child(goal_connect_node)\n                            tree_goal.append(goal_connect_node)\n                            nodes.append(goal_connect_node)\n                            edges.append((new_node_goal, goal_connect_node))\n\n                            path_start = new_node_start.path_from_root()\n                            path_goal = goal_connect_node.path_from_root()\n                            if path_goal:\n                                path_goal.reverse()\n                            full_path = path_start + path_goal[1:]\n                            path_cost = new_node_start.cost + (goal_connect_node.cost - new_node_goal.cost)\n\n                            if path_cost + self.improve_tol < best_cost:\n                                best_cost = path_cost\n                                best_goal_node = goal_connect_node\n                                best_path = full_path\n                                success = True\n                                found_solution = True\n                            break\n\n            # Also try growing goal tree towards sampled sample\n            sample_point = sample_uniform()\n            nearest_node_goal = nearest(tree_goal, sample_point)\n            new_pos_goal = steer(nearest_node_goal.position, sample_point)\n            if (not is_in_obstacle(new_pos_goal)) and (not is_edge_in_obstacle(nearest_node_goal.position, new_pos_goal)):\n                new_node_goal = Node(new_pos_goal)\n                cost_val = nearest_node_goal.cost + dist(nearest_node_goal.position, new_pos_goal)\n                new_node_goal.cost = cost_val\n                nearest_node_goal.add_child(new_node_goal)\n                tree_goal.append(new_node_goal)\n                nodes.append(new_node_goal)\n                edges.append((nearest_node_goal, new_node_goal))\n\n                # Try connect tree_start to new_node_goal\n                nearest_node_start = nearest(tree_start, new_node_goal.position)\n                new_pos_start = steer(nearest_node_start.position, new_node_goal.position)\n                if (not is_in_obstacle(new_pos_start)) and (not is_edge_in_obstacle(nearest_node_start.position, new_pos_start)):\n                    new_node_start = Node(new_pos_start, parent=nearest_node_start)\n                    new_node_start.cost = nearest_node_start.cost + dist(nearest_node_start.position, new_pos_start)\n                    nearest_node_start.add_child(new_node_start)\n                    tree_start.append(new_node_start)\n                    nodes.append(new_node_start)\n                    edges.append((nearest_node_start, new_node_start))\n\n                    if dist(new_node_start.position, new_node_goal.position) <= self.step_size:\n                        if not is_edge_in_obstacle(new_node_start.position, new_node_goal.position):\n                            goal_connect_node = Node(new_node_goal.position, parent=new_node_start)\n                            goal_connect_node.cost = new_node_start.cost + dist(new_node_start.position, new_node_goal.position)\n                            new_node_start.add_child(goal_connect_node)\n                            tree_start.append(goal_connect_node)\n                            nodes.append(goal_connect_node)\n                            edges.append((new_node_start, goal_connect_node))\n\n                            path_start = goal_connect_node.path_from_root()\n                            path_goal = new_node_goal.path_from_root()\n                            if path_goal:\n                                path_goal.reverse()\n                            full_path = path_start + path_goal[1:]\n                            path_cost = goal_connect_node.cost + (new_node_goal.cost)\n\n                            if path_cost + self.improve_tol < best_cost:\n                                best_cost = path_cost\n                                best_goal_node = goal_connect_node\n                                best_path = full_path\n                                success = True\n                                found_solution = True\n                            break\n\n            if found_solution:\n                break\n\n        # Phase 2: Single-tree informed RRT* rewiring refinement\n        if found_solution and best_goal_node:\n            # Use single tree from start plus goal_node appended\n            tree = [start_root] + [n for n in nodes if n not in (start_root, goal_root)] + [best_goal_node]\n            # Reset nodes and edges structures for refinement to keep consistency\n            nodes = [start_root]\n            edges = []\n            tree = [start_root]\n            start_root.children = []\n            start_root.cost = 0.0\n\n            # Insert initial best path nodes\n            previous_node = start_root\n            for p in best_path[1:]:\n                new_node = Node(p)\n                new_node.cost = previous_node.cost + dist(previous_node.position, p)\n                new_node.parent = previous_node\n                previous_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((previous_node, new_node))\n                previous_node = new_node\n\n            best_cost = new_node.cost\n            best_goal_node = new_node\n            success = True\n            extracted_path = best_goal_node.path_from_root()\n\n            c_min = math.dist(start, goal)\n\n            post_iter_count = 0\n            no_improve_streak = 0\n\n            for i in range(self.post_opt_iters):\n                if time.monotonic() - time_start > time_limit:\n                    break\n\n                # Informed sampling\n                x_rand = sample_informed(best_cost)\n\n                # Nearest and near neighbors search\n                x_nearest = nearest(tree, x_rand)\n                x_new_pos = steer(x_nearest.position, x_rand)\n                if is_in_obstacle(x_new_pos) or is_edge_in_obstacle(x_nearest.position, x_new_pos):\n                    no_improve_streak += 1\n                    post_iter_count += 1\n                    if no_improve_streak >= self.no_improve_limit:\n                        break\n                    continue\n\n                # Near nodes radius adaptive\n                gamma_rrt_star = 30.0  # a constant coefficient for radius\n                radius = min(gamma_rrt_star * ((math.log(len(tree) + 1) / (len(tree) + 1)) ** (1 / dim)), self.step_size * 20)\n                near_nodes = near(tree, x_new_pos, radius)\n\n                # Choose best parent\n                min_cost = x_nearest.cost + dist(x_nearest.position, x_new_pos)\n                best_parent = x_nearest\n                for n in near_nodes:\n                    new_cost = n.cost + dist(n.position, x_new_pos)\n                    if new_cost < min_cost and not is_edge_in_obstacle(n.position, x_new_pos):\n                        best_parent = n\n                        min_cost = new_cost\n\n                # Create new node and add to tree/refinement\n                x_new = Node(x_new_pos)\n                x_new.cost = min_cost\n                best_parent.add_child(x_new)\n                x_new.parent = best_parent\n                tree.append(x_new)\n                nodes.append(x_new)\n                edges.append((best_parent, x_new))\n\n                # Rewire neighbors if cheaper through x_new\n                for n in near_nodes:\n                    if n == best_parent:\n                        continue\n                    alt_cost = x_new.cost + dist(x_new.position, n.position)\n                    if alt_cost + 1e-12 < n.cost and not is_edge_in_obstacle(x_new.position, n.position):\n                        # Remove old edge n.parent -> n\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            n.parent.remove_child(n)\n                        n.parent = x_new\n                        n.cost = alt_cost\n                        x_new.add_child(n)\n                        edges.append((x_new, n))\n\n                # Check goal reach condition\n                if dist(x_new.position, goal) < self.step_size and not is_edge_in_obstacle(x_new.position, goal):\n                    new_goal_node = Node(goal)\n                    new_goal_node.cost = x_new.cost + dist(x_new.position, goal)\n                    x_new.add_child(new_goal_node)\n                    new_goal_node.parent = x_new\n                    nodes.append(new_goal_node)\n                    edges.append((x_new, new_goal_node))\n\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        extracted_path = best_goal_node.path_from_root()\n                        no_improve_streak = 0\n                        success = True\n                    else:\n                        no_improve_streak += 1\n\n                else:\n                    no_improve_streak += 1\n\n                post_iter_count += 1\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.no_improve_limit:\n                    break\n\n            if success and best_goal_node:\n                extracted_path = best_goal_node.path_from_root()\n            else:\n                extracted_path = best_path\n\n        else:\n            # No solution found in bidirectional phase: fail early\n            extracted_path = []\n            success = False\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -16.43239,
          "time_improvement": 51.0,
          "length_improvement": 1.0,
          "smoothness_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021007657051086426,
                    "num_nodes_avg": 166.7,
                    "path_length_avg": 178.57139078821234,
                    "smoothness_avg": 0.01089048020807648,
                    "success_improvement": 0.0,
                    "time_improvement": 18.772355175338323,
                    "length_improvement": 2.122191064216494,
                    "smoothness_improvement": 70.45966431268502,
                    "objective_score": 7.257319512694818
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03780534267425537,
                    "num_nodes_avg": 247.8,
                    "path_length_avg": 300.52119057497464,
                    "smoothness_avg": 0.006304153987544167,
                    "success_improvement": 0.0,
                    "time_improvement": 76.99357703244651,
                    "length_improvement": -0.32262343678369665,
                    "smoothness_improvement": 62.21042279809224,
                    "objective_score": 23.215551161654194
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02070934772491455,
                    "num_nodes_avg": 199.9,
                    "path_length_avg": 147.70638510285244,
                    "smoothness_avg": 0.014035244649167852,
                    "success_improvement": 0.0,
                    "time_improvement": 57.63799511620115,
                    "length_improvement": 1.900452036916589,
                    "smoothness_improvement": 78.52727596341828,
                    "objective_score": 18.824306136827385
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a sampling-based path planning algorithm that incrementally builds a space-filling tree rooted at the start position by randomly sampling the configuration space and extending the nearest existing node toward the sample. It continues this process until the goal is reached or a maximum number of iterations is exceeded.",
          "planning_mechanism": "The planner randomly samples free configurations, finds the nearest node in the current tree, attempts to extend toward the sample by a fixed step size, and adds the new node if the move is valid. This repeats until the goal is reached or iteration limit is hit.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            unit = tuple(d / length for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, length) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_position))\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -3.527725190191713,
          "time_improvement": 11.0,
          "length_improvement": 0.0,
          "smoothness_improvement": 1.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027602267265319825,
                    "num_nodes_avg": 440.3,
                    "path_length_avg": 182.456236550706,
                    "smoothness_avg": 0.006392478687258005,
                    "success_improvement": 0.0,
                    "time_improvement": -6.7261882812788105,
                    "length_improvement": -0.007154457526746365,
                    "smoothness_improvement": 0.05617294523809996,
                    "objective_score": -2.0218682941735002
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.1811903238296509,
                    "num_nodes_avg": 1573.1,
                    "path_length_avg": 306.6918871377287,
                    "smoothness_avg": 0.0038348995818691597,
                    "success_improvement": 0.0,
                    "time_improvement": -10.263283778978199,
                    "length_improvement": -2.3825795630835094,
                    "smoothness_improvement": -1.3252715919853058,
                    "objective_score": -4.5151592295034915
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024657821655273436,
                    "num_nodes_avg": 553.4,
                    "path_length_avg": 144.96168668928667,
                    "smoothness_avg": 0.008142102523219058,
                    "success_improvement": 0.0,
                    "time_improvement": 49.56119452628273,
                    "length_improvement": 3.7233500347133996,
                    "smoothness_improvement": 3.566943107853563,
                    "objective_score": 17.12020309425213
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a simplified single-tree Rapidly-exploring Random Tree (RRT) planner with uniform random sampling and goal biasing. It incrementally grows a tree from the start by sampling random free points, extending the nearest node toward them by a fixed step size while performing necessary collision checks. The planner stops when the goal is reached or time expires, returning the best found path.",
          "planning_mechanism": "The planner uses a single tree rooted at start, samples points biased toward the goal, extends toward samples by limited step size if collision-free, records nodes and edges, and reconstructs the path upon reaching goal vicinity or timeout.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0  # seconds\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Goal biasing sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Compute direction and step\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            ratio = min(self.step_size / length, 1.0)\n            new_pos = tuple(nearest_node.position[d] + direction[d] * ratio for d in range(len(bounds)))\n\n            # Check collisions\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached\n            if math.dist(new_pos, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_pos, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        # Extract path if success\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 0.30165,
          "time_improvement": 1.0,
          "length_improvement": -1.0,
          "smoothness_improvement": -1.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.026476287841796876,
                    "num_nodes_avg": 409.9,
                    "path_length_avg": 185.31724552740917,
                    "smoothness_avg": 0.006286208741477205,
                    "success_improvement": 0.0,
                    "time_improvement": -2.372506360854019,
                    "length_improvement": -1.5753188132461502,
                    "smoothness_improvement": -1.6071824751122672,
                    "objective_score": -1.6649791085794572
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.21507534980773926,
                    "num_nodes_avg": 1716.2,
                    "path_length_avg": 304.8790407222185,
                    "smoothness_avg": 0.003826648371960445,
                    "success_improvement": 0.0,
                    "time_improvement": -30.88399992049096,
                    "length_improvement": -1.7773992496953286,
                    "smoothness_improvement": -1.5375811660428151,
                    "objective_score": -10.339327431794699
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.031033658981323244,
                    "num_nodes_avg": 510.8,
                    "path_length_avg": 150.20628867767402,
                    "smoothness_avg": 0.00785439436045736,
                    "success_improvement": 0.0,
                    "time_improvement": 36.51910090111794,
                    "length_improvement": 0.2401351151360828,
                    "smoothness_improvement": -0.0926834860676902,
                    "objective_score": 11.099347921986693
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements an efficient and simplified single-tree sampling-based planner that balances exploration and exploitation with goal biasing. It incrementally builds a tree by sampling points in free space, extending the nearest tree node toward the sample within a fixed step size, and adding collision-free connections without expensive rewiring steps. The search terminates early upon reaching close vicinity of the goal, returning the shortest path found. This design reduces collision checks and bookkeeping overhead, improving planning speed while maintaining reasonable path quality and generality.",
          "planning_mechanism": "The planner samples random points biased towards the goal, grows a tree toward samples stepwise checking collisions, and constructs the path upon reaching the goal neighborhood without expensive rewiring or bidirectional tree management.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n        child.cost = self.cost + self._distance(child.position)\n\n    def _distance(self, other_pos):\n        dist = 0.0\n        for a, b in zip(self.position, other_pos):\n            dist += (a - b) ** 2\n        return dist ** 0.5\nclass Planner:\n    def __init__(self, max_iter: int = 3000, step_size: float=5.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> object:\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes = [Node(start_pos)]\n        edges = []\n        success = False\n        path = []\n\n        def dist(a,b):\n            s = 0.0\n            for x,y in zip(a,b):\n                s += (x - y) **2\n            return s**0.5\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i]-from_p[i]) * ratio for i in range(len(from_p)))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b):\n            length = dist(a,b)\n            steps = max(1,int(length))\n            for i in range(steps+1):\n                interp = tuple(a[j] + (b[j]-a[j]) * (i/steps) for j in range(len(a)))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest_node(sample):\n            return min(nodes, key=lambda n: dist(n.position, sample))\n\n        best_goal_node = None\n        best_goal_cost = float('inf')\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0,bounds[d]) for d in range(len(bounds)))\n                if in_obstacle(sample):\n                    continue\n\n            nearest = nearest_node(sample)\n            new_pos = steer(nearest.position, sample)\n\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            to_goal_dist = dist(new_pos, goal_pos)\n            if to_goal_dist <= self.step_size and not edge_in_obstacle(new_pos, goal_pos) and not in_obstacle(goal_pos):\n                goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + to_goal_dist)\n                new_node.add_child(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                success = True\n                best_goal_node = goal_node\n                break\n\n            # Track best node close to goal in case of timeout\n            if to_goal_dist < best_goal_cost:\n                best_goal_cost = to_goal_dist\n                best_goal_node = new_node\n\n        # Extract path from best goal node found if any\n        if success or best_goal_node:\n            node = best_goal_node\n            while node:\n                path.append(node.position)\n                node = node.parent\n            path.reverse()\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": 82.81658,
          "time_improvement": -274.0,
          "length_improvement": -2.0,
          "smoothness_improvement": 66.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.039451766014099124,
                    "num_nodes_avg": 294.1,
                    "path_length_avg": 189.99396487122107,
                    "smoothness_avg": 0.01024839331358877,
                    "success_improvement": 0.0,
                    "time_improvement": -52.54314318374572,
                    "length_improvement": -4.138702792949801,
                    "smoothness_improvement": 60.40961009994419,
                    "objective_score": -17.944116580393874
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.38731424808502196,
                    "num_nodes_avg": 1023.4,
                    "path_length_avg": 305.6137141288985,
                    "smoothness_avg": 0.006529629368358667,
                    "success_improvement": 0.0,
                    "time_improvement": -135.69989801658286,
                    "length_improvement": -2.022654379246621,
                    "smoothness_improvement": 68.01206674980172,
                    "objective_score": -41.58350169877382
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.35815632343292236,
                    "num_nodes_avg": 618.6,
                    "path_length_avg": 149.26608766170165,
                    "smoothness_avg": 0.013319633202289214,
                    "success_improvement": 0.0,
                    "time_improvement": -632.626643965992,
                    "length_improvement": 0.8645718623836519,
                    "smoothness_improvement": 69.42475118006452,
                    "objective_score": -188.92212631646706
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm with post-optimization: a bidirectional RRT*-Connect that, after finding a first feasible \u201cbest shot\u201d path, keeps optimizing for only a user-defined number of extra iterations (or until no further improvements occur), then terminates\u2014while maintaining strict collision checks and a 30 s time cap.",
          "planning_mechanism": "Mechanism: Alternate tree growth with RRT* best-parent selection and local rewiring; greedily connect the opposite tree; upon the first connection, record the best path and continue only N additional iterations (or until M consecutive non-improving attempts), always staying within bounds and validating node and edge collisions; stop early on time limit and return the best path so far.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from its tree root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        post_opt_iters: int = 400,   # extra iterations after first solution\n        max_no_improve: int = 150,   # early stop if no improvement for this many iterations\n        improve_tol: float = 1e-6,   # minimal cost drop to count as improvement\n        goal_sample_rate: float = 0.05,   # mild goal bias\n        bridge_bias_rate: float = 0.15,   # bias toward the opposite tree root\n        neighbor_gamma: float = 60.0,     # RRT* radius coefficient\n        time_limit_sec: float = 30.0      # hard wall time limit\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.goal_sample_rate = goal_sample_rate\n        self.bridge_bias_rate = bridge_bias_rate\n        self.neighbor_gamma = neighbor_gamma\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map: Map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Core data\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        # Initialize bidirectional trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root  = Node(goal_position,  cost=0.0)\n        tree_start: List[Node] = [start_root]\n        tree_goal:  List[Node] = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Practical RRT* neighborhood clamps\n        max_radius = max(bounds) * 0.30\n        min_radius = max(10.0, self.step_size * 2.0)\n\n        # Best solution tracking + post-optimization control\n        best_cost = float(\"inf\")\n        best_path: List[Tuple[float, ...]] = []\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        # Hard time limit\n        start_time = time.time()\n\n        # ----------------- Helper functions -----------------\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def clamp_bounds(p):\n            return tuple(min(max(p[d], 0.0), bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = math.dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return clamp_bounds(to_pos)\n            r = self.step_size / d\n            return clamp_bounds(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(dim)))\n\n        def nearest(tree, pt):\n            return min(tree, key=lambda n: math.dist(n.position, pt))\n\n        def neighbor_radius(n_nodes: int) -> float:\n            if n_nodes < 2:\n                return min_radius\n            r_theory = self.neighbor_gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(min_radius, min(max_radius, r_theory))\n\n        def near_nodes(tree, pos, radius):\n            return [nd for nd in tree if math.dist(nd.position, pos) <= radius]\n\n        def uniform_sample():\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def sample_free(active_tree, other_tree):\n            # Goal bias toward the global goal or start depending on active tree\n            if random.random() < self.goal_sample_rate:\n                return goal_position if active_tree is tree_start else start_position\n            # Bridge bias: sample around the opposite root to encourage meeting\n            if random.random() < self.bridge_bias_rate:\n                anchor = other_tree[0].position\n                jitter = tuple(random.uniform(-2.0*self.step_size, 2.0*self.step_size) for _ in range(dim))\n                s = clamp_bounds(tuple(anchor[i] + jitter[i] for i in range(dim)))\n                return s if not self._is_in_obstacle(s, obstacles, is_3d) else uniform_sample()\n            # Uniform fallback\n            return uniform_sample()\n\n        def add_with_best_parent(tree, new_pos):\n            \"\"\"Insert new_pos with RRT* best-parent selection; returns (new_node, neighbors) or (None, []).\"\"\"\n            r = neighbor_radius(len(tree))\n            neigh = near_nodes(tree, new_pos, r)\n            if not neigh:\n                parent = nearest(tree, new_pos)\n                if self._is_edge_in_obstacle(parent.position, new_pos, obstacles, is_3d):\n                    return None, []\n            else:\n                candidates = [nb for nb in neigh if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d)]\n                if not candidates:\n                    return None, []\n                parent = min(candidates, key=lambda nb: nb.cost + math.dist(nb.position, new_pos))\n\n            new_node = Node(new_pos, parent=None, cost=parent.cost + math.dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neigh\n\n        def rewire_from(pivot: Node, neigh: List[Node]):\n            \"\"\"Local RRT* rewiring around pivot (edge and cost validated).\"\"\"\n            for nb in neigh:\n                if nb is pivot:\n                    continue\n                if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                    continue\n                new_c = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_c + 1e-12 < nb.cost:\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_c\n                    edges.append((pivot, nb))\n\n        def stitch_paths(a_node: Node, b_node: Node, a_is_start_side: bool) -> List[Tuple[float, ...]]:\n            \"\"\"Combine root\u2192a_node and root\u2192b_node into a single start\u2192goal path.\"\"\"\n            pa = a_node.path_from_root()\n            pb = b_node.path_from_root()\n            if pa and pb and pa[-1] == pb[-1]:\n                merged = pa + pb[-2::-1]\n            else:\n                merged = pa + pb[::-1]\n            return merged if a_is_start_side else merged[::-1]\n\n        def path_cost(path: List[Tuple[float, ...]]) -> float:\n            return sum(math.dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        # ----------------- Main loop -----------------\n        for it in range(self.max_iter):\n            # Enforce 30s time limit (return best so far)\n            if time.time() - start_time > self.time_limit_sec:\n                return PlannerResult(\n                    success=(len(best_path) > 0),\n                    path=best_path if best_path else [],\n                    nodes=nodes,\n                    edges=edges\n                )\n\n            # Alternate trees\n            if it % 2 == 0:\n                grow_tree, other_tree = tree_start, tree_goal\n                a_is_start_side = True\n            else:\n                grow_tree, other_tree = tree_goal, tree_start\n                a_is_start_side = False\n\n            # Sampling\n            s = sample_free(grow_tree, other_tree)\n\n            # Extend grow_tree toward sample\n            a_near = nearest(grow_tree, s)\n            a_new_pos = steer(a_near.position, s)\n\n            # Node & edge validity\n            if not within_bounds(a_new_pos) or self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            if self._is_edge_in_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            a_new, a_neigh = add_with_best_parent(grow_tree, a_new_pos)\n            if a_new is None:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            rewire_from(a_new, a_neigh)\n\n            # Greedy connect the other tree toward a_new with stepwise rewiring\n            b_near = nearest(other_tree, a_new.position)\n            current = b_near\n            connected_b = None\n\n            while True:\n                step_pos = steer(current.position, a_new.position)\n                if not within_bounds(step_pos) or self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                    break\n\n                b_new, b_neigh = add_with_best_parent(other_tree, step_pos)\n                if b_new is None:\n                    break\n                rewire_from(b_new, b_neigh)\n                current = b_new\n\n                # Try to close the final short bridge exactly to a_new\n                if math.dist(current.position, a_new.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(current.position, a_new.position, obstacles, is_3d) and a_new.valid:\n                        final_b = Node(\n                            a_new.position,\n                            parent=None,\n                            cost=current.cost + math.dist(current.position, a_new.position)\n                        )\n                        current.add_child(final_b)\n                        other_tree.append(final_b)\n                        nodes.append(final_b)\n                        edges.append((current, final_b))\n                        connected_b = final_b\n                    break\n\n            # If a connection was made, evaluate candidate and manage post-optimization counters\n            if connected_b is not None:\n                candidate = stitch_paths(a_new, connected_b, a_is_start_side)\n                cand_cost = path_cost(candidate)\n\n                if cand_cost + self.improve_tol < best_cost:\n                    best_cost = cand_cost\n                    best_path = candidate\n                    success_state = True\n                    no_improve_streak = 0\n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0\n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                # No successful connection this iteration\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        extracted_path = best_path if success_state else []\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ----------------- Collision utilities -----------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": 89.28781390660136,
          "time_improvement": -342.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 413.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.15718557834625244,
                    "num_nodes_avg": 389.1,
                    "path_length_avg": 154.89223481632095,
                    "smoothness_avg": 0.03197099300654561,
                    "success_improvement": 0.0,
                    "time_improvement": -507.7695527121206,
                    "length_improvement": 15.101111672647985,
                    "smoothness_improvement": 400.4154666749561,
                    "objective_score": -141.26812147667263
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.14037203788757324,
                    "num_nodes_avg": 566.0,
                    "path_length_avg": 236.87983396021573,
                    "smoothness_avg": 0.01812719383918645,
                    "success_improvement": 0.0,
                    "time_improvement": 14.57666435442349,
                    "length_improvement": 20.922693216105248,
                    "smoothness_improvement": 366.4257539722425,
                    "objective_score": 18.758744005851412
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.30984885692596437,
                    "num_nodes_avg": 520.7,
                    "path_length_avg": 119.37721184940389,
                    "smoothness_avg": 0.04497077105349166,
                    "success_improvement": 0.0,
                    "time_improvement": -533.8113090131791,
                    "length_improvement": 20.715340021589817,
                    "smoothness_improvement": 472.0248884033823,
                    "objective_score": -145.3540642489829
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm with post-optimization limits: a two-tree, asymptotically optimal planner that, after finding a first feasible path, continues improving within the start\u2013goal ellipsoid for only a user-defined number of extra iterations (or until no improvement is observed), then stops.",
          "planning_mechanism": "Mechanism: Alternate expanding start/goal trees with RRT* best-parent selection and local rewiring; greedily connect the opposite tree; upon first connection, switch to informed (ellipsoidal) sampling and keep optimizing for N additional iterations (or until M consecutive non-improvements), always enforcing node and edge collision checks, bounds, and a strict 30 s time limit that returns the best path so far.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        neighbor_radius: float = 25.0,\n        post_opt_iters: int = 400,    # extra iterations after first solution\n        max_no_improve: int = 150,    # stop early if this many consecutive iterations show no improvement\n        improve_tol: float = 1e-6,    # minimal cost drop to count as improvement\n        time_limit_sec: float = 30.0  # hard wall time limit\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map: Map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks / boxes\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Core data\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        # Initialize two trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root  = Node(goal_position,  cost=0.0)\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # RRT* neighborhood (practical clamp)\n        gamma_rrt_star = 60.0\n        max_radius = max(bounds) * 0.30\n        min_radius = max(10.0, self.step_size * 2.0)\n\n        # Best solution & informed sampling params\n        best_cost = float(\"inf\")\n        best_path: List[Tuple[float, ...]] = []\n        c_min = math.dist(start_position, goal_position)\n\n        # Post-optimization control\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        # Time guard\n        start_time = time.time()\n\n        # ---------- Helpers ----------\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def nearest(tree, pt):\n            return min(tree, key=lambda n: math.dist(n.position, pt))\n\n        def steer(from_pos, to_pos):\n            d = math.dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            r = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(dim))\n\n        def neighbor_radius_fn(n_nodes: int) -> float:\n            if n_nodes < 2:\n                return min_radius\n            r_theory = gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(min_radius, min(max_radius, r_theory))\n\n        def near_nodes(tree, pos, radius):\n            return [nd for nd in tree if math.dist(nd.position, pos) <= radius]\n\n        def add_with_best_parent(tree, new_pos):\n            \"\"\"Insert new_pos using RRT* best-parent selection; return (new_node, neighbors) or (None, []).\"\"\"\n            r = neighbor_radius_fn(len(tree))\n            neigh = near_nodes(tree, new_pos, r)\n            parent_candidates = neigh if neigh else [nearest(tree, new_pos)]\n            parent_candidates = [nb for nb in parent_candidates\n                                 if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d)]\n            if not parent_candidates:\n                return None, []\n            parent = min(parent_candidates, key=lambda nb: nb.cost + math.dist(nb.position, new_pos))\n            new_node = Node(new_pos, parent=None, cost=parent.cost + math.dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neigh\n\n        def rewire_from(pivot: Node, neigh: List[Node]):\n            for nb in neigh:\n                if nb is pivot:\n                    continue\n                if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                    continue\n                new_c = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_c + 1e-12 < nb.cost:\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_c\n                    edges.append((pivot, nb))\n\n        def stitch_paths(meet_a: Node, meet_b: Node, a_is_start_side: bool) -> List[Tuple[float, ...]]:\n            \"\"\"Create full path from start to goal using meeting nodes from both trees.\"\"\"\n            path_a = meet_a.path_from_root()\n            path_b = meet_b.path_from_root()\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start_side else merged[::-1]\n\n        def path_cost(path):\n            return sum(math.dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        # ---------- Main loop ----------\n        for it in range(self.max_iter):\n            # Hard time limit\n            if time.time() - start_time > self.time_limit_sec:\n                return PlannerResult(\n                    success=(len(best_path) > 0),\n                    path=best_path if best_path else [],\n                    nodes=nodes,\n                    edges=edges\n                )\n\n            # Choose expansion/connection sides\n            if it % 2 == 0:\n                grow_tree, other_tree = tree_a, tree_b\n                a_is_start_side = True\n            else:\n                grow_tree, other_tree = tree_b, tree_a\n                a_is_start_side = False\n\n            # Informed sampling (uniform before first solution; ellipsoid after)\n            sample = self._sample_informed(start_position, goal_position, best_cost, c_min, bounds)\n\n            # Extend grow_tree toward sample\n            a_near = nearest(grow_tree, sample)\n            a_new_pos = steer(a_near.position, sample)\n\n            if (not within_bounds(a_new_pos)) or self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                # count post-optimization iterations if already in post phase\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            if self._is_edge_in_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            a_new, a_neigh = add_with_best_parent(grow_tree, a_new_pos)\n            if a_new is None:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            rewire_from(a_new, a_neigh)\n\n            # Greedy connect other_tree toward a_new, with local rewiring each step\n            b_near = nearest(other_tree, a_new.position)\n            current = b_near\n            connected_b = None\n\n            while True:\n                step_pos = steer(current.position, a_new.position)\n                if (not within_bounds(step_pos)) or self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                    break\n\n                b_new, b_neigh = add_with_best_parent(other_tree, step_pos)\n                if b_new is None:\n                    break\n                rewire_from(b_new, b_neigh)\n                current = b_new\n\n                # Try a final short bridge\n                if math.dist(current.position, a_new.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(current.position, a_new.position, obstacles, is_3d) and a_new.valid:\n                        final_b = Node(\n                            a_new.position,\n                            parent=None,\n                            cost=current.cost + math.dist(current.position, a_new.position)\n                        )\n                        current.add_child(final_b)\n                        other_tree.append(final_b)\n                        nodes.append(final_b)\n                        edges.append((current, final_b))\n                        connected_b = final_b\n                    break\n\n            # If a connection was made, evaluate and manage post-optimization counters\n            if connected_b is not None:\n                candidate_path = stitch_paths(a_new, connected_b, a_is_start_side)\n                cand_cost = path_cost(candidate_path)\n\n                if cand_cost + self.improve_tol < best_cost:\n                    best_cost = cand_cost\n                    best_path = candidate_path\n                    success_state = True\n                    no_improve_streak = 0\n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0\n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                # No successful connection this iteration\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        extracted_path = best_path if success_state else []\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ---------------- Informed Sampling ----------------\n    def _sample_informed(self, start, goal, c_best, c_min, bounds):\n        \"\"\"Uniform in bounds if no solution; otherwise sample within the start\u2013goal ellipsoid.\"\"\"\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_min <= 1e-12:\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        # Ellipsoid radii\n        r1 = c_best / 2.0\n        r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n        r_other = math.sqrt(r_other_sq) / 2.0\n\n        # Center and first axis (unit)\n        center = tuple((s + g) / 2.0 for s, g in zip(start, goal))\n        a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n        # Orthonormal basis aligned with a1\n        if dim == 2:\n            a2 = (-a1[1], a1[0])\n            basis = (a1, a2)\n            radii = (r1, r_other)\n        else:  # 3D\n            ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = self._normalize(self._cross(a1, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._normalize(self._cross(a1, ref))\n            b3 = self._cross(a1, b2)\n            basis = (a1, b2, b3)\n            radii = (r1, r_other, r_other)\n\n        u = self._sample_unit_ball(dim)\n\n        mapped = []\n        for d in range(dim):\n            val = center[d]\n            for i in range(dim):\n                val += basis[i][d] * radii[i] * u[i]\n            mapped.append(val)\n\n        mapped = tuple(min(max(mapped[d], 0.0), bounds[d]) for d in range(dim))\n        return mapped\n\n    def _sample_unit_ball(self, dim):\n        while True:\n            v = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(x * x for x in v))\n            if n > 1e-12:\n                v = [x / n for x in v]\n                r = random.random() ** (1.0 / dim)\n                return tuple(v[i] * r for i in range(dim))\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)\n\n    # ---------------- Collision Utilities ----------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": 94.46501384019821,
          "time_improvement": -357.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 381.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.17895090579986572,
                    "num_nodes_avg": 390.9,
                    "path_length_avg": 154.3341717065196,
                    "smoothness_avg": 0.0324802231560264,
                    "success_improvement": 0.0,
                    "time_improvement": -591.9267856484383,
                    "length_improvement": 15.406994906205968,
                    "smoothness_improvement": 408.3860243252992,
                    "objective_score": -166.29190862918142
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.1308678150177002,
                    "num_nodes_avg": 530.1,
                    "path_length_avg": 241.79770645922855,
                    "smoothness_avg": 0.017602450907547296,
                    "success_improvement": 0.0,
                    "time_improvement": 20.36045457704448,
                    "length_improvement": 19.28096582282351,
                    "smoothness_improvement": 352.92374038411054,
                    "objective_score": 19.441334568728003
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.29314379692077636,
                    "num_nodes_avg": 662.7,
                    "path_length_avg": 121.84507406198945,
                    "smoothness_avg": 0.0377648866823677,
                    "success_improvement": 0.0,
                    "time_improvement": -499.6402746124881,
                    "length_improvement": 19.07630344696077,
                    "smoothness_improvement": 380.3665710857427,
                    "objective_score": -136.54446746014122
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is an optimal variant of RRT that improves path quality over time by rewiring the tree to minimize path cost. It incrementally builds a space-filling tree from start toward the goal while performing local optimizations by choosing better parents and rewiring nearby nodes.",
          "planning_mechanism": "The planner samples a point, extends the nearest node toward it, finds nearby nodes within a radius, selects the node offering the lowest-cost path as the parent, and rewires suboptimal neighbors to the new node if a shorter path through it is possible and valid.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 101.41304104437963,
          "time_improvement": -382.0,
          "length_improvement": 21.0,
          "smoothness_improvement": 162.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.053715181350708005,
                    "num_nodes_avg": 392.3,
                    "path_length_avg": 156.78696373131942,
                    "smoothness_avg": 0.014175465593175774,
                    "success_improvement": 0.0,
                    "time_improvement": -107.69368339540542,
                    "length_improvement": 14.06258073043635,
                    "smoothness_improvement": 121.87681904942768,
                    "objective_score": -23.261172485112677
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.6489359378814697,
                    "num_nodes_avg": 1631.8,
                    "path_length_avg": 223.49530047136864,
                    "smoothness_avg": 0.01104232999729937,
                    "success_improvement": 0.0,
                    "time_improvement": -294.9096505852839,
                    "length_improvement": 25.390835747117986,
                    "smoothness_improvement": 184.1271042993282,
                    "objective_score": -72.31775820581774
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.4124786376953125,
                    "num_nodes_avg": 964.4,
                    "path_length_avg": 116.51624222188256,
                    "smoothness_avg": 0.021921931756047137,
                    "success_improvement": 0.0,
                    "time_improvement": -743.7456503514102,
                    "length_improvement": 22.615459823455673,
                    "smoothness_improvement": 178.84535382823486,
                    "objective_score": -208.66019244220848
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm with post-optimization: a single-tree, asymptotically optimal sampler that, after the first feasible path, restricts sampling to a start\u2013goal prolate hyperspheroid to accelerate convergence while continuing local rewiring to reduce path cost.",
          "planning_mechanism": "Mechanism: (1) Grow one tree from the start using uniform sampling; (2) when a goal-connecting edge is found, record the best cost and switch to informed sampling inside the ellipsoid defined by start, goal, and current best path length; (3) for each sample, steer a step from the nearest node, then select the lowest-cost parent among nearby nodes and rewire neighbors if the new node offers cheaper paths; (4) whenever the new node lies within one step of the goal and the edge is collision-free, connect and update the best path; (5) after the first solution, continue only a limited number of additional iterations or until no further improvements occur; (6) every candidate node and edge is validated against obstacle occupancy and line-segment collisions, and results include the best path found within the iteration budget.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 post_opt_iters: int = 500, max_no_improve: int = 150,\n                 improve_tol: float = 1e-6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start)\n        goal_node = Node(goal)\n        nodes.append(root)\n        tree = [root]\n\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        c_min = math.dist(start, goal)\n\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        for _ in range(self.max_iter):\n            x_rand = self._sample(start, goal, best_cost, c_min, is_3d, bounds)\n\n            x_nearest = min(tree, key=lambda n: math.dist(n.position, x_rand))\n            x_new_pos = self._steer(x_nearest.position, x_rand)\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            x_new = Node(x_new_pos)\n            near_nodes = [n for n in tree if math.dist(n.position, x_new_pos) <= 20.0]\n\n            min_cost = x_nearest.cost + math.dist(x_nearest.position, x_new_pos)\n            best_parent = x_nearest\n            for n in near_nodes:\n                new_cost = n.cost + math.dist(n.position, x_new_pos)\n                if new_cost < min_cost and not self._is_edge_in_obstacle(n.position, x_new_pos, obstacles, is_3d):\n                    best_parent = n\n                    min_cost = new_cost\n\n            best_parent.add_child(x_new)\n            x_new.cost = min_cost\n            x_new.parent = best_parent\n            tree.append(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            for n in near_nodes:\n                alt_cost = x_new.cost + math.dist(x_new.position, n.position)\n                if alt_cost + 1e-12 < n.cost and not self._is_edge_in_obstacle(x_new.position, n.position, obstacles, is_3d):\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                        if n in n.parent.children:\n                            n.parent.children.remove(n)\n                    n.parent = x_new\n                    n.cost = alt_cost\n                    x_new.add_child(n)\n                    edges.append((x_new, n))\n\n            if math.dist(x_new.position, goal) < self.step_size and                not self._is_edge_in_obstacle(x_new.position, goal, obstacles, is_3d):\n                # \uc0c8 \ud574 \ud6c4\ubcf4\n                goal_node = Node(goal)  # \ubaa9\ud45c \ub178\ub4dc\ub294 \uc0c8\ub85c \ub9cc\ub4e4\uc5b4 \uba85\ud655\ud788 \uc5f0\uacb0\n                goal_node.parent = x_new\n                goal_node.cost = x_new.cost + math.dist(x_new.position, goal)\n                nodes.append(goal_node)\n                edges.append((x_new, goal_node))\n\n                if goal_node.cost + self.improve_tol < best_cost:\n                    best_cost = goal_node.cost\n                    best_goal_node = goal_node\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    no_improve_streak = 0  \n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0  \n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        if success_state and best_goal_node is not None:\n            extracted_path = best_goal_node.path_from_root()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample(self, start, goal, c_best, c_min, is_3d, bounds):\n        import numpy as np\n        import math, random\n\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        dim = len(start)\n        L = np.diag([c_best / 2] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim - 1))\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        a1 = a1 / np.linalg.norm(a1)\n        I = np.eye(dim)\n        M = np.outer(a1, I[:, 0])\n        U, _, Vt = np.linalg.svd(M)\n        C = np.dot(U, np.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]), Vt))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm = np.linalg.norm(x_ball)\n            if norm > 1e-6:\n                x_ball = x_ball / norm * random.random() ** (1.0 / dim)\n            x_rand = np.dot(C, np.dot(L, x_ball)) + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * self.step_size / dist for d in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    \n",
          "objective": 224.3832782257713,
          "time_improvement": -799.0,
          "length_improvement": 22.0,
          "smoothness_improvement": 404.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.3754814386367798,
                    "num_nodes_avg": 775.0,
                    "path_length_avg": 152.76474624495216,
                    "smoothness_avg": 0.028193707753155117,
                    "success_improvement": 0.0,
                    "time_improvement": -1351.8264869648585,
                    "length_improvement": 16.267221870828973,
                    "smoothness_improvement": 341.2927499531815,
                    "objective_score": -394.0811492171942
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.8624645709991455,
                    "num_nodes_avg": 1327.7,
                    "path_length_avg": 221.10105167112638,
                    "smoothness_avg": 0.021675924151594382,
                    "success_improvement": 0.0,
                    "time_improvement": -424.8523968134282,
                    "length_improvement": 26.190104911269486,
                    "smoothness_improvement": 457.73714095762637,
                    "objective_score": -109.45297039247863
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.35188817977905273,
                    "num_nodes_avg": 812.9,
                    "path_length_avg": 114.77233485559756,
                    "smoothness_avg": 0.040275860031244254,
                    "success_improvement": 0.0,
                    "time_improvement": -619.8048431249096,
                    "length_improvement": 23.773680060197126,
                    "smoothness_improvement": 412.3059667426792,
                    "objective_score": -169.6157150676412
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner that balances fast exploration and path quality by adaptive rewiring radius, dynamically adjusted step size, goal biasing sampling, and incremental connection attempts of trees with early termination upon path success or timeout. It uses KD-tree based nearest and near neighbor searches for scalability and a shortcut smoothing post-processing step to reduce path length and improve smoothness.",
          "planning_mechanism": "The planner grows two trees from start and goal positions, sampling points with a goal bias. Each tree is extended towards sampled points with adaptive step size, rewired locally using nodes within a dynamically computed radius to optimize costs, and the two trees attempt to connect after every addition. The algorithm returns the best path found either upon reaching goal or after a 30-second runtime limit, applying shortcut smoothing as a final refinement.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 7.0,\n                 goal_sample_rate: float = 0.1,  # 10% goal bias\n                 gamma_rrt_star: float = 50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star  # Used for radius computation\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = [start_tree[0], goal_tree[0]]\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        # KD-tree-like helper structures for near neighbor queries\n        # For simplicity, use naive searches (could be improved with spatial structures)\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n\n        def steer(from_pos, to_pos, max_length):\n            distance = dist(from_pos, to_pos)\n            if distance <= max_length:\n                return to_pos\n            ratio = max_length / distance\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dimension))\n\n        def is_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d) and self._within_bounds(pos, bounds)\n\n        def is_free_edge(fr, to):\n            return not self._is_edge_in_obstacle(fr, to, obstacles, is_3d, resolution=0.5)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def path_cost(node):\n            return node.cost\n\n        # Radius for rewiring based on RRT* theoretical bound\n        def rewiring_radius(n):\n            unit_ball_volume = math.pi if dimension == 2 else 4/3*math.pi\n            r = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1/dimension))\n            return max(min(r, self.step_size*10), self.step_size)\n\n        # Extract path by following parents\n        def extract_path(node_start_tree, node_goal_tree):\n            path_from_start = []\n            n = node_start_tree\n            while n:\n                path_from_start.append(n.position)\n                n = n.parent\n            path_from_start.reverse()\n            path_from_goal = []\n            n = node_goal_tree\n            while n:\n                path_from_goal.append(n.position)\n                n = n.parent\n            # Remove duplicate middle node\n            if path_from_start[-1] == path_from_goal[0]:\n                path_from_goal = path_from_goal[1:]\n            return path_from_start + path_from_goal\n\n        def shortcut_smooth(path, max_iters=200):\n            if len(path) < 3:\n                return path\n            for _ in range(max_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not is_free_edge(path[i], path[j]):\n                    continue\n                # Remove intermediate nodes between i and j\n                path = path[:i+1] + path[j:]\n            return path\n\n        start_time = time.monotonic()\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        # Maintain sets for bookkeeping\n        def add_node(tree, new_node):\n            tree.append(new_node)\n            all_nodes.append(new_node)\n\n        # Attempt connection between two trees, return connecting nodes if connected\n        def try_connect(t1, t2):\n            node1 = t1[-1]\n            close_nodes = near(t2, node1.position, self.step_size*1.5)\n            for n2 in close_nodes:\n                if is_free_edge(node1.position, n2.position):\n                    return node1, n2\n            return None\n\n        for it in range(self.max_iter):\n            if (time.monotonic() - start_time) > 30:\n                break\n\n            sample = sample_point()\n\n            # Alternate expanding start_tree then goal_tree each iteration\n            expanding_trees = [start_tree, goal_tree] if (it % 2 == 0) else [goal_tree, start_tree]\n\n            for tree_a, tree_b in [expanding_trees]:\n                # Select nearest node and steer\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if not is_free_node(new_pos):\n                    continue\n                if not is_free_edge(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                radius = rewiring_radius(len(all_nodes))\n\n                # Find near neighbors in the same tree for rewiring\n                near_nodes = near(tree_a, new_node.position, radius)\n\n                # Choose best parent minimizing cost + edge cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_node.position)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    if near_node == nearest_node:\n                        continue\n                    if not is_free_edge(near_node.position, new_node.position):\n                        continue\n                    cost = near_node.cost + dist(near_node.position, new_node.position)\n                    if cost < min_cost:\n                        best_parent = near_node\n                        min_cost = cost\n\n                new_node.parent = best_parent\n                new_node.cost = min_cost\n                best_parent.add_child(new_node)\n\n                add_node(tree_a, new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors to new_node if cheaper\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    if not is_free_edge(new_node.position, near_node.position):\n                        continue\n                    cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                    if cost_through_new < near_node.cost:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n                # Attempt connection between trees\n                connection = try_connect(tree_a, tree_b)\n                if connection is not None:\n                    n_start, n_goal = connection\n                    path = extract_path(n_start, n_goal)\n                    cost_path = 0.0\n                    for k in range(len(path) - 1):\n                        cost_path += dist(path[k], path[k+1])\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = path\n                        success = True\n                        # Early stop if found good path\n                        if best_cost <= dist(start_pos, goal_pos) * 1.1:\n                            break\n\n            if success and (time.monotonic() - start_time) > 0.5:\n                # After some time with success, break early to return result\n                break\n\n        # Apply shortcut smoothing on best path if found\n        if best_path:\n            best_path = shortcut_smooth(best_path, max_iters=300)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))",
          "objective": 335.05473,
          "time_improvement": -1071.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1469.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.5458454370498658,
                    "num_nodes_avg": 769.7,
                    "path_length_avg": 154.34017059828255,
                    "smoothness_avg": 0.04368913431155918,
                    "success_improvement": 0.0,
                    "time_improvement": -2010.5513662008188,
                    "length_improvement": 15.403706818572177,
                    "smoothness_improvement": 583.8298244495452,
                    "objective_score": -591.0040366468546
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.5389305353164673,
                    "num_nodes_avg": 903.5,
                    "path_length_avg": 229.20190036403415,
                    "smoothness_avg": 0.09301031161700887,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -227.96591615248155,
                    "length_improvement": 23.485808447575714,
                    "smoothness_improvement": 2293.222310525234,
                    "objective_score": -92.83217822457286
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.5249299049377442,
                    "num_nodes_avg": 895.9,
                    "path_length_avg": 117.56171850798998,
                    "smoothness_avg": 0.12815253476030247,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -973.7703327020907,
                    "length_improvement": 21.92110425445407,
                    "smoothness_improvement": 1530.090782914892,
                    "objective_score": -321.3279833433803
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "m1",
          "algorithm_description": "An enhanced bidirectional RRT* planner that combines fast initial solution discovery via bidirectional RRT* tree growth with adaptive informed sampling and local rewiring for path cost improvement. The planner uses KD-tree-like spatial indexing for efficient neighbor search, adaptive radius for near neighbor connections, and incremental pruning to reduce search space dynamically. The algorithm enforces strict collision checks on nodes and edges and respects map boundaries. It stops after a 30-second timeout or when no significant improvement is observed. This approach targets better balance between computational efficiency, path length optimality, and path smoothness by combining multi-phase sampling and rewiring while pruning redundant nodes.",
          "planning_mechanism": "A bidirectional RRT* extension with adaptive sampling and informed-region pruning. It grows two trees simultaneously from start and goal with asymptotically optimal rewiring, attempts connection when nodes are close, and after a connection is found, switches to focused informed sampling inside a prolate ellipsoid around the best path to refine solution cost and smoothness. Adaptive radius search accelerates local rewiring, and continuous pruning removes suboptimal branches. The planner returns the best found path when time limit or convergence criteria are met.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, post_opt_iters: int=1500, no_improve_limit: int=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit  # number of iterations allowed without improvements\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a,b)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            length = dist(a,b)\n            steps = max(1, int(length/resolution))\n            for i in range(steps+1):\n                t = i/steps\n                p = tuple(a[d] + (b[d]-a[d])*t for d in range(dim))\n                if is_in_obstacle(p):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i]-from_p[i]) * ratio for i in range(dim))\n\n        # Efficient nearest and near queries via spatial indexing (grid-based)\n        # Grid size proportional to step_size for near neighbor searches\n        grid_cell_size = self.step_size * 2.0\n\n        def grid_key(pos):\n            return tuple(int(pos[d]//grid_cell_size) for d in range(dim))\n\n        # Maintain spatial hash tables for quick near queries for both trees\n        def add_node_to_grid(node, grid):\n            key = grid_key(node.position)\n            if key not in grid:\n                grid[key] = []\n            grid[key].append(node)\n\n        def get_near_nodes(grid, point, radius):\n            keys = []\n            base_key = grid_key(point)\n            radius_cells = int(math.ceil(radius/grid_cell_size))\n            for offset in self._grid_offsets(dim, radius_cells):\n                k = tuple(base_key[d]+offset[d] for d in range(dim))\n                keys.append(k)\n            near_nodes = []\n            r2 = radius*radius\n            for k in keys:\n                if k in grid:\n                    for node in grid[k]:\n                        if dist(node.position, point) <= radius:\n                            near_nodes.append(node)\n            return near_nodes\n\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n\n        def sample_informed(c_best, c_min, start, goal):\n            # prolate hyperspheroid sampling around current best path\n            if c_best == float(\"inf\"):\n                return sample_uniform()\n            import numpy as np\n            center = tuple((start[d]+goal[d])/2 for d in range(dim))\n            a1 = tuple(goal[d] - start[d] for d in range(dim))\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-12:\n                return sample_uniform()\n            a1 = tuple(x/norm_a1 for x in a1)\n            # rotation matrix: align x-axis to a1\n            if dim == 2:\n                cos_theta = a1[0]\n                sin_theta = a1[1]\n                R = np.array([[cos_theta, -sin_theta],[sin_theta, cos_theta]])\n            else:\n                # For 3D build rotation matrix using SVD\n                I = np.eye(dim)\n                M = np.outer(a1, I[:,0])\n                U, _, Vt = np.linalg.svd(M)\n                R = U @ np.diag([1]*(dim-1)+[np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n\n            L = np.diag([c_best/2] + [math.sqrt(c_best**2 - c_min**2)/2]*(dim-1))\n            while True:\n                x_ball = np.random.normal(0,1,dim)\n                n = np.linalg.norm(x_ball)\n                if n < 1e-12:\n                    continue\n                x_ball /= n\n                r = random.random()**(1/dim)\n                x_ball *= r\n                rnd = R @ (L @ x_ball) + np.array(center)\n                p = tuple(float(x) for x in rnd)\n                if in_bounds(p) and not is_in_obstacle(p):\n                    return p\n\n        # Path extraction merging two trees\n        def extract_bidirectional_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            path_goal.reverse()\n            # avoid duplicating connecting node\n            if path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def try_connect_nodes(node_a, tree_b_grid, tree_b_nodes):\n            # Attempt to connect from node_a to some node in tree_b within step_size range\n            near_nodes = get_near_nodes(tree_b_grid, node_a.position, self.step_size)\n            near_nodes = [n for n in near_nodes if not is_edge_in_obstacle(node_a.position, n.position)]\n            if not near_nodes:\n                return None, None\n            # Choose minimal cost combined path node pair\n            best_total_cost = float(\"inf\")\n            best_node_b = None\n            for node_b in near_nodes:\n                total_cost = node_a.cost + dist(node_a.position, node_b.position) + node_b.cost\n                if total_cost < best_total_cost:\n                    best_total_cost = total_cost\n                    best_node_b = node_b\n            if best_node_b is not None:\n                return best_node_b, best_total_cost\n            return None, None\n\n        # Rewiring radius calculated based on number of nodes and dimension, proportional to log(n)/n^(1/dim)\n        def rewiring_radius(n):\n            gamma_rrt_star = 2 * (1 + 1/dim) ** (1/dim) * ( ( (map.size[0]*map.size[1]) if dim==2 else (map.size[0]*map.size[1]*map.size[2]) ) )**(1/dim)\n            rad = min(gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1/dim)), self.step_size*25)\n            return rad\n\n        time_start = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        # Initialization of trees\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        tree_start_nodes = [start_root]\n        tree_goal_nodes = [goal_root]\n        tree_start_grid = {}\n        tree_goal_grid = {}\n\n        add_node_to_grid(start_root, tree_start_grid)\n        add_node_to_grid(goal_root, tree_goal_grid)\n\n        all_nodes = [start_root, goal_root]\n        edges = []\n\n        # Track best solution\n        best_cost = float(\"inf\")\n        best_path = []\n        best_start_node = None\n        best_goal_node = None\n\n        found_initial_solution = False\n        no_improve_count = 0\n\n        # Bidirectional RRT* main loop (phase 1)\n        for itr in range(self.max_iter):\n            if time.monotonic() - time_start > TIME_LIMIT:\n                break\n\n            # Alternate sampling from start or goal tree with uniform random sample\n            sample_point = sample_uniform()\n            for tree_nodes, tree_grid, other_tree_nodes, other_tree_grid in [\n                (tree_start_nodes, tree_start_grid, tree_goal_nodes, tree_goal_grid),\n                (tree_goal_nodes, tree_goal_grid, tree_start_nodes, tree_start_grid)\n            ]:\n                # Nearest node in current tree\n                nearest_node = self._nearest(tree_nodes, sample_point)\n                new_pos = steer(nearest_node.position, sample_point)\n                if not in_bounds(new_pos):\n                    continue\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                # Near nodes around new_pos in current tree for rewiring\n                n_nodes = len(tree_nodes)\n                radius = rewiring_radius(n_nodes)\n                near_nodes = get_near_nodes(tree_grid, new_pos, radius)\n\n                # Find best parent minimizing cost to new_pos\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_through_near = near_node.cost + dist(near_node.position, new_pos)\n                    if cost_through_near < min_cost and not is_edge_in_obstacle(near_node.position, new_pos):\n                        min_cost = cost_through_near\n                        best_parent = near_node\n\n                # Create and add new node in current tree\n                new_node = Node(new_pos, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree_nodes.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                add_node_to_grid(new_node, tree_grid)\n\n                # Rewiring neighbors through new_node if cheaper\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if alt_cost + 1e-12 < near_node.cost and not is_edge_in_obstacle(new_node.position, near_node.position):\n                        # Remove old edge\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        # Rewire\n                        near_node.parent = new_node\n                        near_node.cost = alt_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n                # Try connect to opposite tree\n                connecting_node, cost_candidate = try_connect_nodes(new_node, other_tree_grid, other_tree_nodes)\n                if connecting_node is not None:\n                    # Check combined path cost better than best\n                    if cost_candidate + 1e-9 < best_cost:\n                        best_cost = cost_candidate\n                        if tree_nodes is tree_start_nodes:\n                            best_start_node = new_node\n                            best_goal_node = connecting_node\n                        else:\n                            best_start_node = connecting_node\n                            best_goal_node = new_node\n                        best_path = extract_bidirectional_path(best_start_node, best_goal_node)\n                        found_initial_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n            if no_improve_count > self.no_improve_limit and found_initial_solution:\n                # Stop phase 1 if no improvements for a while after solution found\n                break\n\n        # Phase 2: If solution found, refine path by focused informed sampling and single-tree rewiring\n        if found_initial_solution and best_path:\n            # Build a new single tree from start_root with best_path nodes inserted\n            # Reset structures for refinement\n            tree = [start_root]\n            start_root.children = []\n            start_root.cost = 0.0\n            nodes_refine = [start_root]\n            edges_refine = []\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                node = Node(pos)\n                c = prev_node.cost + dist(prev_node.position, pos)\n                node.cost = c\n                node.parent = prev_node\n                prev_node.add_child(node)\n                tree.append(node)\n                nodes_refine.append(node)\n                edges_refine.append((prev_node, node))\n                prev_node = node\n\n            best_goal = tree[-1]\n            best_cost_refine = best_goal.cost\n            c_min = dist(start, goal)\n            no_improve = 0\n\n            # Spatial grid for refinement phase\n            grid_refine = {}\n            for n in tree:\n                add_node_to_grid(n, grid_refine)\n\n            for itr in range(self.post_opt_iters):\n                if time.monotonic() - time_start > TIME_LIMIT:\n                    break\n                if no_improve >= self.no_improve_limit:\n                    break\n\n                x_rand = sample_informed(best_cost_refine, c_min, start, goal)\n                nearest_node = self._nearest(tree, x_rand)\n                x_new_pos = steer(nearest_node.position, x_rand)\n\n                if not in_bounds(x_new_pos) or is_in_obstacle(x_new_pos) or is_edge_in_obstacle(nearest_node.position, x_new_pos):\n                    no_improve += 1\n                    continue\n\n                n_nodes = len(tree)\n                radius = rewiring_radius(n_nodes)\n                near_nodes = get_near_nodes(grid_refine, x_new_pos, radius)\n\n                min_cost = nearest_node.cost + dist(nearest_node.position, x_new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_through = near_node.cost + dist(near_node.position, x_new_pos)\n                    if cost_through < min_cost and not is_edge_in_obstacle(near_node.position, x_new_pos):\n                        min_cost = cost_through\n                        best_parent = near_node\n\n                x_new = Node(x_new_pos, cost=min_cost)\n                best_parent.add_child(x_new)\n                tree.append(x_new)\n                nodes_refine.append(x_new)\n                edges_refine.append((best_parent, x_new))\n                add_node_to_grid(x_new, grid_refine)\n\n                # Rewire neighbors through x_new if cheaper\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    alt_cost = x_new.cost + dist(x_new.position, near_node.position)\n                    if alt_cost + 1e-12 < near_node.cost and not is_edge_in_obstacle(x_new.position, near_node.position):\n                        if near_node.parent:\n                            try:\n                                edges_refine.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = x_new\n                        near_node.cost = alt_cost\n                        x_new.add_child(near_node)\n                        edges_refine.append((x_new, near_node))\n\n                # Check connection to goal\n                if dist(x_new.position, goal) <= self.step_size and not is_edge_in_obstacle(x_new.position, goal):\n                    new_goal_node = Node(goal, cost=x_new.cost + dist(x_new.position, goal))\n                    x_new.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes_refine.append(new_goal_node)\n                    edges_refine.append((x_new, new_goal_node))\n\n                    if new_goal_node.cost + 1e-9 < best_cost_refine:\n                        best_cost_refine = new_goal_node.cost\n                        best_goal = new_goal_node\n                        no_improve = 0\n                    else:\n                        no_improve += 1\n                else:\n                    no_improve += 1\n\n            if best_goal:\n                success = True\n                path_out = best_goal.path_from_root()\n                return PlannerResult(\n                    success=success,\n                    path=path_out,\n                    nodes=all_nodes + nodes_refine,\n                    edges=edges + edges_refine\n                )\n            else:\n                # Fallback return best found from phase 1\n                return PlannerResult(\n                    success=True,\n                    path=best_path,\n                    nodes=all_nodes,\n                    edges=edges\n                )\n        else:\n            # No path found\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=all_nodes,\n                edges=edges\n            )\n\n    def _nearest(self, tree, point):\n        # Linear nearest for simplicity and guaranteed correctness\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = math.dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _grid_offsets(self, dim, n):\n        # Generate grid offsets in dim dimensions within range [-n,n]\n        # Cartesian product of ranges\n        if dim == 1:\n            return [(i,) for i in range(-n,n+1)]\n        elif dim == 2:\n            offsets = []\n            for dx in range(-n,n+1):\n                for dy in range(-n,n+1):\n                    offsets.append((dx,dy))\n            return offsets\n        else:\n            # dim >=3 general recursive generation\n            def rec(depth):\n                if depth == 1:\n                    return [(i,) for i in range(-n,n+1)]\n                smaller = rec(depth-1)\n                result = []\n                for tup in smaller:\n                    for i in range(-n,n+1):\n                        result.append(tup+(i,))\n                return result\n            return rec(dim)",
          "objective": 350.07076,
          "time_improvement": -1227.0,
          "length_improvement": 23.0,
          "smoothness_improvement": 860.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.6666399478912354,
                    "num_nodes_avg": 580.9,
                    "path_length_avg": 149.39828513223893,
                    "smoothness_avg": 0.047190074678873,
                    "success_improvement": 0.0,
                    "time_improvement": -2477.6121907149973,
                    "length_improvement": 18.112432551697133,
                    "smoothness_improvement": 638.6271436116949,
                    "objective_score": -729.2230619654224
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.7077789783477784,
                    "num_nodes_avg": 847.5,
                    "path_length_avg": 219.5926598523241,
                    "smoothness_avg": 0.04575227926671289,
                    "success_improvement": 0.0,
                    "time_improvement": -330.71855435132875,
                    "length_improvement": 26.693649517036892,
                    "smoothness_improvement": 1077.2390995672663,
                    "objective_score": -77.81318109734016
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.47495265007019044,
                    "num_nodes_avg": 686.4,
                    "path_length_avg": 115.50866810396273,
                    "smoothness_avg": 0.07570799158092709,
                    "success_improvement": 0.0,
                    "time_improvement": -871.5393622775066,
                    "length_improvement": 23.284642577054377,
                    "smoothness_improvement": 863.0000647267433,
                    "objective_score": -243.1760228133856
               }
          ],
          "success_rate": 1.0
     }
]